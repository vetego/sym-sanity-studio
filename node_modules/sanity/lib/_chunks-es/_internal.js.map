{"version":3,"file":"_internal.js","sources":["../../src/_internal/cli/commands/backup/backupGroup.ts","../../src/_internal/cli/actions/backup/parseApiErr.ts","../../src/_internal/cli/debug.ts","../../src/_internal/cli/actions/dataset/validateDatasetName.ts","../../src/_internal/cli/actions/dataset/datasetNamePrompt.ts","../../src/_internal/cli/actions/dataset/chooseDatasetPrompt.ts","../../src/_internal/cli/actions/backup/resolveApiClient.ts","../../src/_internal/cli/commands/backup/disableBackupCommand.ts","../../src/_internal/cli/actions/backup/debug.ts","../../src/_internal/cli/actions/backup/archiveDir.ts","../../src/_internal/cli/actions/backup/chooseBackupIdPrompt.ts","../../src/_internal/cli/actions/backup/cleanupTmpDir.ts","../../src/_internal/cli/actions/backup/withRetry.ts","../../src/_internal/cli/actions/backup/downloadAsset.ts","../../src/_internal/cli/actions/backup/downloadDocument.ts","../../src/_internal/cli/actions/backup/fetchNextBackupPage.ts","../../src/_internal/cli/actions/backup/progressSpinner.ts","../../src/_internal/cli/util/humanFileSize.ts","../../src/_internal/cli/util/isPathDirName.ts","../../src/_internal/cli/commands/backup/downloadBackupCommand.ts","../../src/_internal/cli/commands/backup/enableBackupCommand.ts","../../src/_internal/cli/commands/backup/listBackupCommand.ts","../../src/_internal/cli/util/determineIsApp.ts","../../src/_internal/cli/commands/build/buildCommand.ts","../../src/_internal/cli/actions/cors/addCorsOrigin.ts","../../src/_internal/cli/commands/cors/addCorsOriginCommand.ts","../../src/_internal/cli/commands/cors/corsGroup.ts","../../src/_internal/cli/commands/cors/deleteCorsOriginCommand.ts","../../src/_internal/cli/commands/cors/listCorsOriginsCommand.ts","../../src/_internal/cli/actions/dataset/alias/validateDatasetAliasName.ts","../../src/_internal/cli/actions/dataset/alias/promptForDatasetAliasName.ts","../../src/_internal/cli/commands/dataset/alias/datasetAliasesClient.ts","../../src/_internal/cli/commands/dataset/alias/createAliasHandler.ts","../../src/_internal/cli/commands/dataset/alias/deleteAliasHandler.ts","../../src/_internal/cli/commands/dataset/alias/linkAliasHandler.ts","../../src/_internal/cli/commands/dataset/alias/unlinkAliasHandler.ts","../../src/_internal/cli/commands/dataset/alias/aliasCommands.ts","../../src/_internal/cli/actions/dataset/listDatasetCopyJobs.ts","../../src/_internal/cli/util/getClientUrl.ts","../../src/_internal/cli/commands/dataset/copyDatasetCommand.ts","../../src/_internal/cli/commands/dataset/createDatasetCommand.ts","../../src/_internal/cli/commands/dataset/datasetGroup.ts","../../src/_internal/cli/commands/dataset/datasetVisibilityCommand.ts","../../src/_internal/cli/commands/dataset/deleteDatasetCommand.ts","../../src/_internal/cli/commands/dataset/exportDatasetCommand.ts","../../src/_internal/cli/commands/dataset/importDatasetCommand.ts","../../src/_internal/cli/commands/dataset/alias/listAliasesHandler.ts","../../src/_internal/cli/commands/dataset/listDatasetsCommand.ts","../../src/_internal/cli/commands/deploy/deployCommand.ts","../../src/_internal/cli/commands/deploy/undeployCommand.ts","../../src/_internal/cli/commands/dev/devCommand.ts","../../src/_internal/cli/commands/documents/createDocumentsCommand.ts","../../src/_internal/cli/commands/documents/deleteDocumentsCommand.ts","../../src/_internal/cli/commands/documents/documentsGroup.ts","../../src/_internal/cli/util/colorizeJson.ts","../../src/_internal/cli/commands/documents/getDocumentsCommand.ts","../../src/_internal/cli/commands/documents/queryDocumentsCommand.ts","../../src/_internal/cli/commands/documents/validateDocumentsCommand.ts","../../src/_internal/cli/commands/exec/execCommand.ts","../../src/_internal/cli/commands/graphql/deleteGraphQLAPICommand.ts","../../src/_internal/cli/commands/graphql/deployGraphQLAPICommand.ts","../../src/_internal/cli/commands/graphql/graphqlGroup.ts","../../src/_internal/cli/commands/graphql/listGraphQLAPIsCommand.ts","../../src/_internal/cli/commands/hook/createHookCommand.ts","../../src/_internal/cli/commands/hook/deleteHookCommand.ts","../../src/_internal/cli/commands/hook/hookGroup.ts","../../src/_internal/cli/commands/hook/printHookAttemptCommand.ts","../../src/_internal/cli/commands/hook/listHookLogsCommand.ts","../../src/_internal/cli/commands/hook/listHooksCommand.ts","../../src/_internal/cli/commands/manifest/extractManifestCommand.ts","../../src/_internal/cli/commands/manifest/manifestGroup.ts","../../src/_internal/cli/commands/media/createAspectCommand.ts","../../src/_internal/cli/commands/media/deleteAspectCommand.ts","../../src/_internal/cli/commands/media/deployAspectCommand.ts","../../src/_internal/cli/commands/media/exportMediaCommand.ts","../../src/_internal/cli/commands/media/importMediaCommand.ts","../../src/_internal/cli/commands/media/mediaGroup.ts","../../src/_internal/cli/commands/migration/constants.ts","../../src/_internal/cli/commands/migration/templates/minimalAdvanced.ts","../../src/_internal/cli/commands/migration/templates/minimalSimple.ts","../../src/_internal/cli/commands/migration/templates/renameField.ts","../../src/_internal/cli/commands/migration/templates/renameType.ts","../../src/_internal/cli/commands/migration/templates/stringToPTE.ts","../../src/_internal/cli/commands/migration/createMigrationCommand.ts","../../src/_internal/cli/commands/migration/utils/resolveMigrationScript.ts","../../src/_internal/cli/commands/migration/listMigrationsCommand.ts","../../src/_internal/cli/commands/migration/migrationGroup.ts","../../src/_internal/cli/util/tree.ts","../../src/_internal/cli/commands/migration/prettyMutationFormatter.ts","../../src/_internal/cli/commands/migration/utils/ensureApiVersionFormat.ts","../../src/_internal/cli/commands/migration/runMigrationCommand.ts","../../src/_internal/cli/commands/preview/previewCommand.ts","../../src/_internal/cli/commands/schema/deleteSchemaCommand.ts","../../src/_internal/cli/commands/schema/deploySchemaCommand.ts","../../src/_internal/cli/commands/schema/extractSchemaCommand.ts","../../src/_internal/cli/commands/schema/schemaGroup.ts","../../src/_internal/cli/commands/schema/schemaListCommand.ts","../../src/_internal/cli/commands/schema/validateSchemaCommand.ts","../../src/_internal/cli/util/isInteractive.ts","../../src/_internal/cli/commands/start/startCommand.ts","../../src/_internal/cli/actions/tokens/addToken.ts","../../src/_internal/cli/commands/tokens/addTokenCommand.ts","../../src/_internal/cli/actions/tokens/deleteToken.ts","../../src/_internal/cli/commands/tokens/deleteTokenCommand.ts","../../src/_internal/cli/commands/tokens/listTokensCommand.ts","../../src/_internal/cli/commands/tokens/tokensGroup.ts","../../src/_internal/cli/util/prettifyQuotaError.ts","../../src/_internal/cli/commands/users/inviteUserCommand.ts","../../src/_internal/cli/commands/users/listUsersCommand.ts","../../src/_internal/cli/commands/users/usersGroup.ts","../../src/_internal/cli/commands/index.ts"],"sourcesContent":["import {type CliCommandGroupDefinition} from '@sanity/cli'\n\n// defaultApiVersion is the backend API version used for dataset backup.\nexport const defaultApiVersion = 'v2024-02-21'\n\nconst datasetBackupGroup: CliCommandGroupDefinition = {\n  name: 'backup',\n  signature: '[COMMAND]',\n  description: 'Manage backups.',\n  isGroupRoot: true,\n}\n\nexport default datasetBackupGroup\n","// apiErr is a type that represents an error returned by the API\ninterface ApiErr {\n  statusCode: number\n  message: string\n}\n\n// parseApiErr is a function that attempts with the best effort to parse\n// an error returned by the API since different API endpoint may end up\n// returning different error structures.\n// oxlint-disable-next-line no-explicit-any\nfunction parseApiErr(err: any): ApiErr {\n  const apiErr = {} as ApiErr\n  if (err.code) {\n    apiErr.statusCode = err.code\n  } else if (err.statusCode) {\n    apiErr.statusCode = err.statusCode\n  }\n\n  if (err.message) {\n    apiErr.message = err.message\n  } else if (err.statusMessage) {\n    apiErr.message = err.statusMessage\n  } else if (err?.response?.body?.message) {\n    apiErr.message = err.response.body.message\n  } else if (err?.response?.data?.message) {\n    apiErr.message = err.response.data.message\n  } else {\n    // If no message can be extracted, print the whole error.\n    apiErr.message = JSON.stringify(err)\n  }\n\n  return apiErr\n}\n\nexport default parseApiErr\n","import debugIt from 'debug'\n\nexport const debug = debugIt('sanity:core')\n","const MAX_DATASET_NAME_LENGTH = 64\n\nexport function validateDatasetName(datasetName: string): false | string {\n  if (!datasetName) {\n    return 'Dataset name is missing'\n  }\n\n  const name = `${datasetName}`\n\n  if (name.toLowerCase() !== name) {\n    return 'Dataset name must be all lowercase characters'\n  }\n\n  if (name.length < 2) {\n    return 'Dataset name must be at least two characters long'\n  }\n\n  if (name.length > MAX_DATASET_NAME_LENGTH) {\n    return `Dataset name must be at most ${MAX_DATASET_NAME_LENGTH} characters`\n  }\n\n  if (!/^[a-z0-9]/.test(name)) {\n    return 'Dataset name must start with a letter or a number'\n  }\n\n  if (!/^[a-z0-9][-_a-z0-9]+$/.test(name)) {\n    return 'Dataset name must only contain letters, numbers, dashes and underscores'\n  }\n\n  if (/[-_]$/.test(name)) {\n    return 'Dataset name must not end with a dash or an underscore'\n  }\n\n  return false\n}\n","import {type CliPrompter} from '@sanity/cli'\n\nimport {validateDatasetName} from './validateDatasetName'\n\nexport function promptForDatasetName(\n  prompt: CliPrompter,\n  options: {message?: string; default?: string} = {},\n): Promise<string> {\n  return prompt.single({\n    type: 'input',\n    message: 'Dataset name:',\n    validate: (name) => {\n      const err = validateDatasetName(name)\n      if (err) {\n        return err\n      }\n\n      return true\n    },\n    ...options,\n  })\n}\n","import {type CliCommandContext} from '@sanity/cli'\n\nimport {debug} from '../../debug'\nimport {promptForDatasetName} from './datasetNamePrompt'\n\nexport async function chooseDatasetPrompt(\n  context: CliCommandContext,\n  options: {message?: string; allowCreation?: boolean} = {},\n): Promise<string> {\n  const {apiClient, prompt} = context\n  const {message, allowCreation} = options\n  const client = apiClient()\n\n  const datasets = await client.datasets.list()\n  const hasProduction = datasets.find((dataset) => dataset.name === 'production')\n  const datasetChoices = datasets.map((dataset) => ({value: dataset.name}))\n  const selected = await prompt.single({\n    message: message || 'Select dataset to use',\n    type: 'list',\n    choices: allowCreation\n      ? [{value: 'new', name: 'Create new dataset'}, new prompt.Separator(), ...datasetChoices]\n      : datasetChoices,\n  })\n\n  if (selected === 'new') {\n    debug('User wants to create a new dataset, prompting for name')\n    const newDatasetName = await promptForDatasetName(prompt, {\n      message: 'Name your dataset:',\n      default: hasProduction ? undefined : 'production',\n    })\n    await client.datasets.create(newDatasetName)\n    return newDatasetName\n  }\n\n  return selected\n}\n","import {type CliCommandContext} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\n\nimport {chooseDatasetPrompt} from '../dataset/chooseDatasetPrompt'\n\ntype ResolvedApiClient = {\n  projectId: string\n  datasetName: string\n  token?: string\n  client: SanityClient\n}\n\nasync function resolveApiClient(\n  context: CliCommandContext,\n  datasetName: string,\n  apiVersion: string,\n): Promise<ResolvedApiClient> {\n  const {apiClient} = context\n\n  let client = apiClient()\n  const {projectId, token} = client.config()\n\n  if (!projectId) {\n    throw new Error('Project ID not defined')\n  }\n\n  // If no dataset provided, explicitly ask for dataset instead of using dataset\n  // configured in Sanity config. Aligns with `sanity dataset export` behavior.\n  let selectedDataset: string = datasetName\n  if (!selectedDataset) {\n    selectedDataset = await chooseDatasetPrompt(context, {\n      message: 'Select the dataset name:',\n    })\n  }\n\n  client = client.withConfig({dataset: datasetName, apiVersion})\n\n  return {\n    projectId,\n    datasetName: selectedDataset,\n    token,\n    client,\n  }\n}\n\nexport default resolveApiClient\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport parseApiErr from '../../actions/backup/parseApiErr'\nimport resolveApiClient from '../../actions/backup/resolveApiClient'\nimport {defaultApiVersion} from './backupGroup'\n\nconst helpText = `\nExamples\n  sanity backup disable DATASET_NAME\n`\n\nconst disableDatasetBackupCommand: CliCommandDefinition = {\n  name: 'disable',\n  group: 'backup',\n  signature: '[DATASET_NAME]',\n  description: 'Disable backup for a dataset.',\n  helpText,\n  action: async (args, context) => {\n    const {output, chalk} = context\n    const [dataset] = args.argsWithoutOptions\n    const {projectId, datasetName, token, client} = await resolveApiClient(\n      context,\n      dataset,\n      defaultApiVersion,\n    )\n\n    try {\n      await client.request({\n        method: 'PUT',\n        headers: {Authorization: `Bearer ${token}`},\n        uri: `/projects/${projectId}/datasets/${datasetName}/settings/backups`,\n        body: {\n          enabled: false,\n        },\n      })\n      output.print(`${chalk.green(`Disabled daily backups for dataset ${datasetName}\\n`)}`)\n    } catch (error) {\n      const {message} = parseApiErr(error)\n      output.print(`${chalk.red(`Disabling dataset backup failed: ${message}`)}\\n`)\n    }\n  },\n}\n\nexport default disableDatasetBackupCommand\n","import debug from 'debug'\n\nexport default debug('sanity:backup')\n","import {createWriteStream} from 'node:fs'\nimport zlib from 'node:zlib'\n\nimport archiver, {type ProgressData} from 'archiver'\n\nimport debug from './debug'\n\n// ProgressCb is a callback that is called with the number of bytes processed so far.\ntype ProgressCb = (processedBytes: number) => void\n\n// archiveDir creates a tarball of the given directory and writes it to the given file path.\nfunction archiveDir(tmpOutDir: string, outFilePath: string, progressCb: ProgressCb): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const archiveDestination = createWriteStream(outFilePath)\n    archiveDestination.on('error', (err: Error) => {\n      reject(err)\n    })\n\n    archiveDestination.on('close', () => {\n      resolve()\n    })\n\n    const archive = archiver('tar', {\n      gzip: true,\n      gzipOptions: {level: zlib.constants.Z_DEFAULT_COMPRESSION},\n    })\n\n    archive.on('error', (err: Error) => {\n      debug('Archiving errored!\\n%s', err.stack)\n      reject(err)\n    })\n\n    // Catch warnings for non-blocking errors (stat failures and others)\n    archive.on('warning', (err: Error) => {\n      debug('Archive warning: %s', err.message)\n    })\n\n    archive.on('progress', (progress: ProgressData) => {\n      progressCb(progress.fs.processedBytes)\n    })\n\n    // Pipe archive data to the file\n    archive.pipe(archiveDestination)\n    archive.directory(tmpOutDir, false)\n    void archive.finalize()\n  })\n}\n\nexport default archiveDir\n","import {type CliCommandContext} from '@sanity/cli'\n\nimport {defaultApiVersion} from '../../commands/backup/backupGroup'\nimport resolveApiClient from './resolveApiClient'\n\n// maxBackupIdsShown is the maximum number of backup IDs to show in the prompt.\n// Higher numbers will cause the prompt to be slow.\nconst maxBackupIdsShown = 100\n\nasync function chooseBackupIdPrompt(\n  context: CliCommandContext,\n  datasetName: string,\n): Promise<string> {\n  const {prompt} = context\n\n  const {projectId, token, client} = await resolveApiClient(context, datasetName, defaultApiVersion)\n\n  try {\n    // Fetch last $maxBackupIdsShown backups for this dataset.\n    // We expect here that API returns backups sorted by creation date in descending order.\n    const response = await client.request({\n      headers: {Authorization: `Bearer ${token}`},\n      uri: `/projects/${projectId}/datasets/${datasetName}/backups`,\n      query: {limit: maxBackupIdsShown.toString()},\n    })\n\n    if (response?.backups?.length > 0) {\n      const backupIdChoices = response.backups.map((backup: {id: string}) => ({\n        value: backup.id,\n      }))\n      const selected = await prompt.single({\n        message: `Select backup ID to use (only last ${maxBackupIdsShown} shown)`,\n        type: 'list',\n        choices: backupIdChoices,\n      })\n\n      return selected\n    }\n  } catch (err) {\n    throw new Error(`Failed to fetch backups for dataset ${datasetName}: ${err.message}`, {\n      cause: err,\n    })\n  }\n\n  throw new Error('No backups found')\n}\n\nexport default chooseBackupIdPrompt\n","import {rimraf} from 'rimraf'\n\nimport debug from './debug'\n\nasync function cleanupTmpDir(tmpDir: string): Promise<void> {\n  try {\n    await rimraf(tmpDir)\n  } catch (err) {\n    debug(`Error cleaning up temporary files: ${err.message}`)\n  }\n}\n\nexport default cleanupTmpDir\n","import debug from './debug'\n\nconst MAX_RETRIES = 5\nconst BACKOFF_DELAY_BASE = 200\n\nconst exponentialBackoff = (retryCount: number) => Math.pow(2, retryCount) * BACKOFF_DELAY_BASE\n\nasync function withRetry<T>(\n  operation: () => Promise<T>,\n  maxRetries: number = MAX_RETRIES,\n): Promise<T> {\n  for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n    try {\n      return await operation()\n    } catch (err) {\n      // Immediately rethrow if the error is not server-related.\n      if (err.response && err.response.statusCode && err.response.statusCode < 500) {\n        throw err\n      }\n\n      const retryDelay = exponentialBackoff(retryCount)\n      debug(`Error encountered, retrying after ${retryDelay}ms: %s`, err.message)\n      await new Promise((resolve) => setTimeout(resolve, retryDelay))\n    }\n  }\n\n  throw new Error('Operation failed after all retries')\n}\n\nexport default withRetry\n","import {createWriteStream} from 'node:fs'\nimport path from 'node:path'\nimport {pipeline} from 'node:stream/promises'\n\nimport {getIt} from 'get-it'\nimport {keepAlive, promise} from 'get-it/middleware'\n\nimport debug from './debug'\nimport withRetry from './withRetry'\n\nconst CONNECTION_TIMEOUT = 15 * 1000 // 15 seconds\nconst READ_TIMEOUT = 3 * 60 * 1000 // 3 minutes\n\nconst request = getIt([keepAlive(), promise()])\n\nasync function downloadAsset(\n  url: string,\n  fileName: string,\n  fileType: string,\n  outDir: string,\n): Promise<void> {\n  // File names that contain a path to file (e.g. sanity-storage/assets/file-name.tar.gz) fail when archive is\n  // created due to missing parent dir (e.g. sanity-storage/assets), so we want to handle them by taking\n  // the base name as file name.\n  const normalizedFileName = path.basename(fileName)\n\n  const assetFilePath = getAssetFilePath(normalizedFileName, fileType, outDir)\n  await withRetry(async () => {\n    const response = await request({\n      url: url,\n      maxRedirects: 5,\n      timeout: {connect: CONNECTION_TIMEOUT, socket: READ_TIMEOUT},\n      stream: true,\n    })\n\n    debug('Received asset %s with status code %d', normalizedFileName, response?.statusCode)\n\n    await pipeline(response.body, createWriteStream(assetFilePath))\n  })\n}\n\nfunction getAssetFilePath(fileName: string, fileType: string, outDir: string): string {\n  // Set assetFilePath if we are downloading an asset file.\n  // If it's a JSON document, assetFilePath will be an empty string.\n  let assetFilePath = ''\n  if (fileType === 'image') {\n    assetFilePath = path.join(outDir, 'images', fileName)\n  } else if (fileType === 'file') {\n    assetFilePath = path.join(outDir, 'files', fileName)\n  }\n\n  return assetFilePath\n}\n\nexport default downloadAsset\n","import {getIt, type MiddlewareResponse} from 'get-it'\nimport {keepAlive, promise} from 'get-it/middleware'\n\nimport debug from './debug'\nimport withRetry from './withRetry'\n\nconst CONNECTION_TIMEOUT = 15 * 1000 // 15 seconds\nconst READ_TIMEOUT = 3 * 60 * 1000 // 3 minutes\n\nconst request = getIt([keepAlive(), promise()])\n\n// oxlint-disable-next-line no-explicit-any\nasync function downloadDocument(url: string): Promise<any> {\n  const response = await withRetry<MiddlewareResponse>(() =>\n    request({\n      url,\n      maxRedirects: 5,\n      timeout: {connect: CONNECTION_TIMEOUT, socket: READ_TIMEOUT},\n    }),\n  )\n\n  debug('Received document from %s with status code %d', url, response?.statusCode)\n\n  return response.body\n}\n\nexport default downloadDocument\n","import {Readable} from 'node:stream'\n\nimport {type QueryParams, type SanityClient} from '@sanity/client'\n\ntype File = {\n  name: string\n  url: string\n  type: string\n}\n\ntype GetBackupResponse = {\n  createdAt: string\n  totalFiles: number\n  files: File[]\n  nextCursor?: string\n}\n\nclass PaginatedGetBackupStream extends Readable {\n  private cursor = ''\n  private readonly client: SanityClient\n  private readonly projectId: string\n  private readonly datasetName: string\n  private readonly backupId: string\n  private readonly token: string\n  public totalFiles = 0\n\n  constructor(\n    client: SanityClient,\n    projectId: string,\n    datasetName: string,\n    backupId: string,\n    token: string,\n  ) {\n    super({objectMode: true})\n    this.client = client\n    this.projectId = projectId\n    this.datasetName = datasetName\n    this.backupId = backupId\n    this.token = token\n  }\n\n  async _read(): Promise<void> {\n    try {\n      const data = await this.fetchNextBackupPage()\n\n      // Set totalFiles when it's fetched for the first time\n      if (this.totalFiles === 0) {\n        this.totalFiles = data.totalFiles\n      }\n\n      data.files.forEach((file: File) => this.push(file))\n\n      if (typeof data.nextCursor === 'string' && data.nextCursor !== '') {\n        this.cursor = data.nextCursor\n      } else {\n        // No more pages left to fetch.\n        this.push(null)\n      }\n    } catch (err) {\n      this.destroy(err as Error)\n    }\n  }\n\n  // fetchNextBackupPage fetches the next page of backed up files from the backup API.\n  async fetchNextBackupPage(): Promise<GetBackupResponse> {\n    const query: QueryParams = this.cursor === '' ? {} : {nextCursor: this.cursor}\n\n    try {\n      return await this.client.request({\n        headers: {Authorization: `Bearer ${this.token}`},\n        uri: `/projects/${this.projectId}/datasets/${this.datasetName}/backups/${this.backupId}`,\n        query,\n      })\n    } catch (error) {\n      // It can be clearer to pull this logic out in a  common error handling function for re-usability.\n      let msg = error.statusCode ? error.response.body.message : error.message\n\n      // If no message can be extracted, print the whole error.\n      if (msg === undefined) {\n        msg = String(error)\n      }\n      throw new Error(`Downloading dataset backup failed: ${msg}`, {cause: error})\n    }\n  }\n}\n\nexport {PaginatedGetBackupStream}\nexport type {File, GetBackupResponse}\n","import {type CliOutputter} from '@sanity/cli'\nimport prettyMs from 'pretty-ms'\n\ntype ProgressEvent = {\n  step: string\n  update?: boolean\n  current?: number\n  total?: number\n}\n\ninterface ProgressSpinner {\n  set: (progress: ProgressEvent) => void\n  update: (progress: ProgressEvent) => void\n  succeed: () => void\n  fail: () => void\n}\n\nconst newProgress = (output: CliOutputter, startStep: string): ProgressSpinner => {\n  let spinner = output.spinner(startStep).start()\n  let lastProgress: ProgressEvent = {step: startStep}\n  let start = Date.now()\n\n  const print = (progress: ProgressEvent) => {\n    const elapsed = prettyMs(Date.now() - start)\n    if (progress.current && progress.current > 0 && progress.total && progress.total > 0) {\n      spinner.text = `${progress.step} (${progress.current}/${progress.total}) [${elapsed}]`\n    } else {\n      spinner.text = `${progress.step} [${elapsed}]`\n    }\n  }\n\n  return {\n    set: (progress: ProgressEvent) => {\n      if (progress.step !== lastProgress.step) {\n        print(lastProgress) // Print the last progress before moving on\n        spinner.succeed()\n        spinner = output.spinner(progress.step).start()\n        start = Date.now()\n      } else if (progress.step === lastProgress.step && progress.update) {\n        print(progress)\n      }\n      lastProgress = progress\n    },\n    update: (progress: ProgressEvent) => {\n      print(progress)\n      lastProgress = progress\n    },\n    succeed: () => {\n      spinner.succeed()\n      start = Date.now()\n    },\n    fail: () => {\n      spinner.fail()\n      start = Date.now()\n    },\n  }\n}\n\nexport default newProgress\n","function humanFileSize(size: number): string {\n  const i = size == 0 ? 0 : Math.floor(Math.log(size) / Math.log(1024))\n  return `${(size / Math.pow(1024, i)).toFixed(2)} ${['B', 'kB', 'MB', 'GB', 'TB'][i]}`\n}\n\nexport default humanFileSize\n","function isPathDirName(filepath: string): boolean {\n  // Check if the path has an extension, commonly indicating a file\n  return !/\\.\\w+$/.test(filepath)\n}\n\nexport default isPathDirName\n","import {createWriteStream, existsSync, mkdirSync} from 'node:fs'\nimport {mkdtemp} from 'node:fs/promises'\nimport {tmpdir} from 'node:os'\nimport path from 'node:path'\nimport {finished} from 'node:stream/promises'\n\nimport {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n  type SanityClient,\n} from '@sanity/cli'\nimport {absolutify} from '@sanity/util/fs'\nimport {Mutex} from 'async-mutex'\nimport createDebug from 'debug'\nimport {isString} from 'lodash-es'\nimport prettyMs from 'pretty-ms'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport archiveDir from '../../actions/backup/archiveDir'\nimport chooseBackupIdPrompt from '../../actions/backup/chooseBackupIdPrompt'\nimport cleanupTmpDir from '../../actions/backup/cleanupTmpDir'\nimport downloadAsset from '../../actions/backup/downloadAsset'\nimport downloadDocument from '../../actions/backup/downloadDocument'\nimport {type File, PaginatedGetBackupStream} from '../../actions/backup/fetchNextBackupPage'\nimport parseApiErr from '../../actions/backup/parseApiErr'\nimport newProgress from '../../actions/backup/progressSpinner'\nimport resolveApiClient from '../../actions/backup/resolveApiClient'\nimport humanFileSize from '../../util/humanFileSize'\nimport isPathDirName from '../../util/isPathDirName'\nimport {defaultApiVersion} from './backupGroup'\n\nconst debug = createDebug('sanity:backup')\n\nconst DEFAULT_DOWNLOAD_CONCURRENCY = 10\nconst MAX_DOWNLOAD_CONCURRENCY = 24\n\ninterface DownloadBackupOptions {\n  projectId: string\n  datasetName: string\n  token: string\n  backupId: string\n  outDir: string\n  outFileName: string\n  overwrite: boolean\n  concurrency: number\n}\n\nconst helpText = `\nOptions\n  --backup-id <string> The backup ID to download. (required)\n  --out <string>       The file or directory path the backup should download to.\n  --overwrite          Allows overwriting of existing backup file.\n  --concurrency <num>  Concurrent number of backup item downloads. (max: 24)\n\nExamples\n  sanity backup download DATASET_NAME --backup-id 2024-01-01-backup-1\n  sanity backup download DATASET_NAME --backup-id 2024-01-01-backup-2 --out /path/to/file\n  sanity backup download DATASET_NAME --backup-id 2024-01-01-backup-3 --out /path/to/file --overwrite\n`\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2))\n    .options('backup-id', {type: 'string'})\n    .options('out', {type: 'string'})\n    .options('concurrency', {type: 'number', default: DEFAULT_DOWNLOAD_CONCURRENCY})\n    .options('overwrite', {type: 'boolean', default: false}).argv\n}\n\nconst downloadBackupCommand: CliCommandDefinition = {\n  name: 'download',\n  group: 'backup',\n  signature: '[DATASET_NAME]',\n  description: 'Download a dataset backup to a local file.',\n  helpText,\n  // eslint-disable-next-line max-statements\n  action: async (args, context) => {\n    const {output, chalk} = context\n    const [client, opts] = await prepareBackupOptions(context, args)\n    const {projectId, datasetName, backupId, outDir, outFileName} = opts\n\n    // If any of the output path or file name is empty, cancel the operation.\n    if (outDir === '' || outFileName === '') {\n      output.print('Operation cancelled.')\n      return\n    }\n    const outFilePath = path.join(outDir, outFileName)\n\n    output.print('╭───────────────────────────────────────────────────────────╮')\n    output.print('│                                                           │')\n    output.print('│ Downloading backup for:                                   │')\n    output.print(`│ ${chalk.bold('projectId')}: ${chalk.cyan(projectId).padEnd(56)} │`)\n    output.print(`│ ${chalk.bold('dataset')}: ${chalk.cyan(datasetName).padEnd(58)} │`)\n    output.print(`│ ${chalk.bold('backupId')}: ${chalk.cyan(backupId).padEnd(56)} │`)\n    output.print('│                                                           │')\n    output.print('╰───────────────────────────────────────────────────────────╯')\n    output.print('')\n    output.print(`Downloading backup to \"${chalk.cyan(outFilePath)}\"`)\n\n    const start = Date.now()\n    const progressSpinner = newProgress(output, 'Setting up backup environment...')\n\n    // Create a unique temporary directory to store files before bundling them into the archive at outputPath.\n    // Temporary directories are normally deleted at the end of backup process, any unexpected exit may leave them\n    // behind, hence it is important to create a unique directory for each attempt.\n    const tmpOutDir = await mkdtemp(path.join(tmpdir(), `sanity-backup-`))\n\n    // Create required directories if they don't exist.\n    for (const dir of [outDir, path.join(tmpOutDir, 'images'), path.join(tmpOutDir, 'files')]) {\n      mkdirSync(dir, {recursive: true})\n    }\n\n    debug('Writing to temporary directory %s', tmpOutDir)\n    const tmpOutDocumentsFile = path.join(tmpOutDir, 'data.ndjson')\n\n    // Handle concurrent writes to the same file using mutex.\n    const docOutStream = createWriteStream(tmpOutDocumentsFile)\n    const docWriteMutex = new Mutex()\n\n    try {\n      const backupFileStream = new PaginatedGetBackupStream(\n        client,\n        opts.projectId,\n        opts.datasetName,\n        opts.backupId,\n        opts.token,\n      )\n\n      const files: File[] = []\n      let i = 0\n      for await (const file of backupFileStream) {\n        files.push(file)\n        i++\n        progressSpinner.set({\n          step: `Reading backup files...`,\n          update: true,\n          current: i,\n          total: backupFileStream.totalFiles,\n        })\n      }\n\n      let totalItemsDownloaded = 0\n      // This is dynamically imported because this module is ESM only and this file gets compiled to CJS at this time.\n      const {default: pMap} = await import('p-map')\n      await pMap(\n        files,\n        async (file: File) => {\n          if (file.type === 'file' || file.type === 'image') {\n            await downloadAsset(file.url, file.name, file.type, tmpOutDir)\n          } else {\n            const doc = await downloadDocument(file.url)\n            await docWriteMutex.runExclusive(() => {\n              docOutStream.write(`${doc}\\n`)\n            })\n          }\n\n          totalItemsDownloaded += 1\n          progressSpinner.set({\n            step: `Downloading documents and assets...`,\n            update: true,\n            current: totalItemsDownloaded,\n            total: backupFileStream.totalFiles,\n          })\n        },\n        {concurrency: opts.concurrency},\n      )\n    } catch (error) {\n      progressSpinner.fail()\n      const {message} = parseApiErr(error)\n      throw new Error(`Downloading dataset backup failed: ${message}`, {cause: error})\n    }\n\n    docOutStream.end()\n    await finished(docOutStream)\n\n    progressSpinner.set({step: `Archiving files into a tarball...`, update: true})\n    try {\n      await archiveDir(tmpOutDir, outFilePath, (processedBytes: number) => {\n        progressSpinner.update({\n          step: `Archiving files into a tarball, ${humanFileSize(processedBytes)} bytes written...`,\n        })\n      })\n    } catch (err) {\n      progressSpinner.fail()\n      throw new Error(`Archiving backup failed: ${err.message}`, {cause: err})\n    }\n\n    progressSpinner.set({\n      step: `Cleaning up temporary files at ${chalk.cyan(`${tmpOutDir}`)}`,\n    })\n    await cleanupTmpDir(tmpOutDir)\n\n    progressSpinner.set({\n      step: `Backup download complete [${prettyMs(Date.now() - start)}]`,\n    })\n    progressSpinner.succeed()\n  },\n}\n\n// prepareBackupOptions validates backup options from CLI and prepares Client and DownloadBackupOptions.\nasync function prepareBackupOptions(\n  context: CliCommandContext,\n  args: CliCommandArguments,\n): Promise<[SanityClient, DownloadBackupOptions]> {\n  const flags = await parseCliFlags(args)\n  const [dataset] = args.argsWithoutOptions\n  const {prompt, workDir} = context\n  const {projectId, datasetName, client} = await resolveApiClient(\n    context,\n    dataset,\n    defaultApiVersion,\n  )\n\n  const {token} = client.config()\n  if (!isString(token) || token.length < 1) {\n    throw new Error(`token is missing`)\n  }\n\n  if (!isString(datasetName) || datasetName.length < 1) {\n    throw new Error(`dataset ${datasetName} must be a valid dataset name`)\n  }\n\n  const backupId = String(flags['backup-id'] || (await chooseBackupIdPrompt(context, datasetName)))\n  if (backupId.length < 1) {\n    throw new Error(`backup-id ${flags['backup-id']} should be a valid string`)\n  }\n\n  if ('concurrency' in flags) {\n    if (flags.concurrency < 1 || flags.concurrency > MAX_DOWNLOAD_CONCURRENCY) {\n      throw new Error(`concurrency should be in 1 to ${MAX_DOWNLOAD_CONCURRENCY} range`)\n    }\n  }\n\n  const defaultOutFileName = `${datasetName}-backup-${backupId}.tar.gz`\n  let out = await (async (): Promise<string> => {\n    if (flags.out !== undefined) {\n      // Rewrite the output path to an absolute path, if it is not already.\n      return absolutify(flags.out)\n    }\n\n    const input = await prompt.single({\n      type: 'input',\n      message: 'Output path:',\n      default: path.join(workDir, defaultOutFileName),\n      filter: absolutify,\n    })\n    return input\n  })()\n\n  // If path is a directory name, then add a default file name to the path.\n  if (isPathDirName(out)) {\n    out = path.join(out, defaultOutFileName)\n  }\n\n  // If the file already exists, ask for confirmation if it should be overwritten.\n  if (!flags.overwrite && existsSync(out)) {\n    const shouldOverwrite = await prompt.single({\n      type: 'confirm',\n      message: `File \"${out}\" already exists, would you like to overwrite it?`,\n      default: false,\n    })\n\n    // If the user does not want to overwrite the file, set the output path to an empty string.\n    // This should be handled by the caller of this function as cancel operation.\n    if (!shouldOverwrite) {\n      out = ''\n    }\n  }\n\n  return [\n    client,\n    {\n      projectId,\n      datasetName,\n      backupId,\n      token,\n      outDir: path.dirname(out),\n      outFileName: path.basename(out),\n      overwrite: flags.overwrite,\n      concurrency: flags.concurrency || DEFAULT_DOWNLOAD_CONCURRENCY,\n    },\n  ]\n}\n\nexport default downloadBackupCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport parseApiErr from '../../actions/backup/parseApiErr'\nimport resolveApiClient from '../../actions/backup/resolveApiClient'\nimport {defaultApiVersion} from './backupGroup'\n\nconst helpText = `\nExamples\n  sanity backup enable DATASET_NAME\n`\n\nconst enableDatasetBackupCommand: CliCommandDefinition = {\n  name: 'enable',\n  group: 'backup',\n  signature: '[DATASET_NAME]',\n  description: 'Enable backup for a dataset.',\n  helpText,\n  action: async (args, context) => {\n    const {output, chalk} = context\n    const [dataset] = args.argsWithoutOptions\n    const {projectId, datasetName, token, client} = await resolveApiClient(\n      context,\n      dataset,\n      defaultApiVersion,\n    )\n\n    try {\n      await client.request({\n        method: 'PUT',\n        headers: {Authorization: `Bearer ${token}`},\n        uri: `/projects/${projectId}/datasets/${datasetName}/settings/backups`,\n        body: {\n          enabled: true,\n        },\n      })\n\n      output.print(\n        `${chalk.green(\n          `Enabled backups for dataset ${datasetName}.\\nPlease note that it may take up to 24 hours before the first backup is created.\\n`,\n        )}`,\n      )\n\n      output.print(\n        `${chalk.bold(`Retention policies may apply depending on your plan and agreement.\\n`)}`,\n      )\n    } catch (error) {\n      const {message} = parseApiErr(error)\n      output.print(`${chalk.red(`Enabling dataset backup failed: ${message}`)}\\n`)\n    }\n  },\n}\nexport default enableDatasetBackupCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\nimport {Table} from 'console-table-printer'\nimport {isAfter, isValid, lightFormat, parse} from 'date-fns'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport parseApiErr from '../../actions/backup/parseApiErr'\nimport resolveApiClient from '../../actions/backup/resolveApiClient'\nimport {defaultApiVersion} from './backupGroup'\n\nconst DEFAULT_LIST_BACKUP_LIMIT = 30\n\ninterface ListDatasetBackupFlags {\n  before?: string\n  after?: string\n  limit?: string\n}\n\ntype ListBackupRequestQueryParams = {\n  before?: string\n  after?: string\n  limit: string\n}\n\ntype ListBackupResponse = {\n  backups: ListBackupResponseItem[]\n}\n\ntype ListBackupResponseItem = {\n  id: string\n  createdAt: string\n}\n\nconst helpText = `\nOptions\n  --limit <int>     Maximum number of backups returned. Default 30.\n  --after <string>  Only return backups after this date (inclusive)\n  --before <string> Only return backups before this date (exclusive). Cannot be younger than <after> if specified.\n\nExamples\n  sanity backup list DATASET_NAME\n  sanity backup list DATASET_NAME --limit 50\n  sanity backup list DATASET_NAME --after 2024-01-31 --limit 10\n  sanity backup list DATASET_NAME --after 2024-01-31 --before 2024-01-10\n`\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2))\n    .options('after', {type: 'string'})\n    .options('before', {type: 'string'})\n    .options('limit', {type: 'number', default: DEFAULT_LIST_BACKUP_LIMIT, alias: 'l'}).argv\n}\n\nconst listDatasetBackupCommand: CliCommandDefinition<ListDatasetBackupFlags> = {\n  name: 'list',\n  group: 'backup',\n  signature: '[DATASET_NAME]',\n  description: 'List available backups for a dataset.',\n  helpText,\n  action: async (args, context) => {\n    const {output, chalk} = context\n    const flags = await parseCliFlags(args)\n    const [dataset] = args.argsWithoutOptions\n\n    const {projectId, datasetName, token, client} = await resolveApiClient(\n      context,\n      dataset,\n      defaultApiVersion,\n    )\n\n    const query: ListBackupRequestQueryParams = {limit: DEFAULT_LIST_BACKUP_LIMIT.toString()}\n    if (flags.limit) {\n      // We allow limit up to Number.MAX_SAFE_INTEGER to leave it for server-side validation,\n      //  while still sending sensible value in limit string.\n      if (flags.limit < 1 || flags.limit > Number.MAX_SAFE_INTEGER) {\n        throw new Error(\n          `Parsing --limit: must be an integer between 1 and ${Number.MAX_SAFE_INTEGER}`,\n        )\n      }\n      query.limit = flags.limit.toString()\n    }\n\n    if (flags.before || flags.after) {\n      try {\n        const parsedBefore = processDateFlags(flags.before)\n        const parsedAfter = processDateFlags(flags.after)\n\n        if (parsedAfter && parsedBefore && isAfter(parsedAfter, parsedBefore)) {\n          throw new Error('--after date must be before --before')\n        }\n\n        query.before = flags.before\n        query.after = flags.after\n      } catch (err) {\n        throw new Error(`Parsing date flags: ${err}`, {cause: err})\n      }\n    }\n\n    let response\n    try {\n      response = await client.request<ListBackupResponse>({\n        headers: {Authorization: `Bearer ${token}`},\n        uri: `/projects/${projectId}/datasets/${datasetName}/backups`,\n        query: {...query},\n      })\n    } catch (error) {\n      const {message} = parseApiErr(error)\n      output.error(`${chalk.red(`List dataset backup failed: ${message}`)}\\n`)\n    }\n\n    if (response && response.backups) {\n      if (response.backups.length === 0) {\n        output.print('No backups found.')\n        return\n      }\n\n      const table = new Table({\n        columns: [\n          {name: 'resource', title: 'RESOURCE', alignment: 'left'},\n          {name: 'createdAt', title: 'CREATED AT', alignment: 'left'},\n          {name: 'backupId', title: 'BACKUP ID', alignment: 'left'},\n        ],\n      })\n\n      response.backups.forEach((backup: ListBackupResponseItem) => {\n        const {id, createdAt} = backup\n        table.addRow({\n          resource: 'Dataset',\n          createdAt: lightFormat(Date.parse(createdAt), 'yyyy-MM-dd HH:mm:ss'),\n          backupId: id,\n        })\n      })\n\n      table.printTable()\n    }\n  },\n}\n\nfunction processDateFlags(date: string | undefined): Date | undefined {\n  if (!date) return undefined\n  const parsedDate = parse(date, 'yyyy-MM-dd', new Date())\n  if (isValid(parsedDate)) {\n    return parsedDate\n  }\n\n  throw new Error(`Invalid ${date} date format. Use YYYY-MM-DD`)\n}\n\nexport default listDatasetBackupCommand\n","import {type CliConfig} from '@sanity/cli'\n\nexport function determineIsApp(cliConfig?: CliConfig): boolean {\n  return Boolean(cliConfig && 'app' in cliConfig)\n}\n","import type {CliCommandArguments, CliCommandContext, CliCommandDefinition} from '@sanity/cli'\nimport {BuildSanityStudioCommandFlags} from '../../actions/build/buildAction'\nimport {determineIsApp} from '../../util/determineIsApp'\n\nimport {createRequire} from 'node:module'\n\nconst require = createRequire(import.meta.url)\n\nconst helpText = `\nOptions\n  --source-maps Enable source maps for built bundles (increases size of bundle)\n  --no-minify Skip minifying built JavaScript (speeds up build, increases size of bundle)\n  -y, --yes Unattended mode, answers \"yes\" to any \"yes/no\" prompt and otherwise uses defaults\n  --schema-path If you are storing your schemas in a different path than the default one, you need to specify it here.\n\nExamples\n  sanity build\n  sanity build --no-minify --source-maps\n`\n\nconst buildCommand: CliCommandDefinition = {\n  name: 'build',\n  signature: '[OUTPUT_DIR]',\n  description: 'Builds the Sanity Studio configuration into a static bundle',\n  action: async (\n    args: CliCommandArguments<BuildSanityStudioCommandFlags>,\n    context: CliCommandContext,\n    overrides?: {basePath?: string},\n  ) => {\n    const buildAction = await getBuildAction(context)\n\n    return buildAction(args, context, overrides)\n  },\n  helpText,\n}\n\nasync function getBuildAction(context: CliCommandContext) {\n  const isApp = determineIsApp(context.cliConfig)\n  // NOTE: in dev-mode we want to include from `src` so we need to use `.ts` extension\n  // NOTE: this `if` statement is not included in the output bundle\n  if (__DEV__) {\n    if (isApp) {\n      // eslint-disable-next-line import/extensions\n      const mod: typeof import('../../actions/app/buildAction') = require('../../actions/app/buildAction.ts')\n      return mod.default\n    }\n\n    // eslint-disable-next-line import/extensions\n    const mod: typeof import('../../actions/build/buildAction') = require('../../actions/build/buildAction.ts')\n\n    return mod.default\n  }\n\n  if (isApp) {\n    const mod = await import('../../actions/app/buildAction')\n    return mod.default\n  }\n\n  const mod = await import('../../actions/build/buildAction')\n\n  return mod.default\n}\n\nexport default buildCommand\n","import url from 'node:url'\n\nimport {type CliCommandContext, type CliPrompter} from '@sanity/cli'\nimport logSymbols from 'log-symbols'\nimport oneline from 'oneline'\n\nconst wildcardReplacement = 'a-wild-card-r3pl4c3m3n7-a'\nconst portReplacement = ':7777777'\n\ninterface AddCorsOriginFlags {\n  credentials?: boolean\n}\n\nexport async function addCorsOrigin(\n  givenOrigin: string,\n  flags: AddCorsOriginFlags,\n  context: CliCommandContext,\n): Promise<boolean> {\n  const {apiClient, prompt, output} = context\n  const origin = await (givenOrigin\n    ? filterAndValidateOrigin(givenOrigin)\n    : promptForOrigin(prompt))\n\n  const hasWildcard = origin.includes('*')\n  if (hasWildcard && !(await promptForWildcardConfirmation(origin, context))) {\n    return false\n  }\n  const allowCredentials =\n    typeof flags.credentials === 'undefined'\n      ? await promptForCredentials(hasWildcard, context)\n      : Boolean(flags.credentials)\n\n  if (givenOrigin !== origin) {\n    output.print(`Normalized origin to ${origin}`)\n  }\n\n  const client = apiClient({\n    requireUser: true,\n    requireProject: true,\n  })\n\n  await client.request({\n    method: 'POST',\n    url: '/cors',\n    body: {origin, allowCredentials},\n    maxRedirects: 0,\n  })\n\n  return true\n}\n\nfunction promptForCredentials(hasWildcard: boolean, context: CliCommandContext): Promise<string> {\n  const {prompt, output, chalk} = context\n\n  output.print('')\n  if (hasWildcard) {\n    output.print(oneline`\n      ${chalk.yellow(`${logSymbols.warning} Warning:`)}\n      We ${chalk.red(chalk.underline('HIGHLY'))} recommend NOT allowing credentials\n      on origins containing wildcards. If you are logged in to a studio, people will\n      be able to send requests ${chalk.underline('on your behalf')} to read and modify\n      data, from any matching origin. Please tread carefully!\n    `)\n  } else {\n    output.print(oneline`\n      ${chalk.yellow(`${logSymbols.warning} Warning:`)}\n      Should this origin be allowed to send requests using authentication tokens or\n      session cookies? Be aware that any script on this origin will be able to send\n      requests ${chalk.underline('on your behalf')} to read and modify data if you\n      are logged in to a Sanity studio. If this origin hosts a studio, you will need\n      this, otherwise you should probably answer \"No\" (n).\n    `)\n  }\n\n  output.print('')\n\n  return prompt.single({\n    type: 'confirm',\n    message: oneline`\n      Allow credentials to be sent from this origin? Please read the warning above.\n    `,\n    default: false,\n  })\n}\n\nfunction promptForWildcardConfirmation(\n  origin: string,\n  context: CliCommandContext,\n): Promise<boolean> {\n  const {prompt, output, chalk} = context\n\n  output.print('')\n  output.print(chalk.yellow(`${logSymbols.warning} Warning: Examples of allowed origins:`))\n\n  if (origin === '*') {\n    output.print('- http://www.some-malicious.site')\n    output.print('- https://not.what-you-were-expecting.com')\n    output.print('- https://high-traffic-site.com')\n    output.print('- http://192.168.1.1:8080')\n  } else {\n    output.print(`- ${origin.replace(/:\\*/, ':1234').replace(/\\*/g, 'foo')}`)\n    output.print(`- ${origin.replace(/:\\*/, ':3030').replace(/\\*/g, 'foo.bar')}`)\n  }\n\n  output.print('')\n\n  return prompt.single({\n    type: 'confirm',\n    message: oneline`\n      Using wildcards can be ${chalk.red('risky')}.\n      Are you ${chalk.underline('absolutely sure')} you want to allow this origin?`,\n    default: false,\n  })\n}\n\nfunction promptForOrigin(prompt: CliPrompter): Promise<string> {\n  return prompt.single({\n    type: 'input',\n    message: 'Origin (including protocol):',\n    filter: filterOrigin,\n    validate: (origin) => validateOrigin(origin, origin),\n  })\n}\n\nfunction filterOrigin(origin: string): string | null {\n  if (origin === '*' || origin === 'file:///*' || origin === 'null') {\n    return origin\n  }\n\n  try {\n    const example = origin\n      .replace(/([^:])\\*/g, `$1${wildcardReplacement}`)\n      .replace(/:\\*/, portReplacement)\n\n    const parsed = url.parse(example)\n    let host = parsed.host || ''\n    if (/^https?:$/.test(parsed.protocol || '')) {\n      host = host.replace(/:(80|443)$/, '')\n    }\n\n    host = host.replace(portReplacement, ':*').replace(new RegExp(wildcardReplacement, 'g'), '*')\n\n    return `${parsed.protocol}//${host}`\n  } catch (err) {\n    return null\n  }\n}\n\nfunction validateOrigin(origin: string | null, givenOrigin: string): true | string {\n  if (origin === '*' || origin === 'file:///*' || origin === 'null') {\n    return true\n  }\n\n  try {\n    url.parse(origin || (0 as any as string)) // Use 0 to trigger error for unset values\n    return true\n  } catch (err) {\n    // Fall-through to error\n  }\n\n  if (givenOrigin.startsWith('file://')) {\n    return `Only a local file wildcard is currently allowed: file:///*`\n  }\n\n  return `Invalid origin \"${givenOrigin}\", must include protocol (https://some.host)`\n}\n\nfunction filterAndValidateOrigin(givenOrigin: string): string {\n  const origin = filterOrigin(givenOrigin)\n  const result = validateOrigin(origin, givenOrigin)\n  if (result !== true) {\n    throw new Error(result)\n  }\n\n  if (!origin) {\n    throw new Error('Invalid origin')\n  }\n\n  return origin\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport {type CliCommandDefinition} from '@sanity/cli'\n\nimport {addCorsOrigin} from '../../actions/cors/addCorsOrigin'\n\nconst helpText = `\nOptions\n  --credentials Allow credentials (token/cookie) to be sent from this origin\n  --no-credentials Disallow credentials (token/cookie) to be sent from this origin\n\nExamples\n  sanity cors add\n  sanity cors add http://localhost:3000 --no-credentials\n`\n\nconst addCorsOriginCommand: CliCommandDefinition = {\n  name: 'add',\n  group: 'cors',\n  signature: '[ORIGIN]',\n  helpText,\n  description: 'Allow a new origin to use your project API through CORS',\n  action: async (args, context) => {\n    const {output} = context\n    const [origin] = args.argsWithoutOptions\n\n    if (!origin) {\n      throw new Error('No origin specified, use `sanity cors add <origin-url>`')\n    }\n\n    const flags = args.extOptions\n\n    const isFile = fs.existsSync(path.join(process.cwd(), origin))\n    if (isFile) {\n      output.warn(`Origin \"${origin}?\" Remember to quote values (sanity cors add \"*\")`)\n    }\n\n    const success = await addCorsOrigin(origin, flags, context)\n    if (success) {\n      output.print('CORS origin added successfully')\n    }\n  },\n}\n\nexport default addCorsOriginCommand\n","import {type CliCommandGroupDefinition} from '@sanity/cli'\n\nconst corsGroup: CliCommandGroupDefinition = {\n  name: 'cors',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Configures CORS settings for Sanity projects',\n}\n\nexport default corsGroup\n","import {type CliCommandContext, type CliCommandDefinition} from '@sanity/cli'\n\nimport {type CorsOrigin} from './types'\n\nconst helpText = `\nExamples\n  sanity cors delete\n  sanity cors delete http://localhost:3000\n`\n\nconst deleteCorsOriginCommand: CliCommandDefinition = {\n  name: 'delete',\n  group: 'cors',\n  signature: '[ORIGIN]',\n  helpText,\n  description: 'Delete an existing CORS-origin from your project',\n  action: async (args, context) => {\n    const {output, apiClient} = context\n    const [origin] = args.argsWithoutOptions\n    const client = apiClient({requireUser: true, requireProject: true})\n    const originId = await promptForOrigin(origin, context)\n    try {\n      await client.request({method: 'DELETE', uri: `/cors/${originId}`})\n      output.print('Origin deleted')\n    } catch (err) {\n      throw new Error(`Origin deletion failed:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nexport default deleteCorsOriginCommand\n\nasync function promptForOrigin(specified: string | undefined, context: CliCommandContext) {\n  const specifiedOrigin = specified && specified.toLowerCase()\n  const {prompt, apiClient} = context\n  const client = apiClient({requireUser: true, requireProject: true})\n\n  const origins = await client.request<CorsOrigin[]>({url: '/cors'})\n  if (specifiedOrigin) {\n    const selected = origins.filter((origin) => origin.origin.toLowerCase() === specifiedOrigin)[0]\n    if (!selected) {\n      throw new Error(`Origin \"${specified} not found\"`)\n    }\n\n    return selected.id\n  }\n\n  const choices = origins.map((origin) => ({value: origin.id, name: origin.origin}))\n  return prompt.single({\n    message: 'Select origin to delete',\n    type: 'list',\n    choices,\n  })\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {type CorsOrigin} from './types'\n\nconst helpText = `\nExamples\n  sanity cors list\n`\n\nconst listCorsOriginsCommand: CliCommandDefinition = {\n  name: 'list',\n  group: 'cors',\n  signature: '',\n  helpText,\n  description: 'List all origins allowed to access the API for this project',\n  action: async (args, context) => {\n    const {output} = context\n    const {apiClient} = context\n    const client = apiClient({requireUser: true, requireProject: true})\n    const origins = await client.request<CorsOrigin[]>({url: '/cors'})\n    output.print(origins.map((origin) => origin.origin).join('\\n'))\n  },\n}\n\nexport default listCorsOriginsCommand\n","const MAX_DATASET_NAME_LENGTH = 64\n\nexport function validateDatasetAliasName(datasetName: string): false | string {\n  if (!datasetName) {\n    return 'Alias name is missing'\n  }\n\n  const name = `${datasetName}`\n\n  if (name.toLowerCase() !== name) {\n    return 'Alias name must be all lowercase characters'\n  }\n\n  if (name.length < 2) {\n    return 'Alias name must be at least two characters long'\n  }\n\n  if (name.length > MAX_DATASET_NAME_LENGTH) {\n    return `Alias name must be at most ${MAX_DATASET_NAME_LENGTH} characters`\n  }\n\n  if (!/^[a-z0-9~]/.test(name)) {\n    return 'Alias name must start with a letter or a number'\n  }\n\n  if (!/^[a-z0-9~][-_a-z0-9]+$/.test(name)) {\n    return 'Alias name must only contain letters, numbers, dashes and underscores'\n  }\n\n  if (/[-_]$/.test(name)) {\n    return 'Alias name must not end with a dash or an underscore'\n  }\n\n  return false\n}\n","import {type CliPrompter} from '@sanity/cli'\n\nimport {validateDatasetAliasName} from './validateDatasetAliasName'\n\nexport function promptForDatasetAliasName(\n  prompt: CliPrompter,\n  options: {message?: string; default?: string} = {},\n): Promise<string> {\n  return prompt.single({\n    type: 'input',\n    message: 'Alias name:',\n    validate: (name) => {\n      const err = validateDatasetAliasName(name)\n      if (err) {\n        return err\n      }\n\n      return true\n    },\n    ...options,\n  })\n}\n","import {type SanityClient} from '@sanity/client'\n\nimport {validateDatasetAliasName} from '../../../actions/dataset/alias/validateDatasetAliasName'\nimport {type DatasetAliasDefinition, type DatasetModificationResponse} from './types'\n\nexport const ALIAS_PREFIX = '~'\n\nexport function listAliases(client: SanityClient): Promise<DatasetAliasDefinition[]> {\n  return client.request<DatasetAliasDefinition[]>({uri: '/aliases'})\n}\n\nexport function createAlias(\n  client: SanityClient,\n  aliasName: string,\n  datasetName: string | null,\n): Promise<DatasetModificationResponse> {\n  return modify(client, 'PUT', aliasName, datasetName ? {datasetName} : undefined)\n}\n\nexport function updateAlias(\n  client: SanityClient,\n  aliasName: string,\n  datasetName: string | null,\n): Promise<DatasetModificationResponse> {\n  return modify(client, 'PATCH', aliasName, datasetName ? {datasetName} : undefined)\n}\n\nexport function unlinkAlias(\n  client: SanityClient,\n  aliasName: string,\n): Promise<DatasetModificationResponse> {\n  validateDatasetAliasName(aliasName)\n  return modify(client, 'PATCH', `${aliasName}/unlink`, {})\n}\n\nexport function removeAlias(client: SanityClient, aliasName: string): Promise<{deleted: boolean}> {\n  return modify(client, 'DELETE', aliasName)\n}\n\nfunction modify(\n  client: SanityClient,\n  method: string,\n  aliasName: string,\n  body?: {datasetName?: string},\n) {\n  return client.request({method, uri: `/aliases/${aliasName}`, body})\n}\n","import {type CliCommandAction} from '@sanity/cli'\n\nimport {promptForDatasetAliasName} from '../../../actions/dataset/alias/promptForDatasetAliasName'\nimport {validateDatasetAliasName} from '../../../actions/dataset/alias/validateDatasetAliasName'\nimport {promptForDatasetName} from '../../../actions/dataset/datasetNamePrompt'\nimport {validateDatasetName} from '../../../actions/dataset/validateDatasetName'\nimport * as aliasClient from './datasetAliasesClient'\nimport {ALIAS_PREFIX} from './datasetAliasesClient'\n\nexport const createAliasHandler: CliCommandAction = async (args, context) => {\n  const {apiClient, output, prompt} = context\n  const [, alias, targetDataset] = args.argsWithoutOptions\n  const client = apiClient()\n\n  const nameError = alias && validateDatasetAliasName(alias)\n  if (nameError) {\n    throw new Error(nameError)\n  }\n\n  const [datasets, aliases, projectFeatures] = await Promise.all([\n    client.datasets.list().then((sets) => sets.map((ds) => ds.name)),\n    aliasClient.listAliases(client).then((sets) => sets.map((ds) => ds.name)),\n    client.request({uri: '/features'}),\n  ])\n\n  let aliasName = await (alias || promptForDatasetAliasName(prompt))\n  let aliasOutputName = aliasName\n\n  if (aliasName.startsWith(ALIAS_PREFIX)) {\n    aliasName = aliasName.slice(1)\n  } else {\n    aliasOutputName = `${ALIAS_PREFIX}${aliasName}`\n  }\n\n  if (aliases.includes(aliasName)) {\n    throw new Error(`Dataset alias \"${aliasOutputName}\" already exists`)\n  }\n\n  if (targetDataset) {\n    const datasetErr = validateDatasetName(targetDataset)\n    if (datasetErr) {\n      throw new Error(datasetErr)\n    }\n  }\n\n  const datasetName = await (targetDataset || promptForDatasetName(prompt))\n  if (datasetName && !datasets.includes(datasetName)) {\n    throw new Error(`Dataset \"${datasetName}\" does not exist `)\n  }\n\n  const canCreateAlias = projectFeatures.includes('advancedDatasetManagement')\n  if (!canCreateAlias) {\n    throw new Error(`This project cannot create a dataset alias`)\n  }\n\n  try {\n    await aliasClient.createAlias(client, aliasName, datasetName)\n    output.print(\n      `Dataset alias ${aliasOutputName} created ${\n        datasetName && `and linked to ${datasetName}`\n      } successfully`,\n    )\n  } catch (err) {\n    throw new Error(`Dataset alias creation failed:\\n${err.message}`, {cause: err})\n  }\n}\n","import {type CliCommandAction} from '@sanity/cli'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport {validateDatasetAliasName} from '../../../actions/dataset/alias/validateDatasetAliasName'\nimport * as aliasClient from './datasetAliasesClient'\nimport {ALIAS_PREFIX} from './datasetAliasesClient'\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2)).option('force', {type: 'boolean'}).argv\n}\n\ninterface DeleteAliasFlags {\n  force?: boolean\n}\n\nexport const deleteAliasHandler: CliCommandAction<DeleteAliasFlags> = async (args, context) => {\n  const {apiClient, prompt, output} = context\n  const [, ds] = args.argsWithoutOptions\n  const {force} = await parseCliFlags(args)\n  const client = apiClient()\n  if (!ds) {\n    throw new Error('Dataset alias name must be provided')\n  }\n\n  let aliasName = `${ds}`\n  const dsError = validateDatasetAliasName(aliasName)\n  if (dsError) {\n    throw dsError\n  }\n  aliasName = aliasName.startsWith(ALIAS_PREFIX) ? aliasName.slice(1) : aliasName\n\n  const [fetchedAliases] = await Promise.all([aliasClient.listAliases(client)])\n  const linkedAlias = fetchedAliases.find((elem) => elem.name === aliasName)\n  const message =\n    linkedAlias && linkedAlias.datasetName\n      ? `This dataset alias is linked to ${linkedAlias.datasetName}. `\n      : ''\n\n  if (force) {\n    output.warn(`'--force' used: skipping confirmation, deleting alias \"${aliasName}\"`)\n  } else {\n    await prompt.single({\n      type: 'input',\n      message: `${message}Are you ABSOLUTELY sure you want to delete this dataset alias?\\n  Type the name of the dataset alias to confirm delete: `,\n      filter: (input) => `${input}`.trim(),\n      validate: (input) => {\n        return input === aliasName || 'Incorrect dataset alias name. Ctrl + C to cancel delete.'\n      },\n    })\n  }\n\n  // oxlint-disable-next-line always-return -- this is supposed to be Promise<void>\n  return aliasClient.removeAlias(client, aliasName).then(() => {\n    output.print('Dataset alias deleted successfully')\n  })\n}\n","import {type CliCommandAction} from '@sanity/cli'\n\nimport {promptForDatasetAliasName} from '../../../actions/dataset/alias/promptForDatasetAliasName'\nimport {validateDatasetAliasName} from '../../../actions/dataset/alias/validateDatasetAliasName'\nimport {promptForDatasetName} from '../../../actions/dataset/datasetNamePrompt'\nimport {validateDatasetName} from '../../../actions/dataset/validateDatasetName'\nimport * as aliasClient from './datasetAliasesClient'\nimport {ALIAS_PREFIX} from './datasetAliasesClient'\n\nexport const linkAliasHandler: CliCommandAction = async (args, context) => {\n  const {apiClient, output, prompt} = context\n  const [, alias, targetDataset] = args.argsWithoutOptions\n  const flags = args.extOptions\n  const client = apiClient()\n\n  const nameError = alias && validateDatasetAliasName(alias)\n  if (nameError) {\n    throw new Error(nameError)\n  }\n\n  const [datasets, fetchedAliases] = await Promise.all([\n    client.datasets.list().then((sets) => sets.map((ds) => ds.name)),\n    aliasClient.listAliases(client),\n  ])\n  const aliases = fetchedAliases.map((da) => da.name)\n\n  let aliasName = await (alias || promptForDatasetAliasName(prompt))\n  let aliasOutputName = aliasName\n\n  if (aliasName.startsWith(ALIAS_PREFIX)) {\n    aliasName = aliasName.slice(1)\n  } else {\n    aliasOutputName = `${ALIAS_PREFIX}${aliasName}`\n  }\n\n  if (!aliases.includes(aliasName)) {\n    throw new Error(`Dataset alias \"${aliasOutputName}\" does not exist `)\n  }\n\n  const datasetName = await (targetDataset || promptForDatasetName(prompt))\n  const datasetErr = validateDatasetName(datasetName)\n  if (datasetErr) {\n    throw new Error(datasetErr)\n  }\n\n  if (!datasets.includes(datasetName)) {\n    throw new Error(`Dataset \"${datasetName}\" does not exist `)\n  }\n\n  const linkedAlias = fetchedAliases.find((elem) => elem.name === aliasName)\n\n  if (linkedAlias && linkedAlias.datasetName) {\n    if (linkedAlias.datasetName === datasetName) {\n      throw new Error(`Dataset alias ${aliasOutputName} already linked to ${datasetName}`)\n    }\n\n    if (!flags.force) {\n      await prompt.single({\n        type: 'input',\n        message: `This alias is linked to dataset <${linkedAlias.datasetName}>. Are you ABSOLUTELY sure you want to link this dataset alias to this dataset?\n        \\n  Type YES/NO: `,\n        filter: (input) => `${input}`.toLowerCase(),\n        validate: (input) => {\n          return input === 'yes' || 'Ctrl + C to cancel dataset alias link.'\n        },\n      })\n    }\n  }\n\n  try {\n    await aliasClient.updateAlias(client, aliasName, datasetName)\n    output.print(`Dataset alias ${aliasOutputName} linked to ${datasetName} successfully`)\n  } catch (err) {\n    throw new Error(`Dataset alias link failed:\\n${err.message}`, {cause: err})\n  }\n}\n","import {type CliCommandAction} from '@sanity/cli'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport {promptForDatasetAliasName} from '../../../actions/dataset/alias/promptForDatasetAliasName'\nimport {validateDatasetAliasName} from '../../../actions/dataset/alias/validateDatasetAliasName'\nimport * as aliasClient from './datasetAliasesClient'\nimport {ALIAS_PREFIX} from './datasetAliasesClient'\n\ninterface UnlinkFlags {\n  force?: boolean\n}\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2)).option('force', {type: 'boolean'}).argv\n}\n\nexport const unlinkAliasHandler: CliCommandAction<UnlinkFlags> = async (args, context) => {\n  const {apiClient, output, prompt} = context\n  const [, alias] = args.argsWithoutOptions\n  const {force} = await parseCliFlags(args)\n  const client = apiClient()\n\n  const nameError = alias && validateDatasetAliasName(alias)\n  if (nameError) {\n    throw new Error(nameError)\n  }\n\n  const fetchedAliases = await aliasClient.listAliases(client)\n\n  let aliasName = await (alias || promptForDatasetAliasName(prompt))\n  let aliasOutputName = aliasName\n\n  if (aliasName.startsWith(ALIAS_PREFIX)) {\n    aliasName = aliasName.slice(1)\n  } else {\n    aliasOutputName = `${ALIAS_PREFIX}${aliasName}`\n  }\n\n  // get the current alias from the remote alias list\n  const linkedAlias = fetchedAliases.find((elem) => elem.name === aliasName)\n  if (!linkedAlias) {\n    throw new Error(`Dataset alias \"${aliasOutputName}\" does not exist`)\n  }\n\n  if (!linkedAlias.datasetName) {\n    throw new Error(`Dataset alias \"${aliasOutputName}\" is not linked to a dataset`)\n  }\n\n  if (force) {\n    output.warn(`'--force' used: skipping confirmation, unlinking alias \"${aliasOutputName}\"`)\n  } else {\n    await prompt.single({\n      type: 'input',\n      message: `Are you ABSOLUTELY sure you want to unlink this alias from the \"${linkedAlias.datasetName}\" dataset?\n        \\n  Type YES/NO: `,\n      filter: (input) => `${input}`.toLowerCase(),\n      validate: (input) => {\n        return input === 'yes' || 'Ctrl + C to cancel dataset alias unlink.'\n      },\n    })\n  }\n\n  try {\n    const result = await aliasClient.unlinkAlias(client, aliasName)\n    output.print(\n      `Dataset alias ${aliasOutputName} unlinked from ${result.datasetName} successfully`,\n    )\n  } catch (err) {\n    throw new Error(`Dataset alias unlink failed:\\n${err.message}`, {cause: err})\n  }\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\nimport oneline from 'oneline'\n\nimport {createAliasHandler} from './createAliasHandler'\nimport {deleteAliasHandler} from './deleteAliasHandler'\nimport {linkAliasHandler} from './linkAliasHandler'\nimport {unlinkAliasHandler} from './unlinkAliasHandler'\n\nconst helpText = `\nBelow are examples of the alias subcommand\n\nCreate Alias\n  sanity dataset alias create\n  sanity dataset alias create <alias-name>\n  sanity dataset alias create <alias-name> <target-dataset>\n\nDelete Alias\n  Options\n    --force Skips security prompt and forces link command\n\n  Usage\n    sanity dataset alias delete <alias-name>\n    sanity dataset alias delete <alias-name> --force\n\nLink Alias\n  Options\n    --force Skips security prompt and forces link command\n\n  Usage\n    sanity dataset alias link\n    sanity dataset alias link <alias-name>\n    sanity dataset alias link <alias-name> <target-dataset>\n    sanity dataset alias link <alias-name> <target-dataset> --force\n\nUn-link Alias\n  Options\n    --force Skips security prompt and forces link command\n\n  Usage\n    sanity dataset alias unlink\n    sanity dataset alias unlink <alias-name>\n    sanity dataset alias unlink <alias-name> --force\n`\n\nconst aliasCommand: CliCommandDefinition = {\n  name: 'alias',\n  group: 'dataset',\n  signature: 'SUBCOMMAND [ALIAS_NAME, TARGET_DATASET]',\n  helpText,\n  description: 'You can manage your dataset alias using this command.',\n  action: async (args, context) => {\n    const [verb] = args.argsWithoutOptions\n    switch (verb) {\n      case 'create':\n        await createAliasHandler(args, context)\n        break\n      case 'delete':\n        await deleteAliasHandler(args, context)\n        break\n      case 'unlink':\n        await unlinkAliasHandler(args, context)\n        break\n      case 'link':\n        await linkAliasHandler(args, context)\n        break\n      default:\n        throw new Error(oneline`\n          Invalid command provided. Available commands are: create, delete, link and unlink.\n          For more guide run the help command 'sanity dataset alias --help'\n        `)\n    }\n  },\n}\n\nexport default aliasCommand\n","import {type CliCommandContext} from '@sanity/cli'\nimport {Table} from 'console-table-printer'\nimport {formatDistance, formatDistanceToNow, parseISO} from 'date-fns'\n\ninterface ListFlags {\n  offset?: number\n  limit?: number\n}\n\ntype CopyDatasetListResponse = {\n  id: string\n  state: string\n  createdAt: string\n  updatedAt: string\n  sourceDataset: string\n  targetDataset: string\n  withHistory: boolean\n}[]\n\nexport async function listDatasetCopyJobs(\n  flags: ListFlags,\n  context: CliCommandContext,\n): Promise<void> {\n  const {apiClient, output, chalk} = context\n  const client = apiClient()\n  const projectId = client.config().projectId\n  const query: {offset?: string; limit?: string} = {}\n  let response\n\n  if (flags.offset && flags.offset >= 0) {\n    query.offset = `${flags.offset}`\n  }\n  if (flags.limit && flags.limit > 0) {\n    query.limit = `${flags.limit}`\n  }\n\n  try {\n    response = await client.request<CopyDatasetListResponse>({\n      method: 'GET',\n      uri: `/projects/${projectId}/datasets/copy`,\n      query,\n    })\n  } catch (error) {\n    if (error.statusCode) {\n      output.error(`${chalk.red(`Dataset copy list failed:\\n${error.response.body.message}`)}\\n`)\n    } else {\n      output.error(`${chalk.red(`Dataset copy list failed:\\n${error.message}`)}\\n`)\n    }\n  }\n\n  if (response && response.length > 0) {\n    const table = new Table({\n      title: 'Dataset copy jobs for this project in descending order',\n      columns: [\n        {name: 'id', title: 'Job ID', alignment: 'left'},\n        {name: 'sourceDataset', title: 'Source Dataset', alignment: 'left'},\n        {name: 'targetDataset', title: 'Target Dataset', alignment: 'left'},\n        {name: 'state', title: 'State', alignment: 'left'},\n        {name: 'withHistory', title: 'With history', alignment: 'left'},\n        {name: 'timeStarted', title: 'Time started', alignment: 'left'},\n        {name: 'timeTaken', title: 'Time taken', alignment: 'left'},\n      ],\n    })\n\n    response.forEach((job) => {\n      const {id, state, createdAt, updatedAt, sourceDataset, targetDataset, withHistory} = job\n\n      let timeStarted = ''\n      if (createdAt !== '') {\n        timeStarted = formatDistanceToNow(parseISO(createdAt))\n      }\n\n      let timeTaken = ''\n      if (updatedAt !== '') {\n        timeTaken = formatDistance(parseISO(updatedAt), parseISO(createdAt))\n      }\n\n      let color\n      switch (state) {\n        case 'completed':\n          color = 'green'\n          break\n        case 'failed':\n          color = 'red'\n          break\n        case 'pending':\n          color = 'yellow'\n          break\n        default:\n          color = ''\n      }\n\n      table.addRow(\n        {\n          id,\n          state,\n          withHistory,\n          timeStarted: `${timeStarted} ago`,\n          timeTaken,\n          sourceDataset,\n          targetDataset,\n        },\n        {color},\n      )\n    })\n\n    table.printTable()\n  } else {\n    output.print(\"This project doesn't have any dataset copy jobs\")\n  }\n}\n","import {type SanityClient} from '@sanity/client'\n\nexport const getClientUrl = (client: SanityClient, uri: string, useCdn = false): string => {\n  const config = client.config()\n  const base = useCdn ? config.cdnUrl : config.url\n  return `${base}/${uri.replace(/^\\//, '')}`\n}\n","import {type CliCommandDefinition, type CliOutputter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport EventSource from '@sanity/eventsource'\nimport {Observable} from 'rxjs'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport {promptForDatasetName} from '../../actions/dataset/datasetNamePrompt'\nimport {listDatasetCopyJobs} from '../../actions/dataset/listDatasetCopyJobs'\nimport {validateDatasetName} from '../../actions/dataset/validateDatasetName'\nimport {debug} from '../../debug'\nimport {getClientUrl} from '../../util/getClientUrl'\n\nconst helpText = `\nOptions\n  --detach Start the copy without waiting for it to finish\n  --attach <job-id> Attach to the running copy process to show progress\n  --skip-history Don't preserve document history on copy\n  --list Lists all dataset copy jobs corresponding to a certain criteria.\n  --offset Start position in the list of jobs. Default 0. With --list.\n  --limit Maximum number of jobs returned. Default 10. Maximum 1000. With --list.\n\nExamples\n  sanity dataset copy\n  sanity dataset copy <source-dataset>\n  sanity dataset copy <source-dataset> <target-dataset>\n  sanity dataset copy --skip-history <source-dataset> <target-dataset>\n  sanity dataset copy --detach <source-dataset> <target-dataset>\n  sanity dataset copy --attach <job-id>\n  sanity dataset copy --list\n  sanity dataset copy --list --offset=2\n  sanity dataset copy --list --offset=2 --limit=10\n`\n\ninterface CopyProgressStreamEvent {\n  type: 'reconnect' | string\n  progress?: number\n}\n\ninterface CopyDatasetFlags {\n  'list'?: boolean\n  'attach'?: string\n  'detach'?: boolean\n  'offset'?: number\n  'limit'?: number\n  'skip-history'?: boolean\n}\n\ninterface CopyDatasetResponse {\n  jobId: string\n}\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2))\n    .option('attach', {type: 'string'})\n    .option('list', {type: 'boolean'})\n    .option('limit', {type: 'number'})\n    .option('offset', {type: 'number'})\n    .option('skip-history', {type: 'boolean'})\n    .option('detach', {type: 'boolean'}).argv\n}\n\nconst progress = (url: string) => {\n  return new Observable<CopyProgressStreamEvent>((observer) => {\n    let progressSource = new EventSource(url)\n    let stopped = false\n\n    function onError(error: unknown) {\n      if (progressSource) {\n        progressSource.close()\n      }\n\n      debug(`Error received: ${error}`)\n      if (stopped) {\n        return\n      }\n      observer.next({type: 'reconnect'})\n      progressSource = new EventSource(url)\n    }\n\n    function onChannelError(error: MessageEvent) {\n      stopped = true\n      progressSource.close()\n      observer.error(error)\n    }\n\n    function onMessage(event: MessageEvent) {\n      const data = JSON.parse(event.data)\n      if (data.state === 'failed') {\n        debug('Job failed. Data: %o', event)\n        observer.error(event)\n      } else if (data.state === 'completed') {\n        debug('Job succeeded. Data: %o', event)\n        onComplete()\n      } else {\n        debug(`Job progressed. Data: %o`, event)\n        observer.next(data)\n      }\n    }\n\n    function onComplete() {\n      progressSource.removeEventListener('error', onError)\n      progressSource.removeEventListener('channel_error', onChannelError)\n      progressSource.removeEventListener('job', onMessage)\n      progressSource.removeEventListener('done', onComplete)\n      progressSource.close()\n      observer.complete()\n    }\n\n    progressSource.addEventListener('error', onError)\n    progressSource.addEventListener('channel_error', onChannelError)\n    progressSource.addEventListener('job', onMessage)\n    progressSource.addEventListener('done', onComplete)\n  })\n}\n\nconst followProgress = (\n  jobId: string,\n  client: SanityClient,\n  output: CliOutputter,\n): Promise<void> => {\n  let currentProgress = 0\n\n  const spinner = output.spinner({}).start()\n  const listenUrl = getClientUrl(client, `jobs/${jobId}/listen`)\n\n  debug(`Listening to ${listenUrl}`)\n\n  return new Promise((resolve, reject) => {\n    progress(listenUrl).subscribe({\n      next: (event) => {\n        if (typeof event.progress === 'number') {\n          currentProgress = event.progress\n        }\n\n        spinner.text = `Copy in progress: ${currentProgress}%`\n      },\n      error: (err) => {\n        spinner.fail()\n        reject(new Error(`${err.data}`))\n      },\n      complete: () => {\n        spinner.succeed('Copy finished.')\n        resolve()\n      },\n    })\n  })\n}\n\nconst copyDatasetCommand: CliCommandDefinition<CopyDatasetFlags> = {\n  name: 'copy',\n  group: 'dataset',\n  signature: '[SOURCE_DATASET] [TARGET_DATASET]',\n  helpText,\n  description:\n    'Manages dataset copying, including starting a new copy job, listing copy jobs and following the progress of a running copy job',\n  action: async (args, context) => {\n    const {apiClient, output, prompt, chalk} = context\n    // Reparsing CLI flags for better control of binary flags\n    const flags: CopyDatasetFlags = await parseCliFlags(args)\n    const client = apiClient()\n\n    if (flags.list) {\n      await listDatasetCopyJobs(flags, context)\n      return\n    }\n\n    if (flags.attach) {\n      const jobId = flags.attach\n\n      if (!jobId) {\n        throw new Error('Please supply a jobId')\n      }\n\n      await followProgress(jobId, client, output)\n      return\n    }\n\n    const [sourceDataset, targetDataset] = args.argsWithoutOptions\n    const shouldSkipHistory = Boolean(flags['skip-history'])\n\n    const nameError = sourceDataset && validateDatasetName(sourceDataset)\n    if (nameError) {\n      throw new Error(nameError)\n    }\n\n    const existingDatasets = await client.datasets\n      .list()\n      .then((datasets) => datasets.map((ds) => ds.name))\n\n    const sourceDatasetName = await (sourceDataset ||\n      promptForDatasetName(prompt, {message: 'Source dataset name:'}))\n    if (!existingDatasets.includes(sourceDatasetName)) {\n      throw new Error(`Source dataset \"${sourceDatasetName}\" doesn't exist`)\n    }\n\n    const targetDatasetName = await (targetDataset ||\n      promptForDatasetName(prompt, {message: 'Target dataset name:'}))\n    if (existingDatasets.includes(targetDatasetName)) {\n      throw new Error(`Target dataset \"${targetDatasetName}\" already exists`)\n    }\n\n    const err = validateDatasetName(targetDatasetName)\n    if (err) {\n      throw new Error(err)\n    }\n\n    try {\n      const response = await client.request<CopyDatasetResponse>({\n        method: 'PUT',\n        uri: `/datasets/${sourceDatasetName}/copy`,\n        body: {\n          targetDataset: targetDatasetName,\n          skipHistory: shouldSkipHistory,\n        },\n      })\n\n      output.print(\n        `Copying dataset ${chalk.green(sourceDatasetName)} to ${chalk.green(targetDatasetName)}...`,\n      )\n\n      if (!shouldSkipHistory) {\n        output.print(\n          `Note: You can run this command with flag '--skip-history'. The flag will reduce copy time in larger datasets.`,\n        )\n      }\n\n      output.print(`Job ${chalk.green(response.jobId)} started`)\n\n      if (flags.detach) {\n        return\n      }\n\n      await followProgress(response.jobId, client, output)\n      output.print(`Job ${chalk.green(response.jobId)} completed`)\n    } catch (error) {\n      if (error.statusCode) {\n        output.print(`${chalk.red(`Dataset copying failed:\\n${error.response.body.message}`)}\\n`)\n      } else {\n        output.print(`${chalk.red(`Dataset copying failed:\\n${error.message}`)}\\n`)\n      }\n    }\n  },\n}\n\nexport default copyDatasetCommand\n","import {type CliCommandDefinition, type CliOutputter, type CliPrompter} from '@sanity/cli'\n\nimport {promptForDatasetName} from '../../actions/dataset/datasetNamePrompt'\nimport {validateDatasetName} from '../../actions/dataset/validateDatasetName'\nimport {debug} from '../../debug'\n\nconst helpText = `\nOptions\n  --visibility <mode> Set visibility for this dataset (public/private)\n\nExamples\n  sanity dataset create\n  sanity dataset create <name>\n  sanity dataset create <name> --visibility private\n`\n\nconst allowedModes = ['private', 'public', 'custom']\n\ninterface CreateFlags {\n  visibility?: 'private' | 'public' | 'custom'\n}\n\nconst createDatasetCommand: CliCommandDefinition<CreateFlags> = {\n  name: 'create',\n  group: 'dataset',\n  signature: '[NAME]',\n  helpText,\n  description: 'Create a new dataset within your project',\n  action: async (args, context) => {\n    const {apiClient, output, prompt} = context\n    const flags = args.extOptions\n    const [dataset] = args.argsWithoutOptions\n    const client = apiClient()\n\n    const nameError = dataset && validateDatasetName(dataset)\n    if (nameError) {\n      throw new Error(nameError)\n    }\n\n    const [datasets, projectFeatures] = await Promise.all([\n      client.datasets.list().then((sets) => sets.map((ds) => ds.name)),\n      client.request({uri: '/features'}),\n    ])\n\n    if (flags.visibility && !allowedModes.includes(flags.visibility)) {\n      throw new Error(`Visibility mode \"${flags.visibility}\" not allowed`)\n    }\n\n    const datasetName = await (dataset || promptForDatasetName(prompt))\n    if (datasets.includes(datasetName)) {\n      throw new Error(`Dataset \"${datasetName}\" already exists`)\n    }\n\n    const canCreatePrivate = projectFeatures.includes('privateDataset')\n    debug('%s create private datasets', canCreatePrivate ? 'Can' : 'Cannot')\n\n    const defaultAclMode = canCreatePrivate ? flags.visibility : 'public'\n    const aclMode = await (defaultAclMode || promptForDatasetVisibility(prompt, output))\n\n    try {\n      await client.datasets.create(datasetName, {aclMode})\n      output.print('Dataset created successfully')\n    } catch (err) {\n      throw new Error(`Dataset creation failed:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nasync function promptForDatasetVisibility(prompt: CliPrompter, output: CliOutputter) {\n  const mode = await prompt.single<'public' | 'private'>({\n    type: 'list',\n    message: 'Dataset visibility',\n    choices: [\n      {\n        value: 'public',\n        name: 'Public (world readable)',\n      },\n      {\n        value: 'private',\n        name: 'Private (Authenticated user or token needed)',\n      },\n    ],\n  })\n\n  if (mode === 'private') {\n    output.print(\n      'Please note that while documents are private, assets (files and images) are still public\\n',\n    )\n  }\n\n  return mode\n}\n\nexport default createDatasetCommand\n","export default {\n  name: 'dataset',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Manages datasets, like create or delete, within projects',\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {validateDatasetName} from '../../actions/dataset/validateDatasetName'\n\nconst datasetVisibilityCommand: CliCommandDefinition = {\n  name: 'visibility',\n  group: 'dataset',\n  helpText: '',\n  signature: 'get/set [dataset] [mode]',\n  description: 'Set visibility of a dataset',\n  action: async (args, context) => {\n    const {apiClient, output} = context\n    const [action, ds, aclMode] = args.argsWithoutOptions\n    const client = apiClient()\n\n    if (!client.datasets.edit) {\n      throw new Error('@sanity/cli must be upgraded first:\\n  npm install -g @sanity/cli')\n    }\n\n    if (!action) {\n      throw new Error('Action must be provided (get/set)')\n    }\n\n    if (!['set', 'get'].includes(action)) {\n      throw new Error('Invalid action (only get/set allowed)')\n    }\n\n    if (!ds) {\n      throw new Error('Dataset name must be provided')\n    }\n\n    if (action === 'set' && !aclMode) {\n      throw new Error('Please provide a visibility mode (public/private)')\n    }\n\n    const dataset = `${ds}`\n    const dsError = validateDatasetName(dataset)\n    if (dsError) {\n      throw new Error(dsError)\n    }\n\n    const current = (await client.datasets.list()).find((curr) => curr.name === dataset)\n\n    if (!current) {\n      throw new Error('Dataset not found')\n    }\n\n    if (action === 'get') {\n      output.print(current.aclMode)\n      return\n    }\n\n    if (current.aclMode === aclMode) {\n      output.print(`Dataset already in \"${aclMode}\"-mode`)\n      return\n    }\n\n    if (aclMode === 'private') {\n      output.print(\n        'Please note that while documents are private, assets (files and images) are still public\\n',\n      )\n    }\n\n    await client.datasets.edit(dataset, {aclMode: aclMode as 'public' | 'private'})\n    output.print('Dataset visibility changed')\n  },\n}\n\nexport default datasetVisibilityCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport {validateDatasetName} from '../../actions/dataset/validateDatasetName'\n\nconst helpText = `\nOptions\n  --force Do not prompt for delete confirmation - forcefully delete\n\nExamples\n  sanity dataset delete\n  sanity dataset delete my-dataset\n  sanity dataset delete my-dataset --force\n`\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2)).option('force', {type: 'boolean'}).argv\n}\n\ninterface DeleteDatasetFlags {\n  force?: boolean\n}\n\nconst deleteDatasetCommand: CliCommandDefinition<DeleteDatasetFlags> = {\n  name: 'delete',\n  group: 'dataset',\n  helpText,\n  signature: '[datasetName]',\n  description: 'Delete a dataset within your project',\n  action: async (args, context) => {\n    const {apiClient, prompt, output} = context\n    const {force} = await parseCliFlags(args)\n    const [ds] = args.argsWithoutOptions\n    if (!ds) {\n      throw new Error('Dataset name must be provided')\n    }\n\n    const dataset = `${ds}`\n    const dsError = validateDatasetName(dataset)\n    if (dsError) {\n      throw dsError\n    }\n\n    if (force) {\n      output.warn(`'--force' used: skipping confirmation, deleting dataset \"${dataset}\"`)\n    } else {\n      await prompt.single({\n        type: 'input',\n        message:\n          'Are you ABSOLUTELY sure you want to delete this dataset?\\n  Type the name of the dataset to confirm delete:',\n        filter: (input) => `${input}`.trim(),\n        validate: (input) => {\n          return input === dataset || 'Incorrect dataset name. Ctrl + C to cancel delete.'\n        },\n      })\n    }\n\n    await apiClient().datasets.delete(dataset)\n    output.print('Dataset deleted successfully')\n  },\n}\n\nexport default deleteDatasetCommand\n","import fs from 'node:fs/promises'\nimport path from 'node:path'\n\nimport {type CliCommandDefinition, type CliPrompter} from '@sanity/cli'\nimport {exportDataset, type ExportMode, type ExportProgress} from '@sanity/export'\nimport {absolutify} from '@sanity/util/fs'\nimport prettyMs from 'pretty-ms'\n\nimport {chooseDatasetPrompt} from '../../actions/dataset/chooseDatasetPrompt'\nimport {validateDatasetName} from '../../actions/dataset/validateDatasetName'\n\nconst noop = () => null\n\nconst helpText = `\nOptions\n  --raw                     Extract only documents, without rewriting asset references\n  --no-assets               Export only non-asset documents and remove references to image assets\n  --no-drafts               Export only published versions of documents\n  --no-compress             Skips compressing tarball entries (still generates a gzip file)\n  --types                   Defines which document types to export\n  --overwrite               Overwrite any file with the same name\n  --asset-concurrency <num> Concurrent number of asset downloads\n  --mode <stream|cursor>    Uses a cursor when exporting, this might be more performant for larger datasets, but might not be as accurate if the dataset is being modified during export. Defaults to stream\n\nExamples\n  sanity dataset export moviedb localPath.tar.gz\n  sanity dataset export moviedb assetless.tar.gz --no-assets\n  sanity dataset export staging staging.tar.gz --raw\n  sanity dataset export staging staging.tar.gz --types products,shops\n`\n\ninterface ExportFlags {\n  'raw'?: boolean\n  'assets'?: boolean\n  'drafts'?: boolean\n  'compress'?: boolean\n  'overwrite'?: boolean\n  'types'?: string\n  'asset-concurrency'?: string\n  'mode'?: string\n}\n\ninterface ParsedExportFlags {\n  raw?: boolean\n  assets?: boolean\n  drafts?: boolean\n  compress?: boolean\n  overwrite?: boolean\n  types?: string[]\n  assetConcurrency?: number\n  mode?: ExportMode\n}\n\nfunction parseFlags(rawFlags: ExportFlags): ParsedExportFlags {\n  const flags: ParsedExportFlags = {}\n  if (rawFlags.types) {\n    flags.types = `${rawFlags.types}`.split(',')\n  }\n\n  if (rawFlags['asset-concurrency']) {\n    flags.assetConcurrency = parseInt(rawFlags['asset-concurrency'], 10)\n  }\n\n  if (typeof rawFlags.raw !== 'undefined') {\n    flags.raw = Boolean(rawFlags.raw)\n  }\n\n  if (typeof rawFlags.assets !== 'undefined') {\n    flags.assets = Boolean(rawFlags.assets)\n  }\n\n  if (typeof rawFlags.drafts !== 'undefined') {\n    flags.drafts = Boolean(rawFlags.drafts)\n  }\n\n  if (typeof rawFlags.compress !== 'undefined') {\n    flags.compress = Boolean(rawFlags.compress)\n  }\n\n  if (typeof rawFlags.overwrite !== 'undefined') {\n    flags.overwrite = Boolean(rawFlags.overwrite)\n  }\n\n  if (rawFlags.mode === 'stream' || rawFlags.mode === 'cursor') {\n    flags.mode = rawFlags.mode\n  }\n\n  return flags\n}\n\nconst exportDatasetCommand: CliCommandDefinition<ExportFlags> = {\n  name: 'export',\n  group: 'dataset',\n  signature: '[NAME] [DESTINATION]',\n  description: `Export dataset to local filesystem as a gzipped tarball.\n      Assets failing with HTTP status codes 401, 403 and 404 upon download are ignored and excluded from export.`,\n  helpText,\n  action: async (args, context) => {\n    const {apiClient, output, chalk, workDir, prompt} = context\n    const client = apiClient()\n    const [targetDataset, targetDestination] = args.argsWithoutOptions\n    const flags = parseFlags(args.extOptions)\n\n    let dataset = targetDataset ? `${targetDataset}` : null\n    if (!dataset) {\n      dataset = await chooseDatasetPrompt(context, {message: 'Select dataset to export'})\n    }\n\n    const dsError = validateDatasetName(dataset)\n    if (dsError) {\n      throw dsError\n    }\n\n    // Verify existence of dataset before trying to export from it\n    const datasets = await client.datasets.list()\n    if (!datasets.find((set) => set.name === dataset)) {\n      throw new Error(`Dataset with name \"${dataset}\" not found`)\n    }\n\n    // Print information about what projectId and dataset it is being exported from\n    const {projectId} = client.config()\n\n    output.print('╭───────────────────────────────────────────────╮')\n    output.print('│                                               │')\n    output.print('│ Exporting from:                               │')\n    output.print(`│ ${chalk.bold('projectId')}: ${chalk.cyan(projectId).padEnd(44)} │`)\n    output.print(`│ ${chalk.bold('dataset')}: ${chalk.cyan(dataset).padEnd(46)} │`)\n    output.print('│                                               │')\n    output.print('╰───────────────────────────────────────────────╯')\n    output.print('')\n\n    let destinationPath = targetDestination\n    if (!destinationPath) {\n      destinationPath = await prompt.single({\n        type: 'input',\n        message: 'Output path:',\n        default: path.join(workDir, `${dataset}.tar.gz`),\n        filter: absolutify,\n      })\n    }\n\n    const outputPath = await getOutputPath(destinationPath, dataset, prompt, flags)\n    if (!outputPath) {\n      output.print('Cancelled')\n      return\n    }\n\n    // If we are dumping to a file, let the user know where it's at\n    if (outputPath !== '-') {\n      output.print(`Exporting dataset \"${chalk.cyan(dataset)}\" to \"${chalk.cyan(outputPath)}\"`)\n    }\n\n    let currentStep = 'Exporting documents...'\n    let spinner = output.spinner(currentStep).start()\n    const onProgress = (progress: ExportProgress) => {\n      if (progress.step !== currentStep) {\n        spinner.succeed()\n        spinner = output.spinner(progress.step).start()\n      } else if (progress.step === currentStep && progress.update) {\n        spinner.text = `${progress.step} (${progress.current}/${progress.total})`\n      }\n\n      currentStep = progress.step\n    }\n\n    const start = Date.now()\n    try {\n      await exportDataset({\n        client,\n        dataset,\n        outputPath: outputPath === '-' ? process.stdout : outputPath,\n        onProgress,\n        ...flags,\n      })\n      spinner.succeed()\n    } catch (err) {\n      spinner.fail()\n      throw err\n    }\n\n    output.print(`Export finished (${prettyMs(Date.now() - start)})`)\n  },\n}\n\nasync function getOutputPath(\n  destination: string,\n  dataset: string,\n  prompt: CliPrompter,\n  flags: ParsedExportFlags,\n) {\n  if (destination === '-') {\n    return '-'\n  }\n\n  const dstPath = path.isAbsolute(destination)\n    ? destination\n    : path.resolve(process.cwd(), destination)\n\n  let dstStats = await fs.stat(dstPath).catch(noop)\n  const looksLikeFile = dstStats ? dstStats.isFile() : path.basename(dstPath).indexOf('.') !== -1\n\n  if (!dstStats) {\n    const createPath = looksLikeFile ? path.dirname(dstPath) : dstPath\n\n    await fs.mkdir(createPath, {recursive: true})\n  }\n\n  const finalPath = looksLikeFile ? dstPath : path.join(dstPath, `${dataset}.tar.gz`)\n  dstStats = await fs.stat(finalPath).catch(noop)\n\n  if (!flags.overwrite && dstStats && dstStats.isFile()) {\n    const shouldOverwrite = await prompt.single({\n      type: 'confirm',\n      message: `File \"${finalPath}\" already exists, would you like to overwrite it?`,\n      default: false,\n    })\n\n    if (!shouldOverwrite) {\n      return false\n    }\n  }\n\n  return finalPath\n}\n\nexport default exportDatasetCommand\n","import {createReadStream} from 'node:fs'\nimport fs from 'node:fs/promises'\nimport path from 'node:path'\n\nimport {type CliCommandContext, type CliCommandDefinition, type CliOutputter} from '@sanity/cli'\nimport {sanityImport} from '@sanity/import'\nimport {getIt} from 'get-it'\nimport {promise} from 'get-it/middleware'\nimport {padStart} from 'lodash-es'\nimport prettyMs from 'pretty-ms'\n\nimport {chooseDatasetPrompt} from '../../actions/dataset/chooseDatasetPrompt'\nimport {validateDatasetName} from '../../actions/dataset/validateDatasetName'\nimport {debug} from '../../debug'\n\nconst yellow = (str: string) => `\\u001b[33m${str}\\u001b[39m`\n\nconst helpText = `\nOptions\n  --missing On duplicate document IDs, skip importing document in question\n  --replace On duplicate document IDs, replace existing document with imported document\n  --allow-failing-assets Skip assets that cannot be fetched/uploaded\n  --replace-assets Skip reuse of existing assets\n  --skip-cross-dataset-references Skips references to other datasets\n\nRarely used options (should generally not be used)\n  --allow-assets-in-different-dataset Allow asset documents to reference different project/dataset\n  --allow-system-documents Allow system documents like dataset permissions and custom retention to be imported\n\nExamples\n  # Import \"moviedb.ndjson\" from the current directory to the dataset called \"moviedb\"\n  sanity dataset import moviedb.ndjson moviedb\n\n  # Import \"moviedb.tar.gz\" from the current directory to the dataset called \"moviedb\",\n  # replacing any documents encountered that have the same document IDs\n  sanity dataset import moviedb.tar.gz moviedb --replace\n\n  # Import from a folder containing an ndjson file, such as an extracted tarball\n  # retrieved through \"sanity dataset export\".\n  sanity dataset import ~/some/folder moviedb\n\n  # Import from a remote URL. Will download and extract the tarball to a temporary\n  # location before importing it.\n  sanity dataset import https://some.url/moviedb.tar.gz moviedb --replace\n`\n\ninterface ImportFlags {\n  'allow-assets-in-different-dataset'?: boolean\n  'allow-failing-assets'?: boolean\n  'asset-concurrency'?: string\n  'replace-assets'?: boolean\n  'skip-cross-dataset-references'?: boolean\n  'allow-system-documents'?: boolean\n  'replace'?: boolean\n  'missing'?: boolean\n}\n\ninterface ParsedImportFlags {\n  allowAssetsInDifferentDataset?: boolean\n  allowFailingAssets?: boolean\n  assetConcurrency?: number\n  skipCrossDatasetReferences?: boolean\n  allowSystemDocuments?: boolean\n  replaceAssets?: boolean\n  replace?: boolean\n  missing?: boolean\n}\n\ninterface ProgressEvent {\n  step: string\n  total?: number\n  current?: number\n}\n\ninterface ImportWarning {\n  message: string\n  type?: string\n  url?: string\n}\n\nfunction toBoolIfSet(flag: unknown): boolean | undefined {\n  return typeof flag === 'undefined' ? undefined : Boolean(flag)\n}\n\nfunction parseFlags(rawFlags: ImportFlags): ParsedImportFlags {\n  const allowAssetsInDifferentDataset = toBoolIfSet(rawFlags['allow-assets-in-different-dataset'])\n  const allowFailingAssets = toBoolIfSet(rawFlags['allow-failing-assets'])\n  const assetConcurrency = rawFlags['asset-concurrency']\n    ? parseInt(rawFlags['asset-concurrency'], 10)\n    : undefined\n  const replaceAssets = toBoolIfSet(rawFlags['replace-assets'])\n  const skipCrossDatasetReferences = toBoolIfSet(rawFlags['skip-cross-dataset-references'])\n  const allowSystemDocuments = toBoolIfSet(rawFlags['allow-system-documents'])\n  const replace = toBoolIfSet(rawFlags.replace)\n  const missing = toBoolIfSet(rawFlags.missing)\n  return {\n    allowAssetsInDifferentDataset,\n    allowFailingAssets,\n    assetConcurrency,\n    skipCrossDatasetReferences,\n    allowSystemDocuments,\n    replaceAssets,\n    replace,\n    missing,\n  }\n}\n\n// The minimum supported API version, providing the ability to handle version documents.\nconst MINIMUM_API_VERSION = '2025-02-19'\n\nconst importDatasetCommand: CliCommandDefinition = {\n  name: 'import',\n  group: 'dataset',\n  signature: '[FILE | FOLDER | URL] [TARGET_DATASET]',\n  description: 'Import documents to given dataset from either an ndjson file or a gzipped tarball',\n  helpText,\n  // eslint-disable-next-line max-statements\n  action: async (args, context) => {\n    const {apiClient, output, chalk, fromInitCommand} = context\n    const flags = parseFlags(args.extOptions)\n    const {\n      allowAssetsInDifferentDataset,\n      allowFailingAssets,\n      assetConcurrency,\n      skipCrossDatasetReferences,\n      allowSystemDocuments,\n      replaceAssets,\n    } = flags\n\n    const operation = getMutationOperation(args.extOptions)\n    const releasesOperation = getReleasesOperation(flags)\n    const client = apiClient()\n\n    const [file, target] = args.argsWithoutOptions\n    if (!file) {\n      throw new Error(\n        `Source file name and target dataset must be specified (\"sanity dataset import ${chalk.bold(\n          '[file]',\n        )} [dataset]\")`,\n      )\n    }\n\n    const targetDataset = await determineTargetDataset(target, context)\n    debug(`Target dataset has been set to \"${targetDataset}\"`)\n\n    const isUrl = /^https?:\\/\\//i.test(file)\n    let inputStream\n    let assetsBase\n    let sourceIsFolder = false\n\n    if (isUrl) {\n      debug('Input is a URL, streaming from source URL')\n      inputStream = await getUrlStream(file)\n    } else {\n      const sourceFile = path.resolve(process.cwd(), file)\n      const fileStats = await fs.stat(sourceFile).catch(() => null)\n      if (!fileStats) {\n        throw new Error(`${sourceFile} does not exist or is not readable`)\n      }\n\n      sourceIsFolder = fileStats.isDirectory()\n      if (sourceIsFolder) {\n        inputStream = sourceFile\n      } else {\n        assetsBase = path.dirname(sourceFile)\n        inputStream = createReadStream(sourceFile)\n      }\n    }\n\n    const importClient = client.clone().config({\n      apiVersion: MINIMUM_API_VERSION,\n      dataset: targetDataset,\n    })\n\n    // Print information about what projectId and dataset it is being imported to\n    const {projectId, dataset} = importClient.config()\n\n    output.print('╭───────────────────────────────────────────────╮')\n    output.print('│                                               │')\n    output.print('│ Importing to:                                 │')\n    output.print(`│ ${chalk.bold('projectId')}: ${chalk.cyan(projectId).padEnd(44)} │`)\n    output.print(`│ ${chalk.bold('dataset')}: ${chalk.cyan(dataset).padEnd(46)} │`)\n    output.print('│                                               │')\n    output.print('╰───────────────────────────────────────────────╯')\n    output.print('')\n\n    let currentStep: string | undefined\n    let currentProgress: ReturnType<CliOutputter['spinner']> | undefined\n    let stepStart: number | undefined\n    let spinInterval: ReturnType<typeof setInterval> | null = null\n    let percent: string | undefined\n\n    function onProgress(opts: ProgressEvent) {\n      const lengthComputable = opts.total\n      const sameStep = opts.step == currentStep\n      percent = getPercentage(opts)\n\n      if (lengthComputable && opts.total === opts.current) {\n        if (spinInterval) {\n          clearInterval(spinInterval)\n        }\n        spinInterval = null\n      }\n\n      if (sameStep) {\n        return\n      }\n\n      // Moved to a new step\n      const prevStep = currentStep\n      const prevStepStart = stepStart || Date.now()\n      stepStart = Date.now()\n      currentStep = opts.step\n\n      if (currentProgress && currentProgress.succeed) {\n        const timeSpent = prettyMs(Date.now() - prevStepStart, {\n          secondsDecimalDigits: 2,\n        })\n        currentProgress.text = `[100%] ${prevStep} (${timeSpent})`\n        currentProgress.succeed()\n      }\n\n      currentProgress = output.spinner(`[0%] ${opts.step} (0.00s)`).start()\n\n      if (spinInterval) {\n        clearInterval(spinInterval)\n        spinInterval = null\n      }\n\n      spinInterval = setInterval(() => {\n        const timeSpent = prettyMs(Date.now() - prevStepStart, {\n          secondsDecimalDigits: 2,\n        })\n\n        if (currentProgress) {\n          currentProgress.text = `${percent}${opts.step} (${timeSpent})`\n        }\n      }, 60)\n    }\n\n    function endTask({success}: {success: boolean}) {\n      if (spinInterval) {\n        clearInterval(spinInterval)\n      }\n\n      spinInterval = null\n\n      if (success && stepStart && currentProgress) {\n        const timeSpent = prettyMs(Date.now() - stepStart, {\n          secondsDecimalDigits: 2,\n        })\n        currentProgress.text = `[100%] ${currentStep} (${timeSpent})`\n        currentProgress.succeed()\n      } else if (currentProgress) {\n        currentProgress.fail()\n      }\n    }\n\n    // Start the import!\n    try {\n      const {numDocs, warnings} = await sanityImport(inputStream, {\n        client: importClient,\n        assetsBase,\n        operation,\n        releasesOperation,\n        onProgress,\n        allowFailingAssets,\n        allowAssetsInDifferentDataset,\n        skipCrossDatasetReferences,\n        allowSystemDocuments,\n        assetConcurrency,\n        replaceAssets,\n      })\n\n      endTask({success: true})\n\n      output.print('Done! Imported %d documents to dataset \"%s\"\\n', numDocs, targetDataset)\n      printWarnings(warnings, output)\n    } catch (err) {\n      endTask({success: false})\n\n      const isNonRefConflict =\n        !fromInitCommand &&\n        err.response &&\n        err.response.statusCode === 409 &&\n        err.step !== 'strengthen-references'\n\n      if (!isNonRefConflict) {\n        throw err\n      }\n\n      const message = [\n        err.message,\n        '',\n        'You probably want either:',\n        ' --replace (replace existing documents with same IDs)',\n        ' --missing (only import documents that do not already exist)',\n        '',\n      ].join('\\n')\n\n      // @todo SUBCLASS ERROR?\n      const error = new Error(message) as any\n      error.details = err.details\n      error.response = err.response\n      error.responseBody = err.responseBody\n\n      throw error\n    }\n  },\n}\n\nasync function determineTargetDataset(target: string, context: CliCommandContext) {\n  const {apiClient, output, prompt} = context\n  const client = apiClient()\n\n  if (target) {\n    const dsError = validateDatasetName(target)\n    if (dsError) {\n      throw new Error(dsError)\n    }\n  }\n\n  debug('Fetching available datasets')\n  const spinner = output.spinner('Fetching available datasets').start()\n  const datasets = await client.datasets.list()\n  spinner.succeed('[100%] Fetching available datasets')\n\n  let targetDataset = target ? `${target}` : null\n  if (!targetDataset) {\n    targetDataset = await chooseDatasetPrompt(context, {\n      message: 'Select target dataset',\n      allowCreation: true,\n    })\n  } else if (!datasets.find((dataset) => dataset.name === targetDataset)) {\n    debug('Target dataset does not exist, prompting for creation')\n    const shouldCreate = await prompt.single({\n      type: 'confirm',\n      message: `Dataset \"${targetDataset}\" does not exist, would you like to create it?`,\n      default: true,\n    })\n\n    if (!shouldCreate) {\n      throw new Error(`Dataset \"${targetDataset}\" does not exist`)\n    }\n\n    await client.datasets.create(targetDataset)\n  }\n\n  return targetDataset\n}\n\nfunction getMutationOperation(flags: ParsedImportFlags) {\n  const {replace, missing} = flags\n  if (replace && missing) {\n    throw new Error('Cannot use both --replace and --missing')\n  }\n\n  if (flags.replace) {\n    return 'createOrReplace'\n  }\n\n  if (flags.missing) {\n    return 'createIfNotExists'\n  }\n\n  return 'create'\n}\n\nfunction getReleasesOperation(flags: ParsedImportFlags): 'fail' | 'ignore' | 'replace' {\n  const {replace, missing} = flags\n  if (replace) {\n    return 'replace'\n  }\n  if (missing) {\n    return 'ignore'\n  }\n  return 'fail'\n}\n\nfunction getPercentage(opts: ProgressEvent) {\n  if (!opts.total || typeof opts.current === 'undefined') {\n    return ''\n  }\n\n  const percent = Math.floor((opts.current / opts.total) * 100)\n  return `[${padStart(`${percent}`, 3, ' ')}%] `\n}\n\nfunction getUrlStream(url: string) {\n  const request = getIt([promise({onlyBody: true})])\n  return request({url, stream: true})\n}\n\nfunction printWarnings(warnings: ImportWarning[], output: CliOutputter) {\n  const assetFails = warnings.filter((warn) => warn.type === 'asset')\n\n  if (!assetFails.length) {\n    return\n  }\n\n  const warn = (output.warn || output.print).bind(output)\n\n  warn(yellow('⚠ Failed to import the following %s:'), assetFails.length > 1 ? 'assets' : 'asset')\n\n  warnings.forEach((warning) => {\n    warn(`  ${warning.url}`)\n  })\n}\n\nexport default importDatasetCommand\n","import {type CliCommandAction} from '@sanity/cli'\n\nimport * as aliasClient from './datasetAliasesClient'\nimport {ALIAS_PREFIX} from './datasetAliasesClient'\n\nexport const listAliasesHandler: CliCommandAction = async (args, context) => {\n  const {apiClient, output} = context\n  const client = apiClient()\n\n  const aliases = await aliasClient.listAliases(client)\n  output.print(\n    aliases\n      .map((set) => `${ALIAS_PREFIX}${set.name} -> ${set.datasetName || '<unlinked>'}`)\n      .join('\\n'),\n  )\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {listAliasesHandler} from './alias/listAliasesHandler'\n\nconst listDatasetsCommand: CliCommandDefinition = {\n  name: 'list',\n  group: 'dataset',\n  helpText: '',\n  signature: '',\n  description: 'List datasets of your project',\n  action: async (args, context) => {\n    const {apiClient, output} = context\n    const client = apiClient()\n    const datasets = await client.datasets.list()\n    output.print(datasets.map((set) => set.name).join('\\n'))\n\n    // Print alias list\n    await listAliasesHandler(args, context)\n  },\n}\n\nexport default listDatasetsCommand\n","import {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n} from '@sanity/cli'\n\nimport {type DeployStudioActionFlags} from '../../actions/deploy/deployAction'\nimport {determineIsApp} from '../../util/determineIsApp'\n\nconst helpText = `\nOptions\n  --source-maps Enable source maps for built bundles (increases size of bundle)\n  --no-minify Skip minifying built JavaScript (speeds up build, increases size of bundle)\n  --no-build Don't build the studio prior to deploy, instead deploying the version currently in \\`dist/\\`\n  --schema-required Fail-fast deployment if schema store fails\n  --verbose Enable verbose logging\n  -y, --yes Unattended mode, answers \"yes\" to any \"yes/no\" prompt and otherwise uses defaults\n\nExamples\n  # Build the studio\n  sanity deploy\n\n  # Deploys non-minified build with source maps\n  sanity deploy --no-minify --source-maps\n\n  # Fail fast on schema store fails – for when other services rely on the stored schema\n  sanity deploy --schema-required`\n\nconst deployCommand: CliCommandDefinition = {\n  name: 'deploy',\n  signature: '[SOURCE_DIR] [--no-build] [--source-maps] [--no-minify]',\n  description: 'Builds and deploys Sanity Studio or application to Sanity hosting',\n  action: async (\n    args: CliCommandArguments<DeployStudioActionFlags>,\n    context: CliCommandContext,\n  ) => {\n    let mod: {\n      default: (\n        args: CliCommandArguments<DeployStudioActionFlags>,\n        context: CliCommandContext,\n      ) => Promise<void>\n    }\n\n    const isApp = determineIsApp(context.cliConfig)\n\n    if (isApp) {\n      mod = await import('../../actions/app/deployAction')\n    } else {\n      mod = await import('../../actions/deploy/deployAction')\n    }\n\n    return mod.default(args, context)\n  },\n  helpText,\n}\n\nexport default deployCommand\n","import {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n} from '@sanity/cli'\n\nimport {type UndeployStudioActionFlags} from '../../actions/deploy/undeployAction'\nimport {determineIsApp} from '../../util/determineIsApp'\n\nconst helpText = `\nOptions\n  -y, --yes Unattended mode, answers \"yes\" to any \"yes/no\" prompt and otherwise uses defaults\n\nExamples\n  sanity undeploy\n  sanity undeploy --yes\n`\n\nconst undeployCommand: CliCommandDefinition = {\n  name: 'undeploy',\n  signature: '',\n  description: 'Removes the deployed Sanity Studio from Sanity hosting',\n  action: async (\n    args: CliCommandArguments<UndeployStudioActionFlags>,\n    context: CliCommandContext,\n  ) => {\n    let mod: {\n      default: (\n        args: CliCommandArguments<UndeployStudioActionFlags>,\n        context: CliCommandContext,\n      ) => Promise<void>\n    }\n\n    const isApp = determineIsApp(context.cliConfig)\n\n    if (isApp) {\n      mod = await import('../../actions/app/undeployAction')\n    } else {\n      mod = await import('../../actions/deploy/undeployAction')\n    }\n\n    return mod.default(args, context)\n  },\n  helpText,\n}\n\nexport default undeployCommand\n","import {createRequire} from 'node:module'\n\nimport {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n} from '@sanity/cli'\n\nimport {type StartDevServerCommandFlags} from '../../actions/dev/devAction'\nimport {determineIsApp} from '../../util/determineIsApp'\n\nconst require = createRequire(import.meta.url)\n\n// TODO: Add this once we are ready to release it.\n// --load-in-dashboard <boolean> Load the dev server in the Sanity dashboard. [default: false]\n\nconst helpText = `\nNotes\n  Changing the hostname or port number might require a new entry to the CORS-origins allow list.\n\nOptions\n  --port <port> TCP port to start server on. [default: 3333]\n  --host <host> The local network interface at which to listen. [default: \"127.0.0.1\"]\n\nExamples\n  sanity dev --host=0.0.0.0\n  sanity dev --port=1942\n`\n\nconst devCommand: CliCommandDefinition = {\n  name: 'dev',\n  signature: '[--port <port>] [--host <host>]',\n  description: 'Starts a local dev server for Sanity Studio with live reloading',\n  action: async (\n    args: CliCommandArguments<StartDevServerCommandFlags>,\n    context: CliCommandContext,\n  ) => {\n    const devAction = await getDevAction(context)\n\n    return devAction(args, context)\n  },\n  helpText,\n}\n\nexport async function getDevAction(\n  context: CliCommandContext,\n): Promise<\n  (\n    args: CliCommandArguments<StartDevServerCommandFlags>,\n    context: CliCommandContext,\n  ) => Promise<void>\n> {\n  const isApp = determineIsApp(context.cliConfig)\n\n  // NOTE: in dev-mode we want to include from `src` so we need to use `.ts` extension\n  if (__DEV__) {\n    if (isApp) {\n      // eslint-disable-next-line import/extensions\n      const mod = require('../../actions/app/devAction.ts')\n      return mod.default\n    }\n    // eslint-disable-next-line import/extensions\n    const mod = require('../../actions/dev/devAction.ts')\n    return mod.default\n  }\n  if (isApp) {\n    const mod = await import('../../actions/app/devAction')\n    return mod.default\n  }\n  const mod = await import('../../actions/dev/devAction')\n  return mod.default\n}\n\nexport default devCommand\n","import fs from 'node:fs/promises'\nimport os from 'node:os'\nimport path from 'node:path'\n\nimport {type CliCommandDefinition} from '@sanity/cli'\nimport {\n  type IdentifiedSanityDocumentStub,\n  type MultipleMutationResult,\n  type Mutation,\n  type SanityClient,\n} from '@sanity/client'\nimport {uuid} from '@sanity/uuid'\nimport chokidar from 'chokidar'\nimport execa from 'execa'\nimport json5 from 'json5'\nimport {isEqual, isPlainObject, noop} from 'lodash-es'\n\ntype MutationOperationName = 'create' | 'createOrReplace' | 'createIfNotExists'\n\ninterface CreateFlags {\n  dataset?: string\n  replace?: boolean\n  missing?: boolean\n  watch?: boolean\n  json5?: boolean\n  id?: string\n}\n\nconst helpText = `\nOptions\n  --replace On duplicate document IDs, replace existing document with specified document(s)\n  --missing On duplicate document IDs, don't modify the target document(s)\n  --watch   Write the documents whenever the target file or buffer changes\n  --json5   Use JSON5 file type to allow a \"simplified\" version of JSON\n  --id <id> Specify a document ID to use. Will fetch remote document ID and populate editor.\n  --dataset NAME to override dataset\n\nExamples\n  # Create the document specified in \"myDocument.json\".\n  sanity documents create myDocument.json\n\n  # Open configured $EDITOR and create the specified document(s)\n  sanity documents create\n\n  # Fetch document with the ID \"myDocId\" and open configured $EDITOR with the\n  # current document content (if any). Replace document with the edited version\n  # when the editor closes\n  sanity documents create --id myDocId --replace\n\n  # Open configured $EDITOR and replace the document with the given content\n  # on each save. Use JSON5 file extension and parser for simplified syntax.\n  sanity documents create --id myDocId --watch --replace --json5\n`\n\nconst createDocumentsCommand: CliCommandDefinition<CreateFlags> = {\n  name: 'create',\n  group: 'documents',\n  signature: '[FILE]',\n  helpText,\n  description: 'Create one or more documents',\n  action: async (args, context) => {\n    const {apiClient, output} = context\n    const {replace, missing, watch, id, dataset} = args.extOptions\n    const [file] = args.argsWithoutOptions\n    const useJson5 = args.extOptions.json5\n    const client = dataset ? apiClient().clone().config({dataset}) : apiClient()\n\n    if (replace && missing) {\n      throw new Error('Cannot use both --replace and --missing')\n    }\n\n    if (id && file) {\n      throw new Error('Cannot use --id when specifying a file path')\n    }\n\n    let operation: MutationOperationName = 'create'\n    if (replace || missing) {\n      operation = replace ? 'createOrReplace' : 'createIfNotExists'\n    }\n\n    if (file) {\n      const contentPath = path.resolve(process.cwd(), file)\n      const content = json5.parse(await fs.readFile(contentPath, 'utf8'))\n      const result = await writeDocuments(content, operation, client)\n      output.print(getResultMessage(result, operation))\n      return\n    }\n\n    // Create a temporary file and use that as source, opening an editor on it\n    const docId = id || uuid()\n    const ext = useJson5 ? 'json5' : 'json'\n    const tmpFile = path.join(os.tmpdir(), 'sanity-cli', `${docId}.${ext}`)\n    const stringify = useJson5 ? json5.stringify : JSON.stringify\n    const defaultValue = (id && (await client.getDocument(id))) || {_id: docId, _type: 'specify-me'}\n    await fs.mkdir(path.join(os.tmpdir(), 'sanity-cli'), {recursive: true})\n    await fs.writeFile(tmpFile, stringify(defaultValue, null, 2), 'utf8')\n\n    const editor = getEditor()\n    if (watch) {\n      // If we're in watch mode, we want to run the creation on each change (if it validates)\n      registerUnlinkOnSigInt(tmpFile)\n      output.print(`Watch mode: ${tmpFile}`)\n      output.print('Watch mode: Will write documents on each save.')\n      output.print('Watch mode: Press Ctrl + C to cancel watch mode.')\n      chokidar.watch(tmpFile).on('change', () => {\n        output.print('')\n        return readAndPerformCreatesFromFile(tmpFile)\n      })\n      await execa(editor.bin, editor.args.concat(tmpFile), {stdio: 'inherit'})\n    } else {\n      // While in normal mode, we just want to wait for the editor to close and run the thing once\n      execa.sync(editor.bin, editor.args.concat(tmpFile), {stdio: 'inherit'})\n      await readAndPerformCreatesFromFile(tmpFile)\n      await fs.unlink(tmpFile).catch(noop)\n    }\n\n    async function readAndPerformCreatesFromFile(filePath: string) {\n      let content\n      try {\n        content = json5.parse(await fs.readFile(filePath, 'utf8'))\n      } catch (err) {\n        output.error(`Failed to read input: ${err.message}`)\n        return\n      }\n\n      if (isEqual(content, defaultValue)) {\n        output.print('Value not modified, doing nothing.')\n        output.print('Modify document to trigger creation.')\n        return\n      }\n\n      try {\n        const writeResult = await writeDocuments(content, operation, client)\n        output.print(getResultMessage(writeResult, operation))\n      } catch (err) {\n        output.error(`Failed to write documents: ${err.message}`)\n        if (err.message.includes('already exists')) {\n          output.error('Perhaps you want to use `--replace` or `--missing`?')\n        }\n      }\n    }\n  },\n}\n\nfunction registerUnlinkOnSigInt(tmpFile: string) {\n  process.on('SIGINT', async () => {\n    await fs.unlink(tmpFile).catch(noop)\n    process.exit(130)\n  })\n}\n\nfunction writeDocuments(\n  documents: {_id?: string; _type: string} | {_id?: string; _type: string}[],\n  operation: MutationOperationName,\n  client: SanityClient,\n) {\n  const docs = Array.isArray(documents) ? documents : [documents]\n  if (docs.length === 0) {\n    throw new Error('No documents provided')\n  }\n\n  const mutations = docs.map((doc, index): Mutation => {\n    validateDocument(doc, index, docs)\n    if (operation === 'create') {\n      return {create: doc}\n    }\n\n    if (operation === 'createIfNotExists') {\n      if (isIdentifiedSanityDocument(doc)) {\n        return {createIfNotExists: doc}\n      }\n\n      throw new Error(`Missing required _id attribute for ${operation}`)\n    }\n\n    if (operation === 'createOrReplace') {\n      if (isIdentifiedSanityDocument(doc)) {\n        return {createOrReplace: doc}\n      }\n\n      throw new Error(`Missing required _id attribute for ${operation}`)\n    }\n\n    throw new Error(`Unsupported operation ${operation}`)\n  })\n\n  return client.transaction(mutations).commit()\n}\n\nfunction validateDocument(doc: unknown, index: number, arr: unknown[]) {\n  const isSingle = arr.length === 1\n\n  if (!isPlainObject(doc)) {\n    throw new Error(getErrorMessage('must be an object', index, isSingle))\n  }\n\n  if (!isSanityDocumentish(doc)) {\n    throw new Error(getErrorMessage('must have a `_type` property of type string', index, isSingle))\n  }\n}\n\nfunction isSanityDocumentish(doc: unknown): doc is {_type: string} {\n  return (\n    doc !== null &&\n    typeof doc === 'object' &&\n    '_type' in doc &&\n    typeof (doc as any)._type === 'string'\n  )\n}\n\nfunction isIdentifiedSanityDocument(doc: unknown): doc is IdentifiedSanityDocumentStub {\n  return isSanityDocumentish(doc) && '_id' in doc\n}\n\nfunction getErrorMessage(message: string, index: number, isSingle: boolean): string {\n  return isSingle ? `Document ${message}` : `Document at index ${index} ${message}`\n}\n\nfunction getResultMessage(\n  result: MultipleMutationResult,\n  operation: MutationOperationName,\n): string {\n  const joiner = '\\n  - '\n  if (operation === 'createOrReplace') {\n    return `Upserted:\\n  - ${result.results.map((res) => res.id).join(joiner)}`\n  }\n\n  if (operation === 'create') {\n    return `Created:\\n  - ${result.results.map((res) => res.id).join(joiner)}`\n  }\n\n  // \"Missing\" (createIfNotExists)\n  const created: string[] = []\n  const skipped: string[] = []\n  for (const res of result.results) {\n    if (res.operation === 'update') {\n      skipped.push(res.id)\n    } else {\n      created.push(res.id)\n    }\n  }\n\n  if (created.length > 0 && skipped.length > 0) {\n    return [\n      `Created:\\n  - ${created.join(joiner)}`,\n      `Skipped (already exists):${joiner}${skipped.join(joiner)}`,\n    ].join('\\n\\n')\n  } else if (created.length > 0) {\n    return `Created:\\n  - ${created.join(joiner)}`\n  }\n\n  return `Skipped (already exists):\\n  - ${skipped.join(joiner)}`\n}\n\nfunction getEditor() {\n  const defaultEditor = process.platform.startsWith('win') ? 'notepad' : 'vim'\n  const editor = process.env.VISUAL || process.env.EDITOR || defaultEditor\n  const args = editor.split(/\\s+/)\n  const bin = args.shift() || ''\n  return {bin, args}\n}\n\nexport default createDocumentsCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\nimport pluralize from 'pluralize-esm'\n\nconst helpText = `\nDelete a document from the projects configured dataset\n\nOptions\n  --dataset NAME to override dataset\n\nExample\n  # Delete the document with the ID \"myDocId\"\n  sanity documents delete myDocId\n\n  # ID wrapped in double or single quote works equally well\n  sanity documents delete 'myDocId'\n\n  # Delete document with ID \"someDocId\" from dataset \"blog\"\n  sanity documents delete --dataset=blog someDocId\n\n  # Delete the document with ID \"doc1\" and \"doc2\"\n  sanity documents delete doc1 doc2\n`\n\ninterface DeleteFlags {\n  dataset?: string\n}\n\nconst deleteDocumentsCommand: CliCommandDefinition<DeleteFlags> = {\n  name: 'delete',\n  group: 'documents',\n  signature: '[ID] [...IDS]',\n  helpText,\n  description: 'Delete a document by ID',\n  action: async (args, context) => {\n    const {apiClient, output, chalk} = context\n    const {dataset} = args.extOptions\n    const ids = args.argsWithoutOptions.map((str) => `${str}`)\n\n    if (!ids.length) {\n      throw new Error('Document ID must be specified')\n    }\n\n    const client = dataset ? apiClient().clone().config({dataset}) : apiClient()\n\n    const transaction = ids.reduce((trx, id) => trx.delete(id), client.transaction())\n    try {\n      const {results} = await transaction.commit()\n      const deleted = results.filter((res) => res.operation === 'delete').map((res) => res.id)\n      const notFound = ids.filter((id) => !deleted.includes(id))\n      if (deleted.length > 0) {\n        output.print(`Deleted ${deleted.length} ${pluralize('document', deleted.length)}`)\n      }\n\n      if (notFound.length > 0) {\n        output.error(\n          chalk.red(`${pluralize('Document', notFound.length)} not found: ${notFound.join(', ')}`),\n        )\n      }\n    } catch (err) {\n      throw new Error(`Failed to delete ${pluralize('document', ids.length)}:\\n${err.message}`, {\n        cause: err,\n      })\n    }\n  },\n}\n\nexport default deleteDocumentsCommand\n","import {type CliCommandGroupDefinition} from '@sanity/cli'\n\nconst documentsGroup: CliCommandGroupDefinition = {\n  name: 'documents',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Manages documents in your Sanity Content Lake datasets',\n}\n\nexport default documentsGroup\n","import {type CliCommandContext} from '@sanity/cli'\nimport tokenize, {type LexerToken} from 'json-lexer'\n\ninterface KeyToken {\n  type: 'key'\n  value: string\n  raw: string\n}\n\ntype ExtendedLexerToken = LexerToken | KeyToken\n\nconst identity = (inp: string): string => inp\n\nexport function colorizeJson(input: unknown, chalk: CliCommandContext['chalk']): string {\n  const formatters: Record<ExtendedLexerToken['type'], (str: string) => string> = {\n    punctuator: chalk.white,\n    key: chalk.white,\n    string: chalk.green,\n    number: chalk.yellow,\n    literal: chalk.bold,\n    whitespace: identity,\n  }\n\n  const json = JSON.stringify(input, null, 2)\n\n  return tokenize(json)\n    .map((token, i, arr): ExtendedLexerToken => {\n      // Note how the following only works because we pretty-print the JSON\n      const prevToken = i === 0 ? token : arr[i - 1]\n      if (\n        token.type === 'string' &&\n        prevToken.type === 'whitespace' &&\n        /^\\n\\s+$/.test(prevToken.value)\n      ) {\n        return {...token, type: 'key'}\n      }\n\n      return token\n    })\n    .map((token) => {\n      const formatter = formatters[token.type] || identity\n      return formatter(token.raw)\n    })\n    .join('')\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {colorizeJson} from '../../util/colorizeJson'\n\nconst helpText = `\nGet and print a document from the projects configured dataset\n\nOptions\n  --pretty colorized JSON output\n  --dataset NAME to override dataset\n\nExamples\n  # Get the document with the ID \"myDocId\"\n  sanity documents get myDocId\n\n  # ID wrapped in double or single quote works equally well\n  sanity documents get 'myDocId'\n`\n\ninterface GetDocumentFlags {\n  pretty?: boolean\n  dataset?: string\n}\n\nconst getDocumentsCommand: CliCommandDefinition<GetDocumentFlags> = {\n  name: 'get',\n  group: 'documents',\n  signature: '[DOCUMENT_ID]',\n  helpText,\n  description: 'Get and print a document by ID',\n  action: async (args, context) => {\n    const {apiClient, output, chalk} = context\n    const {pretty, dataset} = args.extOptions\n    const [docId] = args.argsWithoutOptions.map((str) => `${str}`)\n\n    if (!docId) {\n      throw new Error('Document ID must be specified')\n    }\n\n    const client = dataset ? apiClient().clone().config({dataset}) : apiClient()\n\n    try {\n      const doc = await client.getDocument(docId)\n      if (!doc) {\n        throw new Error(`Document ${docId} not found`)\n      }\n\n      output.print(pretty ? colorizeJson(doc, chalk) : JSON.stringify(doc, null, 2))\n    } catch (err) {\n      throw new Error(`Failed to fetch document:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nexport default getDocumentsCommand\n","import {type CliCommandArguments, type CliCommandContext} from '@sanity/cli'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport {colorizeJson} from '../../util/colorizeJson'\n\nconst defaultApiVersion = 'v2022-06-01'\n\nconst helpText = `\nRun a query against the projects configured dataset\n\nOptions\n  --pretty colorized JSON output\n  --dataset NAME to override dataset\n  --project PROJECT to override project ID\n  --anonymous Send the query without any authorization token\n  --api-version API version to use (defaults to \\`${defaultApiVersion}\\`)\n\nEnvironment variables\n  \\`SANITY_CLI_QUERY_API_VERSION\\` - will use the defined API version,\n  unless \\`--api-version\\` is specified.\n\nExamples\n  # Fetch 5 documents of type \"movie\"\n  sanity documents query '*[_type == \"movie\"][0..4]'\n\n  # Fetch title of the oldest movie in the dataset named \"staging\"\n  sanity documents query '*[_type == \"movie\"]|order(releaseDate asc)[0]{title}' --dataset staging\n\n  # Use API version v2021-06-07 and do a query\n  sanity documents query --api-version v2021-06-07 '*[_id == \"header\"] { \"headerText\": pt::text(body) }'\n`\n\ninterface CliQueryCommandFlags {\n  pretty?: boolean\n  anonymous?: boolean\n  dataset?: string\n  project?: string\n  apiVersion?: string\n}\n\nexport default {\n  name: 'query',\n  group: 'documents',\n  signature: '[QUERY]',\n  helpText,\n  description: 'Query for documents',\n  action: async (\n    args: CliCommandArguments<CliQueryCommandFlags>,\n    context: CliCommandContext,\n  ): Promise<void> => {\n    // Reparsing arguments for improved control of flags\n    const {\n      pretty,\n      dataset,\n      project,\n      anonymous,\n      'api-version': apiVersion,\n    } = await parseCliFlags(args)\n    const {apiClient, output, chalk, cliConfig} = context\n    const [query] = args.argsWithoutOptions\n\n    if (!query) {\n      throw new Error('Query must be specified')\n    }\n\n    if (!apiVersion) {\n      output.warn(chalk.yellow(`--api-version not specified, using \\`${defaultApiVersion}\\``))\n    }\n\n    const requireDataset = !dataset\n    const requireProject = !project\n    const requireUser = !anonymous\n\n    if (requireProject && !cliConfig?.api?.projectId) {\n      throw new Error(\n        'No project configured in CLI config - either configure one, or use `--project` flag',\n      )\n    }\n\n    if (requireDataset && !cliConfig?.api?.dataset) {\n      throw new Error(\n        'No dataset configured in CLI config - either configure one, or use `--dataset` flag',\n      )\n    }\n\n    const baseClient = apiClient({requireProject, requireUser}).clone()\n    const {dataset: originalDataset, projectId: originalProjectId} = baseClient.config()\n\n    const client = baseClient.config({\n      projectId: project || originalProjectId,\n      dataset: dataset || originalDataset,\n      apiVersion: apiVersion || defaultApiVersion,\n    })\n\n    try {\n      const docs = await client.fetch(query)\n      if (!docs) {\n        throw new Error('Query returned no results')\n      }\n\n      output.print(pretty ? colorizeJson(docs, chalk) : JSON.stringify(docs, null, 2))\n    } catch (err) {\n      throw new Error(`Failed to run query:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nfunction parseCliFlags(args: CliCommandArguments<CliQueryCommandFlags>) {\n  const fallbackApiVersion = process.env.SANITY_CLI_QUERY_API_VERSION\n  return yargs(hideBin(args.argv || process.argv).slice(2))\n    .option('pretty', {type: 'boolean', default: false})\n    .option('dataset', {type: 'string'})\n    .option('project', {type: 'string'})\n    .option('anonymous', {type: 'boolean', default: false})\n    .option('api-version', {type: 'string', default: fallbackApiVersion}).argv\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst description = `Downloads and validates all document specified in a workspace`\n\nconst helpText = `\nOptions\n  -y, --yes Skips the first confirmation prompt.\n  --workspace <name> The name of the workspace to use when downloading and validating all documents.\n  --dataset <name> Override the dataset used. By default, this is derived from the given workspace.\n  --file <filepath> Provide a path to either an .ndjson file or a tarball containing an .ndjson file.\n  --format <pretty|ndjson|json> The output format used to print the found validation markers and report progress.\n  --level <error|warning|info> The minimum level reported out. Defaults to warning.\n  --max-custom-validation-concurrency <number> Specify how many custom validators can run concurrently. Defaults to 5.\n  --max-fetch-concurrency <number> Specify how many \\`client.fetch\\` requests are allow concurrency at once. Defaults to 25.\n\nExamples\n  # Validates all documents in a Sanity project with more than one workspace\n  sanity documents validate --workspace default\n\n  # Override the dataset specified in the workspace\n  sanity documents validate --workspace default --dataset staging\n\n  # Save the results of the report into a file\n  sanity documents validate --yes > report.txt\n\n  # Report out info level validation markers too\n  sanity documents validate --level info\n`\n\nconst validateDocumentsCommand: CliCommandDefinition = {\n  name: 'validate',\n  group: 'documents',\n  signature: '',\n  description,\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/validation/validateAction')\n\n    return mod.default(args, context)\n  },\n} satisfies CliCommandDefinition\n\nexport default validateDocumentsCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst helpText = `\nOptions\n  --with-user-token Prime access token from CLI config into getCliClient()\n  --mock-browser-env Mocks a browser-like environment using jsdom\n\nExamples\n  # Run the script at some/script.js in Sanity context\n  sanity exec some/script.js\n\n  # Run the script at migrations/fullname.ts and configure \\`getCliClient()\\`\n  # from \\`sanity/cli\\`to include the current user's token\n  sanity exec migrations/fullname.ts --with-user-token\n\n  # Run the script at scripts/browserScript.js in a mock browser environment\n  sanity exec scripts/browserScript.js --mock-browser-env\n\n  # Pass arbitrary arguments to scripts by separating them with a \\`--\\`.\n  # Arguments are available in \\`process.argv\\` as they would in regular node scripts\n  # eg the following command would yield a \\`process.argv\\` of:\n  # ['/path/to/node', '/path/to/myscript.js', '--dry-run', 'positional-argument']\n  sanity exec --mock-browser-env myscript.js -- --dry-run positional-argument\n`\n\nexport const execCommand: CliCommandDefinition = {\n  name: 'exec',\n  signature: 'SCRIPT',\n  description: 'Executes a script within the Sanity Studio context',\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/exec/execScript')\n\n    return mod.default(args, context)\n  },\n}\n\nexport default execCommand\n","import {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n} from '@sanity/cli'\n\nimport {type DeleteGraphQLApiFlags} from '../../actions/graphql/deleteApiAction'\n\nconst helpText = `\nOptions\n  --api <api-id> Undeploy API with this ID (project, dataset and tag flags takes preference)\n  --project <projectId> Project ID to delete GraphQL API for\n  --dataset <dataset> Delete GraphQL API for the given dataset\n  --tag <tag> Delete GraphQL API for the given tag (defaults to 'default')\n  --force Skip confirmation prompt, forcefully undeploying the GraphQL API\n\nExamples\n  sanity graphql undeploy\n  sanity graphql undeploy --api ios\n  sanity graphql undeploy --dataset staging\n  sanity graphql undeploy --dataset staging --tag next\n`\n\nconst deleteGraphQLAPICommand: CliCommandDefinition = {\n  name: 'undeploy',\n  group: 'graphql',\n  signature: '',\n  description: 'Remove a deployed GraphQL API',\n  action: async (args: CliCommandArguments<DeleteGraphQLApiFlags>, context: CliCommandContext) => {\n    const mod = await import('../../actions/graphql/deleteApiAction')\n\n    return mod.default(args, context)\n  },\n  helpText,\n}\n\nexport default deleteGraphQLAPICommand\n","import {type CliCommandContext, type CliCommandDefinition} from '@sanity/cli'\n\nconst helpText = `\nOptions\n  --dry-run Validate defined APIs, exiting with an error on breaking changes\n  --force Deploy API without confirming breaking changes\n  --api <api-id> Only deploy API with this ID. Can be specified multiple times.\n\nThe following options will override any setting from the CLI configuration file\n(sanity.cli.js/sanity.cli.ts) - and applies to ALL defined APIs defined in that\nconfiguration file. Tread with caution!\n\n  --tag Deploy API(s) to given tag (defaults to 'default')\n  --dataset <name> Deploy API for the given dataset\n  --generation <gen1|gen2|gen3> API generation to deploy (defaults to 'gen3')\n  --non-null-document-fields Use non-null document fields (_id, _type etc)\n  --playground Enable GraphQL playground for easier debugging\n  --no-playground Disable GraphQL playground\n  --with-union-cache *Experimental:* Enable union cache that optimizes schema generation for schemas with many self referencing types\n\nExamples\n  # Deploy all defined GraphQL APIs\n  sanity graphql deploy\n\n  # Validate defined GraphQL APIs, check for breaking changes, skip deploy\n  sanity graphql deploy --dry-run\n\n  # Deploy only the GraphQL APIs with the IDs \"staging\" and \"ios\"\n  sanity graphql deploy --api staging --api ios\n\n  # Deploy all defined GraphQL APIs, overriding any playground setting\n  sanity graphql deploy --playground\n`\n\nconst deployGraphQLAPICommand: CliCommandDefinition = {\n  name: 'deploy',\n  signature: '',\n  group: 'graphql',\n  description: 'Deploy a GraphQL API from the current Sanity schema',\n  action: async (args: {argv?: string[]}, context: CliCommandContext) => {\n    const mod = await import('../../actions/graphql/deployApiAction')\n\n    return mod.default(args, context)\n  },\n  helpText,\n}\n\nexport default deployGraphQLAPICommand\n","import {type CliCommandGroupDefinition} from '@sanity/cli'\n\nconst graphqlGroup: CliCommandGroupDefinition = {\n  name: 'graphql',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: \"Deploys changes to your project's GraphQL API(s)\",\n}\n\nexport default graphqlGroup\n","import {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n} from '@sanity/cli'\n\nconst helpText = `\nExamples\n  sanity graphql list\n`\n\nconst listGraphQLAPIsCommand: CliCommandDefinition = {\n  name: 'list',\n  signature: '',\n  group: 'graphql',\n  description: 'Lists all the GraphQL endpoints deployed for this project',\n  action: async (\n    args: CliCommandArguments<Record<string, unknown>>,\n    context: CliCommandContext,\n  ) => {\n    const mod = await import('../../actions/graphql/listApisAction')\n\n    return mod.default(args, context)\n  },\n  helpText,\n}\n\nexport default listGraphQLAPIsCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\nimport open from 'open'\n\nconst createHookCommand: CliCommandDefinition = {\n  name: 'create',\n  group: 'hook',\n  signature: '',\n  helpText: '',\n  description: 'Create a new hook for the given dataset',\n  action: async (args, context) => {\n    const {apiClient, output} = context\n    const client = apiClient()\n\n    const {projectId} = client.config()\n    if (!projectId) {\n      throw new Error('No project ID found')\n    }\n\n    const projectInfo = (await client.projects.getById(projectId)) || {}\n    const organizationId = projectInfo.organizationId || 'personal'\n    const manageUrl = `https://www.sanity.io/organizations/${organizationId}/project/${projectId}/api/webhooks/new`\n\n    output.print(`Opening ${manageUrl}`)\n    await open(manageUrl)\n  },\n}\n\nexport default createHookCommand\n","import {type CliCommandContext, type CliCommandDefinition} from '@sanity/cli'\n\nimport {type Hook} from './types'\n\nconst deleteHookCommand: CliCommandDefinition = {\n  name: 'delete',\n  group: 'hook',\n  signature: '[NAME]',\n  helpText: '',\n  description: 'Delete a hook within your project',\n  action: async (args, context) => {\n    const {apiClient} = context\n    const [name] = args.argsWithoutOptions\n    const client = apiClient()\n\n    const hookId = await promptForHook(name, context)\n    try {\n      await client\n        .clone()\n        .config({apiVersion: '2021-10-04'})\n        .request({method: 'DELETE', uri: `/hooks/${hookId}`})\n    } catch (err) {\n      throw new Error(`Hook deletion failed:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nasync function promptForHook(specified: string | undefined, context: CliCommandContext) {\n  const specifiedName = specified && specified.toLowerCase()\n  const {prompt, apiClient} = context\n  const client = apiClient()\n\n  const hooks = await client\n    .clone()\n    .config({apiVersion: '2021-10-04'})\n    .request<Hook[]>({uri: '/hooks', json: true})\n\n  if (specifiedName) {\n    const selected = hooks.filter((hook) => hook.name.toLowerCase() === specifiedName)[0]\n    if (!selected) {\n      throw new Error(`Hook with name \"${specified} not found\"`)\n    }\n\n    return selected.id\n  }\n\n  const choices = hooks.map((hook) => ({value: hook.id, name: hook.name}))\n  return prompt.single({\n    message: 'Select hook to delete',\n    type: 'list',\n    choices,\n  })\n}\n\nexport default deleteHookCommand\n","import {type CliCommandGroupDefinition} from '@sanity/cli'\n\nconst hookGroup: CliCommandGroupDefinition = {\n  name: 'hook',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Sets up and manages webhooks within your Sanity project',\n}\n\nexport default hookGroup\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {type DeliveryAttempt} from './types'\n\nconst printHookAttemptCommand: CliCommandDefinition = {\n  name: 'attempt',\n  group: 'hook',\n  signature: 'ATTEMPT_ID',\n  helpText: '',\n  description: 'Print details of a given webhook delivery attempt',\n  action: async (args, context) => {\n    const {apiClient, output} = context\n    const [attemptId] = args.argsWithoutOptions\n    const client = apiClient()\n\n    let attempt\n    try {\n      attempt = await client.request<DeliveryAttempt>({uri: `/hooks/attempts/${attemptId}`})\n    } catch (err) {\n      throw new Error(`Hook attempt retrieval failed:\\n${err.message}`, {cause: err})\n    }\n\n    const {createdAt, resultCode, resultBody, failureReason, inProgress} = attempt\n\n    output.print(`Date: ${createdAt}`)\n    output.print(`Status: ${getStatus(attempt)}`)\n    output.print(`Status code: ${resultCode}`)\n\n    if (attempt.isFailure) {\n      output.print(`Failure: ${formatFailure(attempt)}`)\n    }\n\n    if (!inProgress && (!failureReason || failureReason === 'http')) {\n      const body = resultBody ? `\\n---\\n${resultBody}\\n---\\n` : '<empty>'\n      output.print(`Response body: ${body}`)\n    }\n  },\n}\n\nexport default printHookAttemptCommand\n\nexport function formatFailure(\n  attempt: DeliveryAttempt,\n  options: {includeHelp?: boolean} = {},\n): string {\n  const {includeHelp} = options\n  const {id, failureReason, resultCode} = attempt\n  const help = includeHelp ? `(run \\`sanity hook attempt ${id}\\` for details)` : ''\n  switch (failureReason) {\n    case 'http':\n      return `HTTP ${resultCode} ${help}`\n    case 'timeout':\n      return 'Request timed out'\n    case 'network':\n      return 'Network error'\n    case 'other':\n    default:\n  }\n\n  return 'Unknown error'\n}\n\nexport function getStatus(attempt: DeliveryAttempt): string {\n  if (attempt.isFailure) {\n    return 'Failed'\n  }\n\n  if (attempt.inProgress) {\n    return 'In progress'\n  }\n\n  return 'Delivered'\n}\n","import {inspect} from 'node:util'\n\nimport {type CliCommandContext, type CliCommandDefinition} from '@sanity/cli'\nimport {groupBy} from 'lodash-es'\n\nimport {formatFailure} from './printHookAttemptCommand'\nimport {type DeliveryAttempt, type Hook, type HookMessage} from './types'\n\ninterface ListHookFlags {\n  detailed?: boolean\n}\n\nconst listHookLogsCommand: CliCommandDefinition<ListHookFlags> = {\n  name: 'logs',\n  group: 'hook',\n  signature: '[NAME]',\n  helpText: '',\n  description: 'List latest log entries for a given hook',\n  action: async (args, context) => {\n    const {apiClient} = context\n    const flags = args.extOptions\n    const [name] = args.argsWithoutOptions\n    const client = apiClient()\n\n    const hookId = await promptForHook(name, context)\n    let messages\n    let attempts\n    try {\n      messages = await client.request<HookMessage[]>({uri: `/hooks/${hookId}/messages`})\n      attempts = await client.request<DeliveryAttempt[]>({uri: `/hooks/${hookId}/attempts`})\n    } catch (err) {\n      throw new Error(`Hook logs retrieval failed:\\n${err.message}`, {cause: err})\n    }\n\n    const groupedAttempts = groupBy(attempts, 'messageId')\n    const populated = messages.map((msg): HookMessage & {attempts: DeliveryAttempt[]} => ({\n      ...msg,\n      attempts: groupedAttempts[msg.id],\n    }))\n\n    const totalMessages = messages.length - 1\n    populated.forEach((message, i) => {\n      printMessage(message, context, {detailed: flags.detailed})\n      printSeparator(context, totalMessages === i)\n    })\n  },\n}\n\nexport default listHookLogsCommand\n\nasync function promptForHook(specified: string | undefined, context: CliCommandContext) {\n  const specifiedName = specified && specified.toLowerCase()\n  const {prompt, apiClient} = context\n  const client = apiClient()\n\n  const hooks = await client\n    .clone()\n    .config({apiVersion: '2021-10-04'})\n    .request<Hook[]>({uri: '/hooks', json: true})\n\n  if (specifiedName) {\n    const selected = hooks.filter((hook) => hook.name.toLowerCase() === specifiedName)[0]\n    if (!selected) {\n      throw new Error(`Hook with name \"${specified} not found\"`)\n    }\n\n    return selected.id\n  }\n\n  if (hooks.length === 0) {\n    throw new Error('No hooks currently registered')\n  }\n\n  if (hooks.length === 1) {\n    return hooks[0].id\n  }\n\n  const choices = hooks.map((hook) => ({value: hook.id, name: hook.name}))\n  return prompt.single({\n    message: 'Select hook to list logs for',\n    type: 'list',\n    choices,\n  })\n}\n\nfunction printSeparator(context: CliCommandContext, skip: boolean) {\n  if (!skip) {\n    context.output.print('---\\n')\n  }\n}\n\nfunction printMessage(\n  message: HookMessage & {attempts: DeliveryAttempt[]},\n  context: CliCommandContext,\n  options: {detailed?: boolean},\n) {\n  const {detailed} = options\n  const {output, chalk} = context\n\n  output.print(`Date: ${message.createdAt}`)\n  output.print(`Status: ${message.status}`)\n  output.print(`Result code: ${message.resultCode}`)\n\n  if (message.failureCount > 0) {\n    output.print(`Failures: ${message.failureCount}`)\n  }\n\n  if (detailed) {\n    output.print('Payload:')\n    output.print(inspect(JSON.parse(message.payload), {colors: true}))\n  }\n\n  if (detailed && message.attempts) {\n    output.print('Attempts:')\n    message.attempts.forEach((attempt) => {\n      const date = attempt.createdAt.replace(/\\.\\d+Z$/, 'Z')\n      const prefix = `  [${date}]`\n\n      if (attempt.inProgress) {\n        output.print(`${prefix} ${chalk.yellow('Pending')}`)\n      } else if (attempt.isFailure) {\n        const failure = formatFailure(attempt, {includeHelp: true})\n        output.print(`${prefix} ${chalk.yellow(`Failure: ${failure}`)}`)\n      } else {\n        output.print(`${prefix} Success: HTTP ${attempt.resultCode} (${attempt.duration}ms)`)\n      }\n    })\n  }\n\n  // Leave some empty space between messages\n  output.print('')\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {type Hook} from './types'\n\nconst listHooksCommand: CliCommandDefinition = {\n  name: 'list',\n  group: 'hook',\n  signature: '',\n  helpText: '',\n  description: 'List hooks for a given project',\n  action: async (args, context) => {\n    const {apiClient, output} = context\n    const client = apiClient()\n\n    let hooks\n    try {\n      hooks = await client\n        .clone()\n        .config({apiVersion: '2021-10-04'})\n        .request<Hook[]>({uri: '/hooks'})\n    } catch (err) {\n      throw new Error(`Hook list retrieval failed:\\n${err.message}`, {cause: err})\n    }\n\n    hooks.forEach((hook) => {\n      output.print(`Name: ${hook.name}`)\n      output.print(`Dataset: ${hook.dataset}`)\n      output.print(`URL: ${hook.url}`)\n\n      if (hook.type === 'document') {\n        output.print(`HTTP method: ${hook.httpMethod}`)\n\n        if (hook.description) {\n          output.print(`Description: ${hook.description}`)\n        }\n      }\n\n      output.print('')\n    })\n  },\n}\n\nexport default listHooksCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst description = 'Extracts the studio configuration as one or more JSON manifest files.'\n\nconst helpText = `\n**Note**: This command is experimental and subject to change. It is currently intended for use with Create only.\n\nOptions\n  --path Optional path to specify destination directory of the manifest files. Default: /dist/static\n\nExamples\n  # Extracts manifests\n  sanity manifest extract\n\n  # Extracts manifests into /public/static\n  sanity manifest extract --path /public/static\n`\n\nconst extractManifestCommand: CliCommandDefinition = {\n  name: 'extract',\n  group: 'manifest',\n  signature: '',\n  description,\n  helpText,\n  action: async (args, context) => {\n    const {extractManifestSafe} = await import('../../actions/manifest/extractManifestAction')\n    const extractError = await extractManifestSafe(args, context)\n    if (extractError) {\n      throw extractError\n    }\n    return extractError\n  },\n}\n\nexport default extractManifestCommand\n","export default {\n  name: 'manifest',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Interacts with the studio configuration.',\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst helpText = `\nExamples\n  # Create a new aspect definition file.\n  sanity media create-aspect\n`\n\nconst createAspectCommand: CliCommandDefinition = {\n  name: 'create-aspect',\n  group: 'media',\n  signature: '',\n  description: 'Create a new aspect definition file.',\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/media/createAspectAction')\n    return mod.default(args, context)\n  },\n}\n\nexport default createAspectCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst helpText = `\nOptions\n  --media-library-id The id of the target media library.\n\nExamples\n  # Delete the aspect named \"someAspect\".\n  sanity media delete-aspect someAspect\n`\n\nconst deleteAspectCommand: CliCommandDefinition = {\n  name: 'delete-aspect',\n  group: 'media',\n  signature: '[ASPECT_NAME]',\n  description: 'Undeploy an aspect.',\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/media/deleteAspectAction')\n    return mod.default(args, context)\n  },\n}\n\nexport default deleteAspectCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst helpText = `\nOptions\n  --media-library-id The id of the target media library.\n  --all              Deploy all aspects.\n\nExamples\n  # Deploy the aspect named \"someAspect\".\n  sanity media deploy-aspect someAspect\n\n  # Deploy all aspects.\n  sanity media deploy-aspect --all\n`\n\nconst deployAspectCommand: CliCommandDefinition = {\n  name: 'deploy-aspect',\n  group: 'media',\n  signature: '[ASPECT_NAME]',\n  description: 'Deploy an aspect.',\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/media/deployAspectAction')\n    return mod.default(args, context)\n  },\n}\n\nexport default deployAspectCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst helpText = `\nOptions\n  --media-library-id The id of the target media library.\n\nExamples\n  # Export all file and image assets including their aspects.\n  sanity media export\n`\n\ninterface MediaFlags {\n  'media-library-id'?: string\n}\n\nconst exportMediaCommand: CliCommandDefinition<MediaFlags> = {\n  name: 'export',\n  group: 'media',\n  signature: '[FILE]',\n  description:\n    'Export an archive of all file and image assets including their aspect data from the target media library.',\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/media/exportAssetsAction')\n    return mod.default(args, context)\n  },\n}\n\nexport default exportMediaCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst helpText = `\nOptions\n  --media-library-id The id of the target media library.\n  --replace-aspects  Replace existing aspect data. All versions will be replaced (e.g. published and draft aspect data).\n\nExamples\n  # Import all assets from the \"products\" directory.\n  sanity media import products\n\n  # Import all assets from \"gallery\" archive.\n  sanity media import gallery.tar.gz\n\n  # Import all assets from the \"products\" directory and replace aspects.\n  sanity media import products --replace-aspects\n`\n\ninterface MediaFlags {\n  'media-library-id'?: string\n}\n\nconst importMediaCommand: CliCommandDefinition<MediaFlags> = {\n  name: 'import',\n  group: 'media',\n  signature: '[FILE | FOLDER]',\n  description: 'Import a set of assets to the target media library.',\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/media/importAssetsAction')\n    return mod.default(args, context)\n  },\n}\n\nexport default importMediaCommand\n","import {type CliCommandGroupDefinition} from '@sanity/cli'\n\nconst mediaGroup: CliCommandGroupDefinition = {\n  name: 'media',\n  signature: '[COMMAND]',\n  description: 'Manage Media Library.',\n  isGroupRoot: true,\n}\n\nexport default mediaGroup\n","export const MIGRATIONS_DIRECTORY = 'migrations'\nexport const MIGRATION_SCRIPT_EXTENSIONS = ['mjs', 'js', 'ts', 'cjs']\nexport const DEFAULT_API_VERSION = 'v2024-01-29'\n","export const minimalAdvanced = ({\n  migrationName,\n  documentTypes,\n}: {\n  migrationName: string\n  documentTypes: string[]\n}) => `import {defineMigration, patch, at, setIfMissing} from 'sanity/migrate'\n\n/**\n * this migration will set \\`Default title\\` on all documents that are missing a title\n * and make \\`true\\` the default value for the \\`enabled\\` field\n */\nexport default defineMigration({\n  title: '${migrationName}',\n${\n  documentTypes.length > 0\n    ? `  documentTypes: [${documentTypes.map((t) => JSON.stringify(t)).join(', ')}],\\n`\n    : ''\n}\n  async *migrate(documents, context) {\n    for await (const document of documents()) {\n      yield patch(document._id, [\n        at('title', setIfMissing('Default title')),\n        at('enabled', setIfMissing(true)),\n      ])\n    }\n  }\n})\n`\n","export const minimalSimple = ({\n  migrationName,\n  documentTypes,\n}: {\n  migrationName: string\n  documentTypes: string[]\n}) => `import {at, defineMigration, setIfMissing, unset} from 'sanity/migrate'\n\nexport default defineMigration({\n  title: '${migrationName}',\n${\n  documentTypes.length > 0\n    ? `  documentTypes: [${documentTypes.map((t) => JSON.stringify(t)).join(', ')}],\\n`\n    : ''\n}\n  migrate: {\n    document(doc, context) {\n      // this will be called for every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n\n      return at('title', setIfMissing('Default title'))\n    },\n    node(node, path, context) {\n      // this will be called for every node in every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n\n      if (typeof node === 'string' && node === 'deleteme') {\n        return unset()\n      }\n    },\n    object(node, path, context) {\n      // this will be called for every object node in every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n      if (node._type === 'author') {\n        // make sure all authors objects have a books array\n        return at('books', setIfMissing([]))\n      }\n    },\n    array(node, path, context) {\n      // this will be called for every array node in every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n    },\n    string(node, path, context) {\n      // this will be called for every string node in every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n    },\n    number(node, path, context) {\n      // this will be called for every number node in every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n    },\n    boolean(node, path, context) {\n      // this will be called for every boolean node in every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n    },\n    null(node, path, context) {\n      // this will be called for every null node in every document of the matching type\n      // any patch returned will be applied to the document\n      // you can also return mutations that touches other documents\n    },\n  },\n})\n`\n","export const renameField = ({\n  migrationName,\n  documentTypes,\n}: {\n  migrationName: string\n  documentTypes: string[]\n}) => `import {defineMigration, at, setIfMissing, unset} from 'sanity/migrate'\n\nconst from = 'oldFieldName'\nconst to = 'newFieldName'\n\nexport default defineMigration({\n  title: '${migrationName}',\n${\n  documentTypes.length > 0\n    ? `  documentTypes: [${documentTypes.map((t) => JSON.stringify(t)).join(', ')}],\\n`\n    : ''\n}\n  migrate: {\n    document(doc, context) {\n      return [\n        at(to, setIfMissing(doc[from])),\n        at(from, unset())\n      ]\n    }\n  }\n})\n`\n","export const renameType = ({\n  migrationName,\n  documentTypes,\n}: {\n  migrationName: string\n  documentTypes: string[]\n}) => `import {defineMigration, at, set} from 'sanity/migrate'\n\nconst oldType = 'old'\nconst newType = 'new'\n\nexport default defineMigration({\n  title: '${migrationName}',\n${\n  documentTypes.length > 0\n    ? `  documentTypes: [${documentTypes.map((t) => JSON.stringify(t)).join(', ')}],\\n`\n    : ''\n}\n  migrate: {\n    object(object, path, context) {\n      if (object._type === oldType) {\n        return at('_type', set(newType))\n      }\n    }\n  }\n})\n`\n","export const stringToPTE = ({\n  migrationName,\n  documentTypes,\n}: {\n  migrationName: string\n  documentTypes: string[]\n}) => `import {pathsAreEqual, stringToPath} from 'sanity'\nimport {defineMigration, set} from 'sanity/migrate'\n\nconst targetPath = stringToPath('some.path')\n\nexport default defineMigration({\n  title: '${migrationName}',\n${\n  documentTypes.length > 0\n    ? `  documentTypes: [${documentTypes.map((t) => JSON.stringify(t)).join(', ')}],\\n`\n    : ''\n}\n  migrate: {\n    string(node, path, ctx) {\n      if (pathsAreEqual(path, targetPath)) {\n        return set([\n          {\n            style: 'normal',\n            _type: 'block',\n            children: [\n              {\n                _type: 'span',\n                marks: [],\n                text: node,\n              },\n            ],\n            markDefs: [],\n          },\n        ])\n      }\n    },\n  },\n})\n`\n","import {existsSync, mkdirSync} from 'node:fs'\nimport {writeFile} from 'node:fs/promises'\nimport path from 'node:path'\n\nimport {type CliCommandDefinition} from '@sanity/cli'\nimport {deburr} from 'lodash-es'\n\nimport {MIGRATIONS_DIRECTORY} from './constants'\nimport {minimalAdvanced} from './templates/minimalAdvanced'\nimport {minimalSimple} from './templates/minimalSimple'\nimport {renameField} from './templates/renameField'\nimport {renameType} from './templates/renameType'\nimport {stringToPTE} from './templates/stringToPTE'\n\nconst helpText = `\nExamples:\n  # Create a new migration, prompting for title and options\n  sanity migration create\n\n  # Create a new migration with the provided title, prompting for options\n  sanity migration create \"Rename field from location to address\"\n`\n\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\ninterface CreateMigrationFlags {}\n\nconst TEMPLATES = [\n  {name: 'Minimalistic migration to get you started', template: minimalSimple},\n  {name: 'Rename an object type', template: renameType},\n  {name: 'Rename a field', template: renameField},\n  {name: 'Convert string field to Portable Text', template: stringToPTE},\n  {\n    name: 'Advanced template using async iterators providing more fine grained control',\n    template: minimalAdvanced,\n  },\n]\n\nconst createMigrationCommand: CliCommandDefinition<CreateMigrationFlags> = {\n  name: 'create',\n  group: 'migration',\n  signature: '[TITLE]',\n  helpText,\n  description: 'Create a new migration within your project',\n  action: async (args, context) => {\n    const {output, prompt, workDir, chalk} = context\n\n    let [title] = args.argsWithoutOptions\n\n    while (!title?.trim()) {\n      title = await prompt.single({\n        type: 'input',\n        suffix: ' (e.g. \"Rename field from location to address\")',\n        message: 'Title of migration',\n      })\n      if (!title.trim()) {\n        output.error(chalk.red('Name cannot be empty'))\n      }\n    }\n    const types = await prompt.single({\n      type: 'input',\n      suffix: ' (optional)',\n      message: 'Type of documents to migrate. You can add multiple types separated by comma',\n    })\n\n    const templatesByName = Object.fromEntries(TEMPLATES.map((t) => [t.name, t]))\n    const template = await prompt.single({\n      type: 'list',\n      message: 'Select a template',\n      choices: TEMPLATES.map((definedTemplate) => ({\n        name: definedTemplate.name,\n        value: definedTemplate.name,\n      })),\n    })\n\n    const sluggedName = deburr(title.toLowerCase())\n      .replace(/\\s+/g, '-')\n      .replace(/[^a-z0-9-]/g, '')\n\n    const destDir = path.join(workDir, MIGRATIONS_DIRECTORY, sluggedName)\n    if (existsSync(destDir)) {\n      if (\n        !(await prompt.single({\n          type: 'confirm',\n          message: `Migration directory ${chalk.cyan(destDir)} already exists. Overwrite?`,\n          default: false,\n        }))\n      ) {\n        return\n      }\n    }\n    mkdirSync(destDir, {recursive: true})\n\n    const renderedTemplate = (templatesByName[template].template || minimalSimple)({\n      migrationName: title,\n      documentTypes: types\n        .split(',')\n        .map((t) => t.trim())\n        .filter(Boolean),\n    })\n\n    const definitionFile = path.join(destDir, 'index.ts')\n\n    await writeFile(definitionFile, renderedTemplate)\n    // To dry run it, run \\`sanity migration run ${sluggedName}\\``)\n    output.print()\n    output.print(`${chalk.green('✓')} Migration created!`)\n    output.print()\n    output.print('Next steps:')\n    output.print(\n      `Open ${chalk.bold(\n        definitionFile,\n      )} in your code editor and write the code for your migration.`,\n    )\n    output.print(\n      `Dry run the migration with:\\n\\`${chalk.bold(\n        `sanity migration run ${sluggedName} --project=<projectId> --dataset <dataset> `,\n      )}\\``,\n    )\n    output.print(\n      `Run the migration against a dataset with:\\n \\`${chalk.bold(\n        `sanity migration run ${sluggedName} --project=<projectId> --dataset <dataset> --no-dry-run`,\n      )}\\``,\n    )\n    output.print()\n    output.print(\n      `👉 Learn more about schema and content migrations at ${chalk.bold(\n        'https://www.sanity.io/docs/schema-and-content-migrations',\n      )}`,\n    )\n  },\n}\nexport default createMigrationCommand\n","import {createRequire} from 'node:module'\nimport path from 'node:path'\n\nimport {type Migration} from '@sanity/migrate'\nimport {isPlainObject} from 'lodash-es'\n\nimport {MIGRATION_SCRIPT_EXTENSIONS, MIGRATIONS_DIRECTORY} from '../constants'\n\nconst require = createRequire(import.meta.url)\n\ninterface ResolvedMigrationScript {\n  /**\n   * Relative path from the working directory to the migration script\n   */\n  relativePath: string\n\n  /**\n   * Absolute path to the migration script\n   */\n  absolutePath: string\n\n  /**\n   * The migration module, if it could be resolved - otherwise `undefined`\n   */\n  mod?: {default: Migration; up?: unknown; down?: unknown}\n}\n\n/**\n * Resolves the potential paths to a migration script.\n * Considers the following paths (where `<ext>` is 'mjs', 'js', 'ts' or 'cjs'):\n *\n * - `<migrationsDir>/<migrationName>.<ext>`\n * - `<migrationsDir>/<migrationName>/index.<ext>`\n *\n * Note that all possible paths are returned, even if the files do not exist.\n * Check the `mod` property to see if a module could actually be loaded.\n *\n * @param workDir - Working directory of the studio\n * @param migrationName - The name of the migration directory to resolve\n * @returns An array of potential migration scripts\n * @internal\n */\nexport function resolveMigrationScript(\n  workDir: string,\n  migrationName: string,\n): ResolvedMigrationScript[] {\n  return [migrationName, path.join(migrationName, 'index')].flatMap((location) =>\n    MIGRATION_SCRIPT_EXTENSIONS.map((ext) => {\n      const relativePath = path.join(MIGRATIONS_DIRECTORY, `${location}.${ext}`)\n      const absolutePath = path.resolve(workDir, relativePath)\n      let mod\n      try {\n        // eslint-disable-next-line import/no-dynamic-require\n        mod = require(absolutePath)\n      } catch (err) {\n        if (err.code !== 'MODULE_NOT_FOUND') {\n          throw new Error(`Error: ${err.message}\"`, {cause: err})\n        }\n      }\n      return {relativePath, absolutePath, mod}\n    }),\n  )\n}\n\n/**\n * Checks whether or not the passed resolved migration script is actually loadable (eg has a default export)\n *\n * @param script - The resolved migration script to check\n * @returns `true` if the script is loadable, `false` otherwise\n * @internal\n */\nexport function isLoadableMigrationScript(\n  script: ResolvedMigrationScript,\n): script is Required<ResolvedMigrationScript> {\n  if (typeof script.mod === 'undefined' || !isPlainObject(script.mod.default)) {\n    return false\n  }\n\n  const mod = script.mod.default\n  return typeof mod.title === 'string' && mod.migrate !== undefined\n}\n","import {readdir} from 'node:fs/promises'\nimport path from 'node:path'\n\nimport {type CliCommandDefinition} from '@sanity/cli'\nimport {type Migration} from '@sanity/migrate'\nimport {Table} from 'console-table-printer'\nimport {register} from 'esbuild-register/dist/node'\n\nimport {MIGRATION_SCRIPT_EXTENSIONS, MIGRATIONS_DIRECTORY} from './constants'\nimport {isLoadableMigrationScript, resolveMigrationScript} from './utils/resolveMigrationScript'\n\nconst helpText = ``\n\nconst listMigrationCommand: CliCommandDefinition = {\n  name: 'list',\n  group: 'migration',\n  signature: '',\n  helpText,\n  description: 'List available migrations',\n  action: async (_, context) => {\n    const {workDir, output, chalk} = context\n    try {\n      const migrations = await resolveMigrations(workDir)\n\n      if (migrations.length === 0) {\n        output.print('No migrations found in migrations folder of the project')\n        output.print(\n          `\\nRun ${chalk.green(`\\`sanity migration create <NAME>\\``)} to create a new migration`,\n        )\n        return\n      }\n\n      const table = new Table({\n        title: `Found ${migrations.length} migrations in project`,\n        columns: [\n          {name: 'id', title: 'ID', alignment: 'left'},\n          {name: 'title', title: 'Title', alignment: 'left'},\n        ],\n      })\n\n      migrations.forEach((definedMigration) => {\n        table.addRow({id: definedMigration.id, title: definedMigration.migration.title})\n      })\n      table.printTable()\n      output.print('\\nRun `sanity migration run <ID>` to run a migration')\n    } catch (error) {\n      if (error.code === 'ENOENT') {\n        output.print('No migrations folder found in the project')\n        output.print(\n          `\\nRun ${chalk.green(`\\`sanity migration create <NAME>\\``)} to create a new migration`,\n        )\n        return\n      }\n      throw new Error(`An error occurred while listing migrations: ${error.message}`, {\n        cause: error,\n      })\n    }\n  },\n}\n\n/**\n * A resolved migration, where you are guaranteed that the migration file exists\n *\n * @internal\n */\nexport interface ResolvedMigration {\n  id: string\n  migration: Migration\n}\n\n/**\n * Resolves all migrations in the studio working directory\n *\n * @param workDir - The studio working directory\n * @returns Array of migrations and their respective paths\n * @internal\n */\nexport async function resolveMigrations(workDir: string): Promise<ResolvedMigration[]> {\n  let unregister\n  if (!__DEV__) {\n    unregister = register({\n      target: `node${process.version.slice(1)}`,\n      supported: {'dynamic-import': true},\n      format: 'cjs',\n    }).unregister\n  }\n\n  const migrationsDir = path.join(workDir, MIGRATIONS_DIRECTORY)\n  const migrationEntries = await readdir(migrationsDir, {withFileTypes: true})\n\n  const migrations: ResolvedMigration[] = []\n  for (const entry of migrationEntries) {\n    const entryName = entry.isDirectory() ? entry.name : removeMigrationScriptExtension(entry.name)\n    const candidates = resolveMigrationScript(workDir, entryName).filter(isLoadableMigrationScript)\n\n    for (const candidate of candidates) {\n      migrations.push({\n        id: entryName,\n        migration: candidate.mod.default,\n      })\n    }\n  }\n\n  if (unregister) {\n    unregister()\n  }\n\n  return migrations\n}\n\nfunction removeMigrationScriptExtension(fileName: string) {\n  // Remove `.ts`, `.js` etc from the end of a filename\n  return MIGRATION_SCRIPT_EXTENSIONS.reduce(\n    (name, ext) => (name.endsWith(`.${ext}`) ? path.basename(name, `.${ext}`) : name),\n    fileName,\n  )\n}\n\nexport default listMigrationCommand\n","export default {\n  name: 'migration',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Manages content migrations for Content Lake datasets',\n}\n","import {isIndexSegment, isIndexTuple, isKeySegment, type Path} from '@sanity/types'\n\n// FIXME: de-dupe this\n// copy/paste of `pathToString` from 'sanity' to prevent circular imports\nfunction pathToString(path: Path): string {\n  if (!Array.isArray(path)) {\n    throw new Error('Path is not an array')\n  }\n\n  return path.reduce<string>((target, segment, i) => {\n    if (isIndexSegment(segment)) {\n      return `${target}[${segment}]`\n    }\n\n    if (isKeySegment(segment) && segment._key) {\n      return `${target}[_key==\"${segment._key}\"]`\n    }\n\n    if (isIndexTuple(segment)) {\n      const [from, to] = segment\n      return `${target}[${from}:${to}]`\n    }\n\n    if (typeof segment === 'string') {\n      const separator = i === 0 ? '' : '.'\n      return `${target}${separator}${segment}`\n    }\n\n    throw new Error(`Unsupported path segment \\`${JSON.stringify(segment)}\\``)\n  }, '')\n}\n\ninterface BaseNode {\n  path: Path\n}\n\nexport interface Tree<Node extends BaseNode> {\n  nodes?: Node[]\n  children?: Record<string, Tree<Node>>\n}\n\n/**\n * Recursively calculates the max length of all the keys in the given validation\n * tree respecting extra length due to indentation depth. Used to calculate the\n * padding for the rest of the tree.\n */\nexport const maxKeyLength = (children: Record<string, Tree<BaseNode>> = {}, depth = 0): number => {\n  return Object.entries(children)\n    .map(([key, child]) =>\n      Math.max(key.length + depth * 2, maxKeyLength(child.children, depth + 1)),\n    )\n    .reduce((max, next) => (next > max ? next : max), 0)\n}\n\ninterface Options<Node extends BaseNode> {\n  node?: Record<string, Tree<Node>>\n  paddingLength: number\n  indent?: string\n  getNodes?: (node: Tree<Node>) => Node[] | undefined\n  getMessage: (node: Node) => string\n}\n\n/**\n * Recursively formats a given tree into a printed user-friendly tree structure\n */\nexport const formatTree = <Node extends BaseNode>({\n  node = {},\n  paddingLength,\n  indent = '',\n  getNodes: getLeaves = ({nodes}) => nodes,\n  getMessage,\n}: Options<Node>): string => {\n  const entries = Object.entries(node)\n\n  return entries\n    .map(([key, child], index) => {\n      const isLast = index === entries.length - 1\n      const nextIndent = `${indent}${isLast ? '  ' : '│ '}`\n      const leaves = getLeaves(child)\n\n      const nested = formatTree({\n        node: child.children,\n        paddingLength,\n        indent: nextIndent,\n        getNodes: getLeaves,\n        getMessage,\n      })\n\n      if (!leaves?.length) {\n        const current = `${indent}${isLast ? '└' : '├'}─ ${key}`\n        return [current, nested].filter(Boolean).join('\\n')\n      }\n\n      const [first, ...rest] = leaves\n      const firstPadding = '.'.repeat(paddingLength - indent.length - key.length)\n      const elbow = isLast ? '└' : '├'\n      const subsequentPadding = ' '.repeat(paddingLength - indent.length + 2)\n\n      const firstMessage = `${indent}${elbow}─ ${key} ${firstPadding} ${getMessage(first)}`\n      const subsequentMessages = rest\n        .map((marker) => `${nextIndent}${subsequentPadding} ${getMessage(marker)}`)\n        .join('\\n')\n\n      const current = [firstMessage, subsequentMessages].filter(Boolean).join('\\n')\n      return [current, nested].filter(Boolean).join('\\n')\n    })\n    .join('\\n')\n}\n\n/**\n * Converts a set of markers with paths into a tree of markers where the paths\n * are embedded in the tree\n */\nexport function convertToTree<const Node extends BaseNode>(nodes: Node[]): Tree<Node> {\n  const root: Tree<Node> = {}\n\n  // add the markers to the tree\n  function addNode(node: Node, tree: Tree<Node> = root) {\n    // if we've traversed the whole path\n    if (!node.path.length) {\n      if (!tree.nodes) tree.nodes = [] // ensure markers is defined\n\n      // then add the marker to the front\n      tree.nodes.push(node)\n      return\n    }\n\n    const [current, ...rest] = node.path\n    const key = pathToString([current])\n\n    // ensure the current node has children and the next node\n    if (!tree.children) tree.children = {}\n    if (!(key in tree.children)) tree.children[key] = {}\n\n    addNode({...node, path: rest}, tree.children[key])\n  }\n\n  for (const node of nodes) addNode(node)\n  return root\n}\n","import {isatty} from 'node:tty'\n\nimport {type Migration, type Mutation, type NodePatch, type Transaction} from '@sanity/migrate'\nimport {type KeyedSegment} from '@sanity/types'\nimport {type Chalk} from 'chalk'\n\nimport {convertToTree, formatTree, maxKeyLength} from '../../util/tree'\n\ntype ItemRef = string | number\ntype Impact = 'destructive' | 'maybeDestructive' | 'incremental'\ntype Variant = Impact | 'info'\n\nconst isTty = isatty(1)\n\ninterface FormatterOptions<Subject> {\n  chalk: Chalk\n  subject: Subject\n  migration: Migration\n  indentSize?: number\n}\n\nexport function prettyFormat({\n  chalk,\n  subject,\n  migration,\n  indentSize = 0,\n}: FormatterOptions<Mutation | Transaction | (Mutation | Transaction)[]>): string {\n  return (Array.isArray(subject) ? subject : [subject])\n    .map((subjectEntry) => {\n      if (subjectEntry.type === 'transaction') {\n        return [\n          [\n            badge('transaction', 'info', chalk),\n            typeof subjectEntry.id === 'undefined' ? null : chalk.underline(subjectEntry.id),\n          ]\n            .filter(Boolean)\n            .join(' '),\n          indent(\n            prettyFormat({\n              chalk,\n              subject: subjectEntry.mutations,\n              migration,\n              indentSize: indentSize,\n            }),\n          ),\n        ].join('\\n\\n')\n      }\n      return prettyFormatMutation({\n        chalk,\n        subject: subjectEntry,\n        migration,\n        indentSize,\n      })\n    })\n    .join('\\n\\n')\n}\n\nfunction encodeItemRef(ref: number | KeyedSegment): ItemRef {\n  return typeof ref === 'number' ? ref : ref._key\n}\n\nfunction badgeStyle(chalk: Chalk, variant: Variant): Chalk {\n  const styles: Record<Variant, Chalk> = {\n    info: chalk.bgWhite.black,\n    incremental: chalk.bgGreen.black.bold,\n    maybeDestructive: chalk.bgYellow.black.bold,\n    destructive: chalk.bgRed.black.bold,\n  }\n\n  return styles[variant]\n}\n\nfunction badge(label: string, variant: Variant, chalk: Chalk): string {\n  if (!isTty) {\n    return `[${label}]`\n  }\n\n  return badgeStyle(chalk, variant)(` ${label} `)\n}\n\nconst mutationImpact: Record<Mutation['type'], Impact> = {\n  create: 'incremental',\n  createIfNotExists: 'incremental',\n  createOrReplace: 'maybeDestructive',\n  delete: 'destructive',\n  patch: 'maybeDestructive',\n}\n\nfunction documentId(mutation: Mutation): string | undefined {\n  if ('id' in mutation) {\n    return mutation.id\n  }\n\n  if ('document' in mutation) {\n    return mutation.document._id\n  }\n\n  return undefined\n}\n\nconst listFormatter = new Intl.ListFormat('en-US', {\n  type: 'disjunction',\n})\n\nfunction mutationHeader(chalk: Chalk, mutation: Mutation, migration: Migration): string {\n  const mutationType = badge(mutation.type, mutationImpact[mutation.type], chalk)\n\n  const documentType =\n    'document' in mutation || migration.documentTypes\n      ? badge(\n          'document' in mutation\n            ? mutation.document._type\n            : listFormatter.format(migration.documentTypes ?? []),\n          'info',\n          chalk,\n        )\n      : null\n\n  // TODO: Should we list documentType when a mutation can be yielded for any document type?\n  return [mutationType, documentType, chalk.underline(documentId(mutation))]\n    .filter(Boolean)\n    .join(' ')\n}\n\nexport function prettyFormatMutation({\n  chalk,\n  subject,\n  migration,\n  indentSize = 0,\n}: FormatterOptions<Mutation>): string {\n  const lock =\n    'options' in subject ? chalk.cyan(`(if revision==${subject.options?.ifRevision})`) : ''\n  const header = [mutationHeader(chalk, subject, migration), lock].join(' ')\n  const padding = ' '.repeat(indentSize)\n\n  if (\n    subject.type === 'create' ||\n    subject.type === 'createIfNotExists' ||\n    subject.type === 'createOrReplace'\n  ) {\n    return [header, '\\n', indent(JSON.stringify(subject.document, null, 2), indentSize)].join('')\n  }\n\n  if (subject.type === 'patch') {\n    const tree = convertToTree<NodePatch>(subject.patches.flat())\n    const paddingLength = Math.max(maxKeyLength(tree.children) + 2, 30)\n\n    return [\n      header,\n      '\\n',\n      formatTree<NodePatch>({\n        node: tree.children,\n        paddingLength,\n        indent: padding,\n        getMessage: (patch) => formatPatchMutation(chalk, patch),\n      }),\n    ].join('')\n  }\n\n  return header\n}\n\nfunction formatPatchMutation(chalk: Chalk, patch: NodePatch): string {\n  const {op} = patch\n  const formattedType = chalk.bold(op.type)\n  if (op.type === 'unset') {\n    return `${chalk.red(formattedType)}()`\n  }\n  if (op.type === 'diffMatchPatch') {\n    return `${chalk.yellow(formattedType)}(${op.value})`\n  }\n  if (op.type === 'inc' || op.type === 'dec') {\n    return `${chalk.yellow(formattedType)}(${op.amount})`\n  }\n  if (op.type === 'set') {\n    return `${chalk.yellow(formattedType)}(${JSON.stringify(op.value)})`\n  }\n  if (op.type === 'setIfMissing') {\n    return `${chalk.green(formattedType)}(${JSON.stringify(op.value)})`\n  }\n  if (op.type === 'insert') {\n    return `${chalk.green(formattedType)}(${op.position}, ${encodeItemRef(\n      op.referenceItem,\n    )}, ${JSON.stringify(op.items)})`\n  }\n  if (op.type === 'replace') {\n    return `${chalk.yellow(formattedType)}(${encodeItemRef(op.referenceItem)}, ${JSON.stringify(\n      op.items,\n    )})`\n  }\n  if (op.type === 'truncate') {\n    return `${chalk.red(formattedType)}(${op.startIndex}, ${op.endIndex})`\n  }\n  // @ts-expect-error all cases are covered\n  throw new Error(`Invalid operation type: ${op.type}`)\n}\n\nfunction indent(subject: string, size = 2): string {\n  const padding = ' '.repeat(size)\n\n  return subject\n    .split('\\n')\n    .map((line) => padding + line)\n    .join('\\n')\n}\n","import {type APIConfig} from '@sanity/migrate'\n\ntype ApiVersion = APIConfig['apiVersion']\n\nconst VERSION_PATTERN = /^v\\d+-\\d+-\\d+$|^vX$/ // Matches version strings like vYYYY-MM-DD or vX\n\n/**\n * Ensures that the provided API version string is in the correct format.\n * If the version does not start with 'v', it will be prefixed with 'v'.\n * If the version does not match the expected pattern, an error will be thrown.\n */\nexport function ensureApiVersionFormat(version: string): ApiVersion {\n  const normalizedVersion = version.startsWith('v') ? version : `v${version}`\n\n  // Check if the version matches the expected pattern\n  if (!VERSION_PATTERN.test(normalizedVersion)) {\n    throw new Error(\n      `Invalid API version format: ${normalizedVersion}. Expected format: vYYYY-MM-DD or vX`,\n    )\n  }\n\n  return normalizedVersion as ApiVersion\n}\n","import path from 'node:path'\n\nimport {type CliCommandDefinition} from '@sanity/cli'\nimport {\n  DEFAULT_MUTATION_CONCURRENCY,\n  dryRun,\n  MAX_MUTATION_CONCURRENCY,\n  type Migration,\n  type MigrationProgress,\n  run,\n} from '@sanity/migrate'\nimport {Table} from 'console-table-printer'\nimport {register} from 'esbuild-register/dist/node'\nimport {hideBin} from 'yargs/helpers'\nimport yargs from 'yargs/yargs'\n\nimport {debug} from '../../debug'\nimport {DEFAULT_API_VERSION, MIGRATIONS_DIRECTORY} from './constants'\nimport {resolveMigrations} from './listMigrationsCommand'\nimport {prettyFormat} from './prettyMutationFormatter'\nimport {ensureApiVersionFormat} from './utils/ensureApiVersionFormat'\nimport {isLoadableMigrationScript, resolveMigrationScript} from './utils/resolveMigrationScript'\n\nconst helpText = `\nOptions\n  --no-dry-run By default the migration runs in dry mode. Pass this option to migrate dataset.\n  --concurrency <concurrent> How many mutation requests to run in parallel. Must be between 1 and ${MAX_MUTATION_CONCURRENCY}. Default: ${DEFAULT_MUTATION_CONCURRENCY}.\n  --no-progress Don't output progress. Useful if you want debug your migration script and see the output of console.log() statements.\n  --dataset <dataset> Dataset to migrate. Defaults to the dataset configured in your Sanity CLI config.\n  --project <project id> Project ID of the dataset to migrate. Defaults to the projectId configured in your Sanity CLI config.\n  --api-version <version> API version to use when migrating. Defaults to ${DEFAULT_API_VERSION}.\n  --no-confirm Skip the confirmation prompt before running the migration. Make sure you know what you're doing before using this flag.\n  --from-export <export.tar.gz> Use a local dataset export as source for migration instead of calling the Sanity API. Note: this is only supported for dry runs.\n\n\nExamples\n  # dry run the migration\n  sanity migration run <id>\n\n  # execute the migration against a dataset\n  sanity migration run <id> --no-dry-run --project xyz --dataset staging\n\n  # execute the migration using a dataset export as the source\n  sanity migration run <id>  --from-export=production.tar.gz --no-dry-run --projectId xyz --dataset staging\n`\n\ninterface CreateFlags {\n  ['dry-run']?: boolean\n  concurrency?: number\n  ['from-export']?: string\n  progress?: boolean\n  dataset?: string\n  project?: string\n  confirm?: boolean\n}\n\nfunction parseCliFlags(args: {argv?: string[]}) {\n  return yargs(hideBin(args.argv || process.argv).slice(2))\n    .options('dry-run', {type: 'boolean', default: true})\n    .options('concurrency', {type: 'number', default: DEFAULT_MUTATION_CONCURRENCY})\n    .options('progress', {type: 'boolean', default: true})\n    .options('dataset', {type: 'string'})\n    .options('from-export', {type: 'string'})\n    .options('project', {type: 'string'})\n    .options('api-version', {type: 'string'})\n    .options('confirm', {type: 'boolean', default: true}).argv\n}\n\nconst runMigrationCommand: CliCommandDefinition<CreateFlags> = {\n  name: 'run',\n  group: 'migration',\n  signature: 'ID',\n  helpText,\n  description: 'Run a migration against a dataset',\n  // eslint-disable-next-line max-statements\n  action: async (args, context) => {\n    const {apiClient, output, prompt, chalk, workDir} = context\n    const [id] = args.argsWithoutOptions\n    const migrationsDirectoryPath = path.join(workDir, MIGRATIONS_DIRECTORY)\n\n    const flags = await parseCliFlags(args)\n\n    const fromExport = flags.fromExport\n    const dry = flags.dryRun\n    const dataset = flags.dataset\n    const project = flags.project\n    const apiVersion = flags.apiVersion\n\n    if ((dataset && !project) || (project && !dataset)) {\n      throw new Error('If either --dataset or --project is provided, both must be provided')\n    }\n\n    if (!id) {\n      output.error(chalk.red('Error: Migration ID must be provided'))\n      const migrations = await resolveMigrations(workDir)\n      const table = new Table({\n        title: `Migrations found in project`,\n        columns: [\n          {name: 'id', title: 'ID', alignment: 'left'},\n          {name: 'title', title: 'Title', alignment: 'left'},\n        ],\n      })\n\n      migrations.forEach((definedMigration) => {\n        table.addRow({id: definedMigration.id, title: definedMigration.migration.title})\n      })\n      table.printTable()\n      output.print('\\nRun `sanity migration run <ID>` to run a migration')\n\n      return\n    }\n\n    if (!__DEV__) {\n      register({\n        target: `node${process.version.slice(1)}`,\n        supported: {'dynamic-import': true},\n        format: 'cjs',\n      })\n    }\n\n    const candidates = resolveMigrationScript(workDir, id)\n    const resolvedScripts = candidates.filter(isLoadableMigrationScript)\n\n    if (resolvedScripts.length > 1) {\n      // todo: consider prompt user about which one to run? note: it's likely a mistake if multiple files resolve to the same name\n      throw new Error(\n        `Found multiple migrations for \"${id}\" in ${chalk.cyan(migrationsDirectoryPath)}: \\n - ${candidates\n          .map((candidate) => path.relative(migrationsDirectoryPath, candidate.absolutePath))\n          .join('\\n - ')}`,\n      )\n    }\n\n    const script = resolvedScripts[0]\n    if (!script) {\n      throw new Error(\n        `No migration found for \"${id}\" in ${chalk.cyan(chalk.cyan(migrationsDirectoryPath))}. Make sure that the migration file exists and exports a valid migration as its default export.\\n\n Tried the following files:\\n - ${candidates\n   .map((candidate) => path.relative(migrationsDirectoryPath, candidate.absolutePath))\n   .join('\\n - ')}`,\n      )\n    }\n\n    const mod = script.mod\n    if ('up' in mod || 'down' in mod) {\n      // todo: consider adding support for up/down as separate named exports\n      // For now, make sure we reserve the names for future use\n      throw new Error(\n        'Only \"up\" migrations are supported at this time, please use a default export',\n      )\n    }\n\n    const migration: Migration = mod.default\n\n    if (fromExport && !dry) {\n      throw new Error('Can only dry run migrations from a dataset export file')\n    }\n\n    const concurrency = flags.concurrency\n    if (concurrency !== undefined) {\n      if (concurrency > MAX_MUTATION_CONCURRENCY) {\n        throw new Error(\n          `Concurrency exceeds the maximum allowed value of ${MAX_MUTATION_CONCURRENCY}`,\n        )\n      }\n\n      if (concurrency === 0) {\n        throw new Error(`Concurrency must be a positive number, got ${concurrency}`)\n      }\n    }\n\n    const projectConfig = apiClient({\n      requireUser: true,\n      requireProject: false,\n    }).config()\n\n    if (!project && !projectConfig.projectId) {\n      throw new Error(\n        'sanity.cli.js does not contain a project identifier (\"api.projectId\") and no --project option was provided.',\n      )\n    }\n\n    const apiConfig = {\n      dataset: dataset ?? projectConfig.dataset!,\n      projectId: project ?? projectConfig.projectId!,\n      apiHost: projectConfig.apiHost!,\n      token: projectConfig.token!,\n      apiVersion: ensureApiVersionFormat(apiVersion ?? DEFAULT_API_VERSION),\n    } as const\n    if (dry) {\n      void dryRunHandler()\n      return\n    }\n\n    output.print(\n      `\\n${chalk.yellow(chalk.bold('Note: During migrations, your webhooks stay active.'))}`,\n    )\n    output.print(\n      `To adjust them, launch the management interface with ${chalk.cyan('sanity manage')}, navigate to the API settings, and toggle the webhooks before and after the migration as needed.\\n`,\n    )\n\n    if (flags.confirm) {\n      const response = await prompt.single<boolean>({\n        message: `This migration will run on the ${chalk.yellow(\n          chalk.bold(apiConfig.dataset),\n        )} dataset in ${chalk.yellow(chalk.bold(apiConfig.projectId))} project. Are you sure?`,\n        type: 'confirm',\n      })\n\n      if (!response) {\n        debug('User aborted migration')\n        return\n      }\n    }\n\n    const spinner = output.spinner(`Running migration \"${id}\"`).start()\n    await run({api: apiConfig, concurrency, onProgress: createProgress(spinner)}, migration)\n    spinner.stop()\n\n    function createProgress(progressSpinner: ReturnType<typeof output.spinner>) {\n      return function onProgress(progress: MigrationProgress) {\n        if (!flags.progress) {\n          progressSpinner.stop()\n          return\n        }\n        if (progress.done) {\n          progressSpinner.text = `Migration \"${id}\" completed.\n\n  Project id:  ${chalk.bold(apiConfig.projectId)}\n  Dataset:     ${chalk.bold(apiConfig.dataset)}\n\n  ${progress.documents} documents processed.\n  ${progress.mutations} mutations generated.\n  ${chalk.green(progress.completedTransactions.length)} transactions committed.`\n          progressSpinner.stopAndPersist({symbol: chalk.green('✔')})\n          return\n        }\n\n        ;[null, ...progress.currentTransactions].forEach((transaction) => {\n          progressSpinner.text = `Running migration \"${id}\" ${dry ? 'in dry mode...' : '...'}\n\n  Project id:     ${chalk.bold(apiConfig.projectId)}\n  Dataset:        ${chalk.bold(apiConfig.dataset)}\n  Document type:  ${chalk.bold(migration.documentTypes?.join(','))}\n\n  ${progress.documents} documents processed…\n  ${progress.mutations} mutations generated…\n  ${chalk.blue(progress.pending)} requests pending…\n  ${chalk.green(progress.completedTransactions.length)} transactions committed.\n\n  ${\n    transaction && !progress.done\n      ? `» ${prettyFormat({chalk, subject: transaction, migration, indentSize: 2})}`\n      : ''\n  }`\n        })\n      }\n    }\n\n    async function dryRunHandler() {\n      output.print(`Running migration \"${id}\" in dry mode`)\n\n      if (fromExport) {\n        output.print(`Using export ${chalk.cyan(fromExport)}`)\n      }\n\n      output.print()\n      output.print(`Project id:  ${chalk.bold(apiConfig.projectId)}`)\n      output.print(`Dataset:     ${chalk.bold(apiConfig.dataset)}`)\n\n      for await (const mutation of dryRun({api: apiConfig, exportPath: fromExport}, migration)) {\n        if (!mutation) continue\n        output.print()\n        output.print(\n          prettyFormat({\n            chalk,\n            subject: mutation,\n            migration,\n          }),\n        )\n      }\n    }\n  },\n}\n\nexport default runMigrationCommand\n","import {createRequire} from 'node:module'\n\nimport {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n} from '@sanity/cli'\n\nimport {type StartPreviewServerCommandFlags} from '../../actions/preview/previewAction'\n\nconst require = createRequire(import.meta.url)\n\nconst helpText = `\nNotes\n  Changing the hostname or port number might require a new entry to the CORS-origins allow list.\n\nOptions\n  --port <port> TCP port to start server on. [default: 3333]\n  --host <host> The local network interface at which to listen. [default: \"127.0.0.1\"]\n\nExamples\n  sanity preview --host=0.0.0.0\n  sanity preview --port=1942\n  sanity preview some/build-output-dir\n`\n\nconst previewCommand: CliCommandDefinition = {\n  name: 'preview',\n  signature: '[BUILD_OUTPUT_DIR] [--port <port>] [--host <host>]',\n  description: 'Starts a server to preview a production build of Sanity Studio',\n  action: async (\n    args: CliCommandArguments<StartPreviewServerCommandFlags>,\n    context: CliCommandContext,\n  ) => {\n    const previewAction = await getPreviewAction()\n\n    return previewAction(args, context)\n  },\n  helpText,\n}\n\nasync function getPreviewAction() {\n  // NOTE: in dev-mode we want to include from `src` so we need to use `.ts` extension\n  // NOTE: this `if` statement is not included in the output bundle\n  if (__DEV__) {\n    // eslint-disable-next-line import/extensions,@typescript-eslint/consistent-type-imports\n    const mod: typeof import('../../actions/preview/previewAction') = require('../../actions/preview/previewAction.ts')\n\n    return mod.default\n  }\n\n  const mod = await import('../../actions/preview/previewAction')\n\n  return mod.default\n}\n\nexport default previewCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst description = 'Delete schema documents by id.'\n\nconst helpText = `\n**Note**: This command is experimental and subject to change.\n\nThis operation (re-)generates a manifest file describing the sanity config workspace by default.\nTo re-use an existing manifest file, use --no-extract-manifest.\n\nOptions\n  --ids <schema_id_1,schema_id_2,...> comma-separated list of schema ids to delete\n  --dataset <dataset_name> delete schemas from a specific dataset\n  --manifest-dir <directory> directory containing manifest file (default: ./dist/static)\n  --no-extract-manifest disables manifest generation – the command will fail if no manifest exists\n\nExamples\n  # Delete single schema\n  sanity schema delete --ids _.schemas.workspaceName\n\n  # Delete multiple schemas\n  sanity schema delete --ids _.schemas.workspaceName, _.schemas.otherWorkspace.tag.taggedSchema\n\n  # Runs using a pre-existing manifest file\n  # Config changes in sanity.config will not be picked up in this case\n  sanity schema delete --no-extract-manifest --ids _.schemas.workspaceName\n\n`\n\nconst deleteSchemaCommand = {\n  name: 'delete',\n  group: 'schema',\n  signature: '',\n  description,\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/schema/deleteSchemaAction')\n    const result = await mod.default(args.extOptions, context)\n    if (result === 'failure') process.exit(1)\n    return result\n  },\n} satisfies CliCommandDefinition\n\nexport default deleteSchemaCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst description = 'Deploy schema documents into workspace datasets.'\n\nconst helpText = `\n**Note**: This command is experimental and subject to change.\n\nThis operation (re-)generates a manifest file describing the sanity config workspace by default.\nTo re-use an existing manifest file, use --no-extract-manifest.\n\nOptions:\n  --workspace <workspace_name> deploy schema for a specific workspace\n  --tag <tag> add a tag suffix to the schema id\n  --manifest-dir <directory> directory containing manifest file (default: ./dist/static)\n  --no-extract-manifest disables manifest generation – the command will fail if no manifest exists\n  --verbose print detailed information during deployment\n\nExamples\n  # Deploy all workspace schemas\n  sanity schema deploy\n\n  # Deploy the schema for only the workspace 'default'\n  sanity schema deploy --workspace default\n\n  # Runs using a pre-existing manifest file\n  # Config changes in sanity.config will not be picked up in this case\n  sanity schema deploy --no-extract-manifest\n`\n\nconst deploySchemaCommand = {\n  name: 'deploy',\n  group: 'schema',\n  signature: '',\n  description,\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/schema/deploySchemasAction')\n\n    const result = await mod.default(args.extOptions, context)\n    if (result === 'failure') process.exit(1)\n    return result\n  },\n} satisfies CliCommandDefinition\n\nexport default deploySchemaCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst description = 'Extracts a JSON representation of a Sanity schema within a Studio context.'\n\nconst helpText = `\n**Note**: This command is experimental and subject to change.\n\nOptions\n  --workspace <name> The name of the workspace to generate a schema for\n  --path Optional path to specify destination of the schema file\n  --enforce-required-fields Makes the schema generated treat fields marked as required as non-optional. Defaults to false.\n  --format=[groq-type-nodes] Format the schema as GROQ type nodes. Only available format at the moment.\n\nExamples\n  # Extracts schema types in a Sanity project with more than one workspace\n  sanity schema extract --workspace default\n`\n\nconst extractSchemaCommand: CliCommandDefinition = {\n  name: 'extract',\n  group: 'schema',\n  signature: '',\n  description,\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/schema/extractAction')\n\n    return mod.default(args, context)\n  },\n} satisfies CliCommandDefinition\n\nexport default extractSchemaCommand\n","export default {\n  name: 'schema',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Interacts with Sanity Studio schema configurations',\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst description = 'Lists all schemas in the current dataset.'\n\nconst helpText = `\n**Note**: This command is experimental and subject to change.\n\nThis operation (re-)generates a manifest file describing the sanity config workspace by default.\nTo re-use an existing manifest file, use --no-extract-manifest.\n\nOptions\n  --json get schema as json\n  --id <schema_id> fetch a single schema by id\n  --manifest-dir <directory> directory containing manifest file (default: ./dist/static)\n  --no-extract-manifest disables manifest generation – the command will fail if no manifest exists\n\nExamples\n  # List all schemas found in any workspace dataset in a table\n  sanity schema list\n\n  # Get a schema for a given id\n  sanity schema list --id _.schemas.workspaceName\n\n  # Get stored schemas as pretty-printed json-array\n  sanity schema list --json\n\n  # Get singular stored schema as pretty-printed json-object\n  sanity schema list --json --id _.schemas.workspaceName\n\n  # Runs using a pre-existing manifest file\n  # Config changes in sanity.config will not be picked up in this case\n  sanity schema list --no-extract-manifest\n`\n\nconst fetchSchemaCommand = {\n  name: 'list',\n  group: 'schema',\n  signature: '',\n  description,\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/schema/listSchemasAction')\n    const result = await mod.default(args.extOptions, context)\n    if (result === 'failure') process.exit(1)\n    return result\n  },\n} satisfies CliCommandDefinition\n\nexport default fetchSchemaCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nconst description = 'Validates all schema types specified in a workspace.'\n\nconst helpText = `\nOptions\n  --workspace <name> The name of the workspace to use when validating all schema types.\n  --format <pretty|ndjson|json> The output format used to print schema errors and warnings.\n  --level <error|warning> The minimum level reported out. Defaults to warning.\n  --debug-metafile-path <path> Optional path where a metafile\n\nExamples\n  # Validates all schema types in a Sanity project with more than one workspace\n  sanity schema validate --workspace default\n\n  # Save the results of the report into a file\n  sanity schema validate > report.txt\n\n  # Report out only errors\n  sanity schema validate --level error\n\n  # Generate a report which can be analyzed with https://esbuild.github.io/analyze/\n  sanity schema validate --debug-metafile-path metafile.json\n`\n\nconst validateDocumentsCommand: CliCommandDefinition = {\n  name: 'validate',\n  group: 'schema',\n  signature: '',\n  description,\n  helpText,\n  action: async (args, context) => {\n    const mod = await import('../../actions/schema/validateAction')\n\n    return mod.default(args, context)\n  },\n} satisfies CliCommandDefinition\n\nexport default validateDocumentsCommand\n","export const isInteractive =\n  process.stdout.isTTY && process.env.TERM !== 'dumb' && !('CI' in process.env)\n","import {createRequire} from 'node:module'\n\nimport {\n  type CliCommandArguments,\n  type CliCommandContext,\n  type CliCommandDefinition,\n} from '@sanity/cli'\n\nimport {type StartPreviewServerCommandFlags} from '../../actions/preview/previewAction'\nimport {isInteractive} from '../../util/isInteractive'\nimport {getDevAction} from '../dev/devCommand'\n\nconst require = createRequire(import.meta.url)\n\nconst helpText = `\nNotes\n  Changing the hostname or port number might require a new CORS-entry to be added.\n\nOptions\n  --port <port> TCP port to start server on. [default: 3333]\n  --host <host> The local network interface at which to listen. [default: \"127.0.0.1\"]\n\nExamples\n  sanity start --host=0.0.0.0\n  sanity start --port=1942\n  sanity start some/build-output-dir\n`\n\nconst startCommand: CliCommandDefinition = {\n  name: 'start',\n  signature: '[BUILD_OUTPUT_DIR] [--port <port>] [--host <host>]',\n  description: 'Alias for `sanity preview`',\n  action: async (\n    args: CliCommandArguments<StartPreviewServerCommandFlags>,\n    context: CliCommandContext,\n  ) => {\n    const {output, chalk, prompt} = context\n    const previewAction = await getPreviewAction()\n\n    const error = (msg: string) => output.warn(chalk.red.bgBlack(msg))\n\n    try {\n      await previewAction(args, context)\n    } catch (err) {\n      if (err.name !== 'BUILD_NOT_FOUND') {\n        throw err\n      }\n\n      error(err.message)\n      error('\\n')\n\n      const shouldRunDevServer =\n        isInteractive &&\n        (await prompt.single({\n          message: 'Do you want to start a development server instead?',\n          type: 'confirm',\n        }))\n\n      if (shouldRunDevServer) {\n        const devAction = await getDevAction(context)\n        await devAction(args, context)\n      } else {\n        // Indicate that this isn't an expected exit\n        process.exit(1)\n      }\n    }\n  },\n  helpText,\n}\n\nasync function getPreviewAction() {\n  // NOTE: in dev-mode we want to include from `src` so we need to use `.ts` extension\n  // NOTE: this `if` statement is not included in the output bundle\n  if (__DEV__) {\n    // eslint-disable-next-line import/extensions,@typescript-eslint/consistent-type-imports\n    const mod: typeof import('../../actions/preview/previewAction') = require('../../actions/preview/previewAction.ts')\n\n    return mod.default\n  }\n\n  const mod = await import('../../actions/preview/previewAction')\n\n  return mod.default\n}\n\nexport default startCommand\n","import {type CliCommandContext, type CliPrompter} from '@sanity/cli'\n\nimport {type ProjectRole, type TokenResponse} from '../../commands/tokens/types'\nimport {isInteractive} from '../../util/isInteractive'\n\ninterface AddTokenFlags {\n  role?: string\n  unattended?: boolean\n}\n\nexport async function addToken(\n  givenLabel: string,\n  flags: AddTokenFlags,\n  context: CliCommandContext,\n): Promise<TokenResponse> {\n  const {apiClient, prompt, output} = context\n  const client = apiClient({requireUser: true, requireProject: true}).config({\n    apiVersion: '2021-06-07',\n  })\n\n  const label = givenLabel || (await promptForLabel(prompt, flags.unattended))\n  const roleName = await (flags.role\n    ? validateRole(flags.role, context)\n    : promptForRole(context, flags.unattended))\n\n  const {projectId} = client.config()\n  const response = await client.request<TokenResponse>({\n    method: 'POST',\n    url: `/projects/${projectId}/tokens`,\n    body: {label, roleName},\n  })\n\n  return response\n}\n\nasync function promptForLabel(prompt: CliPrompter, unattended?: boolean): Promise<string> {\n  if (unattended || !isInteractive) {\n    throw new Error(\n      'Token label is required in non-interactive mode. Provide a label as an argument.',\n    )\n  }\n\n  return prompt.single({\n    type: 'input',\n    message: 'Token label:',\n    validate: (input) => (input && input.trim() ? true : 'Label cannot be empty'),\n  })\n}\n\nasync function promptForRole(context: CliCommandContext, unattended?: boolean): Promise<string> {\n  if (unattended || !isInteractive) {\n    return 'viewer' // Default role for unattended mode\n  }\n\n  const {apiClient, prompt} = context\n  const client = apiClient({requireUser: true, requireProject: true}).config({\n    apiVersion: '2021-06-07',\n  })\n\n  const {projectId} = client.config()\n  const roles = await client.request<ProjectRole[]>({url: `/projects/${projectId}/roles`})\n  const robotRoles = roles.filter((role) => role.appliesToRobots)\n\n  if (robotRoles.length === 0) {\n    throw new Error('No roles available for tokens')\n  }\n\n  const choices = robotRoles.map((role) => ({\n    name: `${role.title} (${role.name})`,\n    value: role.name,\n    short: role.title,\n  }))\n\n  return prompt.single({\n    type: 'list',\n    message: 'Select role for the token:',\n    choices,\n    default: 'viewer',\n  })\n}\n\nasync function validateRole(roleName: string, context: CliCommandContext): Promise<string> {\n  const {apiClient} = context\n  const client = apiClient({requireUser: true, requireProject: true}).config({\n    apiVersion: '2021-06-07',\n  })\n\n  const {projectId} = client.config()\n  const roles = await client.request<ProjectRole[]>({url: `/projects/${projectId}/roles`})\n  const robotRoles = roles.filter((role) => role.appliesToRobots)\n\n  const role = robotRoles.find((r) => r.name === roleName)\n  if (!role) {\n    const availableRoles = robotRoles.map((r) => r.name).join(', ')\n    throw new Error(`Invalid role \"${roleName}\". Available roles: ${availableRoles}`)\n  }\n\n  return roleName\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {addToken} from '../../actions/tokens/addToken'\n\nconst helpText = `\nExamples\n  sanity tokens add \"My API Token\"\n  sanity tokens add \"My API Token\" --role=editor\n  sanity tokens add \"My API Token\" --role=viewer\n  sanity tokens add \"CI Token\" --role=editor --yes\n  sanity tokens add \"API Token\" --json\n\nOptions\n  --role <role>     Role to assign to the token. Default: viewer\n  --json            JSON output format\n  -y, --yes         Skip prompts and use defaults (unattended mode)\n`\n\ntype AddTokenFlags = {\n  role?: string\n  yes?: boolean\n  y?: boolean\n  json?: boolean\n}\n\nconst addTokenCommand: CliCommandDefinition<AddTokenFlags> = {\n  name: 'add',\n  group: 'tokens',\n  signature: '[LABEL]',\n  helpText,\n  description: 'Create a new API token for this project',\n  action: async (args, context) => {\n    const {output} = context\n    const [label] = args.argsWithoutOptions\n    const {role, yes, y, json} = args.extOptions\n\n    const outputJson = json || false\n\n    try {\n      const token = await addToken(label, {role, unattended: Boolean(yes || y)}, context)\n\n      if (outputJson) {\n        output.print(JSON.stringify(token, null, 2))\n        return\n      }\n\n      output.print(`Token created successfully!`)\n      output.print(`Label: ${token.label}`)\n      output.print(`ID: ${token.id}`)\n      output.print(`Role: ${token.roles.map((r) => r.title).join(', ')}`)\n      output.print(`Token: ${token.key}`)\n      output.print('')\n      output.print('Copy the token above – this is your only chance to do so!')\n    } catch (err) {\n      throw new Error(`Token creation failed:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nexport default addTokenCommand\n","import {type CliCommandContext} from '@sanity/cli'\n\nimport {type Token} from '../../commands/tokens/types'\nimport {isInteractive} from '../../util/isInteractive'\n\ninterface DeleteTokenFlags {\n  unattended?: boolean\n}\n\nexport async function deleteToken(\n  specifiedToken: string,\n  flags: DeleteTokenFlags,\n  context: CliCommandContext,\n): Promise<boolean> {\n  const {apiClient} = context\n  const client = apiClient({requireUser: true, requireProject: true}).config({\n    apiVersion: '2021-06-07',\n  })\n\n  const tokenId = await promptForToken(specifiedToken, context, flags.unattended)\n\n  if (!(await confirmDeletion(tokenId, context, flags.unattended))) {\n    return false\n  }\n\n  const config = client.config()\n  try {\n    await client.request({\n      method: 'DELETE',\n      uri: `/projects/${config.projectId}/tokens/${tokenId}`,\n    })\n    return true\n  } catch (err) {\n    if (err.statusCode === 404) {\n      throw new Error(`Token with ID \"${tokenId}\" not found`, {cause: err})\n    }\n    throw err\n  }\n}\n\nasync function promptForToken(\n  specified: string | undefined,\n  context: CliCommandContext,\n  unattended?: boolean,\n): Promise<string> {\n  // If token ID is specified, just return it (validation happens during deletion)\n  if (specified) {\n    return specified\n  }\n\n  if (unattended || !isInteractive) {\n    throw new Error(\n      'Token ID is required in non-interactive mode. Provide a token ID as an argument.',\n    )\n  }\n\n  // Only fetch tokens for interactive selection when no ID provided\n  const {prompt, apiClient} = context\n  const client = apiClient({requireUser: true, requireProject: true}).config({\n    apiVersion: '2021-06-07',\n  })\n\n  const config = client.config()\n  const tokens = await client.request<Token[]>({url: `/projects/${config.projectId}/tokens`})\n\n  if (tokens.length === 0) {\n    throw new Error('No tokens found')\n  }\n\n  const choices = tokens.map((token) => ({\n    value: token.id,\n    name: `${token.label} (${(token.roles || []).map((r) => r.title).join(', ')})`,\n  }))\n\n  return prompt.single({\n    message: 'Select token to delete:',\n    type: 'list',\n    choices,\n  })\n}\n\nasync function confirmDeletion(\n  tokenId: string,\n  context: CliCommandContext,\n  unattended?: boolean,\n): Promise<boolean> {\n  if (unattended || !isInteractive) {\n    return true // Skip confirmation in unattended mode\n  }\n\n  const {prompt} = context\n\n  return prompt.single({\n    type: 'confirm',\n    message: `Are you sure you want to delete the token with ID \"${tokenId}\"?`,\n    default: false,\n  })\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\n\nimport {deleteToken} from '../../actions/tokens/deleteToken'\n\nconst helpText = `\nExamples\n  sanity tokens delete\n  sanity tokens delete silJ2lFmK6dONB\n  sanity tokens delete silJ2lFmK6dONB --yes\n\nOptions\n  -y, --yes     Skip confirmation prompt (unattended mode)\n\nNote: When specifying a token, you must use the token ID, not the label.\n`\n\nconst deleteTokenCommand: CliCommandDefinition = {\n  name: 'delete',\n  group: 'tokens',\n  signature: '[TOKEN_ID]',\n  helpText,\n  description: 'Delete an API token from this project',\n  action: async (args, context) => {\n    const {output} = context\n    const [token] = args.argsWithoutOptions\n    const {yes, y} = args.extOptions as {yes?: boolean; y?: boolean}\n\n    try {\n      const success = await deleteToken(token, {unattended: Boolean(yes || y)}, context)\n      if (success) {\n        output.print('Token deleted successfully')\n      }\n    } catch (err) {\n      throw new Error(`Token deletion failed:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nexport default deleteTokenCommand\n","import {type CliCommandDefinition} from '@sanity/cli'\nimport {Table} from 'console-table-printer'\n\nimport {type Token} from './types'\n\nconst helpText = `\nExamples\n  sanity tokens list\n  sanity tokens list --json\n\nOptions\n  --json            JSON output format\n`\n\ntype ListTokensFlags = {\n  json?: boolean\n}\n\nconst listTokensCommand: CliCommandDefinition<ListTokensFlags> = {\n  name: 'list',\n  group: 'tokens',\n  signature: '',\n  helpText,\n  description: 'List all API tokens for this project',\n  action: async (args, context) => {\n    const {output, apiClient} = context\n    const {json} = args.extOptions\n    const outputJson = json || false\n    const client = apiClient({requireUser: true, requireProject: true}).config({\n      apiVersion: '2021-06-07',\n    })\n\n    try {\n      const config = client.config()\n      const tokens = await client.request<Token[]>({url: `/projects/${config.projectId}/tokens`})\n\n      if (outputJson) {\n        output.print(JSON.stringify(tokens, null, 2))\n        return\n      }\n\n      if (tokens.length === 0) {\n        output.print('No tokens found')\n        return\n      }\n\n      const table = new Table({\n        title: `Found ${tokens.length} API tokens`,\n        columns: [\n          {name: 'label', title: 'Label', alignment: 'left', maxLen: 50},\n          {name: 'id', title: 'Token ID', alignment: 'left', maxLen: 20},\n          {name: 'roles', title: 'Roles', alignment: 'left', maxLen: 30},\n        ],\n      })\n\n      tokens.forEach((token) => {\n        const roles = token.roles?.map((role) => role.title).join(', ') || 'No roles'\n        const truncatedLabel =\n          token.label.length > 47 ? `${token.label.slice(0, 47)}...` : token.label\n        const truncatedRoles = roles.length > 27 ? `${roles.slice(0, 27)}...` : roles\n\n        table.addRow({\n          label: truncatedLabel,\n          id: token.id,\n          roles: truncatedRoles,\n        })\n      })\n\n      table.printTable()\n    } catch (err) {\n      throw new Error(`Failed to list tokens:\\n${err.message}`, {cause: err})\n    }\n  },\n}\n\nexport default listTokensCommand\n","import {type CliCommandGroupDefinition} from '@sanity/cli'\n\nconst tokensGroup: CliCommandGroupDefinition = {\n  name: 'tokens',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Manages API tokens for Sanity projects',\n}\n\nexport default tokensGroup\n","export function prettifyQuotaError(message: string) {\n  return (err: Error & {statusCode?: number}): Error & {statusCode?: number} => {\n    if (err.statusCode === 402) {\n      err.message = message\n      throw err\n    }\n\n    throw err\n  }\n}\n","import {type CliCommandDefinition, type CliPrompter} from '@sanity/cli'\n\nimport {prettifyQuotaError} from '../../util/prettifyQuotaError'\nimport {type Role} from './types'\n\nconst helpText = `\nOptions\n  --role Role to invite the user as\n\nExamples\n  # Invite a new user to the project (prompt for details)\n  sanity users invite\n\n  # Send a new user invite to the email \"pippi@sanity.io\", prompt for role\n  sanity users invite pippi@sanity.io\n\n  # Send a new user invite to the email \"pippi@sanity.io\", as administrator\n  sanity users invite pippi@sanity.io --role administrator\n`\n\ninterface InviteFlags {\n  role?: string\n}\n\nconst inviteUserCommand: CliCommandDefinition<InviteFlags> = {\n  name: 'invite',\n  group: 'users',\n  signature: '[EMAIL]',\n  helpText,\n  description: 'Invite a new user to the project',\n  action: async (args, context) => {\n    const {apiClient, output, prompt} = context\n    const [selectedEmail] = args.argsWithoutOptions\n    const flags = args.extOptions\n\n    const client = apiClient().clone().config({useProjectHostname: false, apiVersion: '2021-06-07'})\n    const {projectId} = client.config()\n    const roles = (await client.request<Role[]>({uri: `/projects/${projectId}/roles`})).filter(\n      (role) => role.appliesToUsers,\n    )\n    const email = selectedEmail || (await promptForEmail(prompt))\n    const selectedRole = flags.role || (await promptForRole(prompt, roles))\n    const role = roles.find(({name}) => name.toLowerCase() === selectedRole.toLowerCase())\n    if (!role) {\n      throw new Error(`Role name \"${selectedRole}\" not found`)\n    }\n\n    await client\n      .clone()\n      .request({\n        method: 'POST',\n        uri: `/invitations/project/${projectId}`,\n        body: {email, role: role.name},\n        useGlobalApi: true,\n        maxRedirects: 0,\n      })\n      .catch(\n        prettifyQuotaError(\n          'Project is already at user quota, add billing details to the project in order to allow overage charges.',\n        ),\n      )\n\n    output.print(`Invitation sent to ${email}`)\n  },\n}\n\nexport default inviteUserCommand\n\nfunction promptForEmail(prompt: CliPrompter): Promise<string> {\n  return prompt.single({\n    type: 'input',\n    message: 'Email to invite:',\n    filter: (val) => val.trim(),\n    validate: (name) => {\n      if (!name || !name.includes('@')) {\n        return 'Invalid email'\n      }\n\n      return true\n    },\n  })\n}\n\nfunction promptForRole(prompt: CliPrompter, roles: Role[]): Promise<string> {\n  return prompt.single({\n    type: 'list',\n    message: 'Which role should the user have?',\n    choices: roles.map((role) => ({\n      value: role.name,\n      name: `${role.title} (${role.description})`,\n    })),\n  })\n}\n","import {type CliCommandDefinition} from '@sanity/cli'\nimport {size, sortBy} from 'lodash-es'\n\nimport {type Invite, type PartialProjectResponse, type User} from './types'\n\nconst sortFields = ['id', 'name', 'role', 'date']\n\nconst helpText = `\nOptions\n  --no-invitations Don't include pending invitations\n  --no-robots Don't include robots (token users)\n  --sort <field> Sort users by specified column: ${sortFields.join(', ')}\n  --order <asc/desc> Sort output ascending/descending\n\nExamples\n  # List all users of the project\n  sanity users list\n\n  # List all users of the project, but exclude pending invitations and robots\n  sanity users list --no-invitations --no-robots\n\n  # List all users, sorted by role\n  sanity users list --sort role\n`\n\nconst listUsersCommand: CliCommandDefinition = {\n  name: 'list',\n  group: 'users',\n  signature: '',\n  helpText,\n  description: 'List all users of the project',\n  action: async (args, context) => {\n    const {apiClient, output, chalk} = context\n    const {sort, order, robots, invitations} = {\n      sort: 'date',\n      order: 'asc',\n      robots: true,\n      invitations: true,\n      ...args.extOptions,\n    }\n\n    if (!sortFields.includes(sort)) {\n      throw new Error(`Can't sort by field \"${sort}\". Must be one of ${sortFields.join(', ')}`)\n    }\n\n    if (order !== 'asc' && order !== 'desc') {\n      throw new Error(`Unknown sort order \"${order}\", must be either \"asc\" or \"desc\"`)\n    }\n\n    const client = apiClient()\n    const globalClient = client.clone().config({useProjectHostname: false})\n    const {projectId} = client.config()\n\n    const useGlobalApi = true\n    const [pendingInvitations, project] = await Promise.all([\n      invitations\n        ? globalClient\n            .request<Invite[]>({uri: `/invitations/project/${projectId}`, useGlobalApi})\n            .then(getPendingInvitations)\n        : [],\n      globalClient.request<PartialProjectResponse>({uri: `/projects/${projectId}`, useGlobalApi}),\n    ])\n\n    const memberIds = project.members.map((member) => member.id)\n    const users = await globalClient\n      .request<User | User[]>({uri: `/users/${memberIds.join(',')}`, useGlobalApi})\n      .then((user) => (Array.isArray(user) ? user : [user]))\n\n    const projectMembers = project.members\n      .map((member) => ({\n        ...member,\n        ...getUserProps(users.find((candidate) => candidate.id === member.id)),\n      }))\n      .filter((member) => !member.isRobot || robots)\n\n    const members = [...projectMembers, ...pendingInvitations]\n\n    const ordered = sortBy(\n      members.map(({id, name, role, date}) => [id, name, role, date]),\n      [sortFields.indexOf(sort)],\n    )\n\n    const rows = order === 'asc' ? ordered : ordered.reverse()\n\n    const maxWidths = rows.reduce(\n      (max, row) => row.map((current, index) => Math.max(size(current), max[index])),\n      sortFields.map((str) => size(str)),\n    )\n\n    const printRow = (row: string[]) => {\n      const isInvite = row[0] === '<pending>'\n      const textRow = row.map((col, i) => `${col}`.padEnd(maxWidths[i])).join('   ')\n      return isInvite ? chalk.dim(textRow) : textRow\n    }\n\n    output.print(chalk.cyan(printRow(sortFields)))\n    rows.forEach((row) => output.print(printRow(row)))\n  },\n}\n\nfunction getUserProps(user: User | undefined) {\n  const {displayName: name, createdAt: date} = user || {}\n  return {name: name || '', date: date || ''}\n}\n\nfunction getPendingInvitations(invitations: Invite[]) {\n  return invitations\n    .filter((invite) => !invite.isAccepted && !invite.isRevoked && !invite.acceptedByUserId)\n    .map((invite) => ({\n      id: '<pending>',\n      name: invite.email,\n      role: invite.role,\n      date: invite.createdAt,\n    }))\n}\n\nexport default listUsersCommand\n","import {type CliCommandGroupDefinition} from '@sanity/cli'\n\nexport const usersGroup: CliCommandGroupDefinition = {\n  name: 'users',\n  signature: '[COMMAND]',\n  isGroupRoot: true,\n  description: 'Manages users of your Sanity project',\n}\n\nexport default usersGroup\n","import {type CliCommandDefinition, type CliCommandGroupDefinition} from '@sanity/cli'\n\nimport backupGroup from './backup/backupGroup'\nimport disableBackupCommand from './backup/disableBackupCommand'\nimport downloadBackupCommand from './backup/downloadBackupCommand'\nimport enableBackupCommand from './backup/enableBackupCommand'\nimport listBackupCommand from './backup/listBackupCommand'\nimport buildCommand from './build/buildCommand'\nimport addCorsOriginCommand from './cors/addCorsOriginCommand'\nimport corsGroup from './cors/corsGroup'\nimport deleteCorsOriginCommand from './cors/deleteCorsOriginCommand'\nimport listCorsOriginsCommand from './cors/listCorsOriginsCommand'\nimport aliasDatasetCommand from './dataset/alias/aliasCommands'\nimport copyDatasetCommand from './dataset/copyDatasetCommand'\nimport createDatasetCommand from './dataset/createDatasetCommand'\nimport datasetGroup from './dataset/datasetGroup'\nimport datasetVisibilityCommand from './dataset/datasetVisibilityCommand'\nimport deleteDatasetCommand from './dataset/deleteDatasetCommand'\nimport exportDatasetCommand from './dataset/exportDatasetCommand'\nimport importDatasetCommand from './dataset/importDatasetCommand'\nimport listDatasetsCommand from './dataset/listDatasetsCommand'\nimport deployCommand from './deploy/deployCommand'\nimport undeployCommand from './deploy/undeployCommand'\nimport devCommand from './dev/devCommand'\nimport createDocumentsCommand from './documents/createDocumentsCommand'\nimport deleteDocumentsCommand from './documents/deleteDocumentsCommand'\nimport documentsGroup from './documents/documentsGroup'\nimport getDocumentsCommand from './documents/getDocumentsCommand'\nimport queryDocumentsCommand from './documents/queryDocumentsCommand'\nimport validateDocumentsCommand from './documents/validateDocumentsCommand'\nimport execCommand from './exec/execCommand'\nimport deleteGraphQLAPICommand from './graphql/deleteGraphQLAPICommand'\nimport deployGraphQLAPICommand from './graphql/deployGraphQLAPICommand'\nimport graphqlGroup from './graphql/graphqlGroup'\nimport listGraphQLAPIsCommand from './graphql/listGraphQLAPIsCommand'\nimport createHookCommand from './hook/createHookCommand'\nimport deleteHookCommand from './hook/deleteHookCommand'\nimport hookGroup from './hook/hookGroup'\nimport listHookLogsCommand from './hook/listHookLogsCommand'\nimport listHooksCommand from './hook/listHooksCommand'\nimport printHookAttemptCommand from './hook/printHookAttemptCommand'\nimport extractManifestCommand from './manifest/extractManifestCommand'\nimport manifestGroup from './manifest/manifestGroup'\nimport createAspectCommand from './media/createAspectCommand'\nimport deleteAspectCommand from './media/deleteAspectCommand'\nimport deployAspectCommand from './media/deployAspectCommand'\nimport exportMediaCommand from './media/exportMediaCommand'\nimport importMediaCommand from './media/importMediaCommand'\nimport mediaGroup from './media/mediaGroup'\nimport createMigrationCommand from './migration/createMigrationCommand'\nimport listMigrationsCommand from './migration/listMigrationsCommand'\nimport migrationGroup from './migration/migrationGroup'\nimport runMigrationCommand from './migration/runMigrationCommand'\nimport previewCommand from './preview/previewCommand'\nimport deleteSchemaCommand from './schema/deleteSchemaCommand'\nimport deploySchemaCommand from './schema/deploySchemaCommand'\nimport extractSchemaCommand from './schema/extractSchemaCommand'\nimport schemaGroup from './schema/schemaGroup'\nimport fetchSchemaCommand from './schema/schemaListCommand'\nimport validateSchemaCommand from './schema/validateSchemaCommand'\nimport startCommand from './start/startCommand'\nimport addTokenCommand from './tokens/addTokenCommand'\nimport deleteTokenCommand from './tokens/deleteTokenCommand'\nimport listTokensCommand from './tokens/listTokensCommand'\nimport tokensGroup from './tokens/tokensGroup'\nimport inviteUserCommand from './users/inviteUserCommand'\nimport listUsersCommand from './users/listUsersCommand'\nimport usersGroup from './users/usersGroup'\n\nconst commands: (CliCommandDefinition | CliCommandGroupDefinition)[] = [\n  buildCommand,\n  datasetGroup,\n  deployCommand,\n  undeployCommand,\n  listDatasetsCommand,\n  createDatasetCommand,\n  datasetVisibilityCommand,\n  exportDatasetCommand,\n  importDatasetCommand,\n  deleteDatasetCommand,\n  copyDatasetCommand,\n  aliasDatasetCommand,\n  backupGroup,\n  listBackupCommand,\n  downloadBackupCommand,\n  disableBackupCommand,\n  enableBackupCommand,\n  corsGroup,\n  listCorsOriginsCommand,\n  addCorsOriginCommand,\n  deleteCorsOriginCommand,\n  tokensGroup,\n  listTokensCommand,\n  addTokenCommand,\n  deleteTokenCommand,\n  usersGroup,\n  inviteUserCommand,\n  listUsersCommand,\n  hookGroup,\n  listHooksCommand,\n  createHookCommand,\n  migrationGroup,\n  createMigrationCommand,\n  runMigrationCommand,\n  listMigrationsCommand,\n  deleteHookCommand,\n  listHookLogsCommand,\n  printHookAttemptCommand,\n  documentsGroup,\n  getDocumentsCommand,\n  queryDocumentsCommand,\n  deleteDocumentsCommand,\n  createDocumentsCommand,\n  validateDocumentsCommand,\n  graphqlGroup,\n  listGraphQLAPIsCommand,\n  deployGraphQLAPICommand,\n  deleteGraphQLAPICommand,\n  devCommand,\n  startCommand,\n  schemaGroup,\n  validateSchemaCommand,\n  extractSchemaCommand,\n  previewCommand,\n  execCommand,\n  manifestGroup,\n  extractManifestCommand,\n  mediaGroup,\n  exportMediaCommand,\n  importMediaCommand,\n  createAspectCommand,\n  deleteAspectCommand,\n  deployAspectCommand,\n  fetchSchemaCommand,\n  deploySchemaCommand,\n  deleteSchemaCommand,\n]\n\n/**\n * @deprecated Not actually deprecated, but these are internals and should not be relied upon outside of the Sanity team\n * @internal\n */\nexport const cliProjectCommands = {\n  requiredCliVersionRange: '^3.0.0',\n  commands,\n}\n"],"names":["defaultApiVersion","datasetBackupGroup","name","signature","description","isGroupRoot","parseApiErr","err","apiErr","code","statusCode","message","statusMessage","response","body","data","JSON","stringify","debug","debugIt","validateDatasetName","datasetName","toLowerCase","length","MAX_DATASET_NAME_LENGTH","test","promptForDatasetName","prompt","options","single","type","validate","chooseDatasetPrompt","context","apiClient","allowCreation","client","datasets","list","hasProduction","find","dataset","datasetChoices","map","value","selected","choices","Separator","newDatasetName","default","undefined","create","resolveApiClient","apiVersion","projectId","token","config","Error","selectedDataset","withConfig","helpText","disableDatasetBackupCommand","group","action","args","output","chalk","argsWithoutOptions","request","method","headers","Authorization","uri","enabled","print","green","error","red","archiveDir","tmpOutDir","outFilePath","progressCb","Promise","resolve","reject","archiveDestination","createWriteStream","on","archive","archiver","gzip","gzipOptions","level","zlib","constants","Z_DEFAULT_COMPRESSION","stack","progress","fs","processedBytes","pipe","directory","finalize","maxBackupIdsShown","chooseBackupIdPrompt","query","limit","toString","backups","backupIdChoices","backup","id","cause","cleanupTmpDir","tmpDir","rimraf","MAX_RETRIES","BACKOFF_DELAY_BASE","exponentialBackoff","retryCount","Math","pow","withRetry","operation","maxRetries","retryDelay","setTimeout","CONNECTION_TIMEOUT","READ_TIMEOUT","getIt","keepAlive","promise","downloadAsset","url","fileName","fileType","outDir","normalizedFileName","path","basename","assetFilePath","getAssetFilePath","maxRedirects","timeout","connect","socket","stream","pipeline","join","downloadDocument","PaginatedGetBackupStream","Readable","cursor","totalFiles","constructor","backupId","objectMode","_read","fetchNextBackupPage","files","forEach","file","push","nextCursor","destroy","msg","String","newProgress","startStep","spinner","start","lastProgress","step","Date","now","elapsed","prettyMs","current","total","text","set","succeed","update","fail","humanFileSize","size","i","floor","log","toFixed","isPathDirName","filepath","createDebug","DEFAULT_DOWNLOAD_CONCURRENCY","MAX_DOWNLOAD_CONCURRENCY","parseCliFlags","yargs","hideBin","argv","process","slice","downloadBackupCommand","opts","prepareBackupOptions","outFileName","bold","cyan","padEnd","progressSpinner","mkdtemp","tmpdir","dir","mkdirSync","recursive","tmpOutDocumentsFile","docOutStream","docWriteMutex","Mutex","backupFileStream","totalItemsDownloaded","pMap","doc","runExclusive","write","concurrency","end","finished","flags","workDir","isString","defaultOutFileName","out","absolutify","filter","overwrite","existsSync","dirname","enableDatasetBackupCommand","DEFAULT_LIST_BACKUP_LIMIT","alias","listDatasetBackupCommand","Number","MAX_SAFE_INTEGER","before","after","parsedBefore","processDateFlags","parsedAfter","isAfter","table","Table","columns","title","alignment","createdAt","addRow","resource","lightFormat","parse","printTable","date","parsedDate","isValid","determineIsApp","cliConfig","Boolean","createRequire","import","buildCommand","overrides","getBuildAction","wildcardReplacement","portReplacement","addCorsOrigin","givenOrigin","origin","filterAndValidateOrigin","promptForOrigin","hasWildcard","includes","promptForWildcardConfirmation","allowCredentials","credentials","promptForCredentials","requireUser","requireProject","oneline","yellow","logSymbols","warning","underline","replace","filterOrigin","validateOrigin","example","parsed","host","protocol","RegExp","startsWith","result","addCorsOriginCommand","extOptions","cwd","warn","corsGroup","deleteCorsOriginCommand","originId","specified","specifiedOrigin","origins","listCorsOriginsCommand","validateDatasetAliasName","promptForDatasetAliasName","ALIAS_PREFIX","listAliases","createAlias","aliasName","modify","updateAlias","unlinkAlias","removeAlias","createAliasHandler","targetDataset","nameError","aliases","projectFeatures","all","then","sets","ds","aliasClient","aliasOutputName","datasetErr","option","deleteAliasHandler","force","dsError","fetchedAliases","linkedAlias","elem","input","trim","linkAliasHandler","da","unlinkAliasHandler","aliasCommand","verb","listDatasetCopyJobs","offset","job","state","updatedAt","sourceDataset","withHistory","timeStarted","formatDistanceToNow","parseISO","timeTaken","formatDistance","color","getClientUrl","useCdn","cdnUrl","Observable","observer","progressSource","EventSource","stopped","onError","close","next","onChannelError","onMessage","event","onComplete","removeEventListener","complete","addEventListener","followProgress","jobId","currentProgress","listenUrl","subscribe","copyDatasetCommand","attach","shouldSkipHistory","existingDatasets","sourceDatasetName","targetDatasetName","skipHistory","detach","allowedModes","createDatasetCommand","visibility","canCreatePrivate","aclMode","promptForDatasetVisibility","mode","datasetVisibilityCommand","edit","curr","deleteDatasetCommand","delete","noop","parseFlags","rawFlags","types","split","assetConcurrency","parseInt","raw","assets","drafts","compress","exportDatasetCommand","targetDestination","destinationPath","outputPath","getOutputPath","currentStep","onProgress","exportDataset","stdout","destination","dstPath","isAbsolute","dstStats","stat","catch","looksLikeFile","isFile","indexOf","createPath","mkdir","finalPath","str","toBoolIfSet","flag","allowAssetsInDifferentDataset","allowFailingAssets","replaceAssets","skipCrossDatasetReferences","allowSystemDocuments","missing","MINIMUM_API_VERSION","importDatasetCommand","fromInitCommand","getMutationOperation","releasesOperation","getReleasesOperation","target","determineTargetDataset","isUrl","inputStream","assetsBase","sourceIsFolder","getUrlStream","sourceFile","fileStats","isDirectory","createReadStream","importClient","clone","stepStart","spinInterval","percent","lengthComputable","sameStep","getPercentage","clearInterval","prevStep","prevStepStart","timeSpent","secondsDecimalDigits","setInterval","endTask","success","numDocs","warnings","sanityImport","printWarnings","details","responseBody","padStart","onlyBody","assetFails","bind","listAliasesHandler","listDatasetsCommand","deployCommand","mod","undeployCommand","devCommand","getDevAction","createDocumentsCommand","watch","useJson5","json5","contentPath","content","readFile","writeDocuments","getResultMessage","docId","uuid","ext","tmpFile","os","defaultValue","getDocument","_id","_type","writeFile","editor","getEditor","registerUnlinkOnSigInt","chokidar","readAndPerformCreatesFromFile","execa","bin","concat","stdio","sync","unlink","filePath","isEqual","writeResult","exit","documents","docs","Array","isArray","mutations","index","validateDocument","isIdentifiedSanityDocument","createIfNotExists","createOrReplace","transaction","commit","arr","isSingle","isPlainObject","getErrorMessage","isSanityDocumentish","joiner","results","res","created","skipped","defaultEditor","platform","env","VISUAL","EDITOR","shift","deleteDocumentsCommand","ids","reduce","trx","deleted","notFound","pluralize","documentsGroup","identity","inp","colorizeJson","formatters","punctuator","white","key","string","number","literal","whitespace","json","tokenize","prevToken","getDocumentsCommand","pretty","project","anonymous","requireDataset","api","baseClient","originalDataset","originalProjectId","fetch","fallbackApiVersion","SANITY_CLI_QUERY_API_VERSION","validateDocumentsCommand","execCommand","deleteGraphQLAPICommand","deployGraphQLAPICommand","graphqlGroup","listGraphQLAPIsCommand","createHookCommand","manageUrl","projects","getById","organizationId","open","deleteHookCommand","hookId","promptForHook","specifiedName","hooks","hook","hookGroup","printHookAttemptCommand","attemptId","attempt","resultCode","resultBody","failureReason","inProgress","getStatus","isFailure","formatFailure","includeHelp","help","listHookLogsCommand","messages","attempts","groupedAttempts","groupBy","populated","totalMessages","printMessage","detailed","printSeparator","skip","status","failureCount","inspect","payload","colors","prefix","failure","duration","listHooksCommand","httpMethod","extractManifestCommand","extractManifestSafe","extractError","createAspectCommand","deleteAspectCommand","deployAspectCommand","exportMediaCommand","importMediaCommand","mediaGroup","MIGRATIONS_DIRECTORY","MIGRATION_SCRIPT_EXTENSIONS","DEFAULT_API_VERSION","minimalAdvanced","migrationName","documentTypes","t","minimalSimple","renameField","renameType","stringToPTE","TEMPLATES","template","createMigrationCommand","suffix","templatesByName","Object","fromEntries","definedTemplate","sluggedName","deburr","destDir","renderedTemplate","definitionFile","require","resolveMigrationScript","flatMap","location","relativePath","absolutePath","isLoadableMigrationScript","script","migrate","listMigrationCommand","_","migrations","resolveMigrations","definedMigration","migration","unregister","register","version","supported","format","migrationsDir","migrationEntries","readdir","withFileTypes","entry","entryName","removeMigrationScriptExtension","candidates","candidate","endsWith","pathToString","segment","isIndexSegment","isKeySegment","_key","isIndexTuple","from","to","maxKeyLength","children","depth","entries","child","max","formatTree","node","paddingLength","indent","getNodes","getLeaves","nodes","getMessage","isLast","nextIndent","leaves","nested","first","rest","firstPadding","repeat","elbow","subsequentPadding","firstMessage","subsequentMessages","marker","convertToTree","root","addNode","tree","isTty","isatty","prettyFormat","subject","indentSize","subjectEntry","badge","prettyFormatMutation","encodeItemRef","ref","badgeStyle","variant","info","bgWhite","black","incremental","bgGreen","maybeDestructive","bgYellow","destructive","bgRed","label","mutationImpact","patch","documentId","mutation","document","listFormatter","Intl","ListFormat","mutationHeader","mutationType","documentType","lock","ifRevision","header","padding","patches","flat","formatPatchMutation","op","formattedType","amount","position","referenceItem","items","startIndex","endIndex","line","VERSION_PATTERN","ensureApiVersionFormat","normalizedVersion","MAX_MUTATION_CONCURRENCY","DEFAULT_MUTATION_CONCURRENCY","runMigrationCommand","migrationsDirectoryPath","fromExport","dry","dryRun","resolvedScripts","relative","projectConfig","apiConfig","apiHost","dryRunHandler","confirm","run","createProgress","stop","done","completedTransactions","stopAndPersist","symbol","currentTransactions","blue","pending","exportPath","previewCommand","getPreviewAction","deleteSchemaCommand","deploySchemaCommand","extractSchemaCommand","fetchSchemaCommand","isInteractive","isTTY","TERM","startCommand","previewAction","bgBlack","addToken","givenLabel","promptForLabel","unattended","roleName","role","validateRole","promptForRole","robotRoles","appliesToRobots","short","r","availableRoles","addTokenCommand","yes","y","outputJson","roles","deleteToken","specifiedToken","tokenId","promptForToken","confirmDeletion","tokens","deleteTokenCommand","listTokensCommand","maxLen","truncatedLabel","truncatedRoles","tokensGroup","prettifyQuotaError","inviteUserCommand","selectedEmail","useProjectHostname","appliesToUsers","email","promptForEmail","selectedRole","useGlobalApi","val","sortFields","listUsersCommand","sort","order","robots","invitations","globalClient","pendingInvitations","getPendingInvitations","memberIds","members","member","users","user","getUserProps","isRobot","ordered","sortBy","rows","reverse","maxWidths","row","printRow","isInvite","textRow","col","dim","displayName","invite","isAccepted","isRevoked","acceptedByUserId","usersGroup","commands","datasetGroup","aliasDatasetCommand","backupGroup","listBackupCommand","disableBackupCommand","enableBackupCommand","migrationGroup","listMigrationsCommand","queryDocumentsCommand","schemaGroup","validateSchemaCommand","manifestGroup","cliProjectCommands","requiredCliVersionRange"],"mappings":"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"}