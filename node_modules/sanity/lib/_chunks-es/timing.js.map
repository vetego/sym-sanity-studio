{"version":3,"file":"timing.js","sources":["../../src/_internal/cli/util/readPackageManifest.ts","../../src/_internal/cli/util/readModuleVersion.ts","../../src/_internal/cli/util/timing.ts"],"sourcesContent":["import {readFile} from 'node:fs/promises'\n\nimport {type PackageJson} from '@sanity/cli'\n\ninterface DependencyDeclarations {\n  dependencies: Record<string, string | undefined>\n  devDependencies: Record<string, string | undefined>\n}\n\ninterface PackageManifest extends DependencyDeclarations {\n  name: string\n  version: string\n}\n\nexport interface PartialPackageManifest extends Partial<DependencyDeclarations> {\n  name: string\n  version: string\n}\n\nfunction isPackageManifest(item: unknown): item is PartialPackageManifest {\n  return typeof item === 'object' && item !== null && 'name' in item && 'version' in item\n}\n\n/**\n * Read the `package.json` file at the given path\n *\n * @param filePath - Path to package.json to read\n * @returns The parsed package.json\n */\nexport async function readPackageJson(filePath: string): Promise<PackageJson> {\n  try {\n    return JSON.parse(await readFile(filePath, 'utf8'))\n  } catch (err) {\n    throw new Error(`Failed to read \"${filePath}\": ${err.message}`, {cause: err})\n  }\n}\n/**\n * Read the `package.json` file at the given path and return an object that guarantees\n * the presence of name, version, dependencies, dev dependencies and peer dependencies\n *\n * @param packageJsonPath - Path to package.json to read\n * @returns Reduced package.json with guarantees for name, version and dependency fields\n */\nexport async function readPackageManifest(\n  packageJsonPath: string,\n  defaults: Partial<PartialPackageManifest> = {},\n): Promise<PackageManifest> {\n  let manifest: unknown\n  try {\n    manifest = {...defaults, ...(await readPackageJson(packageJsonPath))}\n  } catch (err) {\n    throw new Error(`Failed to read \"${packageJsonPath}\": ${err.message}`, {cause: err})\n  }\n\n  if (!isPackageManifest(manifest)) {\n    throw new Error(`Failed to read \"${packageJsonPath}\": Invalid package manifest`)\n  }\n\n  const {name, version, dependencies = {}, devDependencies = {}} = manifest\n  return {name, version, dependencies, devDependencies}\n}\n","import path from 'node:path'\n\nimport resolveFrom from 'resolve-from'\n\nimport {readPackageManifest} from './readPackageManifest'\n\n/**\n * Reads the version number of the _installed_ module, or returns `null` if not found\n *\n * @param dir - Path of the directory to read the module from\n * @param moduleName - Name of module to get installed version for\n * @returns Version number, of null\n */\nexport async function readModuleVersion(dir: string, moduleName: string): Promise<string | null> {\n  const manifestPath = resolveFrom.silent(dir, path.join(moduleName, 'package.json'))\n  return manifestPath ? (await readPackageManifest(manifestPath)).version : null\n}\n","import {performance} from 'node:perf_hooks'\n\nexport interface TimeMeasurer {\n  start: (name: string) => void\n  end: (name: string) => number\n  getTimings: () => Record<string, number>\n}\n\nexport function getTimer(): TimeMeasurer {\n  const timings: Record<string, number> = {}\n  const startTimes: Record<string, number> = {}\n\n  function start(name: string): void {\n    if (typeof startTimes[name] !== 'undefined') {\n      throw new Error(`Timer \"${name}\" already started, cannot overwrite`)\n    }\n\n    startTimes[name] = performance.now()\n  }\n\n  function end(name: string): number {\n    if (typeof startTimes[name] === 'undefined') {\n      throw new Error(`Timer \"${name}\" never started, cannot end`)\n    }\n\n    timings[name] = performance.now() - startTimes[name]\n    return timings[name]\n  }\n\n  return {start, end, getTimings: () => timings}\n}\n"],"names":["isPackageManifest","item","readPackageJson","filePath","JSON","parse","readFile","err","Error","message","cause","readPackageManifest","packageJsonPath","defaults","manifest","name","version","dependencies","devDependencies","readModuleVersion","dir","moduleName","manifestPath","resolveFrom","silent","path","join","getTimer","timings","startTimes","start","performance","now","end","getTimings"],"mappings":";;;;AAmBA,SAASA,kBAAkBC,MAA+C;AACxE,SAAO,OAAOA,QAAS,YAAYA,SAAS,QAAQ,UAAUA,QAAQ,aAAaA;AACrF;AAQA,eAAsBC,gBAAgBC,UAAwC;AAC5E,MAAI;AACF,WAAOC,KAAKC,MAAM,MAAMC,SAASH,UAAU,MAAM,CAAC;AAAA,EACpD,SAASI,KAAK;AACZ,UAAM,IAAIC,MAAM,mBAAmBL,QAAQ,MAAMI,IAAIE,OAAO,IAAI;AAAA,MAACC,OAAOH;AAAAA,IAAAA,CAAI;AAAA,EAC9E;AACF;AAQA,eAAsBI,oBACpBC,iBACAC,WAA4C,IAClB;AAC1B,MAAIC;AACJ,MAAI;AACFA,eAAW;AAAA,MAAC,GAAGD;AAAAA,MAAU,GAAI,MAAMX,gBAAgBU,eAAe;AAAA,IAAA;AAAA,EACpE,SAASL,KAAK;AACZ,UAAM,IAAIC,MAAM,mBAAmBI,eAAe,MAAML,IAAIE,OAAO,IAAI;AAAA,MAACC,OAAOH;AAAAA,IAAAA,CAAI;AAAA,EACrF;AAEA,MAAI,CAACP,kBAAkBc,QAAQ;AAC7B,UAAM,IAAIN,MAAM,mBAAmBI,eAAe,6BAA6B;AAGjF,QAAM;AAAA,IAACG;AAAAA,IAAMC;AAAAA,IAASC,eAAe,CAAA;AAAA,IAAIC,kBAAkB,CAAA;AAAA,EAAC,IAAKJ;AACjE,SAAO;AAAA,IAACC;AAAAA,IAAMC;AAAAA,IAASC;AAAAA,IAAcC;AAAAA,EAAAA;AACvC;AC/CA,eAAsBC,kBAAkBC,KAAaC,YAA4C;AAC/F,QAAMC,eAAeC,YAAYC,OAAOJ,KAAKK,KAAKC,KAAKL,YAAY,cAAc,CAAC;AAClF,SAAOC,gBAAgB,MAAMX,oBAAoBW,YAAY,GAAGN,UAAU;AAC5E;ACRO,SAASW,WAAyB;AACvC,QAAMC,UAAkC,IAClCC,aAAqC,CAAA;AAE3C,WAASC,MAAMf,MAAoB;AACjC,QAAI,OAAOc,WAAWd,IAAI,IAAM;AAC9B,YAAM,IAAIP,MAAM,UAAUO,IAAI,qCAAqC;AAGrEc,eAAWd,IAAI,IAAIgB,YAAYC,IAAAA;AAAAA,EACjC;AAEA,WAASC,IAAIlB,MAAsB;AACjC,QAAI,OAAOc,WAAWd,IAAI,IAAM;AAC9B,YAAM,IAAIP,MAAM,UAAUO,IAAI,6BAA6B;AAG7Da,WAAAA,QAAQb,IAAI,IAAIgB,YAAYC,QAAQH,WAAWd,IAAI,GAC5Ca,QAAQb,IAAI;AAAA,EACrB;AAEA,SAAO;AAAA,IAACe;AAAAA,IAAOG;AAAAA,IAAKC,YAAYA,MAAMN;AAAAA,EAAAA;AACxC;"}