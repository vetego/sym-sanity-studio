{"version":3,"file":"validateSchema.cjs","sources":["../../../../src/_internal/cli/threads/validateSchema.ts"],"sourcesContent":["import {isMainThread, parentPort, workerData as _workerData} from 'node:worker_threads'\n\nimport {\n  type EncodableObject,\n  type EncodableValue,\n  type SetSynchronization,\n} from '@sanity/descriptors'\nimport {DescriptorConverter} from '@sanity/schema/_internal'\nimport {type SchemaValidationProblem, type SchemaValidationProblemGroup} from '@sanity/types'\n\nimport {getStudioWorkspaces} from '../util/getStudioWorkspaces'\nimport {mockBrowserEnvironment} from '../util/mockBrowserEnvironment'\n\n/** @internal */\nexport interface ValidateSchemaWorkerData {\n  workDir: string\n  workspace?: string\n  level?: SchemaValidationProblem['severity']\n  debugSerialize?: boolean\n}\n\n/** @internal */\nexport interface ValidateSchemaWorkerResult {\n  validation: SchemaValidationProblemGroup[]\n  serializedDebug?: SeralizedSchemaDebug\n}\n\n/**\n * Contains debug information about the serialized schema.\n *\n * @internal\n **/\nexport type SeralizedSchemaDebug = {\n  size: number\n  parent?: SeralizedSchemaDebug\n  types: Record<string, SerializedTypeDebug>\n  hoisted: Record<string, SerializedTypeDebug>\n}\n\n/**\n * Contains debug information about a serialized type.\n *\n * @internal\n **/\nexport type SerializedTypeDebug = {\n  size: number\n  extends: string\n  fields?: Record<string, SerializedTypeDebug>\n  of?: Record<string, SerializedTypeDebug>\n}\n\nconst {\n  workDir,\n  workspace: workspaceName,\n  level = 'warning',\n  debugSerialize,\n} = _workerData as ValidateSchemaWorkerData\n\nasync function main() {\n  if (isMainThread || !parentPort) {\n    throw new Error('This module must be run as a worker thread')\n  }\n\n  const cleanup = mockBrowserEnvironment(workDir)\n\n  try {\n    const workspaces = await getStudioWorkspaces({basePath: workDir})\n\n    if (!workspaces.length) {\n      throw new Error(`Configuration did not return any workspaces.`)\n    }\n\n    let workspace\n    if (workspaceName) {\n      workspace = workspaces.find((w) => w.name === workspaceName)\n      if (!workspace) {\n        throw new Error(`Could not find any workspaces with name \\`${workspaceName}\\``)\n      }\n    } else {\n      if (workspaces.length !== 1) {\n        throw new Error(\n          \"Multiple workspaces found. Please specify which workspace to use with '--workspace'.\",\n        )\n      }\n      workspace = workspaces[0]\n    }\n\n    const schema = workspace.schema\n    const validation = schema._validation!\n\n    let serializedDebug: ValidateSchemaWorkerResult['serializedDebug']\n\n    if (debugSerialize) {\n      const conv = new DescriptorConverter()\n      const set = await conv.get(schema)\n      serializedDebug = getSeralizedSchemaDebug(set)\n    }\n\n    const result: ValidateSchemaWorkerResult = {\n      validation: validation\n        .map((group) => ({\n          ...group,\n          problems: group.problems.filter((problem) =>\n            level === 'error' ? problem.severity === 'error' : true,\n          ),\n        }))\n        .filter((group) => group.problems.length),\n      serializedDebug,\n    }\n\n    parentPort?.postMessage(result)\n  } catch (err) {\n    console.error(err)\n    console.error(err.stack)\n    throw err\n  } finally {\n    cleanup()\n  }\n}\n\nfunction getSeralizedSchemaDebug(set: SetSynchronization<string>): SeralizedSchemaDebug {\n  let size = 0\n  const types: Record<string, SerializedTypeDebug> = {}\n  const hoisted: Record<string, SerializedTypeDebug> = {}\n\n  for (const [id, value] of Object.entries(set.objectValues)) {\n    const descType = typeof value.type === 'string' ? value.type : '<unknown>'\n    switch (descType) {\n      case 'sanity.schema.namedType': {\n        const typeName = typeof value.name === 'string' ? value.name : id\n        if (isEncodableObject(value.typeDef)) {\n          const debug = getSerializedTypeDebug(value.typeDef)\n          types[typeName] = debug\n          size += debug.size\n        }\n        break\n      }\n      case 'sanity.schema.hoisted': {\n        const key = typeof value.key === 'string' ? value.key : id\n        // The `hoisted` can technically  hoist _anything_,\n        // but we detect the common case of field + array element.\n        if (isEncodableObject(value.value) && isEncodableObject(value.value.typeDef)) {\n          const debug = getSerializedTypeDebug(value.value.typeDef)\n          hoisted[key] = debug\n          size += debug.size\n        }\n        break\n      }\n      default:\n    }\n    size += JSON.stringify(value).length\n  }\n\n  return {\n    size,\n    types,\n    hoisted,\n  }\n}\n\nfunction isEncodableObject(val: EncodableValue | undefined): val is EncodableObject {\n  return typeof val === 'object' && val !== null && !Array.isArray(val)\n}\n\nfunction getSerializedTypeDebug(typeDef: EncodableObject): SerializedTypeDebug {\n  const ext = typeof typeDef.extends === 'string' ? typeDef.extends : '<unknown>'\n  let fields: SerializedTypeDebug['fields']\n  let of: SerializedTypeDebug['of']\n\n  if (Array.isArray(typeDef.fields)) {\n    fields = {}\n\n    for (const field of typeDef.fields) {\n      if (!isEncodableObject(field)) continue\n      const name = field.name\n      const fieldTypeDef = field.typeDef\n      if (typeof name !== 'string' || !isEncodableObject(fieldTypeDef)) continue\n\n      fields[name] = getSerializedTypeDebug(fieldTypeDef)\n    }\n  }\n\n  if (Array.isArray(typeDef.of)) {\n    of = {}\n\n    for (const field of typeDef.of) {\n      if (!isEncodableObject(field)) continue\n      const name = field.name\n      const arrayTypeDef = field.typeDef\n      if (typeof name !== 'string' || !isEncodableObject(arrayTypeDef)) continue\n\n      of[name] = getSerializedTypeDebug(arrayTypeDef)\n    }\n  }\n\n  return {\n    size: JSON.stringify(typeDef).length,\n    extends: ext,\n    fields,\n    of,\n  }\n}\n\nvoid main().then(() => process.exit())\n"],"names":["workDir","workspace","workspaceName","level","debugSerialize","_workerData","main","isMainThread","parentPort","Error","cleanup","mockBrowserEnvironment","workspaces","getStudioWorkspaces","basePath","length","find","w","name","schema","validation","_validation","serializedDebug","set","DescriptorConverter","get","getSeralizedSchemaDebug","result","map","group","problems","filter","problem","severity","postMessage","err","console","error","stack","size","types","hoisted","id","value","Object","entries","objectValues","type","typeName","isEncodableObject","typeDef","debug","getSerializedTypeDebug","key","JSON","stringify","val","Array","isArray","ext","extends","fields","of","field","fieldTypeDef","arrayTypeDef","then","process","exit"],"mappings":"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"}