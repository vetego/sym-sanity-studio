import {ActorRefFrom} from 'xstate'
import {ActorRefFromLogic} from 'xstate'
import {ArraySchemaType} from '@sanity/types'
import {AssetMetadataType} from '@sanity/types'
import {AssetSource} from '@sanity/types'
import {AssetSourceSpec} from '@sanity/types'
import {BehaviorSubject} from 'rxjs'
import {BifurClient} from '@sanity/bifur-client'
import {BooleanSchemaType} from '@sanity/types'
import {BrowserHistory} from 'history'
import {ButtonTone} from '@sanity/ui'
import {ClientConfig} from '@sanity/client'
import {ClientPerspective} from '@sanity/client'
import {ColorHueKey} from '@sanity/color'
import {ColorTints} from '@sanity/color'
import {ComponentType} from 'react'
import {Context} from 'react'
import {CrossDatasetReferenceValue} from '@sanity/types'
import {CrossDatasetType} from '@sanity/types'
import {CSSProperties} from 'react'
import {CurrentUser} from '@sanity/types'
import {DialogProps} from '@sanity/ui'
import {Diff} from '@sanity/diff'
import {Dispatch} from 'react'
import {EditorChange} from '@portabletext/editor'
import {EditorSelection} from '@portabletext/editor'
import {ErrorInfo} from 'react'
import {EventObject} from 'xstate'
import {FileValue} from '@sanity/types'
import {FocusEvent as FocusEvent_2} from 'react'
import {FocusEventHandler} from 'react'
import {FormEventHandler} from 'react'
import {FormNodeValidation} from '@sanity/types'
import {GeopointValue} from '@sanity/types'
import {HashHistory} from 'history'
import {History as History_2} from 'history'
import {HotkeyOptions} from '@portabletext/editor'
import {HTMLProps} from 'react'
import {i18n} from 'i18next'
import {I18nTextRecord} from '@sanity/types'
import {ImageUrlFitMode} from '@sanity/types'
import {ImageValue} from '@sanity/types'
import {InitialValueProperty} from '@sanity/types'
import {InitialValueResolverContext} from '@sanity/types'
import {IntentParameters} from 'sanity/router'
import {IntrinsicTypeName} from '@sanity/types'
import {JSX} from 'react'
import {KeyedObject} from '@sanity/types'
import {KeyedSegment} from '@sanity/types'
import {MarkdownShortcutsPluginProps} from '@portabletext/plugin-markdown-shortcuts'
import {MemoryHistory} from 'history'
import {MendozaEffectPair} from '@sanity/types'
import {MetaObject} from 'xstate'
import {MutableRefObject} from 'react'
import {NonReducibleUnknown} from 'xstate'
import {NumberSchemaType} from '@sanity/types'
import {ObjectDiff as ObjectDiff_2} from '@sanity/diff'
import {ObjectField} from '@sanity/types'
import {ObjectSchemaType} from '@sanity/types'
import {Observable} from 'rxjs'
import {ObservableActorLogic} from 'xstate'
import {OnCopyFn} from '@portabletext/editor'
import {OnPasteFn} from '@portabletext/editor'
import {Path} from '@sanity/types'
import {PathSegment} from '@sanity/types'
import {PortableTextBlock} from '@sanity/types'
import {PortableTextEditor} from '@portabletext/editor'
import {PortableTextObject} from '@sanity/types'
import {PreviewUrlResolver} from '@sanity/preview-url-secret/define-preview-url'
import {PromiseActorLogic} from 'xstate'
import type {PubSub} from 'nano-pubsub'
import {RangeDecoration} from '@portabletext/editor'
import {ReactNode} from 'react'
import {ReferenceValue} from '@sanity/types'
import {RefObject} from 'react'
import {ReleaseDocument} from '@sanity/client'
import {RootTheme} from '@sanity/ui/theme'
import {Router} from 'sanity/router'
import {RouterState} from 'sanity/router'
import {SanityClient} from '@sanity/client'
import {SanityDocument} from '@sanity/types'
import {SanityDocument as SanityDocument_2} from '@sanity/client'
import {SanityDocumentLike} from '@sanity/types'
import {Schema} from '@sanity/types'
import {SchemaType} from '@sanity/types'
import {SchemaTypeDefinition} from '@sanity/types'
import {SearchParam} from 'sanity/router'
import {SearchStrategy} from '@sanity/types'
import type {SemVer} from 'semver'
import {Serializable} from '@sanity/presentation-comlink'
import {SetStateAction} from 'react'
import {SlugValue} from '@sanity/types'
import {SortOrdering} from '@sanity/types'
import {SortOrderingItem} from '@sanity/types'
import {StackablePerspective} from '@sanity/client'
import {StateMachine} from 'xstate'
import {StringSchemaType} from '@sanity/types'
import {TFunction} from 'i18next'
import {ThemeColorSchemeKey} from '@sanity/ui/theme'
import {TransactionLogEventWithEffects} from '@sanity/types'
import {TypographyPluginProps} from '@portabletext/plugin-typography'
import {User} from '@sanity/types'
import {ValidationMarker} from '@sanity/types'

declare interface Action extends NavbarActionBase {
  onAction: () => void
  selected: boolean
  title: string
  render?: undefined
}

declare interface Action_2 extends NavbarActionBase_2 {
  onAction: () => void
  selected: boolean
  title: string
  render?: undefined
}

/**
 * @hidden
 * @beta
 */
declare interface ActionComponent<ActionProps, ActionDescription> {
  (props: ActionProps): ActionDescription | null
}

/**
 * @hidden
 * @beta
 */
declare interface ActionComponent_2<ActionProps, ActionDescription> {
  (props: ActionProps): ActionDescription | null
}

declare interface ActionWithCustomRender extends NavbarActionBase {
  render: () => React.ReactElement
}

declare interface ActionWithCustomRender_2 extends NavbarActionBase_2 {
  render: () => React.ReactElement
}

/**
 * @beta
 * @hidden
 */
declare type ActiveDocument = {
  documentId: string
  documentType: string
}

/**
 * @hidden
 * @beta */
declare interface ActiveToolLayoutProps {
  renderDefault: (props: ActiveToolLayoutProps) => React.JSX.Element
  activeTool: Tool
}

/**
 * @hidden
 * @beta */
declare interface ActiveToolLayoutProps_2 {
  renderDefault: (props: ActiveToolLayoutProps_2) => React.JSX.Element
  activeTool: Tool_2
}

/** @internal */
export declare const ActiveWorkspaceMatcherContext: Context<ActiveWorkspaceMatcherContextValue | null>

/** @internal */
declare interface ActiveWorkspaceMatcherContextValue {
  activeWorkspace: WorkspaceSummary
  setActiveWorkspace: (workspaceName: string) => void
}

/**
 * @beta
 * @hidden
 */
export declare const AddonDatasetContext: Context<AddonDatasetContextValue | null>

/**
 * @beta
 * @hidden
 */
declare interface AddonDatasetContextValue {
  /**
   * Addon dataset client, currently called `comments` dataset.
   */
  client: SanityClient | null
  isCreatingDataset: boolean
  /**
   * Function to create the addon dataset if it does not exist.
   */
  createAddonDataset: () => Promise<SanityClient | null>
  ready: boolean
  error: Error | null
}

/**
 * @hidden
 * @beta */
declare type Annotation = AnnotationDetails | null

/**
 * @hidden
 * @beta */
declare type Annotation_2 = AnnotationDetails_2 | null

/**
 * Annotation connected to a change
 *
 *
 * @hidden
 * @beta
 */
declare type AnnotationDetails = {
  event?: DocumentGroupEvent
  timestamp: string
  author: string
}

/**
 * Annotation connected to a change
 *
 *
 * @hidden
 * @beta
 */
declare type AnnotationDetails_2 = {
  event?: DocumentGroupEvent_2
  timestamp: string
  author: string
}

declare interface AppIdCache {
  get: (args: {
    projectId: string
    appIdFetcher: AppIdFetcher
  }) => Promise<CompatibleStudioAppId | undefined>
}

/**
 * @internal
 */
export declare const AppIdCacheContext: Context<AppIdCache | null>

declare type AppIdFetcher = (projectId: string) => Promise<CompatibleStudioAppId>

/**
 * @public
 * Config for the apps that are available in the studio.
 */
declare type AppsOptions = {
  canvas?: {
    enabled: boolean
    /**
     * To allow the "Link to canvas" action on localhost, or in studios not listed under Studios in https://www.sanity.io/manage
     * provide a fallback origin as a string.
     *
     * The string must be the exactly equal `name` as shown for the Studio in manage, and the studio must have create-manifest.json available.
     *
     * If the provided fallback Studio does not expose create-manifest.json "Link to canvas" will fail when using the fallback.
     *
     * Example: `wonderful.sanity.studio`
     *
     * Keep in mind that when fallback origin is used, Canvas will use the schema types and dataset in the *deployed* Studio,
     * not from localhost.
     *
     * To see data synced from Canvas in your localhost Studio, you must ensure that the deployed fallback studio uses the same
     * workspace and schemas as your local configuration.
     *
     */
    fallbackStudioOrigin?: string
  }
}

/**
 * @public
 * Config for the apps that are available in the studio.
 */
declare type AppsOptions_2 = {
  canvas?: {
    enabled: boolean
    /**
     * To allow the "Link to canvas" action on localhost, or in studios not listed under Studios in https://www.sanity.io/manage
     * provide a fallback origin as a string.
     *
     * The string must be the exactly equal `name` as shown for the Studio in manage, and the studio must have create-manifest.json available.
     *
     * If the provided fallback Studio does not expose create-manifest.json "Link to canvas" will fail when using the fallback.
     *
     * Example: `wonderful.sanity.studio`
     *
     * Keep in mind that when fallback origin is used, Canvas will use the schema types and dataset in the *deployed* Studio,
     * not from localhost.
     *
     * To see data synced from Canvas in your localhost Studio, you must ensure that the deployed fallback studio uses the same
     * workspace and schemas as your local configuration.
     *
     */
    fallbackStudioOrigin?: string
  }
}

/**
 * @hidden
 * @public */
declare interface ArrayFieldProps extends BaseFieldProps {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfObjectsInputProps
}

/**
 * @hidden
 * @public */
declare interface ArrayFieldProps_2 extends BaseFieldProps_2 {
  schemaType: ArraySchemaType
  value: unknown[] | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  inputProps: ArrayOfObjectsInputProps_2
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputCopyEvent<Item> {
  items: Item[]
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputCopyEvent_2<Item> {
  items: Item[]
}

/**
 * These are the props an implementation of the ArrayFunctions component will receive
 *
 *
 * @hidden
 * @beta
 */
declare interface ArrayInputFunctionsProps<Item, SchemaType extends ArraySchemaType> {
  children?: ReactNode
  onItemAppend: (itemValue: Item) => void
  onChange: (event: PatchEvent) => void
  onValueCreate: (type: SchemaType) => Item
  onItemPrepend: (itemValue: Item) => void
  path: Path
  readOnly?: boolean
  schemaType: SchemaType
  value?: Item[]
}

/**
 * These are the props an implementation of the ArrayFunctions component will receive
 *
 *
 * @hidden
 * @beta
 */
declare interface ArrayInputFunctionsProps_2<Item, SchemaType extends ArraySchemaType> {
  children?: ReactNode
  onItemAppend: (itemValue: Item) => void
  onChange: (event: PatchEvent_2) => void
  onValueCreate: (type: SchemaType) => Item
  onItemPrepend: (itemValue: Item) => void
  path: Path
  readOnly?: boolean
  schemaType: SchemaType
  value?: Item[]
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputInsertEvent<Item> {
  items: Item[]
  position: 'before' | 'after'
  referenceItem: KeyedSegment | number
  skipInitialValue?: boolean
  open?: boolean
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputInsertEvent_2<Item> {
  items: Item[]
  position: 'before' | 'after'
  referenceItem: KeyedSegment | number
  skipInitialValue?: boolean
  open?: boolean
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputMoveItemEvent {
  fromIndex: number
  toIndex: number
}

/**
 * @hidden
 * @beta */
declare interface ArrayInputMoveItemEvent_2 {
  fromIndex: number
  toIndex: number
}

/**
 * @hidden
 * @beta */
declare interface ArrayItemError {
  kind: 'error'
  key: string
  index: number
  error: InvalidItemTypeError
}

/**
 * @hidden
 * @beta */
declare interface ArrayItemError_2 {
  kind: 'error'
  key: string
  index: number
  error: InvalidItemTypeError_2
}

/** @public */
declare interface ArrayOfObjectsFormNode<
  T extends any[] = KeyedObject[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfObjectsMember[]
}

/** @public */
declare interface ArrayOfObjectsFormNode_2<
  T extends any[] = KeyedObject[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode_2<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfObjectsMember_2[]
}

/**
 * @hidden
 * @public */
declare interface ArrayOfObjectsInputProps<
  T extends {
    _key: string
  } = {
    _key: string
  },
  S extends ArraySchemaType = ArraySchemaType,
>
  extends BaseInputProps, Omit<ArrayOfObjectsFormNode<T[], S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemMove: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: ArrayInputInsertEvent<T>) => void
  /**
   * @hidden
   * @beta */
  resolveInitialValue: (type: SchemaType, params: Record<string, unknown>) => Promise<T>
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<ObjectSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload?: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onSelectFile?: (props: InputOnSelectFileFunctionProps) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path, payload?: OnPathFocusPayload) => void
  /**
   * for array inputs using expand/collapse semantics for items
   *
   * @hidden
   * @beta
   */
  onItemCollapse: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemExpand: (itemKey: string) => void
  /**
   * for array inputs using modal open/close semantics for items
   *
   * @hidden
   * @beta
   */
  onItemOpen: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onItemClose: () => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 * @hidden
 * @public */
declare interface ArrayOfObjectsInputProps_2<
  T extends {
    _key: string
  } = {
    _key: string
  },
  S extends ArraySchemaType = ArraySchemaType,
>
  extends BaseInputProps_2, Omit<ArrayOfObjectsFormNode_2<T[], S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps_2<T, S>>
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch_2 | FormPatch_2[] | PatchEvent_2) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: T) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemMove: (event: ArrayInputMoveItemEvent_2) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: ArrayInputInsertEvent_2<T>) => void
  /**
   * @hidden
   * @beta */
  resolveInitialValue: (type: SchemaType, params: Record<string, unknown>) => Promise<T>
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver_2<ObjectSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload?: (event: UploadEvent_2) => void
  /**
   * @hidden
   * @beta */
  onSelectFile?: (props: InputOnSelectFileFunctionProps_2) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path, payload?: OnPathFocusPayload_2) => void
  /**
   * for array inputs using expand/collapse semantics for items
   *
   * @hidden
   * @beta
   */
  onItemCollapse: (itemKey: string) => void
  /**
   * @hidden
   * @beta */
  onItemExpand: (itemKey: string) => void
  /**
   * for array inputs using modal open/close semantics for items
   *
   * @hidden
   * @beta
   */
  onItemOpen: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onItemClose: () => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback_2
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback_2
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback_2
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback_2
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback_2
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback_2
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback_2
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps_2
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfObjectsItemMember<Node extends ObjectArrayFormNode = ObjectArrayFormNode> {
  kind: 'item'
  key: string
  index: number
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfObjectsItemMember_2<
  Node extends ObjectArrayFormNode_2 = ObjectArrayFormNode_2,
> {
  kind: 'item'
  key: string
  index: number
  collapsed: boolean | undefined
  collapsible: boolean | undefined
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare type ArrayOfObjectsMember = ArrayOfObjectsItemMember | ArrayItemError

/**
 * @hidden
 * @beta */
declare type ArrayOfObjectsMember_2 = ArrayOfObjectsItemMember_2 | ArrayItemError_2

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesElementType<T extends any[]> = T extends (infer K)[] ? K : unknown

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesElementType_2<T extends any[]> = T extends (infer K)[] ? K : unknown

/** @public */
declare interface ArrayOfPrimitivesFormNode<
  T extends (string | number | boolean)[] = (string | number | boolean)[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfPrimitivesMember[]
}

/** @public */
declare interface ArrayOfPrimitivesFormNode_2<
  T extends (string | number | boolean)[] = (string | number | boolean)[],
  S extends ArraySchemaType = ArraySchemaType,
> extends BaseFormNode_2<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  members: ArrayOfPrimitivesMember_2[]
}

/**
 * @hidden
 * @public */
declare interface ArrayOfPrimitivesInputProps<
  T extends string | boolean | number = string | boolean | number,
  S extends ArraySchemaType = ArraySchemaType,
>
  extends BaseInputProps, Omit<ArrayOfPrimitivesFormNode<T[], S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps<T, S>>
  onSetCollapsed: (collapsed: boolean) => void
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: ArrayOfPrimitivesElementType<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (index: number) => void
  /**
   * @hidden
   * @beta */
  onMoveItem: (event: ArrayInputMoveItemEvent) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: {items: T[]; position: 'before' | 'after'; referenceIndex: number}) => void
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver<NumberSchemaType | BooleanSchemaType | StringSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent) => void
  /**
   * @hidden
   * @beta */
  onIndexFocus: (index: number) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfPrimitivesItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
}

/**
 * @hidden
 * @public */
declare interface ArrayOfPrimitivesInputProps_2<
  T extends string | boolean | number = string | boolean | number,
  S extends ArraySchemaType = ArraySchemaType,
>
  extends BaseInputProps_2, Omit<ArrayOfPrimitivesFormNode_2<T[], S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  arrayFunctions?: ComponentType<ArrayInputFunctionsProps_2<T, S>>
  onSetCollapsed: (collapsed: boolean) => void
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch_2 | FormPatch_2[] | PatchEvent_2) => void
  /**
   * @hidden
   * @beta */
  onItemAppend: (item: ArrayOfPrimitivesElementType_2<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemPrepend: (item: ArrayOfPrimitivesElementType_2<T[]>) => void
  /**
   * @hidden
   * @beta */
  onItemRemove: (index: number) => void
  /**
   * @hidden
   * @beta */
  onMoveItem: (event: ArrayInputMoveItemEvent_2) => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: {items: T[]; position: 'before' | 'after'; referenceIndex: number}) => void
  /**
   * @hidden
   * @beta */
  resolveUploader: UploaderResolver_2<NumberSchemaType | BooleanSchemaType | StringSchemaType>
  /**
   * @hidden
   * @beta */
  onUpload: (event: UploadEvent_2) => void
  /**
   * @hidden
   * @beta */
  onIndexFocus: (index: number) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback_2
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback_2
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback_2
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback_2
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfPrimitivesItemCallback_2
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback_2
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps_2
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfPrimitivesItemMember<Node extends PrimitiveFormNode = PrimitiveFormNode> {
  kind: 'item'
  key: string
  index: number
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare interface ArrayOfPrimitivesItemMember_2<
  Node extends PrimitiveFormNode_2 = PrimitiveFormNode_2,
> {
  kind: 'item'
  key: string
  index: number
  open: boolean
  parentSchemaType: ArraySchemaType
  /**
   * @hidden
   * @beta */
  item: Node
}

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesMember = ArrayOfPrimitivesItemMember | ArrayItemError

/**
 * @hidden
 * @beta */
declare type ArrayOfPrimitivesMember_2 = ArrayOfPrimitivesItemMember_2 | ArrayItemError_2

/**
 * @internal
 */
export declare const AssetLimitUpsellContext: Context<AssetLimitUpsellContextValue | null>

/**
 * @internal
 */
export declare interface AssetLimitUpsellContextValue {
  upsellDialogOpen: boolean
  handleOpenDialog: (source: UpsellDialogViewedInfo['source']) => void
  upsellData: UpsellData | null
  telemetryLogs: {
    dialogSecondaryClicked: () => void
    dialogPrimaryClicked: () => void
  }
}

/**
 * @hidden
 * @beta
 */
declare type AssetSourceResolver = ComposableOption<AssetSource[], ConfigContext>

/**
 * @hidden
 * @beta
 */
declare type AssetSourceResolver_2 = ComposableOption_2<AssetSource[], ConfigContext_2>

/**
 * @hidden
 * @beta
 */
declare type AsyncComposableOption<TValue, TContext> = (
  prev: TValue,
  context: TContext,
) => Promise<TValue>

/**
 * @hidden
 * @beta
 */
declare type AsyncComposableOption_2<TValue, TContext> = (
  prev: TValue,
  context: TContext,
) => Promise<TValue>

declare type AudienceRole = (typeof audienceRoles)[number]

declare const audienceRoles: readonly [
  'administrator',
  'editor',
  'viewer',
  'contributor',
  'developer',
  'custom',
]

/**
 * Authentication options
 *
 * @public
 */
declare interface AuthConfig {
  /**
   * Login method to use for the studio. Can be one of:
   * - `dual` (default) - attempt to use cookies where possible, falling back to
   *   storing authentication token in `localStorage` otherwise
   * - `cookie` - explicitly disable `localStorage` method, relying only on cookies. May fail due
   *   to cookies being treated as third-party cookies in some browsers, thus the default is `dual`.
   * - `token` - explicitly disable cookies, relying only on `localStorage` method
   */
  loginMethod?: LoginMethod
  /**
   * Whether to append the providers specified in `providers` with the default providers from the
   * API, or replace the default providers with the ones specified.
   *
   * @deprecated Use the function form of `providers` instead for more control
   */
  mode?: 'append' | 'replace'
  /**
   * If true, the "Choose login provider" (eg "Google, "GitHub", "E-mail/password") screen
   * will be skipped if only a single provider is configured in the `providers` array -
   * instead it will redirect unauthenticated users straight to the authentication URL.
   */
  redirectOnSingle?: boolean
  /**
   * Array of authentication providers to use, or a function that takes an array of default
   * authentication providers (fetched from the Sanity API) and should return a new list of
   * providers. This can be used to selectively replace, add or remove providers from the
   * list of choices.
   *
   * @remarks If a static array of providers is provided, the `mode` property is taken into account
   *   when determining what to do with it - `append` will append the providers to the default set
   *   of providers, while `replace` will replace the default providers with the ones specified.
   *
   * If not set, the default providers will be used.
   */
  providers?: AuthProvider[] | ((prev: AuthProvider[]) => AuthProvider[] | Promise<AuthProvider[]>)
  /**
   * The API hostname for requests. Should usually be left undefined,
   * but can be set if using custom cname for API domain.
   */
  apiHost?: string
}

/**
 * Authentication options
 *
 * @public
 */
declare interface AuthConfig_2 {
  /**
   * Login method to use for the studio. Can be one of:
   * - `dual` (default) - attempt to use cookies where possible, falling back to
   *   storing authentication token in `localStorage` otherwise
   * - `cookie` - explicitly disable `localStorage` method, relying only on cookies. May fail due
   *   to cookies being treated as third-party cookies in some browsers, thus the default is `dual`.
   * - `token` - explicitly disable cookies, relying only on `localStorage` method
   */
  loginMethod?: LoginMethod_2
  /**
   * Whether to append the providers specified in `providers` with the default providers from the
   * API, or replace the default providers with the ones specified.
   *
   * @deprecated Use the function form of `providers` instead for more control
   */
  mode?: 'append' | 'replace'
  /**
   * If true, the "Choose login provider" (eg "Google, "GitHub", "E-mail/password") screen
   * will be skipped if only a single provider is configured in the `providers` array -
   * instead it will redirect unauthenticated users straight to the authentication URL.
   */
  redirectOnSingle?: boolean
  /**
   * Array of authentication providers to use, or a function that takes an array of default
   * authentication providers (fetched from the Sanity API) and should return a new list of
   * providers. This can be used to selectively replace, add or remove providers from the
   * list of choices.
   *
   * @remarks If a static array of providers is provided, the `mode` property is taken into account
   *   when determining what to do with it - `append` will append the providers to the default set
   *   of providers, while `replace` will replace the default providers with the ones specified.
   *
   * If not set, the default providers will be used.
   */
  providers?:
    | AuthProvider_2[]
    | ((prev: AuthProvider_2[]) => AuthProvider_2[] | Promise<AuthProvider_2[]>)
  /**
   * The API hostname for requests. Should usually be left undefined,
   * but can be set if using custom cname for API domain.
   */
  apiHost?: string
}

/**
 * A provider of authentication.
 *
 * By default, a list of providers for a project will be fetched from the
 * {@link https://api.sanity.io/v1/auth/providers | Sanity API}, but you may choose to limit this
 * list by explicitly defining the providers you want to allow, or add additional custom providers
 * that conforms to the authentication provider specification outlined in
 * {@link https://www.sanity.io/docs/third-party-login | the documentation}.
 *
 * @public
 */
declare interface AuthProvider {
  /**
   * URL-friendly identifier/name for the provider, eg `github`
   */
  name: string
  /**
   * Human friendly title for the provider, eg `GitHub`
   */
  title: string
  /**
   * URL for the authentication endpoint that will trigger the authentication flow
   */
  url: string
  /**
   * URL for a logo to display next to the provider in the login screen
   */
  logo?: string
}

/**
 * A provider of authentication.
 *
 * By default, a list of providers for a project will be fetched from the
 * {@link https://api.sanity.io/v1/auth/providers | Sanity API}, but you may choose to limit this
 * list by explicitly defining the providers you want to allow, or add additional custom providers
 * that conforms to the authentication provider specification outlined in
 * {@link https://www.sanity.io/docs/third-party-login | the documentation}.
 *
 * @public
 */
declare interface AuthProvider_2 {
  /**
   * URL-friendly identifier/name for the provider, eg `github`
   */
  name: string
  /**
   * Human friendly title for the provider, eg `GitHub`
   */
  title: string
  /**
   * URL for the authentication endpoint that will trigger the authentication flow
   */
  url: string
  /**
   * URL for a logo to display next to the provider in the login screen
   */
  logo?: string
}

/**
 * The unit an `AuthStore` emits to determine the user's authentication state.
 *
 * @beta
 * @hidden
 */
declare interface AuthState {
  /**
   * Similar to a logged-in flag. This state is used in places like the
   * `AuthBoundary` to determine whether or not it should render the
   * `NotAuthenticatedComponent`. Implementers may choose to set this to `true`
   * while also also emitting a `currentUser` of `null` if a `null` user is
   * accepted (e.g. a project that doesn't require a login)
   */
  authenticated: boolean
  /**
   * The value of the user logged in or `null` if none is provided
   */
  currentUser: CurrentUser | null
  /**
   * A client that is expected to be pre-configured to allow for any downstream
   * requests in the Studio
   */
  client: SanityClient
}

/**
 * The unit an `AuthStore` emits to determine the user's authentication state.
 *
 * @beta
 * @hidden
 */
declare interface AuthState_2 {
  /**
   * Similar to a logged-in flag. This state is used in places like the
   * `AuthBoundary` to determine whether or not it should render the
   * `NotAuthenticatedComponent`. Implementers may choose to set this to `true`
   * while also also emitting a `currentUser` of `null` if a `null` user is
   * accepted (e.g. a project that doesn't require a login)
   */
  authenticated: boolean
  /**
   * The value of the user logged in or `null` if none is provided
   */
  currentUser: CurrentUser | null
  /**
   * A client that is expected to be pre-configured to allow for any downstream
   * requests in the Studio
   */
  client: SanityClient
}

/**
 * The interface used by the Studio that produces a `SanityClient` and
 * `CurrentUser` that gets passed to the resulting `Workspace`s and `Source`s.
 *
 * NOTE: This interface is primarily for internal use. Refer to
 * `createAuthStore` instead.
 *
 * @beta
 * @hidden
 */
declare interface AuthStore {
  /**
   * Emits `AuthState`s. This should update when the user's auth state changes.
   * E.g. After a login, a new `AuthState` could be emitted with a non-null
   * `currentUser` and `authenticated: true`
   *
   * NOTE: all auth store implementations should emit on subscribe using
   * something like shareReplay(1) to ensure all new subscribers get an
   * `AuthState` value on subscribe
   */
  state: Observable<AuthState>
  /**
   * Emits auth tokens, or `null` if not configured to use them or they do not exist
   */
  token?: Observable<string | null>
  /**
   * Custom auth stores are expected to implement a UI that initiates the user's
   * authentication. For the typical case in `createAuthStore`, this means
   * loading the providers and showing them as options to the user.
   */
  LoginComponent?: ComponentType<LoginComponentProps>
  /**
   * Custom auth stores can implement a function that runs when the user logs
   * out. The implementation is expected to remove all credentials both locally
   * and on the server.
   */
  logout?: () => void
  /**
   * Custom auth stores can implement a function that is designated to run when
   * the Studio loads (e.g. to trade a session ID for a token in cookie-less
   * mode). Within the Studio, this is called within the `AuthBoundary`.
   */
  handleCallbackUrl?: () => Promise<void>
}

/**
 * The interface used by the Studio that produces a `SanityClient` and
 * `CurrentUser` that gets passed to the resulting `Workspace`s and `Source`s.
 *
 * NOTE: This interface is primarily for internal use. Refer to
 * `createAuthStore` instead.
 *
 * @beta
 * @hidden
 */
declare interface AuthStore_2 {
  /**
   * Emits `AuthState`s. This should update when the user's auth state changes.
   * E.g. After a login, a new `AuthState` could be emitted with a non-null
   * `currentUser` and `authenticated: true`
   *
   * NOTE: all auth store implementations should emit on subscribe using
   * something like shareReplay(1) to ensure all new subscribers get an
   * `AuthState` value on subscribe
   */
  state: Observable<AuthState_2>
  /**
   * Emits auth tokens, or `null` if not configured to use them or they do not exist
   */
  token?: Observable<string | null>
  /**
   * Custom auth stores are expected to implement a UI that initiates the user's
   * authentication. For the typical case in `createAuthStore`, this means
   * loading the providers and showing them as options to the user.
   */
  LoginComponent?: ComponentType<LoginComponentProps_2>
  /**
   * Custom auth stores can implement a function that runs when the user logs
   * out. The implementation is expected to remove all credentials both locally
   * and on the server.
   */
  logout?: () => void
  /**
   * Custom auth stores can implement a function that is designated to run when
   * the Studio loads (e.g. to trade a session ID for a token in cookie-less
   * mode). Within the Studio, this is called within the `AuthBoundary`.
   */
  handleCallbackUrl?: () => Promise<void>
}

/**
 * @hidden
 * @beta */
declare interface BackLinkProps {
  children?: ReactNode
}

/**
 * @hidden
 * @beta
 */
declare interface BaseActionDescription {
  disabled?: boolean
  icon?: ReactNode | ComponentType
  label: string
  onHandle?: () => void
  title?: ReactNode
  tone?: ButtonTone
  shortcut?: string | null
  dialog?: unknown
}

/**
 * @hidden
 * @beta
 */
declare interface BaseActionDescription_2 {
  disabled?: boolean
  icon?: ReactNode | ComponentType
  label: string
  onHandle?: () => void
  title?: ReactNode
  tone?: ButtonTone
  shortcut?: string | null
  dialog?: unknown
}

/**
 * A generic event with a type and a timestamp.
 * @hidden
 * @beta
 */
declare interface BaseEvent {
  id: string
  timestamp: string
  author: string
  /**
   * This is added client side to enhance the UI.
   */
  documentVariantType: DocumentVariantType
}

/**
 * A generic event with a type and a timestamp.
 * @hidden
 * @beta
 */
declare interface BaseEvent_2 {
  id: string
  timestamp: string
  author: string
  /**
   * This is added client side to enhance the UI.
   */
  documentVariantType: DocumentVariantType_2
}

/**
 * @hidden
 * @public */
declare interface BaseFieldProps {
  /** @beta */
  actions?: DocumentFieldAction[]
  /** @internal @deprecated DO NOT USE */
  __internal_comments?: FieldCommentsProps
  /** @internal @deprecated ONLY USED BY AI ASSIST PLUGIN */
  __internal_slot?: ReactNode
  schemaType: SchemaType
  title: string | undefined
  description: string | undefined
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  validation: FormNodeValidation[]
  level: number
  inputId: string
  value: unknown | undefined
  path: Path
  name: string
  index: number
  changed: boolean
  children: ReactNode
  version?: string
  renderDefault: (props: FieldProps) => React.JSX.Element
}

/**
 * @hidden
 * @public */
declare interface BaseFieldProps_2 {
  /** @beta */
  actions?: DocumentFieldAction_2[]
  /** @internal @deprecated DO NOT USE */
  __internal_comments?: FieldCommentsProps_2
  /** @internal @deprecated ONLY USED BY AI ASSIST PLUGIN */
  __internal_slot?: ReactNode
  schemaType: SchemaType
  title: string | undefined
  description: string | undefined
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence_2[]
  validation: FormNodeValidation[]
  level: number
  inputId: string
  value: unknown | undefined
  path: Path
  name: string
  index: number
  changed: boolean
  children: ReactNode
  version?: string
  renderDefault: (props: FieldProps_2) => React.JSX.Element
}

/**
 * @hidden
 * @public
 */
declare interface BaseFormNode<
  T = unknown,
  S extends SchemaType = SchemaType,
> extends NodeDiffProps<ProvenanceDiffAnnotation, T> {
  /** The unique identifier of the node. */
  id: string
  /** The schema type of the node. */
  schemaType: S
  /** The level of the node in the form hierarchy. */
  level: number
  /** The path of the node in the form hierarchy. */
  path: Path
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  /** The validation markers of the node. */
  validation: FormNodeValidation[]
  /** The value of the node. */
  value: T | undefined
  /** Whether the node is read-only. */
  readOnly?: boolean
  /** Whether the node is focused. */
  focused?: boolean
  displayInlineChanges?: boolean
}

/**
 * @hidden
 * @public
 */
declare interface BaseFormNode_2<
  T = unknown,
  S extends SchemaType = SchemaType,
> extends NodeDiffProps_2<ProvenanceDiffAnnotation_2, T> {
  /** The unique identifier of the node. */
  id: string
  /** The schema type of the node. */
  schemaType: S
  /** The level of the node in the form hierarchy. */
  level: number
  /** The path of the node in the form hierarchy. */
  path: Path
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence_2[]
  /** The validation markers of the node. */
  validation: FormNodeValidation[]
  /** The value of the node. */
  value: T | undefined
  /** Whether the node is read-only. */
  readOnly?: boolean
  /** Whether the node is focused. */
  focused?: boolean
  displayInlineChanges?: boolean
}

/**
 * Interface for base generic list
 *
 * @public
 */
declare interface BaseGenericList extends StructureNode {
  /** List layout key. */
  defaultLayout?: PreviewLayoutKey_2
  /** Can handle intent. See {@link IntentChecker} */
  canHandleIntent?: IntentChecker
  /** List display options. See {@link ListDisplayOptions} */
  displayOptions?: ListDisplayOptions
  /** List child. See {@link Child} */
  child: Child
  /** List initial values array. See {@link InitialValueTemplateItem} and {@link InitialValueTemplateItemBuilder} */
  initialValueTemplates?: (InitialValueTemplateItem_2 | InitialValueTemplateItemBuilder)[]
}

/**
 * @hidden
 * @public */
declare interface BaseInputProps {
  renderDefault: (props: InputProps) => React.JSX.Element
  /**
   * Whether the input should display inline changes. Inline changes express how a field's value
   * differs from its upstream version. Unlike custom diff components, inline changes is a mode
   * that allows the input component itself to display the change in situ.
   */
  displayInlineChanges: boolean
}

/**
 * @hidden
 * @public */
declare interface BaseInputProps_2 {
  renderDefault: (props: InputProps_2) => React.JSX.Element
  /**
   * Whether the input should display inline changes. Inline changes express how a field's value
   * differs from its upstream version. Unlike custom diff components, inline changes is a mode
   * that allows the input component itself to display the change in situ.
   */
  displayInlineChanges: boolean
}

/**
 * Base intent parameters
 *
 * @public
 * @todo dedupe with core
 */
declare interface BaseIntentParams {
  /**
   * Document schema type name to create/edit.
   * Required for `create` intents, optional for `edit` (but encouraged, safer and faster)
   */
  type?: string
  /**
   * ID of the document to create/edit.
   * Required for `edit` intents, optional for `create`.
   */
  id?: string
  /**
   * Name (ID) of initial value template to use for `create` intent. Optional.
   */
  template?: string
  /**
   * Experimental field path
   *
   * @beta
   * @experimental
   * @hidden
   */
  path?: string
  /**
   * Optional "mode" to use for edit intent.
   * Known modes are `structure` and `presentation`.
   */
  mode?: string
  /**
   * Arbitrary/custom parameters are generally discouraged - try to keep them to a minimum,
   * or use `payload` (arbitrary JSON-serializable object) instead.
   */
  [key: string]: string | undefined
}

/**
 * Base intent parameters
 *
 * @public
 * @todo dedupe with core/structure
 */
declare interface BaseIntentParams_2 {
  /**
   * Document schema type name to create/edit.
   * Required for `create` intents, optional for `edit` (but encouraged, safer and faster)
   */
  type?: string
  /**
   * ID of the document to create/edit.
   * Required for `edit` intents, optional for `create`.
   */
  id?: string
  template?: string
  /**
   * Experimental field path
   *
   * @beta
   * @experimental
   * @hidden
   */
  path?: string
  /**
   * Optional "mode" to use for edit intent.
   * Known modes are `structure` and `presentation`.
   */
  mode?: string
  /**
   * Arbitrary/custom parameters are generally discouraged - try to keep them to a minimum,
   * or use `payload` (arbitrary JSON-serializable object) instead.
   */
  [key: string]: string | undefined
}

/**
 * Props for the base item component.
 *
 * @public
 */
declare interface BaseItemProps<T> extends NodeDiffProps<ProvenanceDiffAnnotation> {
  /** The schema type of the item. */
  schemaType: SchemaType
  /** The index of the item. */
  index: number
  /** The level of the item. */
  level: number
  /** The value of the item. */
  value: unknown
  /** The path of the item. */
  path: Path
  /** The title of the item. */
  title: string | undefined
  /** The description of the item. */
  description: string | undefined
  /** The ID of the input element. */
  inputId: string
  /** The function to call when the item receives focus. */
  onFocus: (event: FocusEvent_2) => void
  /** The function to call when the item loses focus. */
  onBlur: (event: FocusEvent_2) => void
  /** Whether the item is read-only. */
  readOnly?: boolean
  /** Whether the item is focused. */
  focused?: boolean
  /** The function to call when the item is removed. */
  onRemove: () => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: Omit<ArrayInputInsertEvent<T>, 'referenceItem'>) => void
  /**
   * @hidden
   * @beta */
  onCopy: (event: Omit<ArrayInputCopyEvent<T>, 'referenceItem'>) => void
  /** The children of the item. */
  children: ReactNode
  /** The validation markers for the item. */
  validation: FormNodeValidation[]
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence[]
  /** The function to call to render the default item. See {@link ItemProps} */
  renderDefault: (props: ItemProps) => React.JSX.Element
}

/**
 * Props for the base item component.
 *
 * @public
 */
declare interface BaseItemProps_2<T> extends NodeDiffProps_2<ProvenanceDiffAnnotation_2> {
  /** The schema type of the item. */
  schemaType: SchemaType
  /** The index of the item. */
  index: number
  /** The level of the item. */
  level: number
  /** The value of the item. */
  value: unknown
  /** The path of the item. */
  path: Path
  /** The title of the item. */
  title: string | undefined
  /** The description of the item. */
  description: string | undefined
  /** The ID of the input element. */
  inputId: string
  /** The function to call when the item receives focus. */
  onFocus: (event: FocusEvent_2) => void
  /** The function to call when the item loses focus. */
  onBlur: (event: FocusEvent_2) => void
  /** Whether the item is read-only. */
  readOnly?: boolean
  /** Whether the item is focused. */
  focused?: boolean
  /** The function to call when the item is removed. */
  onRemove: () => void
  /**
   * @hidden
   * @beta */
  onInsert: (event: Omit<ArrayInputInsertEvent_2<T>, 'referenceItem'>) => void
  /**
   * @hidden
   * @beta */
  onCopy: (event: Omit<ArrayInputCopyEvent_2<T>, 'referenceItem'>) => void
  /** The children of the item. */
  children: ReactNode
  /** The validation markers for the item. */
  validation: FormNodeValidation[]
  /**
   * @hidden
   * @beta */
  presence: FormNodePresence_2[]
  /** The function to call to render the default item. See {@link ItemProps} */
  renderDefault: (props: ItemProps_2) => React.JSX.Element
}

/**
 * @beta
 * @hidden
 */
declare interface BaseOptions {
  context: {
    source: 'fieldAction' | 'documentFieldAction' | 'keyboardShortcut' | 'arrayItem' | 'unknown'
  }
}

/** @internal */
declare interface BaseResolvedPaneNode<T extends PaneNode['type']> {
  id: string
  type: T
  title: string
  i18n?: I18nTextRecord<'title'>
  menuItems?: PaneMenuItem[]
  menuItemGroups?: PaneMenuItemGroup[]
  canHandleIntent?: (
    intentName: string,
    params: Record<string, string | undefined>,
    options: {
      pane: PaneNode
      index: number
    },
  ) => boolean
  child?: UnresolvedPaneNode
}

/**
 * Interface for base view
 *
 * @public */
declare interface BaseView {
  /** View id */
  id: string
  /** View Title */
  title: string
  /** View Icon */
  icon?: React.ComponentType | React.ReactNode
}

/**
 * @internal
 * Configuration for studio beta features.
 * */
declare interface BetaFeatures {
  /** beta features with the form namespace */
  form?: {
    /**
     * Enhanced Object Dialog is a new dialog for editing objects in the studio.
     * @beta
     */
    enhancedObjectDialog?: {
      enabled: boolean
    }
  }
  /**
   * @deprecated - The Start in Create flow has been removed and will be updated in an upcoming studio release.
   */
  create?: {
    /**
     * When true, a "Start in Sanity Create" action will be shown for all new documents, in place of regular document actions,
     * when the following are true:
     * - the origin of the current url is listed under Studios in sanity.to/manage (OR fallbackStudioOrigin is provided)
     * - [origin]/static/create-manifest.json is available over HTTP GET
     *
     * The manifest file is automatically created and deployed when deploying studios with `sanity deploy`
     *
     * @see #fallbackStudioOrigin
     */
    startInCreateEnabled?: boolean
    /**
     * To show the "Start in Create" button on localhost, or in studios not listed under Studios in https://www.sanity.io/manage
     * provide a fallback origin as a string.
     *
     * The string must be the exactly equal `name` as shown for the Studio in manage, and the studio must have create-manifest.json available.
     *
     * If the provided fallback Studio does not expose create-manifest.json "Start in Sanity Create" will fail when using the fallback.
     *
     * Example: `wonderful.sanity.studio`
     *
     * Keep in mind that when fallback origin is used, Sanity Create will used the schema types and dataset in the *deployed* Studio,
     * not from localhost.
     *
     * To see data synced from Sanity Create in your localhost Studio, you must ensure that the deployed fallback studio uses the same
     * workspace and schemas as your local configuration.
     *
     * @see #startInCreateEnabled
     */
    fallbackStudioOrigin?: string
  }
  /**
   * Config for the history events API .
   *
   * If enabled, it will use the new events API to fetch document history.
   *
   * If it is not enabled, it will continue using the legacy Timeline.
   */
  eventsAPI?: {
    documents?: boolean
    releases?: boolean
  }
}

/**
 * @internal
 * Configuration for studio beta features.
 * */
declare interface BetaFeatures_2 {
  /** beta features with the form namespace */
  form?: {
    /**
     * Enhanced Object Dialog is a new dialog for editing objects in the studio.
     * @beta
     */
    enhancedObjectDialog?: {
      enabled: boolean
    }
  }
  /**
   * @deprecated - The Start in Create flow has been removed and will be updated in an upcoming studio release.
   */
  create?: {
    /**
     * When true, a "Start in Sanity Create" action will be shown for all new documents, in place of regular document actions,
     * when the following are true:
     * - the origin of the current url is listed under Studios in sanity.to/manage (OR fallbackStudioOrigin is provided)
     * - [origin]/static/create-manifest.json is available over HTTP GET
     *
     * The manifest file is automatically created and deployed when deploying studios with `sanity deploy`
     *
     * @see #fallbackStudioOrigin
     */
    startInCreateEnabled?: boolean
    /**
     * To show the "Start in Create" button on localhost, or in studios not listed under Studios in https://www.sanity.io/manage
     * provide a fallback origin as a string.
     *
     * The string must be the exactly equal `name` as shown for the Studio in manage, and the studio must have create-manifest.json available.
     *
     * If the provided fallback Studio does not expose create-manifest.json "Start in Sanity Create" will fail when using the fallback.
     *
     * Example: `wonderful.sanity.studio`
     *
     * Keep in mind that when fallback origin is used, Sanity Create will used the schema types and dataset in the *deployed* Studio,
     * not from localhost.
     *
     * To see data synced from Sanity Create in your localhost Studio, you must ensure that the deployed fallback studio uses the same
     * workspace and schemas as your local configuration.
     *
     * @see #startInCreateEnabled
     */
    fallbackStudioOrigin?: string
  }
  /**
   * Config for the history events API .
   *
   * If enabled, it will use the new events API to fetch document history.
   *
   * If it is not enabled, it will continue using the legacy Timeline.
   */
  eventsAPI?: {
    documents?: boolean
    releases?: boolean
  }
}

/**
 * Props for rendering a Portable Text annotation
 *
 * @public
 * @remarks If you want to render a mix of the annotated text and non-text content, you have to attribute
 * the non-text containers with `contentEditable={false}`. See the second example.
 * @example Simple example of customizing the annotation text to render yellow.
 * ```ts
 * (props: BlockAnnotationProps) =>
 *   props.renderDefault({
 *     ...props,
 *     textElement: <span style={{color: 'yellow'}}>{props.textElement}</span>,
 *   })
 * ```
 * @example Simple example of rendering the annotation with a custom modal for editing.
 * Note that the form content container is attributed as `contentEditable={false}`.
 * This is to signal to the text editor that this content isn't part of the editable text.
 * ```ts
 * (props: BlockAnnotationProps) => {
 *   return (
 *     <>
 *       // Render the annotated text
 *       <span onClick={props.onOpen}>
 *         {props.textElement}
 *       </span>
 *       // Render the editing form if the object is opened
 *       {props.open && (
 *         <Dialog
 *           contentEditable={false} // Attribute this as non-editable to the text editor
 *           header={`Edit ${props.schemaType.title}`}
 *           id={`dialog-${props.value._key}`}
 *           onClickOutside={props.onClose}
 *           onClose={props.onClose}
 *         >
 *           <Box margin={2} padding={2}>
 *             {props.children}
 *           </Box>
 *         </Dialog>
 *      )}
 *     </>
 *   )
 * }
 * ```
 * */
declare interface BlockAnnotationProps {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element where the text for this annotation appears.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the annotated text.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * Wether the annotated text node has editor focus.
   * @remarks differs from `focused` which is wether the annotation object has form focus.
   */
  __unstable_textElementFocus?: boolean
  /**
   * The input form for the annotation object.
   * @remarks If you wrap this in something, you must make sure to put `contentEditable={false}` on the root container.
   * Otherwise the editor will think content is part of the editable text and will error.
   */
  children: ReactNode
  /**
   * If the editor form for this annotation object currently have form focus.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker[]
  /**
   * Closes the editing form connected to this annotation.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this annotation.
   */
  onOpen: () => void
  /**
   * Focus a form node in the object for this annotation.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the annotation object from the text.
   */
  onRemove: () => void
  /**
   * If the annotation is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type. For annotations this this the block type.
   */
  parentSchemaType: SchemaType
  /**
   * The full form path to this annotation from document root.
   */
  path: Path
  /**
   * Form presence for this annotation.
   */
  presence: FormNodePresence[]
  /**
   * Is the annotation object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderDefault: (props: BlockAnnotationProps) => React.JSX.Element
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback
  /**
   * The schema type for the annotation object.
   */
  schemaType: ObjectSchemaType & {
    i18nTitleKey?: string
  }
  /**
   * If the annotated text currently is selected by the user.
   */
  selected: boolean
  /**
   * React element of the text that is being annotated.
   */
  textElement: React.JSX.Element
  /**
   * Form validation for the annotation object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the annotation object.
   */
  value: PortableTextObject
}

/**
 * Props for rendering a Portable Text annotation
 *
 * @public
 * @remarks If you want to render a mix of the annotated text and non-text content, you have to attribute
 * the non-text containers with `contentEditable={false}`. See the second example.
 * @example Simple example of customizing the annotation text to render yellow.
 * ```ts
 * (props: BlockAnnotationProps) =>
 *   props.renderDefault({
 *     ...props,
 *     textElement: <span style={{color: 'yellow'}}>{props.textElement}</span>,
 *   })
 * ```
 * @example Simple example of rendering the annotation with a custom modal for editing.
 * Note that the form content container is attributed as `contentEditable={false}`.
 * This is to signal to the text editor that this content isn't part of the editable text.
 * ```ts
 * (props: BlockAnnotationProps) => {
 *   return (
 *     <>
 *       // Render the annotated text
 *       <span onClick={props.onOpen}>
 *         {props.textElement}
 *       </span>
 *       // Render the editing form if the object is opened
 *       {props.open && (
 *         <Dialog
 *           contentEditable={false} // Attribute this as non-editable to the text editor
 *           header={`Edit ${props.schemaType.title}`}
 *           id={`dialog-${props.value._key}`}
 *           onClickOutside={props.onClose}
 *           onClose={props.onClose}
 *         >
 *           <Box margin={2} padding={2}>
 *             {props.children}
 *           </Box>
 *         </Dialog>
 *      )}
 *     </>
 *   )
 * }
 * ```
 * */
declare interface BlockAnnotationProps_2 {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element where the text for this annotation appears.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the annotated text.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * Wether the annotated text node has editor focus.
   * @remarks differs from `focused` which is wether the annotation object has form focus.
   */
  __unstable_textElementFocus?: boolean
  /**
   * The input form for the annotation object.
   * @remarks If you wrap this in something, you must make sure to put `contentEditable={false}` on the root container.
   * Otherwise the editor will think content is part of the editable text and will error.
   */
  children: ReactNode
  /**
   * If the editor form for this annotation object currently have form focus.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker_2[]
  /**
   * Closes the editing form connected to this annotation.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this annotation.
   */
  onOpen: () => void
  /**
   * Focus a form node in the object for this annotation.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the annotation object from the text.
   */
  onRemove: () => void
  /**
   * If the annotation is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type. For annotations this this the block type.
   */
  parentSchemaType: SchemaType
  /**
   * The full form path to this annotation from document root.
   */
  path: Path
  /**
   * Form presence for this annotation.
   */
  presence: FormNodePresence_2[]
  /**
   * Is the annotation object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback_2
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback_2
  /**
   * Plugin chain render callback.
   */
  renderDefault: (props: BlockAnnotationProps_2) => React.JSX.Element
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback_2
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback_2
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback_2
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback_2
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback_2
  /**
   * The schema type for the annotation object.
   */
  schemaType: ObjectSchemaType & {
    i18nTitleKey?: string
  }
  /**
   * If the annotated text currently is selected by the user.
   */
  selected: boolean
  /**
   * React element of the text that is being annotated.
   */
  textElement: React.JSX.Element
  /**
   * Form validation for the annotation object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the annotation object.
   */
  value: PortableTextObject
}

/**
 * Props for rendering a Portable Text block
 *
 * @public
 */
declare interface BlockProps {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element for the block.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the block.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * The default rendering of the block (the text).
   */
  children: ReactNode
  /**
   * If the block currently is focused by the user.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker[]
  /**
   * Closes the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onOpen: () => void
  /**
   * Focus a form node in this block.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the block.
   */
  onRemove: () => void
  /**
   * If the block is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type (array type).
   */
  parentSchemaType: ArraySchemaType | ObjectSchemaType
  /**
   * The full form path to this block from document root.
   */
  path: Path
  /**
   * Form presence for this block.
   */
  presence: FormNodePresence[]
  /**
   * Is the block object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback (default rendering function of the block).
   */
  renderDefault: (props: BlockProps) => React.JSX.Element
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback
  /**
   * The schema type for the block.
   */
  schemaType: ObjectSchemaType
  /**
   * If the block is in the user's selection.
   */
  selected: boolean
  /**
   * Form validation for the block object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the block.
   */
  value: PortableTextBlock
}

/**
 * Props for rendering a Portable Text block
 *
 * @public
 */
declare interface BlockProps_2 {
  /**
   * Boundary element of the floating toolbar element.
   */
  __unstable_floatingBoundary: HTMLElement | null
  /**
   * Boundary element for the block.
   */
  __unstable_referenceBoundary: HTMLElement | null
  /**
   * DOM element for the block.
   */
  __unstable_referenceElement: HTMLElement | null
  /**
   * The default rendering of the block (the text).
   */
  children: ReactNode
  /**
   * If the block currently is focused by the user.
   */
  focused: boolean
  /**
   * Markers (meta data) connected to this annotation.
   * @deprecated - use `renderBlock` and `renderInlineBlock` interfaces instead
   */
  markers: PortableTextMarker_2[]
  /**
   * Closes the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onClose: () => void
  /**
   * Opens the editing form connected to this block.
   * For regular text blocks this is not relevant.
   */
  onOpen: () => void
  /**
   * Focus a form node in this block.
   * @param path - the relative path to the form node to put focus on.
   */
  onPathFocus: (path: Path) => void
  /**
   * Removes the block.
   */
  onRemove: () => void
  /**
   * If the block is currently opened for editing.
   */
  open: boolean
  /**
   * The parent schema type (array type).
   */
  parentSchemaType: ArraySchemaType | ObjectSchemaType
  /**
   * The full form path to this block from document root.
   */
  path: Path
  /**
   * Form presence for this block.
   */
  presence: FormNodePresence_2[]
  /**
   * Is the block object read only?
   */
  readOnly: boolean
  /**
   * Plugin chain render callback.
   */
  renderAnnotation?: RenderAnnotationCallback_2
  /**
   * Plugin chain render callback.
   */
  renderBlock?: RenderBlockCallback_2
  /**
   * Plugin chain render callback (default rendering function of the block).
   */
  renderDefault: (props: BlockProps_2) => React.JSX.Element
  /**
   * Plugin chain render callback.
   */
  renderField: RenderFieldCallback_2
  /**
   * Plugin chain render callback.
   */
  renderInlineBlock?: RenderBlockCallback_2
  /**
   * Plugin chain render callback.
   */
  renderInput: RenderInputCallback_2
  /**
   * Plugin chain render callback.
   */
  renderItem: RenderArrayOfObjectsItemCallback_2
  /**
   * Plugin chain render callback.
   */
  renderPreview: RenderPreviewCallback_2
  /**
   * The schema type for the block.
   */
  schemaType: ObjectSchemaType
  /**
   * If the block is in the user's selection.
   */
  selected: boolean
  /**
   * Form validation for the block object.
   */
  validation: FormNodeValidation[]
  /**
   * Value of the block.
   */
  value: PortableTextBlock
}

/**
 * @hidden
 * @public */
declare interface BooleanFieldProps extends BaseFieldProps {
  schemaType: BooleanSchemaType
  value: boolean | undefined
  inputProps: BooleanInputProps
}

/**
 * @hidden
 * @public */
declare interface BooleanFieldProps_2 extends BaseFieldProps_2 {
  schemaType: BooleanSchemaType
  value: boolean | undefined
  inputProps: BooleanInputProps_2
}

/** @public */
declare type BooleanFormNode<S extends BooleanSchemaType = BooleanSchemaType> = BaseFormNode<
  boolean,
  S
>

/** @public */
declare type BooleanFormNode_2<S extends BooleanSchemaType = BooleanSchemaType> = BaseFormNode_2<
  boolean,
  S
>

/**
 * @hidden
 * @public */
declare interface BooleanInputProps<S extends BooleanSchemaType = BooleanSchemaType>
  extends BaseInputProps, Omit<BooleanFormNode<S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * A shorthand aggregation of any validation errors the input currently have
   * Will be falsey if no error.
   * In the case of multiple errors it will be a newline delimited string of each error message
   * For advanced use cases use the validation prop which contains more levels and details
   */
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @public */
declare interface BooleanInputProps_2<S extends BooleanSchemaType = BooleanSchemaType>
  extends BaseInputProps_2, Omit<BooleanFormNode_2<S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch_2 | FormPatch_2[] | PatchEvent_2) => void
  /**
   * A shorthand aggregation of any validation errors the input currently have
   * Will be falsey if no error.
   * In the case of multiple errors it will be a newline delimited string of each error message
   * For advanced use cases use the validation prop which contains more levels and details
   */
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps_2
}

/**
 * @hidden
 * @beta */
declare type BufferedDocumentEvent =
  | SnapshotEvent
  | DocumentRebaseEvent
  | DocumentMutationEvent
  | CommittedEvent

/**
 * Interface for buildable component
 *
 * @public
 */
declare interface BuildableComponent extends Partial<StructureNode> {
  /** Component of type {@link UserComponent} */
  component?: UserComponent
  /** Component child of type {@link Child} */
  child?: Child
  /** Component options */
  options?: {
    [key: string]: unknown
  }
  /** Component menu items. See {@link MenuItem} and {@link MenuItemBuilder}  */
  menuItems?: (MenuItem | MenuItemBuilder)[]
  /** Component menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder} */
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
  canHandleIntent?: IntentChecker
}

/**
 * Interface for buildable generic list
 *
 * @public
 */
declare interface BuildableGenericList extends Partial<BaseGenericList> {
  /** List menu items array. See {@link MenuItem} and {@link MenuItemBuilder} */
  menuItems?: (MenuItem | MenuItemBuilder)[]
  /** List menu items groups array. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder} */
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
}

/**
 * Interface for buildable list
 *
 * @public
 */
declare interface BuildableList extends BuildableGenericList {
  /** List items. See {@link ListItem}, {@link ListItemBuilder} and {@link Divider} */
  items?: (ListItem | ListItemBuilder | Divider | DividerBuilder)[]
}

/**
 * @internal
 */
export declare const CalendarContext: Context<CalendarContextValue | undefined>

declare interface CalendarContextValue {
  date?: Date
  endDate?: Date
  focusedDate: Date
  selectRange?: boolean
  selectTime?: boolean
  /**
   * An integer indicating the first day of the week.
   * Can be either 1 (Monday), 6 (Saturday) or 7 (Sunday).
   */
  firstWeekDay: 1 | 6 | 7
}

/** @internal */
export declare const ChangeIndicatorTrackerContextGetSnapshot: Context<ChangeIndicatorTrackerGetSnapshotType>

/** @internal */
export declare const ChangeIndicatorTrackerContextStore: Context<ChangeIndicatorTrackerContextStoreType>

/**
 * @internal
 * @hidden
 */
declare type ChangeIndicatorTrackerContextStoreType =
  TrackerContextStore<ChangeIndicatorTrackerContextValue> | null

/** @internal */
declare type ChangeIndicatorTrackerContextValue = TrackedChange

/**
 * @internal
 * @hidden
 */
declare type ChangeIndicatorTrackerGetSnapshotType =
  TrackerContextGetSnapshot<ChangeIndicatorTrackerContextValue> | null

declare interface CheckPermissionInput {
  checkPermissionName: DocumentValuePermission
  document: Partial<SanityDocument> | null
}

/**
 * Child of a structure node
 * See {@link Collection}, {@link CollectionBuilder} and {@link ChildResolver}
 *
 * @public
 */
declare type Child = Collection | CollectionBuilder | ChildResolver

/**
 * @hidden
 * @beta */
declare interface ChildLinkProps {
  childId: string
  childParameters?: Record<string, string>
  childPayload?: unknown
  children?: ReactNode
}

/**
 * Interface for child observable
 *
 * @public
 */
declare interface ChildObservable {
  /** Subscribes to the child observable. See {@link ItemChild} */
  subscribe: (child: ItemChild | Promise<ItemChild>) => Record<string, unknown>
}

/**
 * Interface for child resolver
 *
 * @public */
declare interface ChildResolver {
  (
    itemId: string,
    options: ChildResolverOptions,
  ): ItemChild | Promise<ItemChild> | ChildObservable | Observable<ItemChild> | undefined
}

/**
 * Interface for child resolver options
 *
 * @public
 */
declare interface ChildResolverOptions {
  /** Child parent */
  parent: unknown
  /** Child index */
  index: number
  splitIndex: number
  /** Child path */
  path: string[]
  /** Child parameters */
  params: Record<string, string | undefined>
  /** Structure context. See {@link StructureContext} */
  structureContext: StructureContext
  /** Serialize options. See {@link SerializeOptions} */
  serializeOptions?: SerializeOptions
}

/**
 * @hidden
 * @beta */
declare type Chunk = {
  index: number
  id: string
  type: ChunkType
  start: number
  end: number
  startTimestamp: string
  endTimestamp: string
  authors: Set<string>
  draftState: 'present' | 'missing' | 'unknown'
  publishedState: 'present' | 'missing' | 'unknown'
}

/**
 * History timeline / chunking
 *
 *
 * @hidden
 * @beta
 */
declare type ChunkType =
  | 'initial'
  | 'create'
  | 'editDraft'
  | 'delete'
  | 'publish'
  | 'unpublish'
  | 'discardDraft'
  | 'editLive'

/**
 * Collection
 * See {@link List}, {@link DocumentList}, {@link EditorNode}, {@link DocumentNode} and {@link Component}
 *
 * @public
 */
declare type Collection = List | DocumentList | EditorNode | DocumentNode | Component

/**
 * Collection builder
 * See {@link ListBuilder}, {@link DocumentListBuilder}, {@link DocumentTypeListBuilder}, {@link DocumentBuilder} and {@link ComponentBuilder}
 *
 * @public
 */
declare type CollectionBuilder =
  | ListBuilder
  | DocumentListBuilder
  | DocumentTypeListBuilder
  | DocumentBuilder
  | ComponentBuilder

/**
 * The setter for ColorSchemeValueContext, in a separate context to avoid unnecessary re-renders
 * If set to false then the UI should adjust to reflect that the Studio can't change the color scheme
 * @internal
 */
export declare const ColorSchemeSetValueContext: Context<
  false | ((nextScheme: StudioThemeColorSchemeKey) => void) | null
>

/**
 * Used to keep track of the internal value, which can be "system" in addition to "light" and "dark"
 * @internal
 */
export declare const ColorSchemeValueContext: Context<StudioColorScheme | null>

/**
 * @hidden
 * @beta */
declare interface CombinedDocument {
  draft: Record<string, unknown> | null
  published: Record<string, unknown> | null
}

/**
 * All possible URL search parameters used by the Presentation tool
 * @public
 */
declare interface CombinedSearchParams
  extends StructureDocumentPaneParams, PresentationSearchParams {}

/** @internal */
declare interface CommandListHandle {
  focusInputElement: () => void
  focusListElement: () => void
  getTopIndex: () => number
  scrollToIndex: (index: number) => void
}

/**
 * @beta
 * @hidden
 */
declare interface CommentBaseCreatePayload {
  id?: CommentDocument['_id']
  message: CommentDocument['message']
  parentCommentId: CommentDocument['parentCommentId']
  reactions: CommentDocument['reactions']
  status: CommentDocument['status']
  threadId: CommentDocument['threadId']
  payload?: {
    fieldPath: string
  }
}

/**
 * @beta
 * @hidden
 */
declare interface CommentContext {
  tool: string
  payload?: Record<string, unknown>
  notification?: {
    documentTitle: string
    url?: string
    workspaceTitle: string
    workspaceName: string
    currentThreadLength?: number
    subscribers?: string[]
  }
  intent?: {
    title: string
    name: string
    params: IntentParameters
  }
}

declare interface CommentCreateFailedState {
  type: 'createError'
  error: Error
}

/**
 * @beta
 * @hidden
 */
declare type CommentCreatePayload = CommentTaskCreatePayload | CommentFieldCreatePayload

declare interface CommentCreateRetryingState {
  type: 'createRetrying'
}

/**
 * @beta
 * @hidden
 */
declare interface CommentDocument {
  _type: 'comment'
  _createdAt: string
  _id: string
  _rev: string
  _state?: CommentState
  authorId: string
  message: CommentMessage
  threadId: string
  parentCommentId?: string
  status: CommentStatus
  lastEditedAt?: string
  reactions: CommentReactionItem[] | null
  context?: CommentContext
  /**
   * A snapshot value of the content that the comment is related to.
   */
  contentSnapshot?: unknown
  target: {
    path?: CommentPath
    documentRevisionId?: string
    documentVersionId?: string
    documentType: string
    document:
      | {
          _dataset: string
          _projectId: string
          _ref: string
          _type: 'crossDatasetReference'
          _weak: boolean
        }
      | {
          _ref: string
          _type: 'reference'
          _weak: boolean
        }
  }
}

/**
 * @beta
 * @hidden
 */
declare interface CommentFieldCreatePayload extends CommentBaseCreatePayload {
  type: 'field'
  contentSnapshot?: CommentDocument['contentSnapshot']
  /**
   * The stringified path to the field where the comment was created.
   */
  fieldPath: string
  selection?: CommentPathSelection
}

/**
 * @internal
 */
export declare const CommentInputContext: Context<CommentInputContextValue | null>

declare interface CommentInputContextValue {
  canSubmit?: boolean
  closeMentions: () => void
  editor: PortableTextEditor
  expandOnFocus?: boolean
  focused: boolean
  focusEditor: () => void
  focusOnMount?: boolean
  hasChanges: boolean
  insertAtChar: () => void
  insertMention: (userId: string) => void
  mentionOptions: UserListWithPermissionsHookValue
  mentionsMenuOpen: boolean
  mentionsSearchTerm: string
  onBeforeInput: (event: InputEvent) => void
  openMentions: () => void
  readOnly: boolean
  value: CommentMessage
}

/**
 * @beta
 * @hidden
 */
declare type CommentIntentGetter = (comment: {
  id: string
  type: string
  path: string
}) => CommentContext['intent']

/**
 * @beta
 * @hidden
 */
declare type CommentListBreadcrumbs = CommentsListBreadcrumbItem[]

/**
 * @beta
 * @hidden
 */
declare type CommentMessage = PortableTextBlock[] | null

/**
 * @beta
 * @hidden
 */
declare interface CommentOperations {
  create: (comment: CommentCreatePayload) => Promise<void>
  react: (id: string, reaction: CommentReactionOption) => Promise<void>
  remove: (id: string) => Promise<void>
  update: (
    id: string,
    comment: CommentUpdatePayload,
    opts?: CommentUpdateOperationOptions,
  ) => Promise<void>
}

/**
 * @beta
 * @hidden
 */
declare interface CommentPath {
  field: string
  selection?: CommentPathSelection
}

declare type CommentPathSelection = CommentTextSelection

/**
 * @beta
 * @hidden
 */
declare type CommentPostPayload = Omit<CommentDocument, '_rev' | '_updatedAt' | '_createdAt'>

/**
 * @beta
 * @hidden
 */
declare interface CommentReactionItem {
  _key: string
  shortName: CommentReactionShortNames
  userId: string
  addedAt: string
  /**
   * This is a local value and is not stored on the server.
   * It is used to track the optimistic state of the reaction.
   */
  _optimisticState?: 'added' | 'removed'
}

/**
 * @beta
 * @hidden
 */
declare interface CommentReactionOption {
  shortName: CommentReactionShortNames
  title: string
}

/**
 * @beta
 * @hidden
 * The short names for the comment reactions.
 * We follow the convention for short names outlined in https://projects.iamcal.com/emoji-data/table.htm.
 */
declare type CommentReactionShortNames =
  | ':-1:'
  | ':+1:'
  | ':eyes:'
  | ':heart:'
  | ':heavy_plus_sign:'
  | ':rocket:'

/**
 * @beta
 * @hidden
 */
export declare const CommentsAuthoringPathContext: Context<CommentsAuthoringPathContextValue | null>

/**
 * @beta
 * @hidden
 */
declare interface CommentsAuthoringPathContextValue {
  setAuthoringPath: (nextAuthoringPath: string | null) => void
  authoringPath: string | null
}

/**
 * @internal
 */
export declare const CommentsContext: Context<CommentsContextValue | null>

/**
 * @beta
 * @hidden
 */
declare interface CommentsContextValue {
  documentId: string
  documentType: string
  getComment: (id: string) => CommentDocument | undefined
  getCommentLink?: (id: string) => string
  selectedCommentId?: string | undefined
  onClearSelectedComment?: () => void
  isCreatingDataset: boolean
  isCommentsOpen?: boolean
  onCommentsOpen?: () => void
  isConnecting?: boolean
  onPathOpen?: (path: Path) => void
  comments: {
    data: {
      open: CommentThreadItem[]
      resolved: CommentThreadItem[]
    }
    error: Error | null
    loading: boolean
  }
  operation: {
    create: CommentOperations['create']
    remove: CommentOperations['remove']
    update: CommentOperations['update']
    react: CommentOperations['react']
  }
  mentionOptions: UserListWithPermissionsHookValue
  status: CommentStatus
  setStatus: (status: CommentStatus) => void
}

/**
 * @internal
 */
export declare const CommentsEnabledContext: Context<CommentsEnabledContextValue>

declare type CommentsEnabledContextValue =
  | {
      enabled: false
      mode: null
    }
  | {
      enabled: true
      mode: CommentsUIMode
    }

/**
 * @internal
 */
export declare const CommentsIntentContext: Context<CommentIntentGetter | undefined>

/**
 * @beta
 * @hidden
 */
declare interface CommentsListBreadcrumbItem {
  invalid: boolean
  isArrayItem?: boolean
  title: string
}

/**
 * @internal
 */
export declare const CommentsOnboardingContext: Context<CommentsOnboardingContextValue | null>

declare interface CommentsOnboardingContextValue {
  isDismissed: boolean
  setDismissed: () => void
}

/**
 * @internal
 */
declare interface CommentsSelectedPath {
  origin: 'form' | 'inspector' | 'url'
  fieldPath: string | null
  threadId: string | null
}

/**
 * @internal
 */
export declare const CommentsSelectedPathContext: Context<CommentsSelectedPathContextValue | null>

/**
 * @internal
 */
declare interface CommentsSelectedPathContextValue {
  setSelectedPath: (nextSelectedPath: CommentsSelectedPath | null) => void
  selectedPath: CommentsSelectedPath | null
}

/**
 * The state is used to track the state of the comment (e.g. if it failed to be created, etc.)
 * It is a local value and is not stored on the server.
 * When there's no state, the comment is considered to be in a "normal" state (e.g. created successfully).
 *
 * The state value is primarily used to update the UI. That is, to show an error message or retry button.
 */
declare type CommentState = CommentCreateFailedState | CommentCreateRetryingState | undefined

/**
 * @beta
 * @hidden
 */
declare type CommentStatus = 'open' | 'resolved'

/**
 * @beta
 * @hidden
 */
declare interface CommentsTextSelectionItem {
  _key: string
  text: string
}

/**
 * @beta
 * @hidden
 */
declare type CommentsUIMode = 'default' | 'upsell'

/**
 * @internal
 */
export declare const CommentsUpsellContext: Context<CommentsUpsellContextValue | null>

declare interface CommentsUpsellContextValue {
  upsellDialogOpen: boolean
  handleOpenDialog: (source: UpsellDialogViewedInfo['source']) => void
  handleClose: () => void
  upsellData: UpsellData | null
  telemetryLogs: {
    dialogSecondaryClicked: () => void
    dialogPrimaryClicked: () => void
    panelViewed: (source: UpsellDialogViewedInfo['source']) => void
    panelDismissed: () => void
    panelPrimaryClicked: () => void
    panelSecondaryClicked: () => void
  }
}

/**
 * @beta
 * @hidden
 */
declare interface CommentTaskCreatePayload extends CommentBaseCreatePayload {
  type: 'task'
  context: {
    notification: CommentContext['notification']
  }
}

/**
 * @beta
 * @hidden
 */
declare interface CommentTextSelection {
  type: 'text'
  value: CommentsTextSelectionItem[]
}

/**
 * @beta
 * @hidden
 */
declare interface CommentThreadItem {
  breadcrumbs: CommentListBreadcrumbs
  commentsCount: number
  fieldPath: string
  hasReferencedValue: boolean
  parentComment: CommentDocument
  replies: CommentDocument[]
  threadId: string
}

/**
 * @beta
 * @hidden
 */
declare interface CommentUpdateOperationOptions {
  throttled: boolean
}

/**
 * @beta
 * @hidden
 */
declare type CommentUpdatePayload = Partial<Omit<CommentPostPayload, '_id' | '_type'>>

/**
 * @hidden
 * @beta */
declare interface CommittedEvent {
  type: 'committed'
}

declare interface CompatibleStudioAppId {
  /**
   * AppId to use for the current origin
   */
  appId: string | undefined
  /**
   * All available studio apps
   */
  studioApps: StudioApp[]
}

/**
 * @hidden
 * @beta */
declare interface ComplexElementProps {
  'id': string
  'onFocus': FocusEventHandler
  'onBlur': FocusEventHandler
  'ref': MutableRefObject<any>
  'aria-describedby': string | undefined
}

/**
 * @hidden
 * @beta */
declare interface ComplexElementProps_2 {
  'id': string
  'onFocus': FocusEventHandler
  'onBlur': FocusEventHandler
  'ref': MutableRefObject<any>
  'aria-describedby': string | undefined
}

/**
 * Interface for component
 *
 * @public
 */
declare interface Component extends StructureNode {
  /** Component of type {@link UserComponent} */
  component: UserComponent
  /** Component child of type {@link Child} */
  child?: Child
  /** Component menu items, array of type {@link MenuItem} */
  menuItems: MenuItem[]
  /** Component menu item group, array of type {@link MenuItemGroup} */
  menuItemGroups: MenuItemGroup[]
  /** Component options */
  options: {
    [key: string]: unknown
  }
  canHandleIntent?: IntentChecker
}

/**
 * Class for building components
 *
 * @public
 */
declare class ComponentBuilder implements Serializable_2<Component> {
  /** component builder option object */
  protected spec: BuildableComponent
  constructor(spec?: ComponentInput)
  /** Set Component ID
   * @param id - component ID
   * @returns component builder based on ID provided
   */
  id(id: string): ComponentBuilder
  /** Get ID
   * @returns ID
   */
  getId(): BuildableComponent['id']
  /** Set Component title
   * @param title - component title
   * @returns component builder based on title provided (and ID)
   */
  title(title: string): ComponentBuilder
  /** Get Component title
   * @returns title
   */
  getTitle(): BuildableComponent['title']
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n: I18nTextRecord<'title'>): ComponentBuilder
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n(): I18nTextRecord<'title'> | undefined
  /** Set Component child
   * @param child - child component
   * @returns component builder based on child component provided
   */
  child(child: Child): ComponentBuilder
  /** Get Component child
   * @returns child component
   */
  getChild(): BuildableComponent['child']
  /** Set component
   * @param component - user built component
   * @returns component builder based on component provided
   */
  component(component: UserComponent): ComponentBuilder
  /** Get Component
   * @returns component
   */
  getComponent(): BuildableComponent['component']
  /** Set Component options
   * @param options - component options
   * @returns component builder based on options provided
   */
  options(options: {[key: string]: unknown}): ComponentBuilder
  /** Get Component options
   * @returns component options
   */
  getOptions(): NonNullable<BuildableComponent['options']>
  /** Set Component menu items
   * @param menuItems - component menu items
   * @returns component builder based on menuItems provided
   */
  menuItems(menuItems: (MenuItem | MenuItemBuilder)[]): ComponentBuilder
  /** Get Component menu items
   * @returns menu items
   */
  getMenuItems(): BuildableComponent['menuItems']
  /** Set Component menu item groups
   * @param menuItemGroups - component menu item groups
   * @returns component builder based on menuItemGroups provided
   */
  menuItemGroups(menuItemGroups: (MenuItemGroup | MenuItemGroupBuilder)[]): ComponentBuilder
  /** Get Component menu item groups
   * @returns menu item groups
   */
  getMenuItemGroups(): BuildableComponent['menuItemGroups']
  canHandleIntent(canHandleIntent: IntentChecker): ComponentBuilder
  /** Serialize component
   * @param options - serialization options
   * @returns component object based on path provided in options
   *
   */
  serialize(options?: SerializeOptions): Component
  /** Clone component builder (allows for options overriding)
   * @param withSpec - component builder options
   * @returns cloned builder
   */
  clone(withSpec?: BuildableComponent): ComponentBuilder
}

/**
 * Interface for component input
 *
 * @public
 */
declare interface ComponentInput extends StructureNode {
  /** Component of type {@link UserComponent} */
  component: UserComponent
  /** Component child of type {@link Child} */
  child?: Child
  /** Component options */
  options?: {
    [key: string]: unknown
  }
  /** Component menu items. See {@link MenuItem} and {@link MenuItemBuilder}  */
  menuItems?: (MenuItem | MenuItemBuilder)[]
  /** Component menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder} */
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
}

/**
 * Interface for component views.
 *
 * @public */
declare interface ComponentView<TOptions = Record<string, any>> extends BaseView {
  type: 'component'
  /** Component view components. See {@link UserViewComponent} */
  component: UserViewComponent
  /** Component view options */
  options: TOptions
}

/**
 * Class for building a component view.
 *
 * @public */
declare class ComponentViewBuilder extends GenericViewBuilder<
  Partial<ComponentView>,
  ComponentViewBuilder
> {
  /** Partial Component view option object. See {@link ComponentView} */
  protected spec: Partial<ComponentView>
  constructor(
    /**
     * Component view component or spec
     * @param componentOrSpec - user view component or partial component view. See {@link UserViewComponent} and {@link ComponentView}
     */
    componentOrSpec?: UserViewComponent | Partial<ComponentView>,
  )
  /** Set view Component
   * @param component - component view component. See {@link UserViewComponent}
   * @returns component view builder based on component view provided. See {@link ComponentViewBuilder}
   */
  component(component: UserViewComponent): ComponentViewBuilder
  /** Get view Component
   * @returns Partial component view. See {@link ComponentView}
   */
  getComponent(): Partial<ComponentView>['component']
  /** Set view Component options
   * @param options - component view options
   * @returns component view builder based on options provided. See {@link ComponentViewBuilder}
   */
  options(options: {[key: string]: any}): ComponentViewBuilder
  /** Get view Component options
   * @returns component view options. See {@link ComponentView}
   */
  getOptions(): ComponentView['options']
  /** Serialize view Component
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns component view based on path provided in options. See {@link ComponentView}
   *
   */
  serialize(options?: SerializeOptions): ComponentView
  /** Clone Component view builder (allows for options overriding)
   * @param withSpec - partial for component view option. See {@link ComponentView}
   * @returns component view builder. See {@link ComponentViewBuilder}
   */
  clone(withSpec?: Partial<ComponentView>): ComponentViewBuilder
}

/** @public */
declare type ComposableOption<TValue, TContext> = (prev: TValue, context: TContext) => TValue

/** @public */
declare type ComposableOption_2<TValue, TContext> = (prev: TValue, context: TContext) => TValue

/**
 * @public
 */
declare type ComputeDiff<Annotation> = (value: unknown) => Diff<Annotation>

/**
 * @public
 */
declare type ComputeDiff_2<Annotation> = (value: unknown) => Diff<Annotation>

/** @public */
declare interface ConfigContext {
  /**
   * The ID of the project.
   */
  projectId: string
  /**
   * The name of the dataset.
   */
  dataset: string
  /**
   * The schema for this source.
   */
  schema: Schema
  /**
   * The current user or `null` if not authenticated.
   */
  currentUser: CurrentUser | null
  /**
   * A function that returns a Sanity client with the {@link SourceClientOptions | specified options}.
   */
  getClient: (options: SourceClientOptions) => SanityClient
  /**
   * Localization resources
   */
  i18n: LocaleSource
  /** @beta */
  [DECISION_PARAMETERS_SCHEMA]?: DecisionParametersConfig
}

/** @public */
declare interface ConfigContext_2 {
  /**
   * The ID of the project.
   */
  projectId: string
  /**
   * The name of the dataset.
   */
  dataset: string
  /**
   * The schema for this source.
   */
  schema: Schema
  /**
   * The current user or `null` if not authenticated.
   */
  currentUser: CurrentUser | null
  /**
   * A function that returns a Sanity client with the {@link SourceClientOptions | specified options}.
   */
  getClient: (options: SourceClientOptions_2) => SanityClient
  /**
   * Localization resources
   */
  i18n: LocaleSource_2
  /** @beta */
  [DECISION_PARAMETERS_SCHEMA_2]?: DecisionParametersConfig_2
}

/**
 * Represents the connection status between the Sanity Studio and Presentation's preview iframe.
 * @public
 */
declare type ConnectionStatus = 'connected' | 'connecting' | 'reconnecting' | 'idle'

/** @internal */
declare interface ConnectorContextValue {
  isReviewChangesOpen: boolean
  onOpenReviewChanges: () => void | undefined
  onSetFocus: (nextPath: Path) => void | undefined
  isInteractive?: boolean
}

declare interface Context_2 {
  url: URL | null
  error: Error | null
  visualEditingOverlaysEnabled: boolean
}

declare interface Context_3 {
  initialUrl: URL | null
  previewUrl: URL | null
  allowOrigins: URLPattern[] | null
  error: Error | null
  previewSearchParam: string | null
  previewUrlSecret: {
    secret: string
    expiresAt: Date
  } | null
  previewAccessSharingCreatePermission: PermissionCheckResult | null
  previewAccessSharingReadPermission: PermissionCheckResult | null
  previewAccessSharingUpdatePermission: PermissionCheckResult | null
  previewUrlSecretPermission: PermissionCheckResult | null
  previewMode: PreviewUrlPreviewMode | null
}

/**
 * Generic function type used in `DocumentResolver` definitions that receives a `DocumentResolverContext` and returns a computed value.
 * @param context - `DocumentResolverContext` containing route information (origin, params, path)
 * @returns Computed value based on the context (typically a string for filters or an object for parameters)
 * @public
 */
declare type ContextFn<T> = (context: DocumentResolverContext) => T

/**
 * @beta
 * @hidden
 */
declare interface CopyOptions extends BaseOptions {
  patchType?: 'replace' | 'append'
}

/**
 * @beta
 * @hidden
 */
export declare const CopyPasteContext: Context<CopyPasteContextType | null>

/**
 * @beta
 * @hidden
 */
declare interface CopyPasteContextType {
  setDocumentMeta: (documentMeta: DocumentMeta) => void
  onCopy: (path: Path, value: FormDocumentValue | undefined, options: CopyOptions) => Promise<void>
  onPaste: (
    targetPath: Path,
    value: FormDocumentValue | undefined,
    options: PasteOptions,
  ) => Promise<void>
}

/**
 * @hidden
 * @beta
 */
declare interface CreateDocumentVersionEvent extends BaseEvent {
  type: 'createDocumentVersion'
  documentId: string
  releaseId?: string
  versionId: string
  versionRevisionId: string
  /**
   * This is undefined for versions and drafts. (will be present only in publish document?)
   */
  revisionId?: string
  /**
   * This is present when this creation event is already published.
   */
  parentId?: string
}

/**
 * @hidden
 * @beta
 */
declare interface CreateDocumentVersionEvent_2 extends BaseEvent_2 {
  type: 'createDocumentVersion'
  documentId: string
  releaseId?: string
  versionId: string
  versionRevisionId: string
  /**
   * This is undefined for versions and drafts. (will be present only in publish document?)
   */
  revisionId?: string
  /**
   * This is present when this creation event is already published.
   */
  parentId?: string
}

/** @internal */
declare interface CreateLinkedActionsProps {
  metadata: CreateLinkMetadata
  panelPortalElementId: string
  onDocumentChange: (patchEvent: PatchEvent) => void
  documentTitle?: string
}

/** @internal */
declare interface CreateLinkedDocumentBannerContentProps {
  metadata: CreateLinkMetadata
}

/** @internal */
declare interface CreateLinkMetadata {
  /** Create document ID */
  _id: string
  /** Create user dataset ID */
  dataset: string
  /**  If false, document should be put in a limited read-only state. */
  ejected: boolean
  /**  set if Create document originates non-default origin */
  host?: string
}

/**
 * @hidden
 * @beta
 */
declare interface CreateLiveDocumentEvent extends BaseEvent {
  type: 'createLiveDocument'
  documentId: string
  revisionId: string
  author: string
}

/**
 * @hidden
 * @beta
 */
declare interface CreateLiveDocumentEvent_2 extends BaseEvent_2 {
  type: 'createLiveDocument'
  documentId: string
  revisionId: string
  author: string
}

/** @internal */
declare interface CustomComponentPaneNode extends BaseResolvedPaneNode<'component'> {
  component: UserComponent
  options?: Record<string, unknown>
}

/**
 * Symbol for configuring decision parameters schema
 * @beta
 */
declare const DECISION_PARAMETERS_SCHEMA: unique symbol

/**
 * Symbol for configuring decision parameters schema
 * @beta
 */
declare const DECISION_PARAMETERS_SCHEMA_2: unique symbol

/**
 * Configuration for decision parameters
 * @beta
 */
declare interface DecisionParametersConfig {
  [key: string]: string[]
}

/**
 * Configuration for decision parameters
 * @beta
 */
declare interface DecisionParametersConfig_2 {
  [key: string]: string[]
}

/** @beta */
declare type DefaultPluginsWorkspaceOptions = {
  tasks: {
    enabled: boolean
  }
  scheduledDrafts: {
    enabled: boolean
  }
  scheduledPublishing: ScheduledPublishingPluginOptions
  releases: {
    enabled?: boolean
    /**
     * Limit the number of releases that can be created by this workspace.
     */
    limit?: number
    /**
     * Actions for releases.
     */
    actions?: ReleaseActionComponent[] | ReleaseActionsResolver
  }
  mediaLibrary?: MediaLibraryConfig
}

/** @beta */
declare type DefaultPluginsWorkspaceOptions_2 = {
  tasks: {
    enabled: boolean
  }
  scheduledDrafts: {
    enabled: boolean
  }
  scheduledPublishing: ScheduledPublishingPluginOptions_2
  releases: {
    enabled?: boolean
    /**
     * Limit the number of releases that can be created by this workspace.
     */
    limit?: number
    /**
     * Actions for releases.
     */
    actions?: ReleaseActionComponent_2[] | ReleaseActionsResolver_2
  }
  mediaLibrary?: MediaLibraryConfig_2
}

/**
 * @hidden
 * @beta
 */
declare interface DeleteDocumentGroupEvent extends BaseEvent {
  type: 'deleteDocumentGroup'
  documentId: string
  author: string
}

/**
 * @hidden
 * @beta
 */
declare interface DeleteDocumentGroupEvent_2 extends BaseEvent_2 {
  type: 'deleteDocumentGroup'
  documentId: string
  author: string
}

/**
 * @hidden
 * @beta
 */
declare interface DeleteDocumentVersionEvent extends BaseEvent {
  type: 'deleteDocumentVersion'
  documentId: string
  releaseId?: string
  versionId: string
  versionRevisionId: string
  /**
   * This is added client side to enhance the UI.
   * For draft documents, it indicates the event that created this document that was later published
   * It will be used to expand the publish view.
   */
  creationEvent?: CreateDocumentVersionEvent
}

/**
 * @hidden
 * @beta
 */
declare interface DeleteDocumentVersionEvent_2 extends BaseEvent_2 {
  type: 'deleteDocumentVersion'
  documentId: string
  releaseId?: string
  versionId: string
  versionRevisionId: string
  /**
   * This is added client side to enhance the UI.
   * For draft documents, it indicates the event that created this document that was later published
   * It will be used to expand the publish view.
   */
  creationEvent?: CreateDocumentVersionEvent_2
}

/**
 * @deprecated the `previewUrl.initial`, `previewUrl.allowOrigins` and `previewUrl.previewMode.enable` supports async functions that offer advanced control over how preview URLs are resolved
 * @public
 */
declare type DeprecatedPreviewUrlResolver = PreviewUrlResolver<SanityClient>

declare type DialogMode = 'card' | 'help_menu'

/** @internal */
export declare const DiffContext: Context<{
  path: Path
}>

/**
 * A `Divider` is a visual separator in the structure tree.
 *
 * @public
 */
declare interface Divider {
  /**
   * The divider's ID
   */
  id: string
  type: 'divider'
  /**
   * The divider's title
   */
  title?: string
  /**
   * The i18n key and namespace used to populate the localized title
   */
  i18n?: I18nTextRecord<'title'>
}

declare class DividerBuilder implements Serializable_2<Divider> {
  protected spec: Divider
  constructor(spec?: Divider)
  /** Set the title of the divider
   * @param title - the title of the divider
   * @returns divider builder based on title provided
   */
  title(title: string): DividerBuilder
  /** Get the title of the divider
   * @returns the title of the divider
   */
  getTitle(): Divider['title']
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns divider builder based on i18n key and ns provided
   */
  i18n(i18n: I18nTextRecord<'title'>): DividerBuilder
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n(): I18nTextRecord<'title'> | undefined
  /** Serialize the divider
   * @returns the serialized divider
   */
  serialize(): Divider
  /** Clone divider builder (allows for options overriding)
   * @param withSpec - divider builder options
   * @returns cloned builder
   */
  clone(withSpec?: Partial<Divider>): DividerBuilder
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionComponent extends ActionComponent<
  DocumentActionProps,
  DocumentActionDescription
> {
  /**
   * An optional meta property that can used to replace this document action
   * with another. E.g.:
   *
   * ```js
   * import {defineConfig} from 'sanity'
   * import {MyPublishAction} from '...'
   *
   * export default defineConfig({
   *   document: {
   *     actions: (prev) =>
   *       prev.map((previousAction) =>
   *         previousAction.action === 'publish' ? MyPublishAction : previousAction
   *       ),
   *   },
   * })
   * ```
   */
  action?: SanityDefinedAction
  /**
   * For debugging purposes
   */
  displayName?: string
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionComponent_2 extends ActionComponent_2<
  DocumentActionProps_2,
  DocumentActionDescription_2
> {
  /**
   * An optional meta property that can used to replace this document action
   * with another. E.g.:
   *
   * ```js
   * import {defineConfig} from 'sanity'
   * import {MyPublishAction} from '...'
   *
   * export default defineConfig({
   *   document: {
   *     actions: (prev) =>
   *       prev.map((previousAction) =>
   *         previousAction.action === 'publish' ? MyPublishAction : previousAction
   *       ),
   *   },
   * })
   * ```
   */
  action?: SanityDefinedAction_2
  /**
   * For debugging purposes
   */
  displayName?: string
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionConfirmDialogProps {
  type: 'confirm'
  tone?: ButtonTone
  message: ReactNode
  onConfirm: () => void
  onCancel: () => void
  cancelButtonIcon?: ComponentType | ReactNode
  cancelButtonText?: string
  confirmButtonIcon?: ComponentType | ReactNode
  confirmButtonText?: string
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionConfirmDialogProps_2 {
  type: 'confirm'
  tone?: ButtonTone
  message: ReactNode
  onConfirm: () => void
  onCancel: () => void
  cancelButtonIcon?: ComponentType | ReactNode
  cancelButtonText?: string
  confirmButtonIcon?: ComponentType | ReactNode
  confirmButtonText?: string
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionCustomDialogComponentProps {
  type: 'custom'
  component: ReactNode
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionCustomDialogComponentProps_2 {
  type: 'custom'
  component: ReactNode
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentActionDescription extends GroupableActionDescription<DocumentActionGroup> {
  dialog?: DocumentActionDialogProps | false | null
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentActionDescription_2 extends GroupableActionDescription_2<DocumentActionGroup_2> {
  dialog?: DocumentActionDialogProps_2 | false | null
}

/**
 * @hidden
 * @beta */
declare type DocumentActionDialogProps =
  | DocumentActionConfirmDialogProps
  | DocumentActionPopoverDialogProps
  | DocumentActionModalDialogProps
  | DocumentActionCustomDialogComponentProps

/**
 * @hidden
 * @beta */
declare type DocumentActionDialogProps_2 =
  | DocumentActionConfirmDialogProps_2
  | DocumentActionPopoverDialogProps_2
  | DocumentActionModalDialogProps_2
  | DocumentActionCustomDialogComponentProps_2

/**
 * @hidden
 * @beta */
declare type DocumentActionGroup = 'default' | 'paneActions'

/**
 * @hidden
 * @beta */
declare type DocumentActionGroup_2 = 'default' | 'paneActions'

/**
 * @hidden
 * @beta */
declare interface DocumentActionModalDialogProps {
  type?: 'dialog'
  content: ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  footer?: DialogProps['footer']
  /**
   *
   * @hidden
   * @beta
   */
  header?: ReactNode
  onClose: () => void
  showCloseButton?: boolean
  /**
   *
   * @hidden
   * @beta
   */
  width?: 'small' | 'medium' | 'large' | 'full'
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionModalDialogProps_2 {
  type?: 'dialog'
  content: ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  footer?: DialogProps['footer']
  /**
   *
   * @hidden
   * @beta
   */
  header?: ReactNode
  onClose: () => void
  showCloseButton?: boolean
  /**
   *
   * @hidden
   * @beta
   */
  width?: 'small' | 'medium' | 'large' | 'full'
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionPopoverDialogProps {
  type: 'popover'
  content: ReactNode
  onClose: () => void
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionPopoverDialogProps_2 {
  type: 'popover'
  content: ReactNode
  onClose: () => void
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionProps extends EditStateFor {
  revision?: string
  /**
   * @deprecated - do not use, will be removed in a future major version, use local state instead, for example call `setDialogOpen(false)` in dialog's `onCancel` callback.
   */
  onComplete: () => void
  /**
   * Whether the initial value has been resolved.
   */
  initialValueResolved: boolean
}

/**
 * @hidden
 * @beta */
declare interface DocumentActionProps_2 extends EditStateFor_2 {
  revision?: string
  /**
   * @deprecated - do not use, will be removed in a future major version, use local state instead, for example call `setDialogOpen(false)` in dialog's `onCancel` callback.
   */
  onComplete: () => void
  /**
   * Whether the initial value has been resolved.
   */
  initialValueResolved: boolean
}

/**
 * @internal
 */
export declare const DocumentActionPropsContext: Context<DocumentActionProps | undefined>

/**
 * @hidden
 * @beta
 */
declare interface DocumentActionsContext extends ConfigContext {
  documentId?: string
  schemaType: string
  /** releaseId of the open document, it's undefined if it's published or the draft */
  releaseId: string | undefined
  /** the type of the currently active document. */
  versionType: DocumentActionsVersionType
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentActionsContext_2 extends ConfigContext_2 {
  documentId?: string
  schemaType: string
  /** releaseId of the open document, it's undefined if it's published or the draft */
  releaseId: string | undefined
  /** the type of the currently active document. */
  versionType: DocumentActionsVersionType_2
}

/**
 * @hidden
 * @beta
 */
declare type DocumentActionsResolver = ComposableOption<
  DocumentActionComponent[],
  DocumentActionsContext
>

/**
 * @hidden
 * @beta
 */
declare type DocumentActionsResolver_2 = ComposableOption_2<
  DocumentActionComponent_2[],
  DocumentActionsContext_2
>

/**
 * @internal
 */
export declare const DocumentActionsStateContext: Context<DocumentActionDescription[] | null>

/**
 * @hidden
 * @beta
 */
declare type DocumentActionsVersionType =
  | 'published'
  | 'draft'
  | 'revision'
  | 'version'
  | 'scheduled-draft'

/**
 * @hidden
 * @beta
 */
declare type DocumentActionsVersionType_2 =
  | 'published'
  | 'draft'
  | 'revision'
  | 'version'
  | 'scheduled-draft'

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeComponent extends HookCollectionActionHook<
  DocumentBadgeProps,
  DocumentBadgeDescription
> {
  (props: DocumentBadgeProps): DocumentBadgeDescription | null
}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeComponent_2 extends HookCollectionActionHook_2<
  DocumentBadgeProps_2,
  DocumentBadgeDescription_2
> {
  (props: DocumentBadgeProps_2): DocumentBadgeDescription_2 | null
}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeDescription {
  title?: string
  label?: string | undefined
  color?: 'primary' | 'success' | 'warning' | 'danger'
  icon?: ReactNode | ComponentType
}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeDescription_2 {
  title?: string
  label?: string | undefined
  color?: 'primary' | 'success' | 'warning' | 'danger'
  icon?: ReactNode | ComponentType
}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeProps extends EditStateFor {}

/**
 * @hidden
 * @beta */
declare interface DocumentBadgeProps_2 extends EditStateFor_2 {}

/**
 * @hidden
 * @beta
 */
declare interface DocumentBadgesContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentBadgesContext_2 extends ConfigContext_2 {
  documentId?: string
  schemaType: string
}

/**
 * @hidden
 * @beta
 */
declare type DocumentBadgesResolver = ComposableOption<
  DocumentBadgeComponent[],
  DocumentBadgesContext
>

/**
 * @hidden
 * @beta
 */
declare type DocumentBadgesResolver_2 = ComposableOption_2<
  DocumentBadgeComponent_2[],
  DocumentBadgesContext_2
>

/**
 * A `DocumentBuilder` is used to build a document node.
 *
 * @public */
declare class DocumentBuilder implements Serializable_2<DocumentNode> {
  /** Component builder option object See {@link PartialDocumentNode} */
  protected spec: PartialDocumentNode
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: PartialDocumentNode,
  )
  /** Set Document Builder ID
   * @param id - document builder ID
   * @returns document builder based on ID provided. See {@link DocumentBuilder}
   */
  id(id: string): DocumentBuilder
  /** Get Document Builder ID
   * @returns document ID. See {@link PartialDocumentNode}
   */
  getId(): PartialDocumentNode['id']
  /** Set Document title
   * @param title - document title
   * @returns document builder based on title provided (and ID). See {@link DocumentBuilder}
   */
  title(title: string): DocumentBuilder
  /** Get Document title
   * @returns document title. See {@link PartialDocumentNode}
   */
  getTitle(): PartialDocumentNode['title']
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n: I18nTextRecord<'title'>): DocumentBuilder
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n(): I18nTextRecord<'title'> | undefined
  /** Set Document child
   * @param child - document child
   * @returns document builder based on child provided. See {@link DocumentBuilder}
   */
  child(child: Child): DocumentBuilder
  /** Get Document child
   * @returns document child. See {@link PartialDocumentNode}
   */
  getChild(): PartialDocumentNode['child']
  /** Set Document ID
   * @param documentId - document ID
   * @returns document builder with document based on ID provided. See {@link DocumentBuilder}
   */
  documentId(documentId: string): DocumentBuilder
  /** Get Document ID
   * @returns document ID. See {@link DocumentOptions}
   */
  getDocumentId(): Partial<DocumentOptions>['id']
  /** Set Document Type
   * @param documentType - document type
   * @returns document builder with document based on type provided. See {@link DocumentBuilder}
   */
  schemaType(documentType: SchemaType | string): DocumentBuilder
  /** Get Document Type
   * @returns document type. See {@link DocumentOptions}
   */
  getSchemaType(): Partial<DocumentOptions>['type']
  /** Set Document Template
   * @param templateId - document template ID
   * @param parameters - document template parameters
   * @returns document builder with document based on template provided. See {@link DocumentBuilder}
   */
  initialValueTemplate(templateId: string, parameters?: Record<string, unknown>): DocumentBuilder
  /** Get Document Template
   * @returns document template. See {@link DocumentOptions}
   */
  getInitialValueTemplate(): Partial<DocumentOptions>['template']
  /** Get Document's initial value Template parameters
   * @returns document template parameters. See {@link DocumentOptions}
   */
  getInitialValueTemplateParameters(): Partial<DocumentOptions>['templateParameters']
  /** Set Document views
   * @param views - document views. See {@link ViewBuilder} and {@link View}
   * @returns document builder with document based on views provided. See {@link DocumentBuilder}
   */
  views(views: (View | ViewBuilder)[]): DocumentBuilder
  /** Get Document views
   * @returns document views. See {@link ViewBuilder} and {@link View}
   */
  getViews(): (View | ViewBuilder)[]
  /** Serialize Document builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document node based on path, index and hint provided in options. See {@link DocumentNode}
   */
  serialize({path, index, hint}?: SerializeOptions): DocumentNode
  /** Clone Document builder
   * @param withSpec - partial document node specification used to extend the cloned builder. See {@link PartialDocumentNode}
   * @returns document builder based on context and spec provided. See {@link DocumentBuilder}
   */
  clone(withSpec?: PartialDocumentNode): DocumentBuilder
}

/** @internal */
export declare const DocumentChangeContext: Context<DocumentChangeContextInstance | null>

/** @internal */
declare type DocumentChangeContextInstance = {
  documentId: string
  schemaType: SchemaType
  rootDiff: ObjectDiff | null
  isComparingCurrent: boolean
  FieldWrapper: ComponentType<{
    path: Path
    children: ReactNode
    hasRevertHover: boolean
  }>
  value: Partial<SanityDocument>
  /**
   * When comparing two values it decides if it shows the original "from" value in the Diff components.
   * Useful for the DocumentDiff in releases when showing the diff for a new document.
   */
  showFromValue: boolean
}

/** @hidden @beta */
declare interface DocumentCommentsEnabledContext {
  documentId?: string
  documentType: string
}

/** @hidden @beta */
declare interface DocumentCommentsEnabledContext_2 {
  documentId?: string
  documentType: string
}

declare interface DocumentComponents {
  /** @internal */
  unstable_layout?: ComponentType<DocumentLayoutProps>
}

declare interface DocumentComponents_2 {
  /** @internal */
  unstable_layout?: ComponentType<DocumentLayoutProps_2>
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldAction {
  name: string
  useAction: DocumentFieldActionHook
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldAction_2 {
  name: string
  useAction: DocumentFieldActionHook_2
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionDivider {
  type: 'divider'
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionDivider_2 {
  type: 'divider'
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionGroup {
  type: 'group'
  children: DocumentFieldActionNode[]
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  expanded?: boolean
  hidden?: boolean
  icon?: ComponentType
  renderAsButton?: boolean
  status?: DocumentFieldActionStatus
  title: string
  i18n?: I18nTextRecord<'title'>
  tone?: DocumentFieldActionTone
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionGroup_2 {
  type: 'group'
  children: DocumentFieldActionNode_2[]
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  expanded?: boolean
  hidden?: boolean
  icon?: ComponentType
  renderAsButton?: boolean
  status?: DocumentFieldActionStatus_2
  title: string
  i18n?: I18nTextRecord<'title'>
  tone?: DocumentFieldActionTone_2
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionHook {
  (props: DocumentFieldActionProps): DocumentFieldActionItem | DocumentFieldActionGroup
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionHook_2 {
  (props: DocumentFieldActionProps_2): DocumentFieldActionItem_2 | DocumentFieldActionGroup_2
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionItem {
  type: 'action'
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  hidden?: boolean
  icon?: ComponentType
  iconRight?: ComponentType
  onAction: () => void
  renderAsButton?: boolean
  selected?: boolean
  status?: DocumentFieldActionStatus
  title: string
  i18n?: I18nTextRecord<'title'>
  tone?: DocumentFieldActionTone
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionItem_2 {
  type: 'action'
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  hidden?: boolean
  icon?: ComponentType
  iconRight?: ComponentType
  onAction: () => void
  renderAsButton?: boolean
  selected?: boolean
  status?: DocumentFieldActionStatus_2
  title: string
  i18n?: I18nTextRecord<'title'>
  tone?: DocumentFieldActionTone_2
}

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionNode =
  | DocumentFieldActionItem
  | DocumentFieldActionGroup
  | DocumentFieldActionDivider

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionNode_2 =
  | DocumentFieldActionItem_2
  | DocumentFieldActionGroup_2
  | DocumentFieldActionDivider_2

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionProps {
  documentId: string
  documentType: string
  path: Path
  schemaType: SchemaType
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionProps_2 {
  documentId: string
  documentType: string
  path: Path
  schemaType: SchemaType
}

/**
 * @internal
 */
export declare const DocumentFieldActionsContext: Context<DocumentFieldActionsContextValue | null>

/**
 * @internal
 */
export declare interface DocumentFieldActionsContextValue {
  actions: DocumentFieldAction[]
}

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionsResolver = ComposableOption<
  DocumentFieldAction[],
  DocumentFieldActionsResolverContext
>

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionsResolver_2 = ComposableOption_2<
  DocumentFieldAction_2[],
  DocumentFieldActionsResolverContext_2
>

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionsResolverContext extends ConfigContext {
  documentId: string
  documentType: string
  schemaType: SchemaType
}

/**
 * @hidden
 * @beta */
declare interface DocumentFieldActionsResolverContext_2 extends ConfigContext_2 {
  documentId: string
  documentType: string
  schemaType: SchemaType
}

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionStatus = 'info' | 'success' | 'warning' | 'error'

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionStatus_2 = 'info' | 'success' | 'warning' | 'error'

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionTone = 'primary' | 'positive' | 'caution' | 'critical'

/**
 * @hidden
 * @beta */
declare type DocumentFieldActionTone_2 = 'primary' | 'positive' | 'caution' | 'critical'

/** @internal */
declare type DocumentFormNode<
  T extends {
    [key in string]: unknown
  } = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
> = ObjectFormNode_2<T, S>

/**
 * Events relevant for the whole document group.
 * @hidden
 * @beta
 */
declare type DocumentGroupEvent =
  | CreateDocumentVersionEvent
  | DeleteDocumentVersionEvent
  | PublishDocumentVersionEvent
  | UnpublishDocumentEvent
  | ScheduleDocumentVersionEvent
  | UnscheduleDocumentVersionEvent
  | DeleteDocumentGroupEvent
  | CreateLiveDocumentEvent
  | UpdateLiveDocumentEvent
  | EditDocumentVersionEvent
  | HistoryClearedEvent

/**
 * Events relevant for the whole document group.
 * @hidden
 * @beta
 */
declare type DocumentGroupEvent_2 =
  | CreateDocumentVersionEvent_2
  | DeleteDocumentVersionEvent_2
  | PublishDocumentVersionEvent_2
  | UnpublishDocumentEvent_2
  | ScheduleDocumentVersionEvent_2
  | UnscheduleDocumentVersionEvent_2
  | DeleteDocumentGroupEvent_2
  | CreateLiveDocumentEvent_2
  | UpdateLiveDocumentEvent_2
  | EditDocumentVersionEvent_2
  | HistoryClearedEvent_2

/**
 * @internal
 */
export declare const DocumentIdContext: Context<DocumentIdContextValue | null>

/**
 * @internal
 */
export declare interface DocumentIdContextValue {
  id: string
}

declare interface DocumentInRelease {
  memoKey: string
  isPending?: boolean
  document: SanityDocument & {
    publishedDocumentExists: boolean
  }
  validation: DocumentValidationStatus
}

declare interface DocumentInRelease_2 {
  memoKey: string
  isPending?: boolean
  document: SanityDocument & {
    publishedDocumentExists: boolean
  }
  validation: DocumentValidationStatus_2
}

/** @hidden @beta */
declare interface DocumentInspector {
  name: string
  component: DocumentInspectorComponent
  /**
   * Hook for defining a menu item for the inspector.
   */
  useMenuItem?: (props: DocumentInspectorUseMenuItemProps) => DocumentInspectorMenuItem
  /**
   * Callback for when the inspector is closed, which can be used to clean up custom document pane
   * parameters.
   */
  onClose?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
  /**
   * Callback for when the inspector is opened, which can be used to set custom document pane
   * parameters.
   */
  onOpen?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
}

/** @hidden @beta */
declare interface DocumentInspector_2 {
  name: string
  component: DocumentInspectorComponent_2
  /**
   * Hook for defining a menu item for the inspector.
   */
  useMenuItem?: (props: DocumentInspectorUseMenuItemProps_2) => DocumentInspectorMenuItem_2
  /**
   * Callback for when the inspector is closed, which can be used to clean up custom document pane
   * parameters.
   */
  onClose?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
  /**
   * Callback for when the inspector is opened, which can be used to set custom document pane
   * parameters.
   */
  onOpen?: (ctx: {params: Record<string, string | undefined>}) => {
    params: Record<string, string | undefined>
  }
}

/** @hidden @beta */
declare type DocumentInspectorComponent = ComponentType<DocumentInspectorProps>

/** @hidden @beta */
declare type DocumentInspectorComponent_2 = ComponentType<DocumentInspectorProps_2>

/** @hidden @beta */
declare interface DocumentInspectorContext extends ConfigContext {
  documentId?: string
  documentType: string
}

/** @hidden @beta */
declare interface DocumentInspectorContext_2 extends ConfigContext_2 {
  documentId?: string
  documentType: string
}

/** @hidden @beta */
declare interface DocumentInspectorMenuItem {
  hidden?: boolean
  hotkeys?: string[]
  icon?: ComponentType
  showAsAction?: boolean
  status?: ButtonTone
  title: string
  tone?: ButtonTone
}

/** @hidden @beta */
declare interface DocumentInspectorMenuItem_2 {
  hidden?: boolean
  hotkeys?: string[]
  icon?: ComponentType
  showAsAction?: boolean
  status?: ButtonTone
  title: string
  tone?: ButtonTone
}

/** @hidden @beta */
declare interface DocumentInspectorProps {
  documentId: string
  documentType: string
  onClose: () => void
}

/** @hidden @beta */
declare interface DocumentInspectorProps_2 {
  documentId: string
  documentType: string
  onClose: () => void
}

/** @hidden @beta */
declare type DocumentInspectorsResolver = ComposableOption<
  DocumentInspector[],
  DocumentInspectorContext
>

/** @hidden @beta */
declare type DocumentInspectorsResolver_2 = ComposableOption_2<
  DocumentInspector_2[],
  DocumentInspectorContext_2
>

/** @hidden @beta */
declare interface DocumentInspectorUseMenuItemProps {
  documentId: string
  documentType: string
}

/** @hidden @beta */
declare interface DocumentInspectorUseMenuItemProps_2 {
  documentId: string
  documentType: string
}

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterComponent = ComponentType<{
  schemaType: ObjectSchemaType
}>

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterComponent_2 = ComponentType<{
  schemaType: ObjectSchemaType
}>

/**
 *
 * @hidden
 * @beta
 */
declare interface DocumentLanguageFilterContext extends ConfigContext {
  documentId?: string
  schemaType: string
}

/**
 *
 * @hidden
 * @beta
 */
declare interface DocumentLanguageFilterContext_2 extends ConfigContext_2 {
  documentId?: string
  schemaType: string
}

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterResolver = ComposableOption<
  DocumentLanguageFilterComponent[],
  DocumentLanguageFilterContext
>

/**
 *
 * @hidden
 * @beta
 */
declare type DocumentLanguageFilterResolver_2 = ComposableOption_2<
  DocumentLanguageFilterComponent_2[],
  DocumentLanguageFilterContext_2
>

/** @internal*/
declare interface DocumentLayoutProps {
  /**
   * The ID of the document. This is a read-only property and changing it will have no effect.
   */
  documentId: string
  /**
   * The type of the document. This is a read-only property and changing it will have no effect.
   */
  documentType: string
  renderDefault: (props: DocumentLayoutProps) => React.JSX.Element
}

/** @internal*/
declare interface DocumentLayoutProps_2 {
  /**
   * The ID of the document. This is a read-only property and changing it will have no effect.
   */
  documentId: string
  /**
   * The type of the document. This is a read-only property and changing it will have no effect.
   */
  documentType: string
  renderDefault: (props: DocumentLayoutProps_2) => React.JSX.Element
}

/**
 * @internal
 */
export declare const DocumentLimitUpsellContext: Context<DocumentLimitUpsellContextValue | null>

/**
 * @internal
 */
export declare interface DocumentLimitUpsellContextValue {
  upsellDialogOpen: boolean
  handleOpenDialog: (source: UpsellDialogViewedInfo['source']) => void
  handleClose: () => void
  upsellData: UpsellData | null
  telemetryLogs: {
    dialogSecondaryClicked: () => void
    dialogPrimaryClicked: () => void
    panelPrimaryClicked: () => void
    panelSecondaryClicked: () => void
  }
}

/**
 * Interface for document list
 *
 * @public
 */
declare interface DocumentList extends GenericList {
  type: 'documentList'
  /** Document list options. See {@link DocumentListOptions} */
  options: DocumentListOptions
  /** Document list child. See {@link Child} */
  child: Child
  /** Document schema type name */
  schemaTypeName?: string
}

/**
 * Class for building document list
 *
 * @public
 */
declare class DocumentListBuilder extends GenericListBuilder<
  PartialDocumentList,
  DocumentListBuilder
> {
  /** Document list options. See {@link PartialDocumentList} */
  protected spec: PartialDocumentList
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: DocumentListInput,
  )
  /** Set API version
   * @param apiVersion - API version
   * @returns document list builder based on the options and API version provided. See {@link DocumentListBuilder}
   */
  apiVersion(apiVersion: string): DocumentListBuilder
  /** Get API version
   * @returns API version
   */
  getApiVersion(): string | undefined
  /** Set Document list filter
   * @param filter - GROQ-filter used to determine which documents to display. Do not support joins, since they operate on individual documents, and will ignore order-clauses and projections. See {@link https://www.sanity.io/docs/realtime-updates}
   * @returns document list builder based on the options and filter provided. See {@link DocumentListBuilder}
   */
  filter(filter: string): DocumentListBuilder
  /** Get Document list filter
   * @returns filter
   */
  getFilter(): string | undefined
  /** Set Document list schema type name
   * @param type - schema type name.
   * @returns document list builder based on the schema type name provided. See {@link DocumentListBuilder}
   */
  schemaType(type: SchemaType | string): DocumentListBuilder
  /** Get Document list schema type name
   * @returns schema type name
   */
  getSchemaType(): string | undefined
  /** Set Document list options' parameters
   * @param params - parameters
   * @returns document list builder based on the options provided. See {@link DocumentListBuilder}
   */
  params(params: Record<string, unknown>): DocumentListBuilder
  /** Get Document list options' parameters
   * @returns options
   */
  getParams(): Record<string, unknown> | undefined
  /** Set Document list default ordering
   * @param ordering - default sort ordering array. See {@link SortOrderingItem}
   * @returns document list builder based on ordering provided. See {@link DocumentListBuilder}
   */
  defaultOrdering(ordering: SortOrderingItem[]): DocumentListBuilder
  /** Get Document list default ordering
   * @returns default ordering. See {@link SortOrderingItem}
   */
  getDefaultOrdering(): SortOrderingItem[] | undefined
  /** Serialize Document list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list object based on path provided in options. See {@link DocumentList}
   */
  serialize(options?: SerializeOptions): DocumentList
  /** Clone Document list builder (allows for options overriding)
   * @param withSpec - override document list spec. See {@link PartialDocumentList}
   * @returns document list builder. See {@link DocumentListBuilder}
   */
  clone(withSpec?: PartialDocumentList): DocumentListBuilder
  /** Get Document list spec
   * @returns document list spec. See {@link PartialDocumentList}
   */
  getSpec(): PartialDocumentList
}

/**
 * Interface for document list input
 *
 * @public
 */
declare interface DocumentListInput extends GenericListInput {
  /** Document list options. See {@link DocumentListOptions} */
  options: DocumentListOptions
}

/**
 * Interface for document list item
 *
 * @public
 */
declare interface DocumentListItem extends ListItem {
  /** Document schema type. See {@link SchemaType} */
  schemaType: SchemaType
  /** Document ID */
  _id: string
}

/**
 * Class for building a document list item
 *
 * @public
 */
declare class DocumentListItemBuilder extends ListItemBuilder {
  /** Document list options. See {@link PartialDocumentListItem} */
  protected spec: PartialDocumentListItem
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: DocumentListItemInput,
  )
  /**
   * Serialize document list item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns document list item object based on path provided in options. See {@link DocumentListItem}
   */
  serialize(options?: SerializeOptions): DocumentListItem
  /** Clone Document list item builder (allows for options overriding)
   * @param withSpec - Document list item builder options. See {@link PartialDocumentListItem}
   * @returns document list item builder. See {@link DocumentListItemBuilder}
   */
  clone(withSpec?: PartialDocumentListItem): DocumentListItemBuilder
}

/**
 * Interface for document list item input
 *
 * @public
 */
declare interface DocumentListItemInput extends ListItemInput {
  /** Document list item input schema type. See {@link SchemaType} */
  schemaType: SchemaType | string
}

/**
 * Interface for document List options
 *
 * @public
 */
declare interface DocumentListOptions {
  /** Document list filter */
  filter: string
  /** Document list parameters */
  params?: Record<string, unknown>
  /** Document list API version */
  apiVersion?: string
  /** Document list API default ordering array. */
  defaultOrdering?: SortOrderingItem[]
}

/** @internal */
declare interface DocumentListPaneNode extends BaseResolvedPaneNode<'documentList'> {
  defaultLayout?: GeneralPreviewLayoutKey_2
  displayOptions?: {
    showIcons?: boolean
  }
  initialValueTemplates?: InitialValueTemplateItem_2[]
  options: {
    filter: string
    defaultOrdering?: Array<{
      field: string
      direction: 'asc' | 'desc'
    }>
    params?: Record<string, unknown>
    apiVersion?: string
  }
  schemaTypeName: string
  source?: string
}

/**
 * Represents a document location
 * @public
 */
declare interface DocumentLocation {
  /**
   * Title of the document
   */
  title: string
  /**
   * URL of the document location
   */
  href: string
}

/**
 * Function used for advanced document location resolution
 * @param params - Object with document `id` and document `type` properties
 * @param context - Object with `documentStore` property for creating listenQuery subscriptions
 * @returns Document location state, optionally as an Observable, or null/undefined if no locations are available
 * @public
 */
declare type DocumentLocationResolver = (
  params: {
    id: string
    type: string
    version: string | undefined
    perspectiveStack: StackablePerspective[]
  },
  context: {
    documentStore: DocumentStore
  },
) =>
  | DocumentLocationsState
  | null
  | undefined
  | Observable<DocumentLocationsState | null | undefined>

/**
 * Document location resolver object
 * @public
 */
declare type DocumentLocationResolverObject<K extends string = string> = {
  /**
   * Object for selecting document fields
   */
  select: Record<K, string>
  /**
   * Function that accepts a document with the selected fields and returns an optional document location state
   */
  resolve: (value: Record<K, any> | null) => DocumentLocationsState | null | undefined | void
}

/**
 * Object of document location resolver definitions per document type
 * @public
 */
declare type DocumentLocationResolvers = Record<
  string,
  DocumentLocationResolverObject | DocumentLocationsState
>

/**
 * State for describing document locations or providing a message if locations are unavailable
 * @public
 */
declare interface DocumentLocationsState {
  /**
   * Array of document locations
   */
  locations?: DocumentLocation[]
  /**
   * Message to display if locations are unavailable
   */
  message?: string
  /**
   * Tone of the message
   */
  tone?: 'positive' | 'caution' | 'critical'
}

/**
 * @beta
 * @hidden
 */
declare interface DocumentMeta {
  documentId: string
  documentType: string
  schemaType: ObjectSchemaType
  onChange: (event: PatchEvent) => void
}

/**
 * @hidden
 * @beta */
declare interface DocumentMutationEvent {
  type: 'mutation'
  document: SanityDocument
  mutations: MutationPayload[]
  origin: 'local' | 'remote'
}

/**
 * Interface for the document list builder (focused on the document pane)
 *
 * @public */
declare interface DocumentNode extends StructureNode {
  /**
   * Document children. See {@link Child}
   */
  child?: Child
  /**
   * Options for the document pane
   */
  options: {
    /** Document Id */
    id: string
    /** Document Type */
    type?: string
    /** Document Template */
    template?: string
    /** Template parameters */
    templateParameters?: {
      [key: string]: any
    }
  }
  /**
   * View array for the document pane. See {@link View}
   */
  views: View[]
}

/**
 * Interface for options of Partial Documents. See {@link PartialDocumentNode}
 *
 * @public */
declare interface DocumentOptions {
  /** Document Id */
  id: string
  /** Document Type */
  type: string
  /** Document Template */
  template?: string
  /** Template parameters */
  templateParameters?: Record<string, unknown>
}

/** @internal */
export declare const DocumentPaneContext: Context<DocumentPaneContextValue | null>

/** @internal */
declare interface DocumentPaneContextValue extends Pick<
  NodeChronologyProps_2,
  'hasUpstreamVersion'
> {
  actions: DocumentActionComponent_2[] | null
  activeViewId: string | null
  badges: DocumentBadgeComponent_2[] | null
  changesOpen: boolean
  closeInspector: (inspectorName?: string) => void
  collapsedFieldSets: StateTree<boolean> | undefined
  collapsedPaths: StateTree<boolean> | undefined
  compareValue: SanityDocument | null
  connectionState: 'connecting' | 'reconnecting' | 'connected'
  displayed: Partial<SanityDocument> | null
  displayInlineChanges?: boolean
  documentId: string
  documentIdRaw: string
  documentType: string
  editState: EditStateFor_2 | null
  fieldActions: DocumentFieldAction_2[]
  focusPath: Path
  index: number
  inspectOpen: boolean
  inspector: DocumentInspector_2 | null
  inspectors: DocumentInspector_2[]
  menuItemGroups: PaneMenuItemGroup[]
  onBlur: (blurredPath: Path) => void
  onChange: (event: PatchEvent_2) => void
  onFocus: (pathOrEvent: Path) => void
  onHistoryClose: () => void
  onHistoryOpen: () => void
  onInspectClose: () => void
  onMenuAction: (item: PaneMenuItem) => void
  onPaneClose: () => void
  onPaneSplit?: () => void
  onPathOpen: (path: Path) => void
  onSetActiveFieldGroup: (path: Path, groupName: string) => void
  onSetCollapsedPath: (path: Path, expanded: boolean) => void
  onSetCollapsedFieldSet: (path: Path, expanded: boolean) => void
  onSetMaximizedPane?: () => void
  maximized: boolean
  openInspector: (inspectorName: string, paneParams?: Record<string, string>) => void
  openPath: Path
  paneKey: string
  previewUrl?: string | null
  ready: boolean
  schemaType: ObjectSchemaType
  /**
   * @deprecated not used anymore
   * */
  setTimelineMode?: undefined
  /**
   * @deprecated not used anymore
   * */
  timelineMode?: undefined
  setTimelineRange(since: string | null, rev: string | null): void
  setIsDeleting: (state: boolean) => void
  timelineError: Error | null
  /**
   * Soon to be deprecated with the upcoming `releases` changes.
   */
  timelineStore?: TimelineStore
  title: string | null
  validation: ValidationMarker[]
  value: SanityDocumentLike
  views: View[]
  formState: DocumentFormNode | null
  /**
   * TODO: COREL - Remove this after updating sanity-assist to use <PerspectiveProvider>
   *
   * @deprecated use `usePerspective()` instead
   */
  selectedReleaseId: ReleaseId | undefined
  permissions?: PermissionCheckResult | null
  isDeleting: boolean
  isDeleted: boolean
  isPermissionsLoading: boolean
  isInitialValueLoading?: boolean
  unstable_languageFilter: DocumentLanguageFilterComponent_2[]
  revisionId: string | null
  revisionNotFound: boolean
  lastNonDeletedRevId: string | null
  lastRevisionDocument: SanityDocument | null
}

/** @internal */
declare interface DocumentPaneNode extends BaseResolvedPaneNode<'document'> {
  options: {
    id: string
    type: string
    template?: string
    templateParameters?: Record<string, unknown>
  }
  source?: string
  views?: View[]
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentPluginOptions {
  badges?: DocumentBadgeComponent[] | DocumentBadgesResolver
  actions?: DocumentActionComponent[] | DocumentActionsResolver
  /**
   * Components for the document.
   * @internal
   */
  components?: DocumentComponents
  /** @internal */
  unstable_fieldActions?: DocumentFieldAction[] | DocumentFieldActionsResolver
  /** @hidden @beta */
  inspectors?: DocumentInspector[] | DocumentInspectorsResolver
  /**
   * @hidden
   * @beta
   */
  productionUrl?: AsyncComposableOption<string | undefined, ResolveProductionUrlContext>
  /**
   * @hidden
   * @beta
   */
  unstable_languageFilter?: DocumentLanguageFilterResolver
  /**
   * @hidden
   * @beta
   */
  newDocumentOptions?: NewDocumentOptionsResolver
  /** @deprecated Use `comments` instead */
  unstable_comments?: {
    enabled: boolean | ((context: DocumentCommentsEnabledContext) => boolean)
  }
  /** @internal */
  comments?: {
    enabled: boolean | ((context: DocumentCommentsEnabledContext) => boolean)
  }
  drafts?: {
    /**
     * Whether the workspace provides the draft model for interacting with documents.
     *
     * When switched off, documents may only be edited:
     *
     *  - Inside a release.
     *  - Outside a release if they support live-edit.
     */
    enabled?: boolean
  }
}

/**
 * @hidden
 * @beta
 */
declare interface DocumentPluginOptions_2 {
  badges?: DocumentBadgeComponent_2[] | DocumentBadgesResolver_2
  actions?: DocumentActionComponent_2[] | DocumentActionsResolver_2
  /**
   * Components for the document.
   * @internal
   */
  components?: DocumentComponents_2
  /** @internal */
  unstable_fieldActions?: DocumentFieldAction_2[] | DocumentFieldActionsResolver_2
  /** @hidden @beta */
  inspectors?: DocumentInspector_2[] | DocumentInspectorsResolver_2
  /**
   * @hidden
   * @beta
   */
  productionUrl?: AsyncComposableOption_2<string | undefined, ResolveProductionUrlContext_2>
  /**
   * @hidden
   * @beta
   */
  unstable_languageFilter?: DocumentLanguageFilterResolver_2
  /**
   * @hidden
   * @beta
   */
  newDocumentOptions?: NewDocumentOptionsResolver_2
  /** @deprecated Use `comments` instead */
  unstable_comments?: {
    enabled: boolean | ((context: DocumentCommentsEnabledContext_2) => boolean)
  }
  /** @internal */
  comments?: {
    enabled: boolean | ((context: DocumentCommentsEnabledContext_2) => boolean)
  }
  drafts?: {
    /**
     * Whether the workspace provides the draft model for interacting with documents.
     *
     * When switched off, documents may only be edited:
     *
     *  - Inside a release.
     *  - Outside a release if they support live-edit.
     */
    enabled?: boolean
  }
}

/**
 * @hidden
 * @beta */
declare interface DocumentRebaseEvent {
  type: 'rebase'
  document: SanityDocument
  remoteMutations: MutationPayload[]
  localMutations: MutationPayload[]
}

/**
 * @hidden
 * @beta */
declare interface DocumentRemoteMutationEvent {
  type: 'remoteMutation'
  head: SanityDocument
  transactionId: string
  author: string
  timestamp: Date
  effects: {
    apply: unknown
    revert: unknown
  }
}

/**
 * @hidden
 * @beta */
declare type DocumentRemoteMutationVersionEvent = Exclude<
  RemoteSnapshotVersionEvent,
  {
    type: 'snapshot'
  }
>

/**
 * Configuration object for resolving documents based on URL route patterns.
 * Used to define the main document when navigating to specific URLs in
 * Presentation tool's preview iframe.
 *
 * Supports three different resolution strategies:
 *
 * **Simple type-based resolution:**
 * ```ts
 * {
 *   route: '/blog',
 *   type: 'blog'  // Useful for singleton documents
 * }
 * ```
 *
 * **GROQ filter-based resolution:**
 * ```ts
 * {
 *   route: '/blog/:category/:slug',
 *   filter: ({ params }) => `_type == "post" && slug.current == "${params.slug}"`,
 *   params: ({ params }) => ({ category: params.category })
 * }
 * ```
 *
 * **Advanced resolution with custom logic:**
 * ```ts
 * {
 *   route: '/products/:id',
 *   resolve: ({ params }) => ({
 *     filter: `_type == "product" && _id == $id`,
 *     params: { id: params.id }
 *   })
 * }
 * ```
 *
 * @public
 */
declare type DocumentResolver =
  | {
      route: string | Array<string>
      type: string
      filter?: never
      params?: never
      resolve?: never
    }
  | {
      route: string | Array<string>
      type?: never
      filter: ContextFn<string> | string
      params?: ContextFn<Record<string, string>> | Record<string, string>
      resolve?: never
    }
  | {
      route: string | Array<string>
      type?: never
      filter?: never
      params?: never
      resolve: ContextFn<
        | {
            filter: string
            params?: Record<string, string>
          }
        | undefined
      >
    }

/**
 * Context object passed to functions used in `DocumentResolver` definitions.
 * Contains information about the current URL being matched against route patterns.
 *
 * @example
 * For a route pattern `/blog/:category/:slug` matching URL `https://example.com/blog/tech/hello-world`:
 * ```ts
 * {
 *   origin: 'https://example.com',
 *   params: { category: 'tech', slug: 'hello-world' },
 *   path: '/blog/tech/hello-world'
 * }
 * ```
 *
 * @public
 */
declare interface DocumentResolverContext {
  /**
   * The origin (protocol + hostname + port) of the matched URL
   */
  origin: string
  /**
   * Extracted route parameters from URL path matching (e.g., `:slug`  `{slug: 'value'}`)
   */
  params: Record<string, string>
  /**
   * The pathname of the matched URL (without query parameters)
   */
  path: string
}

/**
 * Represents a document revision identifier.
 * Can be either a specific revision string
 * or 'lastRevision' to get the most recent revision.
 *
 * @beta
 */
declare type DocumentRevision = string | 'lastRevision'

/** @internal */
export declare const DocumentSheetListContext: Context<DocumentSheetListContextValue | undefined>

/** @internal */
declare interface DocumentSheetListContextValue {
  focusAnchorCell: () => void
  resetFocusSelection: () => void
  setSelectedAnchorCell: (colId: string, rowIndex: number) => void
  getStateByCellId: (
    colId: string,
    rowIndex: number,
  ) => 'focused' | 'selectedAnchor' | 'selectedRange' | null
  submitFocusedCell: () => void
}

/**
 * @hidden
 * @beta */
declare interface DocumentStore {
  /**
   * Checks out a document (with its published and draft version) for real-time editing.
   * Note that every call to this function will open a new listener to the server.
   * It's recommended to use the helper functions on `pair` below which will re-use a single connection.
   *
   * @internal
   **/
  checkoutPair: (idPair: IdPair) => Pair
  initialValue: (
    opts: InitialValueOptions,
    context: InitialValueResolverContext,
  ) => Observable<InitialValueMsg>
  listenQuery: (
    query:
      | string
      | {
          fetch: string
          listen: string
        },
    params: QueryParams,
    options: ListenQueryOptions,
  ) => Observable<any>
  resolveTypeForDocument: (id: string, specifiedType?: string) => Observable<string>
  pair: {
    consistencyStatus: (publishedId: string, type: string, version?: string) => Observable<boolean>
    /** @internal */
    documentEvents: (
      publishedId: string,
      type: string,
      version?: string,
    ) => Observable<DocumentVersionEvent>
    /** @internal */
    editOperations: (
      publishedId: string,
      type: string,
      version?: string,
    ) => Observable<OperationsAPI>
    editState: (publishedId: string, type: string, version?: string) => Observable<EditStateFor_2>
    operationEvents: (
      publishedId: string,
      type: string,
    ) => Observable<OperationSuccess | OperationError>
    validation: (
      validationTargetId: string,
      type: string,
      releaseId?: string,
    ) => Observable<ValidationStatus_2>
  }
}

/**
 * Class for building a document type list
 *
 * @public
 */
declare class DocumentTypeListBuilder extends DocumentListBuilder {
  /** Document list options. See {@link PartialDocumentList} */
  protected spec: PartialDocumentList
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: DocumentListInput,
  )
  /**
   * Set Document type list child
   * @param child - Child component. See {@link Child}
   * @returns document type list builder based on child component provided without default intent handler. See {@link DocumentTypeListBuilder}
   */
  child(child: Child): DocumentTypeListBuilder
  /** Clone Document type list builder (allows for options overriding)
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder. See {@link DocumentTypeListBuilder}
   */
  clone(withSpec?: PartialDocumentList): DocumentTypeListBuilder
  /** Clone Document type list builder (allows for options overriding) and remove default intent handler
   * @param withSpec - Document type list builder options. See {@link PartialDocumentList}
   * @returns document type list builder without default intent handler. See {@link DocumentTypeListBuilder}
   */
  cloneWithoutDefaultIntentHandler(withSpec?: PartialDocumentList): DocumentTypeListBuilder
}

/**
 * Interface for document type list input
 *
 * @public
 */
declare interface DocumentTypeListInput extends Partial<GenericListInput> {
  /** Document type list input schema type. See {@link SchemaType} */
  schemaType: SchemaType | string
}

declare interface DocumentValidationStatus extends ValidationStatus {
  hasError: boolean
}

declare interface DocumentValidationStatus_2 extends ValidationStatus_2 {
  hasError: boolean
}

/**
 * @hidden
 * @beta */
declare type DocumentValuePermission = 'read' | 'create' | 'update' | 'history' | 'editHistory'

/**
 * Indicates the type of document variant, either `draft`, `version` or `published`.
 * Draft documents are prefixed with `drafts.`.
 * Version documents are prefixed with `versions.<versionName>`
 * The rest are considered published documents.
 * @public
 */
declare type DocumentVariantType = 'draft' | 'version' | 'published'

/**
 * Indicates the type of document variant, either `draft`, `version` or `published`.
 * Draft documents are prefixed with `drafts.`.
 * Version documents are prefixed with `versions.<versionName>`
 * The rest are considered published documents.
 * @public
 */
declare type DocumentVariantType_2 = 'draft' | 'version' | 'published'

/**
 * @hidden
 * @beta */
declare interface DocumentVersion {
  consistency$: Observable<boolean>
  remoteSnapshot$: Observable<RemoteSnapshotVersionEvent>
  events: Observable<DocumentVersionEvent>
  patch: (patches: any[]) => MutationPayload[]
  create: (document: Partial<SanityDocument>) => MutationPayload
  createIfNotExists: (document: SanityDocument) => MutationPayload
  createOrReplace: (document: SanityDocument) => MutationPayload
  delete: () => MutationPayload
  mutate: (mutations: MutationPayload[]) => void
  commit: () => void
}

/**
 * @hidden
 * @beta */
declare type DocumentVersionEvent = WithVersion<
  ReconnectEvent | BufferedDocumentEvent | WelcomeEvent
>

/**
 * This error may happen for arrays of objects where one or more of the members are having duplicate keys
 *
 * @public
 */
declare type DuplicateKeysError = {
  type: 'DUPLICATE_KEYS'
  schemaType: ArraySchemaType
  duplicates: [index: number, key: string][]
}

/**
 * This error may happen for arrays of objects where one or more of the members are having duplicate keys
 *
 * @public
 */
declare type DuplicateKeysError_2 = {
  type: 'DUPLICATE_KEYS'
  schemaType: ArraySchemaType
  duplicates: [index: number, key: string][]
}

/**
 * @hidden
 * @beta
 * This event won't be exposed by the API, it needs to be generated by validating the
 * transactions that occurred between two events. Usually, between two PublishDocumentEvents.
 * Or a create event and a publish event.
 */
declare interface EditDocumentVersionEvent extends BaseEvent {
  type: 'editDocumentVersion'
  documentId: string
  contributors: string[]
  releaseId?: string
  /**
   * One edit event could contain multiple transactions that are merged together.
   * This represents the newest transaction in the merged events.
   */
  revisionId: string
  transactions: {
    type: 'editTransaction'
    author: string
    timestamp: string
    revisionId: string
  }[]
  /**
   * Present when an edit was already published, then the user decided to expand the event.
   */
  parentId?: string
}

/**
 * @hidden
 * @beta
 * This event won't be exposed by the API, it needs to be generated by validating the
 * transactions that occurred between two events. Usually, between two PublishDocumentEvents.
 * Or a create event and a publish event.
 */
declare interface EditDocumentVersionEvent_2 extends BaseEvent_2 {
  type: 'editDocumentVersion'
  documentId: string
  contributors: string[]
  releaseId?: string
  /**
   * One edit event could contain multiple transactions that are merged together.
   * This represents the newest transaction in the merged events.
   */
  revisionId: string
  transactions: {
    type: 'editTransaction'
    author: string
    timestamp: string
    revisionId: string
  }[]
  /**
   * Present when an edit was already published, then the user decided to expand the event.
   */
  parentId?: string
}

/**
 * Interface for Editor node
 *
 * @public */
declare interface EditorNode extends StructureNode {
  /** Editor child. See {@link Child} */
  child?: Child
  /** Editor options */
  options: {
    /** Editor ID */
    id: string
    /** Editor type */
    type?: string
    /** Editor template */
    template?: string
    /** Template parameters */
    templateParameters?: {
      [key: string]: any
    }
  }
}

/** @internal */
declare interface EditReferenceLinkComponentProps {
  documentId: string
  documentType: string
  parentRefPath: Path
  template?: TemplateOption
  children: ReactNode
}

/**
 * @hidden
 * @beta */
declare interface EditReferenceOptions {
  parentRefPath: Path
  id: string
  type: string
  version?: ReleaseId
  template: {
    id: string
    params?: Record<string, string | number | boolean>
  }
}

/**
 * @internal
 */
declare interface EditReferenceOptions_2 {
  id: string
  type: string
  parentRefPath: Path
  template: TemplateOption
  version?: ReleaseId_2
}

/**
 * @hidden
 * @beta */
declare interface EditStateFor {
  id: string
  type: string
  transactionSyncLock: TransactionSyncLockState | null
  draft: SanityDocument | null
  published: SanityDocument | null
  version: SanityDocument | null
  /**
   * Whether live edit is enabled. This may be true for various reasons:
   *
   * - The schema type has live edit enabled.
   * - A version of the document is checked out.
   */
  liveEdit: boolean
  /**
   * Whether the schema type has live edit enabled.
   */
  liveEditSchemaType: boolean
  ready: boolean
  /**
   * When editing a version, the name of the release the document belongs to.
   */
  release: string | undefined
}

/**
 * @hidden
 * @beta */
declare interface EditStateFor_2 {
  id: string
  type: string
  transactionSyncLock: TransactionSyncLockState_2 | null
  draft: SanityDocument | null
  published: SanityDocument | null
  version: SanityDocument | null
  /**
   * Whether live edit is enabled. This may be true for various reasons:
   *
   * - The schema type has live edit enabled.
   * - A version of the document is checked out.
   */
  liveEdit: boolean
  /**
   * Whether the schema type has live edit enabled.
   */
  liveEditSchemaType: boolean
  ready: boolean
  /**
   * When editing a version, the name of the release the document belongs to.
   */
  release: string | undefined
}

/**
 * @internal
 */
export declare const EnhancedObjectDialogContext: Context<EnhancedObjectDialogContextValue>

/**
 * @internal
 */
declare interface EnhancedObjectDialogContextValue {
  /**
   * A boolean indicating whether tree editing is enabled
   */
  enabled: boolean
  /**
   * A boolean indicating whether the EnhancedObjectDialog component is available in this tree to handle paths
   */
  isDialogAvailable: boolean
  /**
   * A boolean indicating whether legacy editing is enabled - meaning that it will use the old modal based editing experience
   */
  legacyEditing: boolean
}

/**
 * @internal
 */
export declare const EventsContext: Context<EventsStore | null>

/**
 * @internal
 * */
declare interface EventsStore {
  events: DocumentGroupEvent[]
  nextCursor: string | null
  loading: boolean
  error: Error | null
  revision: EventsStoreRevision | null
  sinceRevision: EventsStoreRevision | null
  findRangeForRevision: (nextRev: string) => [string | null, string | null]
  findRangeForSince: (nextSince: string) => [string | null, string | null]
  loadMoreEvents: () => void
  getChangesList: () => Observable<{
    diff: ObjectDiff | null
    loading: boolean
    error: Error | null
  }>
  expandEvent: (event: DocumentGroupEvent) => Promise<void>
}

/**
 * @hidden
 * @beta
 */
declare interface EventsStoreRevision {
  revisionId: string
  loading: boolean
  document?: SanityDocument | null
}

declare type ExtractArray<Union> = Union extends unknown[] ? Union : never

declare type ExtractArray_2<Union> = Union extends unknown[] ? Union : never

/** @internal */
export declare const FieldActionsContext: Context<FieldActionsContextValue>

/** @internal */
export declare interface FieldActionsContextValue {
  actions: DocumentFieldActionNode[]
  __internal_comments?: FieldCommentsProps
  __internal_slot?: ReactNode
  focused?: boolean
  hovered: boolean
  onMouseEnter: () => void
  onMouseLeave: () => void
}

/** @internal @deprecated DO NOT USE */
declare interface FieldCommentsProps {
  hasComments: boolean
  button: ReactNode
  isAddingComment: boolean
}

/** @internal @deprecated DO NOT USE */
declare interface FieldCommentsProps_2 {
  hasComments: boolean
  button: ReactNode
  isAddingComment: boolean
}

/**
 * Represents an error that occurred in a specific field of a data object.
 * @public
 *
 * @remarks
 * This interface is used to provide detailed information about the error,
 * including the field name, the error type, and the error message.
 */
declare interface FieldError {
  /**
   * The type of error that occurred.
   */
  kind: 'error'
  /**
   * The unique identifier for the error.
   */
  key: string
  /**
   * The name of the field that the error occurred in.
   */
  fieldName: string
  /**
   * The specific error that occurred.
   *
   * ```md
   * Possible error types include:
   * - IncompatibleTypeError
   * - TypeAnnotationMismatchError
   * - MissingKeysError
   * - DuplicateKeysError
   * - UndeclaredMembersError
   * - MixedArrayError
   * ```
   *
   * See {@link IncompatibleTypeError},
   * {@link TypeAnnotationMismatchError},
   * {@link MissingKeysError},
   * {@link DuplicateKeysError},
   * {@link UndeclaredMembersError} and
   * {@link MixedArrayError} for more information.
   *
   */
  error:
    | IncompatibleTypeError
    | TypeAnnotationMismatchError
    | MissingKeysError
    | DuplicateKeysError
    | UndeclaredMembersError
    | MixedArrayError
}

/**
 * Represents an error that occurred in a specific field of a data object.
 * @public
 *
 * @remarks
 * This interface is used to provide detailed information about the error,
 * including the field name, the error type, and the error message.
 */
declare interface FieldError_2 {
  /**
   * The type of error that occurred.
   */
  kind: 'error'
  /**
   * The unique identifier for the error.
   */
  key: string
  /**
   * The name of the field that the error occurred in.
   */
  fieldName: string
  /**
   * The specific error that occurred.
   *
   * ```md
   * Possible error types include:
   * - IncompatibleTypeError
   * - TypeAnnotationMismatchError
   * - MissingKeysError
   * - DuplicateKeysError
   * - UndeclaredMembersError
   * - MixedArrayError
   * ```
   *
   * See {@link IncompatibleTypeError},
   * {@link TypeAnnotationMismatchError},
   * {@link MissingKeysError},
   * {@link DuplicateKeysError},
   * {@link UndeclaredMembersError} and
   * {@link MixedArrayError} for more information.
   *
   */
  error:
    | IncompatibleTypeError_2
    | TypeAnnotationMismatchError_2
    | MissingKeysError_2
    | DuplicateKeysError_2
    | UndeclaredMembersError_2
    | MixedArrayError_2
}

/**
 * Represents a field member in a form.
 * @public
 */
declare interface FieldMember<Node extends BaseFormNode = BaseFormNode> {
  /** The kind of the form node. */
  kind: 'field'
  /** The key of the field. */
  key: string
  /** The name of the field. */
  name: string
  /** The index of the field. */
  index: number
  /** Whether the field is collapsed. */
  collapsed: boolean | undefined
  /** Whether the field is collapsible. */
  collapsible: boolean | undefined
  /** Whether the field is open. */
  open: boolean
  /**
   * @internal
   * Whether this field is in the selected group.
   */
  inSelectedGroup: boolean
  /**
   * @internal
   * Names of the field groups this field is part of.
   */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The form node that represents this field.
   */
  field: Node
}

/**
 * Represents a field member in a form.
 * @public
 */
declare interface FieldMember_2<Node extends BaseFormNode_2 = BaseFormNode_2> {
  /** The kind of the form node. */
  kind: 'field'
  /** The key of the field. */
  key: string
  /** The name of the field. */
  name: string
  /** The index of the field. */
  index: number
  /** Whether the field is collapsed. */
  collapsed: boolean | undefined
  /** Whether the field is collapsible. */
  collapsible: boolean | undefined
  /** Whether the field is open. */
  open: boolean
  /**
   * @internal
   * Whether this field is in the selected group.
   */
  inSelectedGroup: boolean
  /**
   * @internal
   * Names of the field groups this field is part of.
   */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The form node that represents this field.
   */
  field: Node
}

/** @internal */
declare type FieldPresenceData = {
  element: HTMLElement | null
  presence: FormNodePresence[]
  maxAvatars: number
}

/**
 * @hidden
 * @public */
declare type FieldProps =
  | ObjectFieldProps
  | ObjectFieldProps<CrossDatasetReferenceValue>
  | ObjectFieldProps<FileValue>
  | ObjectFieldProps<GeopointValue>
  | ObjectFieldProps<ImageValue>
  | ObjectFieldProps<ReferenceValue>
  | ObjectFieldProps<SlugValue>
  | ArrayFieldProps
  | NumberFieldProps
  | BooleanFieldProps
  | StringFieldProps

/**
 * @hidden
 * @public */
declare type FieldProps_2 =
  | ObjectFieldProps_2
  | ObjectFieldProps_2<CrossDatasetReferenceValue>
  | ObjectFieldProps_2<FileValue>
  | ObjectFieldProps_2<GeopointValue>
  | ObjectFieldProps_2<ImageValue>
  | ObjectFieldProps_2<ReferenceValue>
  | ObjectFieldProps_2<SlugValue>
  | ArrayFieldProps_2
  | NumberFieldProps_2
  | BooleanFieldProps_2
  | StringFieldProps_2

/**
 * Represents a member of a field set.
 * @public
 */
declare interface FieldSetMember {
  /** The kind of member. */
  kind: 'fieldSet'
  /** The key of the member. */
  key: string
  /**
   * Indicates whether the member is included in the currently selected group.
   * If it's hidden and in the currently selected group, it should still be excluded from its group.
   * @internal
   */
  _inSelectedGroup: boolean
  /** The names of the field groups the member belongs to. */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The state of the field set.
   */
  fieldSet: FieldsetState
}

/**
 * Represents a member of a field set.
 * @public
 */
declare interface FieldSetMember_2 {
  /** The kind of member. */
  kind: 'fieldSet'
  /** The key of the member. */
  key: string
  /**
   * Indicates whether the member is included in the currently selected group.
   * If it's hidden and in the currently selected group, it should still be excluded from its group.
   * @internal
   */
  _inSelectedGroup: boolean
  /** The names of the field groups the member belongs to. */
  groups: string[]
  /**
   * @hidden
   * @beta
   * The state of the field set.
   */
  fieldSet: FieldsetState_2
}

/**
 * @hidden
 * @beta */
declare interface FieldsetState {
  path: Path
  name: string
  level: number
  title?: string
  description?: string
  hidden?: boolean
  collapsible?: boolean
  collapsed?: boolean
  columns?: number | number[]
  members: (FieldMember | FieldError)[]
}

/**
 * @hidden
 * @beta */
declare interface FieldsetState_2 {
  path: Path
  name: string
  level: number
  title?: string
  description?: string
  hidden?: boolean
  collapsible?: boolean
  collapsed?: boolean
  columns?: number | number[]
  members: (FieldMember_2 | FieldError_2)[]
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FileLike {
  type: string
  name?: string
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FileLike_2 {
  type: string
  name?: string
}

declare type FiltersVisibleSet = {
  type: 'FILTERS_VISIBLE_SET'
  visible: boolean
}

/**
 * @internal
 */
export declare const FormBuilderContext: Context<FormBuilderContextValue | null>

/**
 *
 * @hidden
 * @beta
 */
declare interface FormBuilderContextValue {
  /**
   * @deprecated INTERNAL USE ONLY
   * @internal
   */
  __internal: {
    components: {
      CustomMarkers: FormBuilderCustomMarkersComponent
      Markers: FormBuilderMarkersComponent
    }
    file: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    filterField: FormBuilderFilterFieldFn
    image: {
      assetSources: AssetSource[]
      directUploads: boolean
    }
    patchChannel: PatchChannel
  }
  autoFocus?: boolean
  changesOpen?: boolean
  collapsedFieldSets: StateTree_2<boolean> | undefined
  collapsedPaths: StateTree_2<boolean> | undefined
  focusPath: Path
  focused?: boolean
  groups: FormFieldGroup[]
  id: string
  readOnly?: boolean
  renderAnnotation?: RenderAnnotationCallback
  renderBlock?: RenderBlockCallback
  renderField: RenderFieldCallback
  renderInlineBlock?: RenderBlockCallback
  renderInput: RenderInputCallback
  renderItem: RenderItemCallback
  renderPreview: RenderPreviewCallback
  schemaType: ObjectSchemaType
}

/**
 * Component for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type FormBuilderCustomMarkersComponent = ComponentType<{
  markers: PortableTextMarker[]
}>

/**
 * Component for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type FormBuilderCustomMarkersComponent_2 = ComponentType<{
  markers: PortableTextMarker_2[]
}>

/**
 * @internal
 */
declare interface FormBuilderFilterFieldFn {
  (type: ObjectSchemaType, field: ObjectField, selectedLanguageIds: string[]): boolean
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormBuilderMarkersComponent = ComponentType<{
  markers: PortableTextMarker[]
  renderCustomMarkers?: RenderCustomMarkers
  validation: FormNodeValidation[]
}>

/**
 *
 * @hidden
 * @beta
 */
declare type FormBuilderMarkersComponent_2 = ComponentType<{
  markers: PortableTextMarker_2[]
  renderCustomMarkers?: RenderCustomMarkers_2
  validation: FormNodeValidation[]
}>

/**
 * @internal
 */
export declare const FormCallbacksContext: Context<FormCallbacksValue | null>

/** @internal */
declare interface FormCallbacksValue {
  transformPatches?: (patches: FormPatch[]) => FormPatch[]
  onChange: (patchEvent: PatchEvent) => void
  onPathFocus: (path: Path, payload?: OnPathFocusPayload) => void
  onPathBlur: (path: Path) => void
  onPathOpen: (path: Path) => void
  onSetPathCollapsed: (path: Path, collapsed: boolean) => void
  onSetFieldSetCollapsed: (path: Path, collapsed: boolean) => void
  onFieldGroupSelect: (path: Path, fieldGroupName: string) => void
}

/**
 * @hidden
 * @beta */
declare interface FormComponents {
  annotation?: ComponentType<BlockAnnotationProps>
  block?: ComponentType<BlockProps>
  field?: ComponentType<FieldProps>
  inlineBlock?: ComponentType<BlockProps>
  input?: ComponentType<InputProps>
  item?: ComponentType<ItemProps>
  preview?: ComponentType<PreviewProps>
  portableText?: {
    plugins?: ComponentType<PortableTextPluginsProps>
  }
}

/**
 * @hidden
 * @beta */
declare interface FormComponents_2 {
  annotation?: ComponentType<BlockAnnotationProps_2>
  block?: ComponentType<BlockProps_2>
  field?: ComponentType<FieldProps_2>
  inlineBlock?: ComponentType<BlockProps_2>
  input?: ComponentType<InputProps_2>
  item?: ComponentType<ItemProps_2>
  preview?: ComponentType<PreviewProps_3>
  portableText?: {
    plugins?: ComponentType<PortableTextPluginsProps_2>
  }
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormDiffMatchPatch extends FormPatchBase {
  path: Path
  type: 'diffMatchPatch'
  origin?: FormPatchOrigin
  value: string
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormDiffMatchPatch_2 extends FormPatchBase_2 {
  path: Path
  type: 'diffMatchPatch'
  origin?: FormPatchOrigin_2
  value: string
}

/**
 * This represents the shape of the root value sanity forms expect
 * @hidden
 * @public
 */
declare interface FormDocumentValue {
  _type: string
  _id: string
  [key: string]: unknown
}

/**
 * @hidden
 * @beta */
declare interface FormFieldGroup {
  name: string
  selected?: boolean
  disabled?: boolean
  title?: string
  i18n?: I18nTextRecord<'title'>
  icon?: ComponentType
}

/**
 * @hidden
 * @beta */
declare interface FormFieldGroup_2 {
  name: string
  selected?: boolean
  disabled?: boolean
  title?: string
  i18n?: I18nTextRecord<'title'>
  icon?: ComponentType
}

/** @internal */
export declare const FormFieldPresenceContext: Context<FormNodePresence[]>

/**
 *
 * @hidden
 * @beta
 */
declare interface FormInsertPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'insert'
  position: FormInsertPatchPosition
  items: FormPatchJSONValue[]
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormInsertPatch_2 extends FormPatchBase_2 {
  path: Path
  origin?: FormPatchOrigin_2
  type: 'insert'
  position: FormInsertPatchPosition_2
  items: FormPatchJSONValue_2[]
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormInsertPatchPosition = 'before' | 'after'

/**
 *
 * @hidden
 * @beta
 */
declare type FormInsertPatchPosition_2 = 'before' | 'after'

/**
 * @hidden
 * @public */
declare interface FormNodePresence {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
  selection?: EditorSelection
}

/**
 * @hidden
 * @public */
declare interface FormNodePresence_2 {
  user: User
  path: Path
  sessionId: string
  lastActiveAt: string
  selection?: EditorSelection
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatch =
  | FormSetPatch
  | FormSetIfMissingPatch
  | FormUnsetPatch
  | FormInsertPatch
  | FormDiffMatchPatch

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatch_2 =
  | FormSetPatch_2
  | FormSetIfMissingPatch_2
  | FormUnsetPatch_2
  | FormInsertPatch_2
  | FormDiffMatchPatch_2

/**
 * @hidden
 * @beta */
declare interface FormPatchBase {
  /**
   * A property used to identify this as a Sanity patch type, eg "set", "unset", "insert", etc.
   * This allows us to potentially introduce new patch types in the future without breaking
   * existing code. This is an internal property/implementation detail and should not be used by
   * consumers.
   *
   * @internal
   */
  patchType: symbol
}

/**
 * @hidden
 * @beta */
declare interface FormPatchBase_2 {
  /**
   * A property used to identify this as a Sanity patch type, eg "set", "unset", "insert", etc.
   * This allows us to potentially introduce new patch types in the future without breaking
   * existing code. This is an internal property/implementation detail and should not be used by
   * consumers.
   *
   * @internal
   */
  patchType: symbol
}

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchJSONValue =
  | number
  | string
  | boolean
  | {
      [key: string]: FormPatchJSONValue
    }
  | FormPatchJSONValue[]

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchJSONValue_2 =
  | number
  | string
  | boolean
  | {
      [key: string]: FormPatchJSONValue_2
    }
  | FormPatchJSONValue_2[]

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchOrigin = 'remote' | 'local' | 'internal'

/**
 *
 * @hidden
 * @beta
 */
declare type FormPatchOrigin_2 = 'remote' | 'local' | 'internal'

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetIfMissingPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'setIfMissing'
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetIfMissingPatch_2 extends FormPatchBase_2 {
  path: Path
  origin?: FormPatchOrigin_2
  type: 'setIfMissing'
  value: FormPatchJSONValue_2
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetPatch extends FormPatchBase {
  path: Path
  type: 'set'
  origin?: FormPatchOrigin
  value: FormPatchJSONValue
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormSetPatch_2 extends FormPatchBase_2 {
  path: Path
  type: 'set'
  origin?: FormPatchOrigin_2
  value: FormPatchJSONValue_2
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormUnsetPatch extends FormPatchBase {
  path: Path
  origin?: FormPatchOrigin
  type: 'unset'
}

/**
 *
 * @hidden
 * @beta
 */
declare interface FormUnsetPatch_2 extends FormPatchBase_2 {
  path: Path
  origin?: FormPatchOrigin_2
  type: 'unset'
}

/**
 * @internal
 */
export declare const FormValueContext: Context<FormValueContextValue | null>

/**
 * @internal
 * @hidden
 */
declare interface FormValueContextValue {
  value: FormDocumentValue | undefined
}

/**
 * Interface for form views.
 *
 * @public */
declare interface FormView extends BaseView {
  type: 'form'
}

/**
 * Class for building a form view.
 *
 * @public */
declare class FormViewBuilder extends GenericViewBuilder<Partial<BaseView>, FormViewBuilder> {
  /** Document list options. See {@link FormView} */
  protected spec: Partial<FormView>
  constructor(spec?: Partial<FormView>)
  /**
   * Serialize Form view builder
   * @param options - Serialize options. See {@link SerializeOptions}
   * @returns form view builder based on path provided in options. See {@link FormView}
   */
  serialize(options?: SerializeOptions): FormView
  /**
   * Clone Form view builder (allows for options overriding)
   * @param withSpec - Partial form view builder options. See {@link FormView}
   * @returns form view builder. See {@link FormViewBuilder}
   */
  clone(withSpec?: Partial<FormView>): FormViewBuilder
}

/**
 * @internal
 */
export declare const FreeTrialContext: Context<FreeTrialContextProps | undefined>

/**
 * @internal
 */
declare interface FreeTrialContextProps {
  data: FreeTrialResponse | null
  showDialog: boolean
  showOnLoad: boolean
  /**
   * If the user is seeing the `showOnLoad` popover or modal, and clicks on the pricing button the `showOnClick` modal should be triggered.
   */
  toggleShowContent: (closeAndReOpen?: boolean) => void
}

declare interface FreeTrialDialog {
  _id: string
  _type: 'dialog'
  _createdAt: string
  ctaButton?: {
    text: string
    action: 'openNext' | 'closeDialog' | 'openUrl'
    url?: string
  }
  secondaryButton?: {
    text: string
  }
  descriptionText: PortableTextBlock[]
  dialogType: 'modal' | 'popover'
  headingText: string
  id: string
  image: Image_2 | null
  tags?: Tag[]
  _rev: string
  _updatedAt: string
}

declare interface FreeTrialResponse {
  id: string
  icon: string
  style: string
  showOnLoad: FreeTrialDialog | null
  showOnClick: FreeTrialDialog | null
  daysLeft: number
  totalDays: number
}

/**
 * @internal
 */
export declare const FullscreenPTEContext: Context<FullscreenPTEContextValue>

/**
 * Context for tracking fullscreen state of portable text editors by their path
 * @internal
 */
declare interface FullscreenPTEContextValue {
  /**
   * Get the fullscreen state for a specific path
   */
  getFullscreenPath: (path: Path) => string | undefined
  /**
   * Set the fullscreen state for a specific path
   */
  setFullscreenPath: (path: Path, isFullscreen: boolean) => void
  /**
   * Check if any portable text editor is currently in fullscreen mode
   */
  hasAnyFullscreen: () => boolean
  /**
   * Get all fullscreen paths
   */
  allFullscreenPaths: string[]
}

/**
 * General preview layout key
 *
 * @public
 */
declare type GeneralPreviewLayoutKey = 'compact' | 'default' | 'media' | 'detail'

/**
 * General preview layout key
 *
 * @public
 */
declare type GeneralPreviewLayoutKey_2 = 'compact' | 'default' | 'media' | 'detail'

/**
 * Interface for generic list
 *
 * @public
 */
declare interface GenericList extends BaseGenericList {
  /** List type */
  type: string
  /** List menu items array. See {@link MenuItem} */
  menuItems: MenuItem[]
  /** List menu item groups array. See {@link MenuItemGroup} */
  menuItemGroups: MenuItemGroup[]
}

/**
 * Class for building generic lists
 *
 * @public
 */
declare abstract class GenericListBuilder<
  TList extends BuildableGenericList,
  ConcreteImpl,
> implements Serializable_2<GenericList> {
  /** Check if initial value templates are set */
  protected initialValueTemplatesSpecified: boolean
  /** Generic list option object */
  protected spec: TList
  /** Set generic list ID
   * @param id - generic list ID
   * @returns generic list builder based on ID provided.
   */
  id(id: string): ConcreteImpl
  /** Get generic list ID
   * @returns generic list ID
   */
  getId(): TList['id']
  /** Set generic list title
   * @param title - generic list title
   * @returns generic list builder based on title and ID provided.
   */
  title(title: string): ConcreteImpl
  /** Get generic list title
   * @returns generic list title
   */
  getTitle(): TList['title']
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n: I18nTextRecord<'title'>): ConcreteImpl
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n(): TList['i18n']
  /** Set generic list layout
   * @param defaultLayout - generic list layout key.
   * @returns generic list builder based on layout provided.
   */
  defaultLayout(defaultLayout: PreviewLayoutKey_2): ConcreteImpl
  /** Get generic list layout
   * @returns generic list layout
   */
  getDefaultLayout(): TList['defaultLayout']
  /** Set generic list menu items
   * @param menuItems - generic list menu items. See {@link MenuItem} and {@link MenuItemBuilder}
   * @returns generic list builder based on menu items provided.
   */
  menuItems(menuItems: (MenuItem | MenuItemBuilder)[] | undefined): ConcreteImpl
  /** Get generic list menu items
   * @returns generic list menu items
   */
  getMenuItems(): TList['menuItems']
  /** Set generic list menu item groups
   * @param menuItemGroups - generic list menu item groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder}
   * @returns generic list builder based on menu item groups provided.
   */
  menuItemGroups(menuItemGroups: (MenuItemGroup | MenuItemGroupBuilder)[]): ConcreteImpl
  /** Get generic list menu item groups
   * @returns generic list menu item groups
   */
  getMenuItemGroups(): TList['menuItemGroups']
  /** Set generic list child
   * @param child - generic list child. See {@link Child}
   * @returns generic list builder based on child provided (clone).
   */
  child(child: Child): ConcreteImpl
  /** Get generic list child
   * @returns generic list child
   */
  getChild(): TList['child']
  /** Set generic list can handle intent
   * @param canHandleIntent - generic list intent checker. See {@link IntentChecker}
   * @returns generic list builder based on can handle intent provided.
   */
  canHandleIntent(canHandleIntent?: IntentChecker): ConcreteImpl
  /** Get generic list can handle intent
   * @returns generic list can handle intent
   */
  getCanHandleIntent(): TList['canHandleIntent']
  /** Set generic list display options
   * @param enabled - allow / disallow for showing icons
   * @returns generic list builder based on display options (showIcons) provided.
   */
  showIcons(enabled?: boolean): ConcreteImpl
  /** Get generic list display options
   * @returns generic list display options (specifically showIcons)
   */
  getShowIcons(): boolean | undefined
  /** Set generic list initial value templates
   * @param templates - generic list initial value templates. See {@link InitialValueTemplateItemBuilder}
   * @returns generic list builder based on templates provided.
   */
  initialValueTemplates(
    templates:
      | InitialValueTemplateItem_2
      | InitialValueTemplateItemBuilder
      | Array<InitialValueTemplateItem_2 | InitialValueTemplateItemBuilder>,
  ): ConcreteImpl
  /** Get generic list initial value templates
   * @returns generic list initial value templates
   */
  getInitialValueTemplates(): TList['initialValueTemplates']
  /** Serialize generic list
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic list object based on path provided in options. See {@link GenericList}
   */
  serialize(options?: SerializeOptions): GenericList
  /** Clone generic list builder (allows for options overriding)
   * @param _withSpec - generic list options.
   * @returns generic list builder.
   */
  abstract clone(_withSpec?: object): ConcreteImpl
}

/**
 * Interface for generic list input
 * Allows builders and only requires things not inferrable
 *
 * @public */
declare interface GenericListInput extends StructureNode {
  /** Input id */
  id: string
  /** Input title */
  title: string
  /** Input menu items groups. See {@link MenuItem} and {@link MenuItemBuilder} */
  menuItems?: (MenuItem | MenuItemBuilder)[]
  /** Input menu items groups. See {@link MenuItemGroup} and {@link MenuItemGroupBuilder} */
  menuItemGroups?: (MenuItemGroup | MenuItemGroupBuilder)[]
  /** Input initial value array. See {@link InitialValueTemplateItem} and {@link InitialValueTemplateItemBuilder} */
  initialValueTemplates?: (InitialValueTemplateItem_2 | InitialValueTemplateItemBuilder)[]
  /** Input default layout. */
  defaultLayout?: PreviewLayoutKey_2
  /** If input can handle intent. See {@link IntentChecker} */
  canHandleIntent?: IntentChecker
  /** Input child of type {@link Child} */
  child?: Child
}

/**
 * Class for building generic views.
 *
 * @public
 */
declare abstract class GenericViewBuilder<
  TView extends Partial<BaseView>,
  ConcreteImpl,
> implements Serializable_2<BaseView> {
  /** Generic view option object */
  protected spec: TView
  /** Set generic view ID
   * @param id - generic view ID
   * @returns generic view builder based on ID provided.
   */
  id(id: string): ConcreteImpl
  /** Get generic view ID
   * @returns generic view ID
   */
  getId(): TView['id']
  /** Set generic view title
   * @param title - generic view title
   * @returns generic view builder based on title provided and (if provided) its ID.
   */
  title(title: string): ConcreteImpl
  /** Get generic view title
   * @returns generic view title
   */
  getTitle(): TView['title']
  /** Set generic view icon
   * @param icon - generic view icon
   * @returns generic view builder based on icon provided.
   */
  icon(icon: React.ComponentType | React.ReactNode): ConcreteImpl
  /** Get generic view icon
   * @returns generic view icon
   */
  getIcon(): TView['icon']
  /** Serialize generic view
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns generic view object based on path provided in options. See {@link BaseView}
   */
  serialize(options?: SerializeOptions): BaseView
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - Partial generic view builder options. See {@link BaseView}
   * @returns Generic view builder.
   */
  abstract clone(withSpec?: Partial<BaseView>): ConcreteImpl
}

/**
 * @internal
 */
export declare const GetFormValueContext: Context<GetFormValueContextValue | null>

/**
 * @internal
 * @hidden
 */
export declare type GetFormValueContextValue = (path: Path) => unknown

/**
 * @hidden
 * @beta
 */
declare interface GroupableActionDescription<GroupType = unknown> extends BaseActionDescription {
  group?: GroupType[]
}

/**
 * @hidden
 * @beta
 */
declare interface GroupableActionDescription_2<
  GroupType = unknown,
> extends BaseActionDescription_2 {
  group?: GroupType[]
}

declare type GuardedOperation = Operation<any[], 'NOT_READY'>

declare interface HasUsedScheduledPublishing {
  used: boolean
  loading: boolean
}

/**
 * Configuration options for Presentation tool's optional custom preview header component
 *
 * @public
 */
declare interface HeaderOptions {
  /**
   * React component to render as the preview header, receives PreviewHeaderProps
   */
  component: ComponentType<PreviewHeaderProps>
}

/** @internal */
declare type HexColor = string

/**
 * @hidden
 * @beta
 */
declare interface HistoryClearedEvent extends BaseEvent {
  type: 'historyCleared'
  documentId: string
}

/**
 * @hidden
 * @beta
 */
declare interface HistoryClearedEvent_2 extends BaseEvent_2 {
  type: 'historyCleared'
  documentId: string
}

/** @public */
declare interface HookCollectionActionHook<Args, State> {
  (args: Args): State | null
  displayName?: string | undefined
  action?: string
}

/** @public */
declare interface HookCollectionActionHook_2<Args, State> {
  (args: Args): State | null
  displayName?: string | undefined
  action?: string
}

/** @internal */
export declare const HoveredFieldContext: Context<HoveredFieldContextValue>

/** @internal */
export declare interface HoveredFieldContextValue {
  store: {
    subscribe: (onStoreCallback: () => void) => () => void
    getSnapshot: () => string[]
  }
  onMouseEnter: (path: Path) => void
  onMouseLeave: (path: Path) => void
}

/**
 * @alpha
 */
declare type I18nSearchOperatorDescriptionKey = `search.operator.${Lowercase<string>}.description`

/**
 * @alpha
 */
declare type I18nSearchOperatorDescriptionKey_2 = `search.operator.${Lowercase<string>}.description`

/**
 * @alpha
 */
declare type I18nSearchOperatorNameKey = `search.operator.${Lowercase<string>}.name`

/**
 * @alpha
 */
declare type I18nSearchOperatorNameKey_2 = `search.operator.${Lowercase<string>}.name`

/** @internal */
declare interface IdPair {
  draftId: string
  publishedId: string
  versionId?: string
}

declare interface Image_2 {
  asset: {
    url: string
    altText: string | null
  }
}

/**
 * A locale resource bundle where the locale is inherited from the parent locale definition.
 *
 * @public
 */
declare type ImplicitLocaleResourceBundle = Omit<LocaleResourceBundle, 'locale'>

/**
 * A locale resource bundle where the locale is inherited from the parent locale definition.
 *
 * @public
 */
declare type ImplicitLocaleResourceBundle_2 = Omit<LocaleResourceBundle_2, 'locale'>

/**
 * This error may happen if the member type is structurally incompatible with the defined schema type.
 * Some examples:
 *   - the schema type defines an array, but the actual value is an object (or vice versa)
 *   - the schema type defines a number, but the actual value is a string (or vice versa)
 *   - the schema type defines an object, but the actual value is a string (or vice versa)
 *
 * @public
 */
declare type IncompatibleTypeError = {
  type: 'INCOMPATIBLE_TYPE'
  expectedSchemaType: SchemaType
  resolvedValueType: string
  value: unknown
}

/**
 * This error may happen if the member type is structurally incompatible with the defined schema type.
 * Some examples:
 *   - the schema type defines an array, but the actual value is an object (or vice versa)
 *   - the schema type defines a number, but the actual value is a string (or vice versa)
 *   - the schema type defines an object, but the actual value is a string (or vice versa)
 *
 * @public
 */
declare type IncompatibleTypeError_2 = {
  type: 'INCOMPATIBLE_TYPE'
  expectedSchemaType: SchemaType
  resolvedValueType: string
  value: unknown
}

/**
 * @hidden
 * @beta */
declare interface InitialValueErrorMsg {
  type: 'error'
  error: Error
}

/**
 * @hidden
 * @beta */
declare interface InitialValueLoadingMsg {
  type: 'loading'
}

/**
 * @hidden
 * @beta */
declare type InitialValueMsg =
  | InitialValueLoadingMsg
  | InitialValueSuccessMsg
  | InitialValueErrorMsg

/**
 * @hidden
 * @beta */
declare interface InitialValueOptions {
  documentId: string
  documentType: string
  templateName?: string
  templateParams?: Record<string, any>
}

/**
 * @hidden
 * @beta */
declare interface InitialValueSuccessMsg {
  type: 'success'
  value: SanityDocumentLike | null
}

/**
 * Representation of an initial value template _item_
 * Used by the {@link structure.StructureBuilder} class to determine which initial value templates
 * should be available for a structure node, such as a list pane.
 *
 * @public
 */
declare interface InitialValueTemplateItem extends TemplateItem {
  type: 'initialValueTemplateItem'
  /** ID for this template item */
  id: string
  /** Initial value template schema type */
  schemaType: string
}

/**
 * Representation of an initial value template _item_
 * Used by the {@link structure.StructureBuilder} class to determine which initial value templates
 * should be available for a structure node, such as a list pane.
 *
 * @public
 */
declare interface InitialValueTemplateItem_2 extends TemplateItem_2 {
  type: 'initialValueTemplateItem'
  /** ID for this template item */
  id: string
  /** Initial value template schema type */
  schemaType: string
}

/**
 * A `InitialValueTemplateItemBuilder` is used to build a document node with an initial value set.
 *
 * @public
 */
declare class InitialValueTemplateItemBuilder implements Serializable_2<InitialValueTemplateItem_2> {
  /** Initial Value template item option object. See {@link InitialValueTemplateItem} */
  protected spec: Partial<InitialValueTemplateItem_2>
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: Partial<InitialValueTemplateItem_2>,
  )
  /** Set initial value template item builder ID
   * @param id - initial value template item ID
   * @returns initial value template item based on ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  id(id: string): InitialValueTemplateItemBuilder
  /** Get initial value template item builder ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getId(): Partial<InitialValueTemplateItem_2>['id']
  /** Set initial value template item title
   * @param title - initial value template item title
   * @returns initial value template item based on title provided. See {@link InitialValueTemplateItemBuilder}
   */
  title(title: string): InitialValueTemplateItemBuilder
  /** Get initial value template item title
   * @returns initial value template item title. See {@link InitialValueTemplateItem}
   */
  getTitle(): Partial<InitialValueTemplateItem_2>['title']
  /** Set initial value template item description
   * @param description - initial value template item description
   * @returns initial value template item builder based on description provided. See {@link InitialValueTemplateItemBuilder}
   */
  description(description: string): InitialValueTemplateItemBuilder
  /** Get initial value template item description
   * @returns initial value template item description. See {@link InitialValueTemplateItem}
   */
  getDescription(): Partial<InitialValueTemplateItem_2>['description']
  /** Set initial value template ID
   * @param templateId - initial value template item template ID
   * @returns initial value template item based builder on template ID provided. See {@link InitialValueTemplateItemBuilder}
   */
  templateId(templateId: string): InitialValueTemplateItemBuilder
  /** Get initial value template item template ID
   * @returns initial value template item ID. See {@link InitialValueTemplateItem}
   */
  getTemplateId(): Partial<InitialValueTemplateItem_2>['templateId']
  /** Get initial value template item template parameters
   * @param parameters - initial value template item parameters
   * @returns initial value template item builder based on parameters provided. See {@link InitialValueTemplateItemBuilder}
   */
  parameters(parameters: {[key: string]: any}): InitialValueTemplateItemBuilder
  /** Get initial value template item template parameters
   * @returns initial value template item parameters. See {@link InitialValueTemplateItem}
   */
  getParameters(): Partial<InitialValueTemplateItem_2>['parameters']
  /** Serialize initial value template item
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns initial value template item object based on the path, index and hint provided in options. See {@link InitialValueTemplateItem}
   */
  serialize({path, index, hint}?: SerializeOptions): InitialValueTemplateItem_2
  /** Clone generic view builder (allows for options overriding)
   * @param withSpec - initial value template item builder options. See {@link InitialValueTemplateItemBuilder}
   * @returns initial value template item builder based on the context and options provided. See {@link InitialValueTemplateItemBuilder}
   */
  clone(withSpec?: Partial<InitialValueTemplateItem_2>): InitialValueTemplateItemBuilder
}

declare type Input = Omit<SetPreviewSearchParamEvent, 'type'>

/**
 * @hidden
 * @beta */
declare interface InputOnSelectFileFunctionProps {
  assetSource: AssetSource
  schemaType: SchemaType
  file: File
}

/**
 * @hidden
 * @beta */
declare interface InputOnSelectFileFunctionProps_2 {
  assetSource: AssetSource
  schemaType: SchemaType
  file: File
}

/**
 * @hidden
 * @public */
declare type InputProps =
  | ArrayOfObjectsInputProps
  | ArrayOfPrimitivesInputProps
  | BooleanInputProps
  | NumberInputProps
  | ObjectInputProps
  | ObjectInputProps<CrossDatasetReferenceValue>
  | ObjectInputProps<FileValue>
  | ObjectInputProps<GeopointValue>
  | ObjectInputProps<ImageValue>
  | ObjectInputProps<ReferenceValue>
  | ObjectInputProps<SlugValue>
  | PortableTextInputProps
  | StringInputProps

/**
 * @hidden
 * @public */
declare type InputProps_2 =
  | ArrayOfObjectsInputProps_2
  | ArrayOfPrimitivesInputProps_2
  | BooleanInputProps_2
  | NumberInputProps_2
  | ObjectInputProps_2
  | ObjectInputProps_2<CrossDatasetReferenceValue>
  | ObjectInputProps_2<FileValue>
  | ObjectInputProps_2<GeopointValue>
  | ObjectInputProps_2<ImageValue>
  | ObjectInputProps_2<ReferenceValue>
  | ObjectInputProps_2<SlugValue>
  | PortableTextInputProps_2
  | StringInputProps_2

/**
 * parameters for the changes inspector
 * @public
 */
declare interface InspectorTab {
  changesInspectorTab?: 'history' | 'review'
}

/**
 * Interface for intents
 * @public */
declare interface Intent {
  /** Intent type */
  type: string
  /** Intent parameters. See {@link IntentParams}
   */
  params?: IntentParams
  searchParams?: SearchParam[]
}

/**
 * Interface for intent checker
 *
 * @public
 */
declare interface IntentChecker {
  (
    /** Intent name */
    intentName: string,
    /** Intent checker parameter */
    params: {
      [key: string]: any
    },
    /** Structure context. See {@link StructureNode} */
    context: {
      pane: StructureNode
      index: number
    },
  ): boolean
  /** intent checker identify */
  identity?: symbol
}

/**
 * Intent parameters (json)
 *
 * @public
 */
declare type IntentJsonParams = {
  [key: string]: any
}

/**
 * Intent parameters (json)
 *
 * @public
 */
declare type IntentJsonParams_2 = {
  [key: string]: any
}

/**
 * @public
 * @todo dedupe with intent types in core
 */
declare type IntentParameters_2 = BaseIntentParams_2 | [BaseIntentParams_2, IntentJsonParams_2]

/**
 * Intent parameters
 * See {@link structure.BaseIntentParams} and {@link structure.IntentJsonParams}
 *
 * @public
 */
declare type IntentParams = BaseIntentParams | [BaseIntentParams, IntentJsonParams]

/**
 * This error may happen for arrays (of both objects and primitive values) if we encounter items that are not valid according to the schema definition
 *
 *
 * @hidden
 * @beta
 */
declare type InvalidItemTypeError = {
  type: 'INVALID_ITEM_TYPE'
  validTypes: SchemaType[]
  resolvedValueType: string
  value: unknown
}

/**
 * This error may happen for arrays (of both objects and primitive values) if we encounter items that are not valid according to the schema definition
 *
 *
 * @hidden
 * @beta
 */
declare type InvalidItemTypeError_2 = {
  type: 'INVALID_ITEM_TYPE'
  validTypes: SchemaType[]
  resolvedValueType: string
  value: unknown
}

/**
 * @internal
 */
export declare const IsLastPaneContext: Context<boolean>

/**
 * Item Child. See {@link CollectionBuilder} and {@link Collection}
 *
 * @public
 */
declare type ItemChild = CollectionBuilder | Collection | undefined

/** @public */
declare type ItemProps =
  | ObjectItemProps
  | ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>
  | ObjectItemProps<FileValue & ObjectItem>
  | ObjectItemProps<GeopointValue & ObjectItem>
  | ObjectItemProps<ImageValue & ObjectItem>
  | ObjectItemProps<ReferenceValue & ObjectItem>
  | ObjectItemProps<SlugValue & ObjectItem>
  | PrimitiveItemProps

/** @public */
declare type ItemProps_2 =
  | ObjectItemProps_2
  | ObjectItemProps_2<CrossDatasetReferenceValue & ObjectItem_2>
  | ObjectItemProps_2<FileValue & ObjectItem_2>
  | ObjectItemProps_2<GeopointValue & ObjectItem_2>
  | ObjectItemProps_2<ImageValue & ObjectItem_2>
  | ObjectItemProps_2<ReferenceValue & ObjectItem_2>
  | ObjectItemProps_2<SlugValue & ObjectItem_2>
  | PrimitiveItemProps_2

declare type LastActiveIndexSet = {
  type: 'LAST_ACTIVE_INDEX_SET'
  index: number
}

/**
 * @hidden
 * @beta */
declare interface LayoutProps {
  renderDefault: (props: LayoutProps) => React.JSX.Element
}

/**
 * @hidden
 * @beta */
declare interface LayoutProps_2 {
  renderDefault: (props: LayoutProps_2) => React.JSX.Element
}

/**
 * Interface for List
 *
 * @public
 */
declare interface List extends GenericList {
  type: 'list'
  /** List items. See {@link ListItem} and {@link Divider} */
  items: (ListItem | Divider)[]
}

/**
 * A `ListBuilder` is used to build a list of items in the structure tool.
 *
 * @public */
declare class ListBuilder extends GenericListBuilder<BuildableList, ListBuilder> {
  /** buildable list option object. See {@link BuildableList} */
  protected spec: BuildableList
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: ListInput,
  )
  /**
   * Set list builder based on items provided
   * @param items - list items. See {@link ListItemBuilder}, {@link ListItem} and {@link Divider}
   * @returns list builder based on items provided. See {@link ListBuilder}
   */
  items(items: (ListItemBuilder | ListItem | Divider | DividerBuilder)[]): ListBuilder
  /** Get list builder items
   * @returns list items. See {@link BuildableList}
   */
  getItems(): BuildableList['items']
  /** Serialize list builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns list based on path in options. See {@link List}
   */
  serialize(options?: SerializeOptions): List
  /**
   * Clone list builder and return new list builder based on context and spec provided
   * @param withSpec - list options. See {@link BuildableList}
   * @returns new list builder based on context and spec provided. See {@link ListBuilder}
   */
  clone(withSpec?: BuildableList): ListBuilder
}

/**
 * Interface for list display options
 *
 * @public */
declare interface ListDisplayOptions {
  /** Check if list display should show icons */
  showIcons?: boolean
}

/**
 * @hidden
 * @beta */
declare interface ListenQueryOptions {
  tag?: string
  apiVersion?: string
  perspective?: ClientPerspective
  throttleTime?: number
  transitions?: ('update' | 'appear' | 'disappear')[]
}

/**
 * Interface for list input
 *
 * @public
 */
declare interface ListInput extends GenericListInput {
  /** List input items array. See {@link ListItem}, {@link ListItemBuilder} and {@link Divider} */
  items?: (ListItem | ListItemBuilder | Divider | DividerBuilder)[]
}

/**
 * Interface for List Item
 *
 * @public */
declare interface ListItem {
  /** List item id */
  id: string
  /** List item type */
  type: string
  /**
   * The i18n key and namespace used to populate the localized title. This is
   * the recommend way to set the title if you are localizing your studio.
   */
  i18n?: I18nTextRecord<'title'>
  /** List item title. Note that the `i18n` key and namespace will take precedence. */
  title?: string
  /** List item icon */
  icon?: React.ComponentType | React.ReactNode
  /** List item child. See {@link ListItemChild} */
  child?: ListItemChild
  /** List item display options. See {@link ListItemDisplayOptions} */
  displayOptions?: ListItemDisplayOptions
  /** List item schema type. See {@link SchemaType} */
  schemaType?: SchemaType
}

/**
 * Class for building list items
 *
 * @public */
declare class ListItemBuilder implements Serializable_2<ListItem> {
  /** List item option object. See {@link PartialListItem} */
  protected spec: PartialListItem
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: ListItemInput,
  )
  /**
   * Set list item ID
   * @returns list item builder based on ID provided. See {@link ListItemBuilder}
   */
  id(id: string): ListItemBuilder
  /**
   * Get list item ID
   * @returns list item ID. See {@link PartialListItem}
   */
  getId(): PartialListItem['id']
  /**
   * Set list item title
   * @returns list item builder based on title provided. See {@link ListItemBuilder}
   */
  title(title: string): ListItemBuilder
  /**
   * Get list item title
   * @returns list item title. See {@link PartialListItem}
   */
  getTitle(): PartialListItem['title']
  /** Set the i18n key and namespace used to populate the localized title.
   * @param i18n - the key and namespaced used to populate the localized title.
   * @returns component builder based on i18n key and ns provided
   */
  i18n(i18n: I18nTextRecord<'title'>): ListItemBuilder
  /** Get i18n key and namespace used to populate the localized title
   * @returns the i18n key and namespace used to populate the localized title
   */
  getI18n(): I18nTextRecord<'title'> | undefined
  /**
   * Set list item icon
   * @returns list item builder based on icon provided. See {@link ListItemBuilder}
   */
  icon(icon: React.ComponentType | React.ReactNode): ListItemBuilder
  /**
   * Set if list item should show icon
   * @returns list item builder based on showIcon provided. See {@link ListItemBuilder}
   */
  showIcon(enabled?: boolean): ListItemBuilder
  /**
   * Check if list item should show icon
   * @returns true if it should show the icon, false if not, undefined if not set
   */
  getShowIcon(): boolean | undefined
  /**
   *Get list item icon
   * @returns list item icon. See {@link PartialListItem}
   */
  getIcon(): PartialListItem['icon']
  /**
   * Set list item child
   * @param child - list item child. See {@link UnserializedListItemChild}
   * @returns list item builder based on child provided. See {@link ListItemBuilder}
   */
  child(child: UnserializedListItemChild): ListItemBuilder
  /**
   * Get list item child
   * @returns list item child. See {@link PartialListItem}
   */
  getChild(): PartialListItem['child']
  /**
   * Set list item schema type
   * @param schemaType - list item schema type. See {@link SchemaType}
   * @returns list item builder based on schema type provided. See {@link ListItemBuilder}
   */
  schemaType(schemaType: SchemaType | string): ListItemBuilder
  /**
   * Get list item schema type
   * @returns list item schema type. See {@link PartialListItem}
   */
  getSchemaType(): PartialListItem['schemaType']
  /** Serialize list item builder
   * @param options - serialization options. See {@link ListItemSerializeOptions}
   * @returns list item node based on path provided in options. See {@link ListItem}
   */
  serialize(options?: ListItemSerializeOptions): ListItem
  /** Clone list item builder
   * @param withSpec - partial list item options. See {@link PartialListItem}
   * @returns list item builder based on context and spec provided. See {@link ListItemBuilder}
   */
  clone(withSpec?: PartialListItem): ListItemBuilder
}

/**
 * Child of List Item
 * See {@link Collection}, {@link ChildResolver}, {@link ItemChild}
 * @public
 */
declare type ListItemChild = Collection | ChildResolver | Observable<ItemChild> | undefined

/**
 * Interface for ist item display options
 *
 * @public */
declare interface ListItemDisplayOptions {
  /** Check if list item display should show icon */
  showIcon?: boolean
}

/**
 * interface for list item input
 *
 * @public */
declare interface ListItemInput {
  /** List item id */
  id: string
  /** List item title */
  title?: string
  /** List item icon */
  icon?: React.ComponentType | React.ReactNode
  /** List item child. See {@link ListItemChild} */
  child?: ListItemChild
  /** List item display options. See {@link ListItemDisplayOptions} */
  displayOptions?: ListItemDisplayOptions
  /** List item schema type. See {@link SchemaType} */
  schemaType?: SchemaType | string
}

/**
 * Interface for serialize list item options
 *
 * @public
 */
declare interface ListItemSerializeOptions extends SerializeOptions {
  /** Check if list item title is optional */
  titleIsOptional?: boolean
}

/** @internal */
declare interface ListPaneNode extends BaseResolvedPaneNode<'list'> {
  defaultLayout?: GeneralPreviewLayoutKey_2
  displayOptions?: {
    showIcons?: boolean
  }
  items?: Array<PaneListItem | PaneListItemDivider>
  source?: string
}

/**
 *
 * @hidden
 * @internal
 */
export declare const LiveUserApplicationContext: Context<LiveUserApplicationContextValue>

/**
 * @hidden
 * @internal
 */
export declare type LiveUserApplicationContextValue = {
  userApplication: UserApplication | undefined
}

declare type Loadable<T> = {
  data: T | null
  error: Error | null
  loading: boolean
}

declare const LOADING_PANE: unique symbol

/**
 * A locale representation
 *
 * @public
 */
declare interface Locale {
  /**
   * The ID of the locale, eg `en-US`, `nb-NO`, `th-TH`
   */
  id: string
  /**
   * The title of locale, eg `English (US)`, `Norsk (bokml)`, ``
   */
  title: string
  /**
   * Week information for this locale. Based on the `Intl.Locale['weekInfo']` type.
   */
  weekInfo: LocaleWeekInfo
}

/**
 * A locale representation
 *
 * @public
 */
declare interface Locale_2 {
  /**
   * The ID of the locale, eg `en-US`, `nb-NO`, `th-TH`
   */
  id: string
  /**
   * The title of locale, eg `English (US)`, `Norsk (bokml)`, ``
   */
  title: string
  /**
   * Week information for this locale. Based on the `Intl.Locale['weekInfo']` type.
   */
  weekInfo: LocaleWeekInfo_2
}

/**
 * Context passed to locale config resolvers
 *
 * @public
 */
declare interface LocaleConfigContext {
  projectId: string
  dataset: string
}

/**
 * Context passed to locale config resolvers
 *
 * @public
 */
declare interface LocaleConfigContext_2 {
  projectId: string
  dataset: string
}

/**
 * @internal
 * @hidden
 */
export declare const LocaleContext: Context<LocaleContextValue | undefined>

/**
 * @internal
 * @hidden
 */
export declare interface LocaleContextValue {
  locales: Locale[]
  currentLocale: Locale
  __internal: {
    i18next: i18n
  }
  changeLocale: (newLocale: string) => Promise<void>
}

/**
 * A locale definition, which describes a locale and its resources.
 *
 * @public
 */
declare interface LocaleDefinition extends Locale {
  /**
   * Array of resource bundles for this locale, if any.
   *
   * Generally you'll want to provide some base resources, eg for the studio core namespace,
   * as well as for common namespaces like `structure` and `vision`. You can also provide resources
   * for other plugins/namespaces - but preferably the resources should be provided as an async
   * function that imports the resources, in order to lazy load them on use.
   */
  bundles?: (ImplicitLocaleResourceBundle | LocaleResourceBundle)[]
}

/**
 * A locale definition, which describes a locale and its resources.
 *
 * @public
 */
declare interface LocaleDefinition_2 extends Locale_2 {
  /**
   * Array of resource bundles for this locale, if any.
   *
   * Generally you'll want to provide some base resources, eg for the studio core namespace,
   * as well as for common namespaces like `structure` and `vision`. You can also provide resources
   * for other plugins/namespaces - but preferably the resources should be provided as an async
   * function that imports the resources, in order to lazy load them on use.
   */
  bundles?: (ImplicitLocaleResourceBundle_2 | LocaleResourceBundle_2)[]
}

/**
 * An object of locale resources, or a string array of resources
 *
 * @public
 */
declare type LocaleNestedResource = LocaleResourceRecord | string[]

/**
 * An object of locale resources, or a string array of resources
 *
 * @public
 */
declare type LocaleNestedResource_2 = LocaleResourceRecord_2 | string[]

/**
 * Options that defines or adds resources to existing locales
 *
 * @public
 */
declare interface LocalePluginOptions {
  /**
   * Locales available for user selection.
   *
   * Titles and icons can be changed by using a function (reducer pattern) and transforming values.
   */
  locales?: LocalesOption
  /**
   * Bundles contain "resources" (strings) that yields translations for different locales
   * throughout the studio. The strings are scoped to a specific locale and namespace.
   * Namespaces in this context usually means a specific part of the studio, like a tool or plugin.
   */
  bundles?: LocalesBundlesOption
}

/**
 * Options that defines or adds resources to existing locales
 *
 * @public
 */
declare interface LocalePluginOptions_2 {
  /**
   * Locales available for user selection.
   *
   * Titles and icons can be changed by using a function (reducer pattern) and transforming values.
   */
  locales?: LocalesOption_2
  /**
   * Bundles contain "resources" (strings) that yields translations for different locales
   * throughout the studio. The strings are scoped to a specific locale and namespace.
   * Namespaces in this context usually means a specific part of the studio, like a tool or plugin.
   */
  bundles?: LocalesBundlesOption_2
}

/**
 * A collection of locale resources for a given locale and namespace.
 * In other words, an object of translated locale strings.
 *
 * @public
 */
declare interface LocaleResourceBundle {
  /**
   * The locale ID the resources belong to, eg `en-US`, `nb-NO`, `th-TH`
   */
  locale: string
  /**
   * The namespace the resources belong to, eg `vision`, `structure`, `studio`
   */
  namespace: string
  /**
   * An object of locale resources, or a function that resolves to one.
   * The localization framework automatically handles ESM modules with a default export,
   * since a common use case is to dynamically load a resource file on use. This is the
   * preferred option, since it allows for lazy loading of locale resources on use.
   */
  resources:
    | LocaleResourceRecord
    | (() => Promise<
        | LocaleResourceRecord
        | {
            default: LocaleResourceRecord
          }
      >)
  /**
   * Whether the resources should be merged deeply (eg for nested objects). Default: true
   */
  deep?: boolean
  /**
   * Whether any existing resource keys for the namespace be overwritten. Default: true
   */
  overwrite?: boolean
}

/**
 * A collection of locale resources for a given locale and namespace.
 * In other words, an object of translated locale strings.
 *
 * @public
 */
declare interface LocaleResourceBundle_2 {
  /**
   * The locale ID the resources belong to, eg `en-US`, `nb-NO`, `th-TH`
   */
  locale: string
  /**
   * The namespace the resources belong to, eg `vision`, `structure`, `studio`
   */
  namespace: string
  /**
   * An object of locale resources, or a function that resolves to one.
   * The localization framework automatically handles ESM modules with a default export,
   * since a common use case is to dynamically load a resource file on use. This is the
   * preferred option, since it allows for lazy loading of locale resources on use.
   */
  resources:
    | LocaleResourceRecord_2
    | (() => Promise<
        | LocaleResourceRecord_2
        | {
            default: LocaleResourceRecord_2
          }
      >)
  /**
   * Whether the resources should be merged deeply (eg for nested objects). Default: true
   */
  deep?: boolean
  /**
   * Whether any existing resource keys for the namespace be overwritten. Default: true
   */
  overwrite?: boolean
}

/**
 * A locale resource key, which can be a leaf string, or a nested resource
 *
 * @public
 */
declare type LocaleResourceKey = string | LocaleNestedResource

/**
 * A locale resource key, which can be a leaf string, or a nested resource
 *
 * @public
 */
declare type LocaleResourceKey_2 = string | LocaleNestedResource_2

/**
 * An object of locale resources.
 *
 * @public
 */
declare interface LocaleResourceRecord {
  [key: string]: LocaleResourceKey
}

/**
 * An object of locale resources.
 *
 * @public
 */
declare interface LocaleResourceRecord_2 {
  [key: string]: LocaleResourceKey_2
}

/**
 * Either an array of locale resource bundles, or a resolver that returns one.
 *
 * @public
 */
declare type LocalesBundlesOption =
  | ((prev: LocaleResourceBundle[], context: LocaleConfigContext) => LocaleResourceBundle[])
  | LocaleResourceBundle[]

/**
 * Either an array of locale resource bundles, or a resolver that returns one.
 *
 * @public
 */
declare type LocalesBundlesOption_2 =
  | ((prev: LocaleResourceBundle_2[], context: LocaleConfigContext_2) => LocaleResourceBundle_2[])
  | LocaleResourceBundle_2[]

/**
 * Either an array of locale definitions, or a resolver that returns one.
 *
 * @public
 */
declare type LocalesOption =
  | ((prev: LocaleDefinition[], context: LocaleConfigContext) => LocaleDefinition[])
  | LocaleDefinition[]

/**
 * Either an array of locale definitions, or a resolver that returns one.
 *
 * @public
 */
declare type LocalesOption_2 =
  | ((prev: LocaleDefinition_2[], context: LocaleConfigContext_2) => LocaleDefinition_2[])
  | LocaleDefinition_2[]

/**
 * Internal representation of the available locale configuration.
 *
 * Generally not something you will want to use directly.
 *
 * @public
 */
declare interface LocaleSource {
  /**
   * Current locale ID (eg `en-US`, `nb-NO`, `th-TH`)
   */
  currentLocale: Locale
  /**
   * Array of locale definitions
   */
  locales: Locale[]
  /**
   * Loads the given namespaces, if not already done.
   *
   * @param namespaces - Array of namespace names to load
   * @returns Promise which resolves once loaded.
   */
  loadNamespaces(namespaces: string[]): Promise<void>
  /**
   * Translation function, eg `t('some.key') => 'Some string'`
   */
  t: TFunction
}

/**
 * Internal representation of the available locale configuration.
 *
 * Generally not something you will want to use directly.
 *
 * @public
 */
declare interface LocaleSource_2 {
  /**
   * Current locale ID (eg `en-US`, `nb-NO`, `th-TH`)
   */
  currentLocale: Locale_2
  /**
   * Array of locale definitions
   */
  locales: Locale_2[]
  /**
   * Loads the given namespaces, if not already done.
   *
   * @param namespaces - Array of namespace names to load
   * @returns Promise which resolves once loaded.
   */
  loadNamespaces(namespaces: string[]): Promise<void>
  /**
   * Translation function, eg `t('some.key') => 'Some string'`
   */
  t: TFunction
}

/**
 * An object representing week information associated with the Locale data specified in
 * {@link https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Patterns_Week_Elements | UTS 35's Week Elements }
 *
 * @public
 */
declare interface LocaleWeekInfo {
  /**
   * An integer indicating the first day of the week for the locale.
   * Can be either 1 (Monday), 6 (Saturday) or 7 (Sunday).
   */
  firstDay: 1 | 6 | 7
  /**
   * An array of integers indicating the weekend days for the locale, where 1 is Monday and 7 is Sunday.
   */
  weekend: (1 | 2 | 3 | 4 | 5 | 6 | 7)[]
  /**
   * An integer between 1 and 7 indicating the minimal days required in the first week of a month or year, for calendar purposes.
   * @deprecated Kept for backwards compatibility in typings, but not used anywhere.
   */
  minimalDays?: 1 | 2 | 3 | 4 | 5 | 6 | 7
}

/**
 * An object representing week information associated with the Locale data specified in
 * {@link https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Patterns_Week_Elements | UTS 35's Week Elements }
 *
 * @public
 */
declare interface LocaleWeekInfo_2 {
  /**
   * An integer indicating the first day of the week for the locale.
   * Can be either 1 (Monday), 6 (Saturday) or 7 (Sunday).
   */
  firstDay: 1 | 6 | 7
  /**
   * An array of integers indicating the weekend days for the locale, where 1 is Monday and 7 is Sunday.
   */
  weekend: (1 | 2 | 3 | 4 | 5 | 6 | 7)[]
  /**
   * An integer between 1 and 7 indicating the minimal days required in the first week of a month or year, for calendar purposes.
   * @deprecated Kept for backwards compatibility in typings, but not used anywhere.
   */
  minimalDays?: 1 | 2 | 3 | 4 | 5 | 6 | 7
}

/**
 * @beta
 * @hidden
 */
declare type LoginComponentProps =
  | {
      projectId: string
      /** @deprecated use redirectPath instead */
      basePath: string
      redirectPath?: string
    }
  | {
      projectId: string
      redirectPath: string
      /** @deprecated use redirectPath instead */
      basePath?: string
    }

/**
 * @beta
 * @hidden
 */
declare type LoginComponentProps_2 =
  | {
      projectId: string
      /** @deprecated use redirectPath instead */
      basePath: string
      redirectPath?: string
    }
  | {
      projectId: string
      redirectPath: string
      /** @deprecated use redirectPath instead */
      basePath?: string
    }

/**
 * Login methods that may be used for Studio authentication.
 *
 * @public
 */
declare type LoginMethod = 'dual' | 'cookie' | 'token'

/**
 * Login methods that may be used for Studio authentication.
 *
 * @public
 */
declare type LoginMethod_2 = 'dual' | 'cookie' | 'token'

/**
 * @hidden
 * @beta */
declare interface LogoProps {
  title: string
  renderDefault: (props: LogoProps) => React.JSX.Element
}

/**
 * @hidden
 * @beta */
declare interface LogoProps_2 {
  title: string
  renderDefault: (props: LogoProps_2) => React.JSX.Element
}

/** @public */
declare type MapDocument = (document: SanityDocumentLike) => SanityDocumentLike

/**
 * @beta
 */
declare type MarkdownConfig = Omit<MarkdownShortcutsPluginProps, 'unorderedList' | 'orderedList'> &
  (
    | {
        orderedList?: undefined
        /**
         * @deprecated - use `orderedList` instead
         */
        orderedListStyle?: MarkdownShortcutsPluginProps['orderedList']
      }
    | {
        orderedList?: MarkdownShortcutsPluginProps['orderedList']
        /**
         * @deprecated - use `orderedList` instead
         */
        orderedListStyle?: undefined
      }
  ) &
  (
    | {
        unorderedList?: undefined
        /**
         * @deprecated - use `unorderedList` instead
         */
        unorderedListStyle?: MarkdownShortcutsPluginProps['unorderedList']
      }
    | {
        unorderedList?: MarkdownShortcutsPluginProps['unorderedList']
        /**
         * @deprecated - use `unorderedList` instead
         */
        unorderedListStyle?: undefined
      }
  )

/**
 * @beta
 */
declare type MarkdownConfig_2 = Omit<
  MarkdownShortcutsPluginProps,
  'unorderedList' | 'orderedList'
> &
  (
    | {
        orderedList?: undefined
        /**
         * @deprecated - use `orderedList` instead
         */
        orderedListStyle?: MarkdownShortcutsPluginProps['orderedList']
      }
    | {
        orderedList?: MarkdownShortcutsPluginProps['orderedList']
        /**
         * @deprecated - use `orderedList` instead
         */
        orderedListStyle?: undefined
      }
  ) &
  (
    | {
        unorderedList?: undefined
        /**
         * @deprecated - use `unorderedList` instead
         */
        unorderedListStyle?: MarkdownShortcutsPluginProps['unorderedList']
      }
    | {
        unorderedList?: MarkdownShortcutsPluginProps['unorderedList']
        /**
         * @deprecated - use `unorderedList` instead
         */
        unorderedListStyle?: undefined
      }
  )

/**
 * Config for the Sanity Media Library asset source integration.
 * @beta
 */
declare interface MediaLibraryConfig {
  /**
   * Whether the Media Library is enabled.
   */
  enabled?: boolean
  /**
   * The ID of the Media Library that is connected to the Studio.
   * If not provided, the Media Library will be automatically detected.
   */
  libraryId?: string
}

/**
 * Config for the Sanity Media Library asset source integration.
 * @beta
 */
declare interface MediaLibraryConfig_2 {
  /**
   * Whether the Media Library is enabled.
   */
  enabled?: boolean
  /**
   * The ID of the Media Library that is connected to the Studio.
   * If not provided, the Media Library will be automatically detected.
   */
  libraryId?: string
}

/** @internal */
declare type MediaLibraryIds = {
  libraryId: string
  organizationId: string
}

/** @internal */
export declare const MediaLibraryIdsContext: Context<MediaLibraryIds | null>

/**
 * @internal
 */
export declare const MentionUserContext: Context<MentionUserContextValue | null>

/**
 * @internal
 */
declare interface MentionUserContextValue {
  mentionOptions: UserListWithPermissionsHookValue
  selectedDocument: SanityDocument_2 | null
  setSelectedDocument: (document: SanityDocument_2 | null) => void
}

/**
 * Interface for menu items
 *
 * @public */
declare interface MenuItem {
  /**
   * The i18n key and namespace used to populate the localized title. This is
   * the recommend way to set the title if you are localizing your studio.
   */
  i18n?: I18nTextRecord<'title'>
  /**
   * Menu Item title. Note that the `i18n` configuration will take
   * precedence and this title is left here as a fallback if no i18n key is
   * provided and compatibility with older plugins
   */
  title: string
  /** Menu Item action */
  action?: MenuItemActionType
  /** Menu Item intent */
  intent?: Intent
  /** Menu Item group */
  group?: string
  /** Menu Item icon */
  icon?: React.ComponentType | React.ReactNode
  /** Menu Item parameters. See {@link MenuItemParamsType} */
  params?: MenuItemParamsType
  /** Determine if it will show the MenuItem as action */
  showAsAction?: boolean
}

/**
 * Menu item action type
 * @public */
declare type MenuItemActionType =
  | string
  | ((params: Record<string, string> | undefined, scope?: any) => void)

/**
 * Class for building menu items.
 *
 * @public */
declare class MenuItemBuilder implements Serializable_2<MenuItem> {
  /** menu item option object. See {@link PartialMenuItem} */
  protected spec: PartialMenuItem
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: MenuItem,
  )
  /**
   * Set menu item action
   * @param action - menu item action. See {@link MenuItemActionType}
   * @returns menu item builder based on action provided. See {@link MenuItemBuilder}
   */
  action(action: MenuItemActionType): MenuItemBuilder
  /**
   * Get menu item action
   * @returns menu item builder action. See {@link PartialMenuItem}
   */
  getAction(): PartialMenuItem['action']
  /**
   * Set menu item intent
   * @param intent - menu item intent. See {@link Intent}
   * @returns menu item builder based on intent provided. See {@link MenuItemBuilder}
   */
  intent(intent: Intent): MenuItemBuilder
  /**
   * Get menu item intent
   * @returns menu item intent. See {@link PartialMenuItem}
   */
  getIntent(): PartialMenuItem['intent']
  /**
   * Set menu item title
   * @param title - menu item title
   * @returns menu item builder based on title provided. See {@link MenuItemBuilder}
   */
  title(title: string): MenuItemBuilder
  /**
   * Get menu item title. Note that the `i18n` configuration will take
   * precedence and this title is left here for compatibility.
   * @returns menu item title
   */
  getTitle(): string | undefined
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item builder based on i18n config provided. See {@link MenuItemBuilder}
   */
  i18n(i18n: I18nTextRecord<'title'>): MenuItemBuilder
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n(): I18nTextRecord<'title'> | undefined
  /**
   * Set menu item group
   * @param group - menu item group
   * @returns menu item builder based on group provided. See {@link MenuItemBuilder}
   */
  group(group: string): MenuItemBuilder
  /**
   * Get menu item group
   * @returns menu item group. See {@link PartialMenuItem}
   */
  getGroup(): PartialMenuItem['group']
  /**
   * Set menu item icon
   * @param icon - menu item icon
   * @returns menu item builder based on icon provided. See {@link MenuItemBuilder}
   */
  icon(icon: React.ComponentType | React.ReactNode): MenuItemBuilder
  /**
   * Get menu item icon
   * @returns menu item icon. See {@link PartialMenuItem}
   */
  getIcon(): PartialMenuItem['icon']
  /**
   * Set menu item parameters
   * @param params - menu item parameters. See {@link MenuItemParamsType}
   * @returns menu item builder based on parameters provided. See {@link MenuItemBuilder}
   */
  params(params: MenuItemParamsType): MenuItemBuilder
  /**
   * Get meny item parameters
   * @returns menu item parameters. See {@link PartialMenuItem}
   */
  getParams(): PartialMenuItem['params']
  /**
   * Set menu item to show as action
   * @param showAsAction - determine if menu item should show as action
   * @returns menu item builder based on if it should show as action. See {@link MenuItemBuilder}
   */
  showAsAction(showAsAction?: boolean): MenuItemBuilder
  /**
   * Check if menu item should show as action
   * @returns true if menu item should show as action, false if not. See {@link PartialMenuItem}
   */
  getShowAsAction(): PartialMenuItem['showAsAction']
  /** Serialize menu item builder
   * @param options - serialization options. See {@link SerializeOptions}
   * @returns menu item node based on path provided in options. See {@link MenuItem}
   */
  serialize(options?: SerializeOptions): MenuItem
  /** Clone menu item builder
   * @param withSpec - menu item options. See {@link PartialMenuItem}
   * @returns menu item builder based on context and spec provided. See {@link MenuItemBuilder}
   */
  clone(withSpec?: PartialMenuItem): MenuItemBuilder
}

/**
 * Interface for menu item groups
 * @public
 */
declare interface MenuItemGroup {
  /** Menu group Id */
  id: string
  /** Menu group title */
  title: string
  i18n?: I18nTextRecord<'title'>
}

/**
 * Class for building menu item groups.
 *
 * @public
 */
declare class MenuItemGroupBuilder implements Serializable_2<MenuItemGroup> {
  /** Menu item group ID */
  protected _id: string
  /** Menu item group title */
  protected _title: string
  protected _i18n?: I18nTextRecord<'title'>
  protected _context: StructureContext
  constructor(
    /**
     * Structure context. See {@link StructureContext}
     */
    _context: StructureContext,
    spec?: MenuItemGroup,
  )
  /**
   * Set menu item group ID
   * @param id - menu item group ID
   * @returns menu item group builder based on ID provided. See {@link MenuItemGroupBuilder}
   */
  id(id: string): MenuItemGroupBuilder
  /**
   * Get menu item group ID
   * @returns menu item group ID
   */
  getId(): string
  /**
   * Set menu item group title
   * @param title - menu item group title
   * @returns menu item group builder based on title provided. See {@link MenuItemGroupBuilder}
   */
  title(title: string): MenuItemGroupBuilder
  /**
   * Get menu item group title
   * @returns menu item group title
   */
  getTitle(): string
  /**
   * Set the i18n key and namespace used to populate the localized title.
   * @param i18n - object with i18n key and related namespace
   * @returns menu item group builder based on i18n info provided. See {@link MenuItemGroupBuilder}
   */
  i18n(i18n: I18nTextRecord<'title'>): MenuItemGroupBuilder
  /**
   * Get the i18n key and namespace used to populate the localized title.
   * @returns the i18n key and namespace used to populate the localized title.
   */
  getI18n(): I18nTextRecord<'title'> | undefined
  /**
   * Serialize menu item group builder
   * @param options - serialization options (path). See {@link SerializeOptions}
   * @returns menu item group based on path provided in options. See {@link MenuItemGroup}
   */
  serialize(options?: SerializeOptions): MenuItemGroup
}

/**
 * Menu items parameters
 *
 * @public */
declare type MenuItemParamsType = Record<string, string | unknown | undefined>

declare type MetadataWrapper = {
  data: ReleasesMetadataMap | null
  error: null
  loading: boolean
}

/**
 * This error may happen for arrays of objects where one or more of the members are missing a _key
 *
 * @public
 */
declare type MissingKeysError = {
  type: 'MISSING_KEYS'
  schemaType: ArraySchemaType
  value: {
    _key?: string
  }[]
}

/**
 * This error may happen for arrays of objects where one or more of the members are missing a _key
 *
 * @public
 */
declare type MissingKeysError_2 = {
  type: 'MISSING_KEYS'
  schemaType: ArraySchemaType
  value: {
    _key?: string
  }[]
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type MixedArrayError = {
  type: 'MIXED_ARRAY'
  schemaType: ArraySchemaType
  value: unknown[]
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type MixedArrayError_2 = {
  type: 'MIXED_ARRAY'
  schemaType: ArraySchemaType
  value: unknown[]
}

/**
 *
 * @hidden
 * @beta
 */
declare interface MutationPatchMsg {
  type: 'mutation'
  patches: FormPatch[]
  snapshot: unknown
}

/**
 * @hidden
 * @beta */
declare interface MutationPayload {
  create?: any
  createIfNotExists?: any
  createOrReplace?: any
  delete?: any
  patch?: any
}

/**
 * @internal
 * @beta
 * An internal API for defining actions in the navbar.
 */
declare type NavbarAction = Action | ActionWithCustomRender

/**
 * @internal
 * @beta
 * An internal API for defining actions in the navbar.
 */
declare type NavbarAction_2 = Action_2 | ActionWithCustomRender_2

declare interface NavbarActionBase {
  icon?: React.ComponentType
  location: 'topbar' | 'sidebar'
  name: string
}

declare interface NavbarActionBase_2 {
  icon?: React.ComponentType
  location: 'topbar' | 'sidebar'
  name: string
}

/** @internal */
export declare const NavbarContext: Context<NavbarContextValue>

/** @internal */
declare interface NavbarContextValue {
  onSearchFullscreenOpenChange: (open: boolean) => void
  onSearchOpenChange: (open: boolean) => void
  searchFullscreenOpen: boolean
  searchFullscreenPortalEl: HTMLElement | null
  searchOpen: boolean
}

/**
 * @hidden
 * @beta */
declare interface NavbarProps {
  renderDefault: (props: NavbarProps) => React.JSX.Element
  /**
   * @internal
   * @beta */
  __internal_actions?: NavbarAction[]
}

/**
 * @hidden
 * @beta */
declare interface NavbarProps_2 {
  renderDefault: (props: NavbarProps_2) => React.JSX.Element
  /**
   * @internal
   * @beta */
  __internal_actions?: NavbarAction_2[]
}

/**
 * @public
 */
declare interface NavigateBaseOptions {
  replace?: boolean
}

/**
 * @public
 */
declare interface NavigateOptions extends NavigateBaseOptions {
  stickyParams?: Record<string, string | undefined | null>
}

/**
 * Configuration options for Presentation tool's optional navigator component
 * The navigator appears as a resizable sidebar panel
 *
 * @public
 */
declare interface NavigatorOptions {
  /**
   * Minimum width of the navigator panel in pixels
   */
  minWidth?: number
  /**
   * Maximum width of the navigator panel in pixels
   */
  maxWidth?: number
  /**
   * React component to render in the navigator panel
   */
  component: ComponentType
}

/**
 * @hidden
 * @beta
 */
declare type NewDocumentCreationContext =
  | {
      type: 'global'
      documentId?: undefined
      schemaType?: undefined
    }
  | {
      type: 'document'
      documentId: string
      schemaType: string
    }
  | {
      type: 'structure'
      documentId?: undefined
      schemaType: string
    }

/**
 * @hidden
 * @beta
 */
declare type NewDocumentCreationContext_2 =
  | {
      type: 'global'
      documentId?: undefined
      schemaType?: undefined
    }
  | {
      type: 'document'
      documentId: string
      schemaType: string
    }
  | {
      type: 'structure'
      documentId?: undefined
      schemaType: string
    }

/**
 * @hidden
 * @beta
 */
declare interface NewDocumentOptionsContext extends ConfigContext {
  creationContext: NewDocumentCreationContext
}

/**
 * @hidden
 * @beta
 */
declare interface NewDocumentOptionsContext_2 extends ConfigContext_2 {
  creationContext: NewDocumentCreationContext_2
}

/**
 * @hidden
 * @beta
 */
declare type NewDocumentOptionsResolver = ComposableOption<
  TemplateItem[],
  NewDocumentOptionsContext
>

/**
 * @hidden
 * @beta
 */
declare type NewDocumentOptionsResolver_2 = ComposableOption_2<
  TemplateItem_2[],
  NewDocumentOptionsContext_2
>

/**
 * Props that encapsulate document chronology within a stack of versions.
 *
 * @public
 */
declare interface NodeChronologyProps {
  /**
   * Whether the document has an upstream version.
   */
  hasUpstreamVersion: boolean
}

/**
 * Props that encapsulate document chronology within a stack of versions.
 *
 * @public
 */
declare interface NodeChronologyProps_2 {
  /**
   * Whether the document has an upstream version.
   */
  hasUpstreamVersion: boolean
}

/**
 * Props that encapsulate changes in the node's value.
 *
 * @public
 */
declare interface NodeDiffProps<Annotation, Value = unknown> extends NodeChronologyProps {
  /**
   * A function that takes any value and produces a diff between that value and the value the node
   * is being compared to.
   *
   * This can be used to compute a diff optimistically.
   *
   * This is marked as unstable because the API may need to evolve as we iterate on the advanced
   * version control functionality. It will be stabilised when that project has matured.
   */
  __unstable_computeDiff: ComputeDiff<Annotation>
  /**
   * Whether the current value is different to the value the node is being compared to.
   */
  changed: boolean
  /**
   * The value the node is currently being compared to. This is taken from the upstream version, if
   * the document has an upstream version. Otherwise, it's taken from the document's current value.
   *
   * You can use the `hasUpstreamVersion` prop to determine whether the document has an upstream
   * version.
   */
  compareValue?: Value
}

/**
 * Props that encapsulate changes in the node's value.
 *
 * @public
 */
declare interface NodeDiffProps_2<Annotation, Value = unknown> extends NodeChronologyProps_2 {
  /**
   * A function that takes any value and produces a diff between that value and the value the node
   * is being compared to.
   *
   * This can be used to compute a diff optimistically.
   *
   * This is marked as unstable because the API may need to evolve as we iterate on the advanced
   * version control functionality. It will be stabilised when that project has matured.
   */
  __unstable_computeDiff: ComputeDiff_2<Annotation>
  /**
   * Whether the current value is different to the value the node is being compared to.
   */
  changed: boolean
  /**
   * The value the node is currently being compared to. This is taken from the upstream version, if
   * the document has an upstream version. Otherwise, it's taken from the document's current value.
   *
   * You can use the `hasUpstreamVersion` prop to determine whether the document has an upstream
   * version.
   */
  compareValue?: Value
}

/**
 * @hidden
 * @public */
declare interface NumberFieldProps extends BaseFieldProps {
  schemaType: NumberSchemaType
  value: number | undefined
  inputProps: NumberInputProps
}

/**
 * @hidden
 * @public */
declare interface NumberFieldProps_2 extends BaseFieldProps_2 {
  schemaType: NumberSchemaType
  value: number | undefined
  inputProps: NumberInputProps_2
}

/** @public */
declare type NumberFormNode<S extends NumberSchemaType = NumberSchemaType> = BaseFormNode<number, S>

/** @public */
declare type NumberFormNode_2<S extends NumberSchemaType = NumberSchemaType> = BaseFormNode_2<
  number,
  S
>

/**
 * @hidden
 * @public */
declare interface NumberInputProps<S extends NumberSchemaType = NumberSchemaType>
  extends BaseInputProps, Omit<NumberFormNode<S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @public */
declare interface NumberInputProps_2<S extends NumberSchemaType = NumberSchemaType>
  extends BaseInputProps_2, Omit<NumberFormNode_2<S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch_2 | FormPatch_2[] | PatchEvent_2) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps_2
}

/** @public */
declare interface ObjectArrayFormNode<
  T extends ObjectItem = ObjectItem,
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  value: T
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
  changesOpen?: boolean
}

/** @public */
declare interface ObjectArrayFormNode_2<
  T extends ObjectItem_2 = ObjectItem_2,
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode_2<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  value: T
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup_2[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember_2[]
  changesOpen?: boolean
}

/** @internal */
declare type ObjectDiff<T extends object = Record<string, any>> = ObjectDiff_2<Annotation, T>

/**
 * @hidden
 * @public */
declare interface ObjectFieldProps<T = Record<string, unknown>> extends BaseFieldProps {
  schemaType: ObjectSchemaType
  value: T | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  inputProps: ObjectInputProps<T>
}

/**
 * @hidden
 * @public */
declare interface ObjectFieldProps_2<T = Record<string, unknown>> extends BaseFieldProps_2 {
  schemaType: ObjectSchemaType
  value: T | undefined
  collapsed?: boolean
  collapsible?: boolean
  onCollapse: () => void
  onExpand: () => void
  open: boolean
  onClose: () => void
  onOpen: () => void
  inputProps: ObjectInputProps_2<T>
}

/** @public */
declare interface ObjectFormNode<
  T = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember[]
}

/** @public */
declare interface ObjectFormNode_2<
  T = {
    [key in string]: unknown
  },
  S extends ObjectSchemaType = ObjectSchemaType,
> extends BaseFormNode_2<T, S> {
  /** The focus path of the form node. */
  focusPath: Path
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup_2[]
  /**
   * @hidden
   * @beta */
  members: ObjectMember_2[]
}

/**
 * @hidden
 * @public */
declare interface ObjectInputProps<
  T = Record<string, any>,
  S extends ObjectSchemaType = ObjectSchemaType,
>
  extends BaseInputProps, Omit<ObjectFormNode<T, S>, '_allMembers' | 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup[]
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  /**
   * @hidden
   * @beta */
  onFieldCollapse: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldExpand: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetCollapse: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetExpand: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldGroupSelect: (groupName: string) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onFieldOpen: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldClose: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps
  /**
   * @deprecated  DO NOT USE
   *
   * The node for the array editing modal.
   * This node renders the array editing modal as a child of the root input.
   * It is necessary for the array editing dialog to be a child of the root input
   * because the root input may be wrapped in a React context using the Components API,
   * which is utilized by inputs in the form.
   */
  __internal_enhancedbjectDialog?: ReactNode
}

/**
 * @hidden
 * @public */
declare interface ObjectInputProps_2<
  T = Record<string, any>,
  S extends ObjectSchemaType = ObjectSchemaType,
>
  extends BaseInputProps_2, Omit<ObjectFormNode_2<T, S>, '_allMembers' | 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  groups: FormFieldGroup_2[]
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch_2 | FormPatch_2[] | PatchEvent_2) => void
  /**
   * @hidden
   * @beta */
  onFieldCollapse: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldExpand: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetCollapse: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldSetExpand: (fieldSetName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldGroupSelect: (groupName: string) => void
  /**
   * @hidden
   * @beta */
  onPathFocus: (path: Path) => void
  /**
   * @hidden
   * @beta */
  onFieldOpen: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  onFieldClose: (fieldName: string) => void
  /**
   * @hidden
   * @beta */
  renderAnnotation?: RenderAnnotationCallback_2
  /**
   * @hidden
   * @beta */
  renderBlock?: RenderBlockCallback_2
  /**
   * @hidden
   * @beta */
  renderInput: RenderInputCallback_2
  /**
   * @hidden
   * @beta */
  renderField: RenderFieldCallback_2
  /**
   * @hidden
   * @beta */
  renderInlineBlock?: RenderBlockCallback_2
  /**
   * @hidden
   * @beta */
  renderItem: RenderArrayOfObjectsItemCallback_2
  /**
   * @hidden
   * @beta */
  renderPreview: RenderPreviewCallback_2
  /**
   * @hidden
   * @beta */
  elementProps: ComplexElementProps_2
  /**
   * @deprecated  DO NOT USE
   *
   * The node for the array editing modal.
   * This node renders the array editing modal as a child of the root input.
   * It is necessary for the array editing dialog to be a child of the root input
   * because the root input may be wrapped in a React context using the Components API,
   * which is utilized by inputs in the form.
   */
  __internal_enhancedbjectDialog?: ReactNode
}

/** @public */
declare type ObjectItem = {
  _type?: string
  _key: string
}

/** @public */
declare type ObjectItem_2 = {
  _type?: string
  _key: string
}

/**
 * Props for the ObjectItem component.
 * @public
 */
declare interface ObjectItemProps<
  Item extends ObjectItem = ObjectItem,
> extends BaseItemProps<Item> {
  /** Whether the item has changes in a draft. */
  changed: boolean
  /** The schema type of the object. */
  schemaType: ObjectSchemaType
  /** The schema type of the parent array. */
  parentSchemaType: ArraySchemaType
  /** Whether the item is collapsed. */
  collapsed: boolean | undefined
  /** Whether the item is collapsible. */
  collapsible: boolean | undefined
  /** Callback for when the item is collapsed. */
  onCollapse: () => void
  /** Callback for when the item is expanded. */
  onExpand: () => void
  /** Whether the item is open. */
  open: boolean
  /** Callback for when the item is closed. */
  onClose: () => void
  /** Callback for when the item is opened. */
  onOpen: () => void
  /** The value of the item. */
  value: Item
  /**
   * @hidden
   * @beta */
  inputProps: Omit<ObjectInputProps, 'renderDefault'>
}

/**
 * Props for the ObjectItem component.
 * @public
 */
declare interface ObjectItemProps_2<
  Item extends ObjectItem_2 = ObjectItem_2,
> extends BaseItemProps_2<Item> {
  /** Whether the item has changes in a draft. */
  changed: boolean
  /** The schema type of the object. */
  schemaType: ObjectSchemaType
  /** The schema type of the parent array. */
  parentSchemaType: ArraySchemaType
  /** Whether the item is collapsed. */
  collapsed: boolean | undefined
  /** Whether the item is collapsible. */
  collapsible: boolean | undefined
  /** Callback for when the item is collapsed. */
  onCollapse: () => void
  /** Callback for when the item is expanded. */
  onExpand: () => void
  /** Whether the item is open. */
  open: boolean
  /** Callback for when the item is closed. */
  onClose: () => void
  /** Callback for when the item is opened. */
  onOpen: () => void
  /** The value of the item. */
  value: Item
  /**
   * @hidden
   * @beta */
  inputProps: Omit<ObjectInputProps_2, 'renderDefault'>
}

/** @public */
declare type ObjectMember = FieldMember | FieldSetMember | FieldError

/** @public */
declare type ObjectMember_2 = FieldMember_2 | FieldSetMember_2 | FieldError_2

/**
 * @hidden
 * @beta */
declare interface OnPathFocusPayload {
  selection?: EditorSelection
}

/**
 * @hidden
 * @beta */
declare interface OnPathFocusPayload_2 {
  selection?: EditorSelection
}

/** @internal */
declare interface Operation<ExtraArgs extends any[] = [], ErrorStrings extends string = string> {
  disabled: false | ErrorStrings | 'NOT_READY'
  execute(...extra: ExtraArgs): void
}

/**
 * @hidden
 * @beta */
declare interface OperationError {
  type: 'error'
  /** @internal */
  op: keyof OperationsAPI
  id: string
  error: Error
}

/** @internal */
declare interface OperationsAPI {
  commit: Operation | GuardedOperation
  delete: Operation<[versions?: string[]], 'NOTHING_TO_DELETE' | 'NOT_READY'>
  del: Operation<[versions?: string[]], 'NOTHING_TO_DELETE'> | GuardedOperation
  publish:
    | Operation<[], 'LIVE_EDIT_ENABLED' | 'ALREADY_PUBLISHED' | 'NO_CHANGES'>
    | GuardedOperation
  patch: Operation<[patches: Patch[], initialDocument?: Record<string, any>]> | GuardedOperation
  discardChanges: Operation<[], 'NO_CHANGES' | 'NOT_PUBLISHED'> | GuardedOperation
  unpublish: Operation<[], 'LIVE_EDIT_ENABLED' | 'NOT_PUBLISHED'> | GuardedOperation
  duplicate:
    | Operation<
        [
          documentId: string,
          options?: {
            mapDocument?: MapDocument
          },
        ],
        'NOTHING_TO_DUPLICATE'
      >
    | GuardedOperation
  restore: Operation<[revision: DocumentRevision]> | GuardedOperation
}

/**
 * @hidden
 * @beta */
declare interface OperationSuccess {
  type: 'success'
  /** @internal */
  op: keyof OperationsAPI
  id: string
}

declare type Operator<TOperators = string> = OperatorDivider | OperatorItem<TOperators>

declare type Operator_2<TOperators = string> = OperatorDivider_2 | OperatorItem_2<TOperators>

/**
 * @alpha
 */
declare interface OperatorButtonValueComponentProps<T> {
  value: T
}

/**
 * @alpha
 */
declare interface OperatorButtonValueComponentProps_2<T> {
  value: T
}

declare type OperatorDivider = {
  type: 'divider'
}

declare type OperatorDivider_2 = {
  type: 'divider'
}

/**
 * @alpha
 */
declare interface OperatorInputComponentProps<T> {
  fieldDefinition?: SearchFieldDefinition
  onChange: (value: T | null) => void
  value: T | null
}

/**
 * @alpha
 */
declare interface OperatorInputComponentProps_2<T> {
  fieldDefinition?: SearchFieldDefinition_2
  onChange: (value: T | null) => void
  value: T | null
}

declare type OperatorItem<TOperators = string> = {
  name: TOperators
  type: 'item'
}

declare type OperatorItem_2<TOperators = string> = {
  name: TOperators
  type: 'item'
}

declare type OrderingReset = {
  type: 'ORDERING_RESET'
}

declare type OrderingSet = {
  ordering: SearchOrdering
  type: 'ORDERING_SET'
}

/**
 *
 * @hidden
 * @internal
 */
export declare const PackageVersionInfoContext: Context<PackageVersionInfoContextValue>

/**
 * @hidden
 * @internal
 */
export declare type PackageVersionInfoContextValue = {
  /**
   * Request a new update check
   */
  checkForUpdates: () => void
  /**
   * Status of version check (i.e. are we currently checking for updates)
   */
  versionCheckStatus: {
    lastCheckedAt: Date | null
    checking: boolean
  }
  /**
   * Whether this Studio is configured to be auto-updating
   */
  isAutoUpdating: boolean
  /**
   * If an importmap for the sanity module exists in the DOM, includes details
   * will be undefined if no importmap is found
   */
  importMapInfo?:
    | {
        valid: false
        error: Error
      }
    | {
        valid: true
        minVersion: SemVer
        appId?: string
      }
  /**
   * What is the version tagged as latest (periodically checked)
   */
  latestTaggedVersion?: SemVer
  /**
   * What version is the Studio currently running
   */
  currentVersion: SemVer
  /**
   * What is the current auto-updating version (as periodically resolved via module server and configured via manage)
   */
  autoUpdatingVersion?: SemVer
}

declare type PageIncrement = {
  type: 'PAGE_INCREMENT'
}

declare interface PaginationState {
  cursor: string | null
  nextCursor: string | null
}

/**
 * @hidden
 * @beta */
declare type Pair = {
  /** @internal */
  transactionsPendingEvents$: Observable<PendingMutationsEvent>
  published: DocumentVersion
  draft: DocumentVersion
  version?: DocumentVersion
}

/**
 * @internal
 */
declare interface PaneConfigOpts {
  currentMinWidth?: number
  currentMaxWidth?: number
  flex: number
  id: string
  minWidth?: number
  maxWidth?: number
}

/**
 * @internal
 */
export declare const PaneContext: Context<PaneContextValue | null>

/**
 *
 * @hidden
 * @beta
 */
declare interface PaneContextValue {
  collapse: () => void
  collapsed: boolean
  expand: () => void
  index?: number
  isLast: boolean
  rootElement: HTMLDivElement | null
}

/**
 * @internal
 */
declare interface PaneData {
  maximized: boolean
  element: HTMLElement
  collapsed: boolean
  currentMinWidth?: number
  currentMaxWidth?: number
  flex: number
}

declare interface PaneData_2 {
  active: boolean
  childItemId: string | null
  groupIndex: number
  index: number
  itemId: string
  key: string
  pane: PaneNode | typeof LOADING_PANE
  params: Record<string, string | undefined> & {
    perspective?: string
  }
  path: string
  payload: unknown
  selected: boolean
  siblingIndex: number
  maximized: boolean
}

/**
 * @internal
 */
export declare const PaneLayoutContext: Context<PaneLayoutContextValue | null>

/**
 *
 * @hidden
 * @beta
 */
declare interface PaneLayoutContextValue {
  collapse: (element: HTMLElement) => void
  collapsed?: boolean
  expand: (element: HTMLElement) => void
  expandedElement: HTMLElement | null
  mount: (element: HTMLElement, opts: PaneConfigOpts) => () => void
  resize: (type: 'start' | 'move' | 'end', element: HTMLElement, deltaX: number) => void
  resizing: boolean
  panes: PaneData[]
}

declare interface PanelElement {
  id: string
  type: 'panel'
  defaultSize: number | null
  order: number
  maxWidth: number | null
  minWidth: number
}

/** @internal */
declare interface PaneListItem<TParams = unknown> {
  type: 'listItem'
  id: string
  _id?: string
  schemaType?: SchemaType
  title: string
  i18n?: I18nTextRecord<'title'>
  icon?: React.ComponentType | false
  displayOptions?: {
    showIcon?: boolean
  }
  action?: (t: TParams) => unknown
  params?: TParams
}

/** @internal */
declare interface PaneListItemDivider {
  type: 'divider'
  /**
   * The title of the divider.
   */
  title?: string
  /**
   * The i18n key and namespace used to populate the localized title
   */
  i18n?: I18nTextRecord<'title'>
}

/**
 * Represents what can be passed into `menuItems` inside of structure-tool panes
 *
 * @see BaseResolvedPaneNode
 *
 * @internal
 */
declare interface PaneMenuItem extends MenuItem {
  disabled?: _PaneMenuItem['disabled']
  shortcut?: string
  selected?: boolean
  tone?: 'primary' | 'positive' | 'caution' | 'critical'
}

declare interface _PaneMenuItem {
  type: 'item'
  key: string
  disabled?:
    | boolean
    | {
        reason: ReactNode
      }
  hotkey?: string
  icon: ComponentType | ReactNode
  iconRight?: ComponentType | ReactNode
  intent?: Intent
  onAction: () => void
  renderAsButton: boolean
  selected?: boolean
  title?: string
  i18n?: I18nTextRecord<'title'>
  tone?: 'primary' | 'critical' | 'caution' | 'positive'
}

/** @internal */
declare interface PaneMenuItemGroup {
  id: string
  title?: string
  i18n?: I18nTextRecord<'title'>
}

/** @internal */
declare type PaneNode =
  | CustomComponentPaneNode
  | DocumentPaneNode
  | DocumentListPaneNode
  | ListPaneNode

/** @internal */
declare type PaneNodeResolver = (
  id: string,
  context: RouterPaneSiblingContext,
) => UnresolvedPaneNode

/**
 *
 * @hidden
 * @beta
 */
export declare const PaneRouterContext: Context<PaneRouterContextValue>

/**
 * @hidden
 * @beta */
declare interface PaneRouterContextValue {
  /**
   * Zero-based index (position) of pane, visually
   */
  index: number
  /**
   * Zero-based index of pane group (within URL structure)
   */
  groupIndex: number
  /**
   * Zero-based index of pane within sibling group
   */
  siblingIndex: number
  /**
   * Payload of the current pane
   */
  payload?: unknown
  /**
   * Params of the current pane
   */
  params?: RouterPaneSibling['params']
  /**
   * Whether or not the pane has any siblings (within the same group)
   */
  hasGroupSiblings: boolean
  /**
   * The length of the current group
   */
  groupLength: number
  /**
   * Current router state for the "panes" property
   */
  routerPanesState: RouterPanes
  /**
   * Curried StateLink that passes the correct state automatically
   */
  ChildLink: ComponentType<ChildLinkProps>
  /**
   * Curried StateLink that pops off the last pane group
   */
  BackLink?: ComponentType<BackLinkProps>
  /**
   * A specialized `ChildLink` that takes in the needed props to open a
   * referenced document to the right
   */
  ReferenceChildLink: ComponentType<ReferenceChildLinkProps>
  /**
   * Similar to `ReferenceChildLink` expect without the wrapping component
   */
  handleEditReference: (options: EditReferenceOptions) => void
  /**
   * Curried StateLink that passed the correct state, but merges params/payload
   */
  ParameterizedLink: ComponentType<ParameterizedLinkProps>
  /**
   * Replaces the current pane with a new one
   */
  replaceCurrent: (pane: {id?: string; payload?: unknown; params?: Record<string, string>}) => void
  /**
   * Removes the current pane from the group
   */
  closeCurrent: () => void
  /**
   * Removes all panes to the right including current pane
   */
  closeCurrentAndAfter: (expandLast?: boolean) => void
  /**
   * Duplicate the current pane, with optional overrides for item ID and parameters
   */
  duplicateCurrent: (pane?: {payload?: unknown; params?: Record<string, string>}) => void
  /**
   * Set the current "view" for the pane
   */
  setView: (viewId: string | null) => void
  /**
   * Set the parameters for the current pane
   */
  setParams: (
    params: Record<string, string | undefined>,
    stickyParams?: Record<string, string>,
  ) => void
  /**
   * Set the payload for the current pane
   */
  setPayload: (payload: unknown) => void
  /**
   * A function that creates a path with the given parameters without navigating to it.
   * Useful for creating links that can be e.g. copied to clipboard and shared.
   */
  createPathWithParams: (params: Record<string, string | undefined>) => string
  /**
   * Proxied navigation to a given intent. Consider just exposing `router` instead?
   */
  navigateIntent: (
    intentName: string,
    params: Record<string, string>,
    options?: {
      replace?: boolean
    },
  ) => void
}

declare interface Panes {
  paneDataItems: PaneData_2[]
  routerPanes: RouterPanes
  resolvedPanes: (PaneNode | typeof LOADING_PANE)[]
  maximizedPane: PaneData_2 | null
  setMaximizedPane: (pane: PaneData_2 | null) => void
}

/**
 * @hidden
 * @beta */
declare interface ParameterizedLinkProps {
  params?: Record<string, string>
  payload?: unknown
}

/**
 * @hidden
 * @beta */
declare type ParsedTimeRef = Chunk | 'loading' | 'invalid'

/**
 * @hidden
 * @beta
 */
declare type PartialContext<TContext extends ConfigContext> = Pick<
  TContext,
  Exclude<keyof TContext, keyof ConfigContext>
>

/**
 * @hidden
 * @beta
 */
declare type PartialContext_2<TContext extends ConfigContext_2> = Pick<
  TContext,
  Exclude<keyof TContext, keyof ConfigContext_2>
>

/**
 * Partial document list
 *
 * @public
 */
declare interface PartialDocumentList extends BuildableGenericList {
  /** Document list options. See {@link DocumentListOptions} */
  options?: DocumentListOptions
  /** Schema type name */
  schemaTypeName?: string
}

/**
 * Partial document list item
 *
 * @public
 */
declare type PartialDocumentListItem = Partial<UnserializedListItem>

/**
 * Interface for partial document (focused on the document pane)
 *
 * @public */
declare interface PartialDocumentNode {
  /** Document Id */
  id?: string
  /** Document title */
  title?: string
  /** I18n key and namespace used to populate the localized title */
  i18n?: I18nTextRecord<'title'>
  /** Document children of type {@link Child} */
  child?: Child
  /**
   * Views for the document pane. See {@link ViewBuilder} and {@link View}
   */
  views?: (View | ViewBuilder)[]
  /**
   * Document options. See {@link DocumentOptions}
   */
  options?: Partial<DocumentOptions>
}

/**
 * Partial list item. See {@link UnserializedListItem}
 *
 * @public */
declare type PartialListItem = Partial<UnserializedListItem>

/**
 * Partial menu items
 * @public
 */
declare type PartialMenuItem = Partial<MenuItem>

/**
 * @beta
 * @hidden
 */
declare interface PasteOptions extends BaseOptions {}

declare type Patch = any

/**
 *
 * @hidden
 * @beta
 */
declare type PatchArg = FormPatch | FormPatch[]

/**
 *
 * @hidden
 * @beta
 */
declare type PatchArg_2 = FormPatch_2 | FormPatch_2[]

/**
 *
 * @hidden
 * @beta
 */
declare interface PatchChannel {
  publish: (msg: PatchMsg) => void
  subscribe: (subscriber: PatchMsgSubscriber) => () => void
}

/**
 *
 * @hidden
 * @beta
 */
declare class PatchEvent {
  static from(input: PatchArg | PatchEvent): PatchEvent
  patches: Array<FormPatch>
  constructor(patches: Array<FormPatch>)
  prepend(...patches: PatchArg[]): PatchEvent
  append(...patches: PatchArg[]): PatchEvent
  prefixAll(segment: PathSegment): PatchEvent
}

/**
 *
 * @hidden
 * @beta
 */
declare class PatchEvent_2 {
  static from(input: PatchArg_2 | PatchEvent_2): PatchEvent_2
  patches: Array<FormPatch_2>
  constructor(patches: Array<FormPatch_2>)
  prepend(...patches: PatchArg_2[]): PatchEvent_2
  append(...patches: PatchArg_2[]): PatchEvent_2
  prefixAll(segment: PathSegment): PatchEvent_2
}

/**
 *
 * @hidden
 * @beta
 */
declare type PatchMsg = MutationPatchMsg | RebasePatchMsg

/**
 *
 * @hidden
 * @beta
 */
declare interface PatchMsgSubscriber {
  (msg: PatchMsg): void
}

/** @internal */
declare interface PendingMutationsEvent {
  type: 'pending'
  phase: 'begin' | 'end'
}

/**
 * @hidden
 * @beta */
declare interface PermissionCheckResult {
  granted: boolean
  reason: string
}

/**
 * @hidden
 * @beta */
declare interface PermissionCheckResult_2 {
  granted: boolean
  reason: string
}

/**
 *
 * @hidden
 * @beta
 */
export declare const PerspectiveContext: Context<PerspectiveContextValue | null>

/**
 * @beta
 */
declare interface PerspectiveContextValue {
  selectedPerspectiveName: 'published' | ReleaseId_2 | undefined
  /**
   * The releaseId as `r<string>`; it will be undefined if the selected perspective is `published` or `drafts`
   */
  selectedReleaseId: ReleaseId_2 | undefined
  selectedPerspective: TargetPerspective
  /**
   * The stacked array of perspectives ids ordered chronologically to represent the state of documents at the given point in time.
   * It can be used as the perspective param in the client to get the correct view of the documents.
   * @returns ["published"] | ["drafts"] | ["releaseId2", "releaseId1", "drafts"]
   */
  perspectiveStack: PerspectiveStack
  excludedPerspectives: string[]
}

/**
 * @beta
 */
declare type PerspectiveStack = ExtractArray<ClientPerspective>

/**
 * @beta
 */
declare type PerspectiveStack_2 = ExtractArray_2<ClientPerspective>

/** @beta */
declare interface PluginOptions {
  name: string
  plugins?: PluginOptions[]
  schema?: SchemaPluginOptions
  document?: DocumentPluginOptions
  tools?: Tool[] | ComposableOption<Tool[], ConfigContext>
  form?: SanityFormConfig
  __internal_tasks?: {
    footerAction: ReactNode
  }
  studio?: {
    /**
     * Components for the studio.
     * @hidden
     * @beta
     */
    components?: StudioComponentsPluginOptions
  }
  /** @beta @hidden */
  i18n?: LocalePluginOptions
  search?: {
    unstable_partialIndexing?: {
      enabled: boolean
    }
    /**
     * Control the strategy used for searching documents. This should generally only be used if you
     * wish to try experimental search strategies.
     *
     * This option takes precedence over the deprecated `search.enableLegacySearch` option.
     *
     * Can be one of:
     *
     * - `"groqLegacy"` (default): Use client-side tokenization and schema introspection to search
     *   using the GROQ Query API.
     * - `"groq2024"`: (experimental) Perform full text searching using the GROQ Query API and its
     *   new `text::matchQuery` function.
     */
    strategy?: SearchStrategy
    /**
     * Enables the legacy Query API search strategy.
     *
     * @deprecated Use `search.strategy` instead.
     */
    enableLegacySearch?: boolean
  }
  /** @internal */
  __internal_serverDocumentActions?: WorkspaceOptions['__internal_serverDocumentActions']
  /** Configuration for Scheduled drafts */
  scheduledDrafts?: DefaultPluginsWorkspaceOptions['scheduledDrafts']
  /** @beta */
  [DECISION_PARAMETERS_SCHEMA]?: DecisionParametersConfig
  /** Configuration for Content Releases */
  releases?: DefaultPluginsWorkspaceOptions['releases']
  /** Configuration for studio beta features.
   * @internal
   */
  beta?: BetaFeatures
  /** Configuration for error handling.
   * @beta
   */
  onUncaughtError?: (error: Error, errorInfo: ErrorInfo) => void
  /**
   * @hidden
   * @internal
   */
  announcements?: {
    enabled: boolean
  }
  /**
   * Config for the Sanity Media Library asset source integration.
   * @beta
   */
  mediaLibrary?: DefaultPluginsWorkspaceOptions['mediaLibrary']
  /**
   * Advanced version control provides features such as inline content diffs in Studio to make
   * resolving conflicts across document versions easier.
   *
   * @beta
   */
  advancedVersionControl?: {
    /**
     * Control whether advanced version control functionality is enabled.
     *
     * Advanced version control provides features such as inline content diffs in Studio to make
     * resolving conflicts across document versions easier.
     *
     * @beta
     */
    enabled?: boolean | ComposableOption<boolean, ConfigContext>
  }
}

/** @beta */
declare interface PluginOptions_2 {
  name: string
  plugins?: PluginOptions_2[]
  schema?: SchemaPluginOptions_2
  document?: DocumentPluginOptions_2
  tools?: Tool_2[] | ComposableOption_2<Tool_2[], ConfigContext_2>
  form?: SanityFormConfig_2
  __internal_tasks?: {
    footerAction: ReactNode
  }
  studio?: {
    /**
     * Components for the studio.
     * @hidden
     * @beta
     */
    components?: StudioComponentsPluginOptions_2
  }
  /** @beta @hidden */
  i18n?: LocalePluginOptions_2
  search?: {
    unstable_partialIndexing?: {
      enabled: boolean
    }
    /**
     * Control the strategy used for searching documents. This should generally only be used if you
     * wish to try experimental search strategies.
     *
     * This option takes precedence over the deprecated `search.enableLegacySearch` option.
     *
     * Can be one of:
     *
     * - `"groqLegacy"` (default): Use client-side tokenization and schema introspection to search
     *   using the GROQ Query API.
     * - `"groq2024"`: (experimental) Perform full text searching using the GROQ Query API and its
     *   new `text::matchQuery` function.
     */
    strategy?: SearchStrategy
    /**
     * Enables the legacy Query API search strategy.
     *
     * @deprecated Use `search.strategy` instead.
     */
    enableLegacySearch?: boolean
  }
  /** @internal */
  __internal_serverDocumentActions?: WorkspaceOptions_2['__internal_serverDocumentActions']
  /** Configuration for Scheduled drafts */
  scheduledDrafts?: DefaultPluginsWorkspaceOptions_2['scheduledDrafts']
  /** @beta */
  [DECISION_PARAMETERS_SCHEMA_2]?: DecisionParametersConfig_2
  /** Configuration for Content Releases */
  releases?: DefaultPluginsWorkspaceOptions_2['releases']
  /** Configuration for studio beta features.
   * @internal
   */
  beta?: BetaFeatures_2
  /** Configuration for error handling.
   * @beta
   */
  onUncaughtError?: (error: Error, errorInfo: ErrorInfo) => void
  /**
   * @hidden
   * @internal
   */
  announcements?: {
    enabled: boolean
  }
  /**
   * Config for the Sanity Media Library asset source integration.
   * @beta
   */
  mediaLibrary?: DefaultPluginsWorkspaceOptions_2['mediaLibrary']
  /**
   * Advanced version control provides features such as inline content diffs in Studio to make
   * resolving conflicts across document versions easier.
   *
   * @beta
   */
  advancedVersionControl?: {
    /**
     * Control whether advanced version control functionality is enabled.
     *
     * Advanced version control provides features such as inline content diffs in Studio to make
     * resolving conflicts across document versions easier.
     *
     * @beta
     */
    enabled?: boolean | ComposableOption_2<boolean, ConfigContext_2>
  }
}

/** @internal */
export declare type PortableTextEditorElement = HTMLDivElement | HTMLSpanElement

/**
 * Component props for the {@link PortableTextInput} React component.
 *
 * Extends {@link ArrayOfObjectsInputProps}.
 *
 * @public
 * */
declare interface PortableTextInputProps extends ArrayOfObjectsInputProps<
  PortableTextBlock,
  ArraySchemaType<PortableTextBlock>
> {
  /**
   * A React Ref that can reference the underlying editor instance
   */
  editorRef?: React.MutableRefObject<PortableTextEditor | null>
  /**
   * Option to hide the default toolbar
   */
  hideToolbar?: boolean
  /**
   * Assign hotkeys that can be attached to custom editing functions
   */
  hotkeys?: HotkeyOptions
  /**
   * Whether the input is activated and should receive events on mount.
   * By default, this value is set to `true`
   */
  initialActive?: boolean
  /**
   * Whether the input is _initially_ open in fullscreen mode
   */
  initialFullscreen?: boolean
  /**
   * Array of {@link PortableTextMarker} with meta data connected to the content.
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  markers?: PortableTextMarker[]
  /**
   * Returns changes from the underlying editor
   */
  onEditorChange?: (change: EditorChange, editor: PortableTextEditor) => void
  /**
   * Optional callback for when the editor goes into or out of full screen mode
   * @hidden
   * @beta
   */
  onFullScreenChange?: (isFullScreen: boolean) => void
  /**
   * Custom copy function
   */
  onCopy?: OnCopyFn
  /**
   * Custom paste function
   */
  onPaste?: OnPasteFn
  /**
   * Function to render custom block actions
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderBlockActions?: RenderBlockActionsCallback
  /**
   * Function to render custom markers
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderCustomMarkers?: RenderCustomMarkers
  /**
   * Array of {@link RangeDecoration} that can be used to decorate the content.
   */
  rangeDecorations?: RangeDecoration[]
}

/**
 * Component props for the {@link PortableTextInput} React component.
 *
 * Extends {@link ArrayOfObjectsInputProps}.
 *
 * @public
 * */
declare interface PortableTextInputProps_2 extends ArrayOfObjectsInputProps_2<
  PortableTextBlock,
  ArraySchemaType<PortableTextBlock>
> {
  /**
   * A React Ref that can reference the underlying editor instance
   */
  editorRef?: React.MutableRefObject<PortableTextEditor | null>
  /**
   * Option to hide the default toolbar
   */
  hideToolbar?: boolean
  /**
   * Assign hotkeys that can be attached to custom editing functions
   */
  hotkeys?: HotkeyOptions
  /**
   * Whether the input is activated and should receive events on mount.
   * By default, this value is set to `true`
   */
  initialActive?: boolean
  /**
   * Whether the input is _initially_ open in fullscreen mode
   */
  initialFullscreen?: boolean
  /**
   * Array of {@link PortableTextMarker} with meta data connected to the content.
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  markers?: PortableTextMarker_2[]
  /**
   * Returns changes from the underlying editor
   */
  onEditorChange?: (change: EditorChange, editor: PortableTextEditor) => void
  /**
   * Optional callback for when the editor goes into or out of full screen mode
   * @hidden
   * @beta
   */
  onFullScreenChange?: (isFullScreen: boolean) => void
  /**
   * Custom copy function
   */
  onCopy?: OnCopyFn
  /**
   * Custom paste function
   */
  onPaste?: OnPasteFn
  /**
   * Function to render custom block actions
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderBlockActions?: RenderBlockActionsCallback_2
  /**
   * Function to render custom markers
   * @deprecated will be removed in the next major version of Sanity Studio.
   * Use the `renderBlock` interface instead.
   */
  renderCustomMarkers?: RenderCustomMarkers_2
  /**
   * Array of {@link RangeDecoration} that can be used to decorate the content.
   */
  rangeDecorations?: RangeDecoration[]
}

/**
 * A generic marker for attaching metadata to specific nodes of the Portable Text input.
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 * @param type - a type name for this marker
 * @param data - some data connected to this marker
 * @param path - the path to the Portable Text content connected to this marker
 */
declare interface PortableTextMarker {
  type: string
  data?: unknown
  path: Path
}

/**
 * A generic marker for attaching metadata to specific nodes of the Portable Text input.
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 * @param type - a type name for this marker
 * @param data - some data connected to this marker
 * @param path - the path to the Portable Text content connected to this marker
 */
declare interface PortableTextMarker_2 {
  type: string
  data?: unknown
  path: Path
}

/**
 * @internal
 */
export declare const PortableTextMarkersContext: Context<PortableTextMarker[]>

/** @internal */
declare interface PortableTextMemberItem {
  kind: 'annotation' | 'textBlock' | 'objectBlock' | 'inlineObject'
  key: string
  member: ArrayOfObjectsItemMember
  node: ObjectFormNode
  input?: ReactNode
}

/**
 * @internal
 */
export declare const PortableTextMemberItemElementRefsContext: Context<
  BehaviorSubject<Record<string, PortableTextEditorElement | null | undefined>>
>

/**
 * @internal
 */
export declare const PortableTextMemberItemsContext: Context<PortableTextMemberItem[]>

/**
 * Props for rendering Portable Text plugins
 *
 * @beta
 */
declare interface PortableTextPluginsProps {
  renderDefault: (props: PortableTextPluginsProps) => React.JSX.Element
  plugins: {
    markdown?:
      | {
          /**
           * @deprecated - add the configuration directly to `markdown` instead
           */
          config: MarkdownConfig
        }
      | (MarkdownShortcutsPluginProps & {
          config?: undefined
          /**
           * @defaultValue true
           */
          enabled?: boolean
        })
    typography?: {
      /**
       * @defaultValue true
       */
      enabled?: boolean
    } & TypographyPluginProps
  }
}

/**
 * Props for rendering Portable Text plugins
 *
 * @beta
 */
declare interface PortableTextPluginsProps_2 {
  renderDefault: (props: PortableTextPluginsProps_2) => React.JSX.Element
  plugins: {
    markdown?:
      | {
          /**
           * @deprecated - add the configuration directly to `markdown` instead
           */
          config: MarkdownConfig_2
        }
      | (MarkdownShortcutsPluginProps & {
          config?: undefined
          /**
           * @defaultValue true
           */
          enabled?: boolean
        })
    typography?: {
      /**
       * @defaultValue true
       */
      enabled?: boolean
    } & TypographyPluginProps
  }
}

/**
 * Portable text preview layout key
 *
 * @public
 */
declare type PortableTextPreviewLayoutKey = 'block' | 'blockImage' | 'inline'

/**
 * Portable text preview layout key
 *
 * @public
 */
declare type PortableTextPreviewLayoutKey_2 = 'block' | 'blockImage' | 'inline'

/**
 * @internal
 */
export declare const PresenceContext: Context<FormNodePresence[]>

/** @internal */
export declare const PresenceTrackerContextGetSnapshot: Context<PresenceTrackerGetSnapshotType>

/** @internal */
export declare const PresenceTrackerContextStore: Context<PresenceTrackerContextStoreType>

/**
 * @internal
 * @hidden
 */
declare type PresenceTrackerContextStoreType = TrackerContextStore<FieldPresenceData> | null

/**
 * @internal
 * @hidden
 */
declare type PresenceTrackerGetSnapshotType = TrackerContextGetSnapshot<FieldPresenceData> | null

/**
 * @internal
 */
export declare const PresentationContext: Context<PresentationContextValue | null>

declare interface PresentationContextValue {
  devMode: boolean
  name: string
  navigate: PresentationNavigate
  params: PresentationParamsContextValue
  structureParams: StructureDocumentPaneParams
  searchParams: PresentationSearchParams
}

/**
 * @internal
 */
export declare const PresentationDisplayedDocumentContext: Context<PresentationDisplayedDocumentContextValue | null>

/** @internal */
declare type PresentationDisplayedDocumentContextValue = (
  displayed: Partial<SanityDocument> | null | undefined,
) => void

/**
 * @internal
 */
export declare const PresentationDocumentContext: Context<PresentationDocumentContextValue | null>

declare interface PresentationDocumentContextValue {
  options: PresentationPluginOptions[]
  register: (options: PresentationPluginOptions) => () => void
}

declare const presentationMachine: StateMachine<
  Context_2,
  | {
      type: 'toggle visual editing overlays'
      enabled: boolean
    }
  | {
      type: 'iframe loaded'
    }
  | {
      type: 'iframe refresh'
    }
  | {
      type: 'iframe reload'
    },
  {},
  never,
  never,
  never,
  never,
  | 'loading'
  | 'error'
  | {
      loaded: 'idle' | 'refreshing' | 'reloading'
    },
  'error' | 'busy',
  NonReducibleUnknown,
  NonReducibleUnknown,
  EventObject,
  MetaObject,
  {
    id: 'Presentation Tool'
    states: {
      readonly error: {}
      readonly loading: {}
      readonly loaded: {
        states: {
          readonly idle: {}
          readonly refreshing: {}
          readonly reloading: {}
        }
      }
    }
  }
>

declare type PresentationMachineRef = ActorRefFrom<typeof presentationMachine>

/** @public */
declare type PresentationNavigate = (options: PresentationNavigateOptions) => void

/**
 * @internal
 */
export declare const PresentationNavigateContext: Context<PresentationNavigateContextValue | null>

/** @public */
declare type PresentationNavigateContextValue = (
  preview: string | undefined,
  document?: {
    type: string
    id: string
  },
) => void

/** @public */
declare type PresentationNavigateOptions = (
  | {
      state: PresentationStateParams
      params?: CombinedSearchParams
    }
  | {
      params: CombinedSearchParams
      state?: PresentationStateParams
    }
) & {
  replace?: boolean
}

/**
 * @internal
 */
export declare const PresentationPanelsContext: Context<PresentationPanelsContextValue | null>

declare interface PresentationPanelsContextValue {
  activeResizer: string | null
  drag: (id: string, event: MouseEvent) => void
  getPanelStyle: (id: string) => React.CSSProperties
  registerElement: (id: string, panel: PanelElement | ResizerElement) => void
  startDragging: (id: string, event: MouseEvent) => void
  stopDragging: () => void
  unregisterElement: (id: string) => void
}

/**
 * @internal
 */
export declare const PresentationParamsContext: Context<PresentationParamsContextValue | null>

/**
 * All possible parameters that can be used to describe the state of the
 * Presentation tool, stored in the pathname and as search parameters of the URL
 * @public
 */
declare interface PresentationParamsContextValue
  extends PresentationStateParams, CombinedSearchParams {}

/** @public */
declare type PresentationPerspective = Exclude<ClientPerspective, 'raw'>

/**
 * Configuration options for the Presentation tool.
 * @public
 */
declare interface PresentationPluginOptions {
  devMode?: boolean | (() => boolean)
  icon?: ComponentType
  name?: string
  title?: string
  allowOrigins?: PreviewUrlAllowOption
  previewUrl: PreviewUrlOption
  /**
   * @deprecated use `resolve.locations` instead
   */
  locate?: DocumentLocationResolver
  resolve?: {
    mainDocuments?: DocumentResolver[]
    locations?: DocumentLocationResolvers | DocumentLocationResolver
  }
  components?: {
    unstable_header?: HeaderOptions
    unstable_navigator?: NavigatorOptions
  }
  /**
   * @deprecated this feature flag is no longer needed
   */
  unstable_showUnsafeShareUrl?: boolean
}

/**
 * Presentation specific URL search parameters, they should persist when
 * navigating between the document pane and document list pane
 * @public
 */
declare interface PresentationSearchParams {
  preview?: string
  perspective?: string
  viewport?: string
}

/**
 * @internal
 */
export declare const PresentationSharedStateContext: Context<PresentationSharedStateContextValue | null>

declare interface PresentationSharedStateContextValue {
  removeValue: (key: string) => void
  setValue: (key: string, value: Serializable) => void
}

/**
 * Presentation specific state that is stored in the pathname section of the URL
 * @public
 */
declare interface PresentationStateParams {
  type?: string
  id?: string
  path?: string
}

/** @public */
declare type PresentationViewport = 'desktop' | 'mobile'

/**
 * @internal
 */
export declare const PreviewCardContext: Context<PreviewCardContextValue>

/** @internal */
declare interface PreviewCardContextValue {
  selected?: boolean
}

/** @public */
declare interface PreviewHeaderProps extends PreviewProps_2 {
  iframeRef: RefObject<HTMLIFrameElement | null>
  renderDefault: (props: PreviewHeaderProps) => React.JSX.Element
}

/**
 * Preview layout key. See also {@link GeneralPreviewLayoutKey} and {@link PortableTextPreviewLayoutKey}
 *
 * @public
 */
declare type PreviewLayoutKey = GeneralPreviewLayoutKey | PortableTextPreviewLayoutKey

/**
 * Preview layout key. See also {@link GeneralPreviewLayoutKey} and {@link PortableTextPreviewLayoutKey}
 *
 * @public
 */
declare type PreviewLayoutKey_2 = GeneralPreviewLayoutKey_2 | PortableTextPreviewLayoutKey_2

/**
 * @hidden
 * @public
 */
declare interface PreviewMediaDimensions {
  aspect?: number
  dpr?: number
  fit?: ImageUrlFitMode
  height?: number
  width?: number
}

/**
 * @hidden
 * @public
 */
declare interface PreviewMediaDimensions_2 {
  aspect?: number
  dpr?: number
  fit?: ImageUrlFitMode
  height?: number
  width?: number
}

/**
 * @hidden
 * @beta
 */
declare interface PreviewProps<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  description?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  error?: Error | null
  fallbackTitle?: ReactNode
  imageUrl?: string
  isPlaceholder?: boolean
  layout?: TLayoutKey
  media?:
    | ReactNode
    | ComponentType<{
        dimensions: PreviewMediaDimensions
        layout: TLayoutKey
      }>
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  subtitle?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  title?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType?: SchemaType
  renderDefault: (props: PreviewProps) => React.JSX.Element
}

/** @public */
declare interface PreviewProps_2 {
  canSharePreviewAccess: boolean
  canToggleSharePreviewAccess: boolean
  canUseSharedPreviewAccess: boolean
  header?: HeaderOptions
  initialUrl: URL
  loadersConnection: ConnectionStatus
  navigatorEnabled: boolean
  onPathChange: (nextPath: string) => void
  onRefresh: (fallback: () => void) => void
  openPopup: (url: string) => void
  overlaysConnection: ConnectionStatus
  presentationRef: PresentationMachineRef
  perspective: PresentationPerspective
  previewUrl?: string
  setViewport: (mode: 'desktop' | 'mobile') => void
  targetOrigin: string
  toggleNavigator?: () => void
  toggleOverlay: () => void
  viewport: PresentationViewport
  vercelProtectionBypass: string | null
  previewUrlRef: PreviewUrlRef
}

/**
 * @hidden
 * @beta
 */
declare interface PreviewProps_3<TLayoutKey = PreviewLayoutKey_2> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  description?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  error?: Error | null
  fallbackTitle?: ReactNode
  imageUrl?: string
  isPlaceholder?: boolean
  layout?: TLayoutKey
  media?:
    | ReactNode
    | ComponentType<{
        dimensions: PreviewMediaDimensions_2
        layout: TLayoutKey
      }>
  mediaDimensions?: PreviewMediaDimensions_2
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  subtitle?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  title?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType?: SchemaType
  renderDefault: (props: PreviewProps_3) => React.JSX.Element
}

/** @public */
declare type PreviewUrlAllowOption =
  | string
  | string[]
  | ((context: PreviewUrlAllowOptionContext) => string | string[] | Promise<string | string[]>)

/** @public */
declare interface PreviewUrlAllowOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
  /**
   * The initial URL of the preview
   */
  initialUrl: URL
}

/** @public */
declare type PreviewUrlInitialOption =
  | string
  | ((context: PreviewUrlInitialOptionContext) => string | Promise<string>)

/** @public */
declare interface PreviewUrlInitialOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
}

declare const previewUrlMachine: StateMachine<
  Context_3,
  SetPreviewSearchParamEvent,
  {
    [x: string]:
      | ActorRefFromLogic<
          PromiseActorLogic<
            URL,
            {
              initialUrl: URL
              previewSearchParam: string | null | undefined
              allowOrigins: URLPattern[]
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          ObservableActorLogic<PermissionCheckResult, CheckPermissionInput, EventObject>
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            URL,
            {
              previewSearchParam: string | null
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            URLPattern[],
            {
              initialUrl: URL
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            false | PreviewUrlPreviewMode,
            {
              targetOrigin: string
            },
            EventObject
          >
        >
      | ActorRefFromLogic<
          PromiseActorLogic<
            {
              secret: string
              expiresAt: Date
            },
            NonReducibleUnknown,
            EventObject
          >
        >
      | ActorRefFromLogic<PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>>
      | ActorRefFromLogic<PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>>
      | undefined
  },
  | {
      src: 'resolve url from preview search param'
      logic: PromiseActorLogic<
        URL,
        {
          initialUrl: URL
          previewSearchParam: string | null | undefined
          allowOrigins: URLPattern[]
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'check permission'
      logic: ObservableActorLogic<PermissionCheckResult, CheckPermissionInput, EventObject>
      id: string | undefined
    }
  | {
      src: 'resolve initial url'
      logic: PromiseActorLogic<
        URL,
        {
          previewSearchParam: string | null
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'resolve allow patterns'
      logic: PromiseActorLogic<
        URLPattern[],
        {
          initialUrl: URL
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'resolve preview mode'
      logic: PromiseActorLogic<
        false | PreviewUrlPreviewMode,
        {
          targetOrigin: string
        },
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'create preview secret'
      logic: PromiseActorLogic<
        {
          secret: string
          expiresAt: Date
        },
        NonReducibleUnknown,
        EventObject
      >
      id: string | undefined
    }
  | {
      src: 'read shared preview secret'
      logic: PromiseActorLogic<string | null, NonReducibleUnknown, EventObject>
      id: string | undefined
    }
  | {
      src: 'resolve preview mode url'
      logic: PromiseActorLogic<URL, ResolvePreviewModeUrlInput, EventObject>
      id: string | undefined
    },
  | {
      type: 'notify preview will likely fail'
      params: NonReducibleUnknown
    }
  | {
      type: 'assign preview search param'
      params: {
        previewSearchParam: string | null
      }
    }
  | {
      type: 'assign error'
      params: {
        message: string
        error: unknown
      }
    },
  | {
      type: 'has checked permissions'
      params: unknown
    }
  | {
      type: 'search param has new origin'
      params: unknown
    }
  | {
      type: 'can create preview secret'
      params: unknown
    }
  | {
      type: 'has preview mode with created secret'
      params: false | PreviewUrlPreviewMode
    }
  | {
      type: 'has preview mode with share access'
      params: false | PreviewUrlPreviewMode
    }
  | {
      type: 'has preview mode without permissions'
      params: false | PreviewUrlPreviewMode
    },
  'expiredSecret',
  | 'error'
  | 'success'
  | 'checkingPermissions'
  | 'resolvingInitialUrl'
  | 'resolvingAllowPatterns'
  | 'resolvingUrlFromPreviewSearchParam'
  | 'resolvingPreviewMode'
  | {
      previewMode:
        | 'error'
        | 'success'
        | 'createPreviewSecret'
        | 'resolvePreviewUrl'
        | 'readShareAccess'
    },
  'error' | 'busy',
  Input,
  NonReducibleUnknown,
  EventObject,
  MetaObject,
  {
    id: 'Preview URL'
    states: {
      readonly checkingPermissions: {}
      readonly resolvingInitialUrl: {}
      readonly error: {}
      readonly resolvingAllowPatterns: {}
      readonly resolvingUrlFromPreviewSearchParam: {
        id: 'loop'
      }
      readonly resolvingPreviewMode: {}
      readonly success: {}
      readonly previewMode: {
        states: {
          readonly createPreviewSecret: {}
          readonly readShareAccess: {}
          readonly resolvePreviewUrl: {}
          readonly error: {}
          readonly success: {}
        }
      }
    }
  }
>

/** @public */
declare type PreviewUrlOption = string | DeprecatedPreviewUrlResolver | PreviewUrlResolverOptions

/** @public */
declare interface PreviewUrlPreviewMode {
  /**
   * The route that enables Preview Mode
   * @example '/api/preview'
   * @example '/api/draft-mode/enable'
   */
  enable: string
  /**
   * Allow sharing access to a preview with others.
   * This is enabled/disabled in the Presentation Tool. It's initially disabled, and can be enabled by someone who has access to creating draft documents in the Studio.
   * Custom roles can limit access to `_id in path("drafts.**") && _type == "sanity.previewUrlSecret"`.
   * This will create a secret that is valid until sharing is disabled. Turning sharing off and on again will create a new secret and can be used to remove access for folks that got the link in an email but should no longer have access.
   * Share URLs to previews will append this secret and give access to anyone who is given the URL, they don't need to be logged into the Studio or to Vercel.
   */
  shareAccess?: boolean
  /**
   * The route that reports if Preview Mode is enabled or not, useful for debugging
   * @example '/api/check-preview'
   * @deprecated - this API is not yet implemented
   */
  check?: string
  /**
   * The route that disables Preview Mode, useful for debugging
   * @example '/api/disable-preview'
   * @deprecated - this API is not yet implemented
   */
  disable?: string
}

/** @public */
declare type PreviewUrlPreviewModeOption =
  | PreviewUrlPreviewMode
  | ((
      context: PreviewUrlPreviewModeOptionContext,
    ) => false | PreviewUrlPreviewMode | Promise<false | PreviewUrlPreviewMode>)

/** @public */
declare interface PreviewUrlPreviewModeOptionContext {
  client: SanityClient
  /**
   * Equivalent to `location.origin`
   */
  origin: string
  /**
   * The origin on the URL that will be used in the preview iframe
   */
  targetOrigin: string
}

declare type PreviewUrlRef = ActorRefFrom<typeof previewUrlMachine>

/**
 * @public
 */
declare interface PreviewUrlResolverOptions {
  /**
   * The default preview URL, used when the URL to use is not yet known, or there's no `&preview=...` search param in the studio URL.
   * @example '/en/preview?q=shoes'
   * @example 'https://example.com'
   * @defaultValue `location.origin`
   */
  initial?: PreviewUrlInitialOption
  previewMode?: PreviewUrlPreviewModeOption
  /**
   * @defaultValue `location.origin`
   * @deprecated - use `initial` instead
   */
  origin?: string
  /**
   * @defaultValue '/'
   * @deprecated - use `initial` instead
   */
  preview?: string
  /**
   * @deprecated - use `previewMode` instead
   */
  draftMode?: {
    /**
     * @deprecated - use `previewMode.enable` instead
     */
    enable: string
    /**
     * @deprecated - use `previewMode.shareAccess` instead
     */
    shareAccess?: boolean
    /**
     * @deprecated - use `previewMode.check` instead
     */
    check?: string
    /**
     * @deprecated - use `previewMode.disable` instead
     */
    disable?: string
  }
}

/**
 * @hidden
 * @beta */
declare type PrimitiveFormNode = BooleanFormNode | NumberFormNode | StringFormNode

/**
 * @hidden
 * @beta */
declare type PrimitiveFormNode_2 = BooleanFormNode_2 | NumberFormNode_2 | StringFormNode_2

/**
 * @hidden
 * @public */
declare interface PrimitiveInputElementProps {
  'value'?: string
  'id': string
  'readOnly': boolean
  'placeholder'?: string
  'onChange': FormEventHandler
  'onFocus': FocusEventHandler
  'onBlur': FocusEventHandler
  'ref': MutableRefObject<any>
  'aria-describedby': string | undefined
}

/**
 * @hidden
 * @public */
declare interface PrimitiveInputElementProps_2 {
  'value'?: string
  'id': string
  'readOnly': boolean
  'placeholder'?: string
  'onChange': FormEventHandler
  'onFocus': FocusEventHandler
  'onBlur': FocusEventHandler
  'ref': MutableRefObject<any>
  'aria-describedby': string | undefined
}

/** @public */
declare interface PrimitiveItemProps extends BaseItemProps<string | number | boolean> {
  /**
   * The value of the primitive item.
   */
  value: string | number | boolean
  /**
   * The schema type of the primitive item.
   */
  schemaType: NumberSchemaType | BooleanSchemaType | StringSchemaType
  /**
   * The schema type of the parent array containing the item.
   */
  parentSchemaType: ArraySchemaType
}

/** @public */
declare interface PrimitiveItemProps_2 extends BaseItemProps_2<string | number | boolean> {
  /**
   * The value of the primitive item.
   */
  value: string | number | boolean
  /**
   * The schema type of the primitive item.
   */
  schemaType: NumberSchemaType | BooleanSchemaType | StringSchemaType
  /**
   * The schema type of the parent array containing the item.
   */
  parentSchemaType: ArraySchemaType
}

/**
 * When comparing documents, diff provenance reflects details about the bundle in which a change
 * was introduced.
 *
 * @public
 */
declare interface ProvenanceDiffAnnotation {
  provenance: {
    bundle?: TargetPerspective
  }
}

/**
 * When comparing documents, diff provenance reflects details about the bundle in which a change
 * was introduced.
 *
 * @public
 */
declare interface ProvenanceDiffAnnotation_2 {
  provenance: {
    bundle?: TargetPerspective_2
  }
}

/**
 * @hidden
 * @beta
 */
declare interface PublishDocumentVersionEvent extends BaseEvent {
  type: 'publishDocumentVersion'
  documentId: string
  revisionId: string
  versionId: string
  releaseId?: string
  /** This is only available when it was triggered by Publish action. */
  versionRevisionId?: string
  publishCause: 'document.publish' | 'release.publish' | 'release.schedule'
  contributors?: string[]
  /**
   * This is added client side to enhance the UI.
   */
  release?:
    | ReleaseDocument
    | {
        _id: string
        metadata?: undefined
      }
  /**
   * This is added client side to enhance the UI.
   * For draft documents, it indicates the event that created this document that was later published
   * It will be used to expand the publish view.
   */
  creationEvent?: CreateDocumentVersionEvent
}

/**
 * @hidden
 * @beta
 */
declare interface PublishDocumentVersionEvent_2 extends BaseEvent_2 {
  type: 'publishDocumentVersion'
  documentId: string
  revisionId: string
  versionId: string
  releaseId?: string
  /** This is only available when it was triggered by Publish action. */
  versionRevisionId?: string
  publishCause: 'document.publish' | 'release.publish' | 'release.schedule'
  contributors?: string[]
  /**
   * This is added client side to enhance the UI.
   */
  release?:
    | ReleaseDocument
    | {
        _id: string
        metadata?: undefined
      }
  /**
   * This is added client side to enhance the UI.
   * For draft documents, it indicates the event that created this document that was later published
   * It will be used to expand the publish view.
   */
  creationEvent?: CreateDocumentVersionEvent_2
}

/**
 * @hidden
 * @beta */
declare type QueryParams = Record<string, string | number | boolean | string[]>

/**
 *
 * @hidden
 * @beta
 */
declare interface RebasePatchMsg {
  type: 'rebase'
  patches: FormPatch[]
  snapshot: unknown
}

declare type RecentSearch = SearchTerms & {
  __recent: {
    index: number
    timestamp: number
  }
  filters?: SearchFilter[]
}

/**
 * @hidden
 * @beta */
declare interface ReconnectEvent {
  type: 'reconnect'
}

/**
 * @hidden
 * @beta */
declare interface ReferenceChildLinkProps {
  documentId: string
  documentType: string
  parentRefPath: Path
  template?: {
    id: string
    params?: Record<string, string | number | boolean>
  }
  children: ReactNode
}

/**
 * @internal
 */
declare interface ReferenceInputOptions {
  /**
   * Represents the highlighted path if ths current document has a related open
   * child (e.g. reference in place).
   */
  activePath?: {
    path: Path
    state: 'selected' | 'pressed' | 'none'
  }
  /**
   * A specialized `EditReferenceLinkComponent` component that takes in the needed props to open a
   * referenced document to the right
   */
  EditReferenceLinkComponent?: ComponentType<
    Omit<HTMLProps<'a'>, 'children'> & EditReferenceLinkComponentProps
  >
  initialValueTemplateItems?: TemplatePermissionsResult[]
  /**
   * Similar to `EditReferenceChildLink` expect without the wrapping component
   */
  onEditReference?: (options: EditReferenceOptions_2) => void
  /**
   * Prevent creation of documents from reference fields.
   */
  disableNew?: boolean
}

/**
 * @internal
 */
export declare const ReferenceInputOptionsContext: Context<ReferenceInputOptions>

/**
 * @internal
 */
export declare interface ReferenceItemRef {
  menuRef: MutableRefObject<HTMLDivElement | null>
  menuButtonRef: MutableRefObject<HTMLButtonElement | null>
  containerRef: MutableRefObject<HTMLDivElement | null>
}

/**
 * This is a way to store ref of the menu as well as the container of the ReferenceItem
 * so it can be used down the tree for clickOutside handling
 * @internal
 */
export declare const ReferenceItemRefContext: Context<ReferenceItemRef | null>

/**
 * @hidden
 * @public
 */
declare interface ReleaseActionComponent {
  (props: ReleaseActionProps): ReleaseActionDescription
  displayName?: string
}

/**
 * @hidden
 * @public
 */
declare interface ReleaseActionComponent_2 {
  (props: ReleaseActionProps_2): ReleaseActionDescription_2
  displayName?: string
}

/**
 * @hidden
 * @public
 */
declare interface ReleaseActionDescription {
  disabled?: boolean
  icon?: ReactNode | ComponentType
  label: string
  onHandle?: () => void
  title?: ReactNode
}

/**
 * @hidden
 * @public
 */
declare interface ReleaseActionDescription_2 {
  disabled?: boolean
  icon?: ReactNode | ComponentType
  label: string
  onHandle?: () => void
  title?: ReactNode
}

/**
 * @public
 */
declare interface ReleaseActionProps {
  release: ReleaseDocument
  documents: DocumentInRelease[]
}

/**
 * @public
 */
declare interface ReleaseActionProps_2 {
  release: ReleaseDocument
  documents: DocumentInRelease_2[]
}

/**
 * @hidden
 * @public
 */
declare type ReleaseActionsContext = ConfigContext & ReleaseActionProps

/**
 * @hidden
 * @public
 */
declare type ReleaseActionsContext_2 = ConfigContext_2 & ReleaseActionProps_2

/**
 * @hidden
 * @public
 */
declare type ReleaseActionsResolver = ComposableOption<
  ReleaseActionComponent[],
  ReleaseActionsContext
>

/**
 * @hidden
 * @public
 */
declare type ReleaseActionsResolver_2 = ComposableOption_2<
  ReleaseActionComponent_2[],
  ReleaseActionsContext_2
>

/**
 * @beta
 */
declare type ReleaseId = string

/**
 * @beta
 */
declare type ReleaseId_2 = string

declare interface ReleasesMetadata {
  /**
   * The number of documents with the release version as a prefix
   */
  documentCount: number
  /**
   * The last time a document in the release was edited
   */
  updatedAt: string | null
}

/**
 * @internal
 * @hidden
 */
export declare const ReleasesMetadataContext: Context<ReleasesMetadataContextValue | null>

/**
 * @internal
 */
declare interface ReleasesMetadataContextValue {
  state: MetadataWrapper
  addReleaseIdsToListener: (slugs: string[]) => void
  removeReleaseIdsFromListener: (slugs: string[]) => void
}

declare type ReleasesMetadataMap = Record<string, ReleasesMetadata>

/**
 * @beta
 * @hidden
 */
export declare const ReleasesUpsellContext: Context<ReleasesUpsellContextValue | null>

declare interface ReleasesUpsellContextValue {
  /**
   * Is upsell mode when the user has reached the release limit
   * Is default mode when the user has not reached the release limits
   */
  mode: 'upsell' | 'default'
  upsellDialogOpen: boolean
  upsellData: UpsellData | null
  guardWithReleaseLimitUpsell: (
    callback: () => void,
    throwError?: boolean,
    whenResolved?: (hasPassed: boolean) => void,
  ) => Promise<false | void>
  onReleaseLimitReached: (limit: number) => void
  handleOpenDialog: (source?: UpsellDialogViewedInfo['source']) => void
  telemetryLogs: {
    dialogSecondaryClicked: () => void
    dialogPrimaryClicked: () => void
    panelViewed: (source: UpsellDialogViewedInfo['source']) => void
    panelDismissed: () => void
    panelPrimaryClicked: () => void
    panelSecondaryClicked: () => void
  }
}

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotEvent = DocumentRemoteMutationEvent | SnapshotEvent

/**
 * @hidden
 * @beta */
declare type RemoteSnapshotVersionEvent = WithVersion<RemoteSnapshotEvent>

/**
 * @hidden
 * @public */
declare type RenderAnnotationCallback<T extends BlockAnnotationProps = BlockAnnotationProps> = (
  annotationProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderAnnotationCallback_2<T extends BlockAnnotationProps_2 = BlockAnnotationProps_2> =
  (annotationProps: Omit<T, 'renderDefault'>) => ReactNode

/**
 * @hidden
 * @public  */
declare type RenderArrayOfObjectsItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public  */
declare type RenderArrayOfObjectsItemCallback_2 = (
  itemProps: Omit<ObjectItemProps_2, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @beta */
declare type RenderArrayOfPrimitivesItemCallback = (
  itemProps: Omit<PrimitiveItemProps, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @beta */
declare type RenderArrayOfPrimitivesItemCallback_2 = (
  itemProps: Omit<PrimitiveItemProps_2, 'renderDefault'>,
) => ReactNode

/**
 * Function for rendering custom block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type RenderBlockActionsCallback = (props: RenderBlockActionsProps) => ReactNode

/**
 * Function for rendering custom block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type RenderBlockActionsCallback_2 = (props: RenderBlockActionsProps_2) => ReactNode

/**
 * Props for rendering block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare interface RenderBlockActionsProps {
  block: PortableTextBlock
  value: PortableTextBlock[] | undefined
  set: (block: PortableTextBlock) => void
  unset: () => void
  insert: (block: PortableTextBlock | PortableTextBlock[]) => void
}

/**
 * Props for rendering block actions
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare interface RenderBlockActionsProps_2 {
  block: PortableTextBlock
  value: PortableTextBlock[] | undefined
  set: (block: PortableTextBlock) => void
  unset: () => void
  insert: (block: PortableTextBlock | PortableTextBlock[]) => void
}

/**
 * @hidden
 * @public */
declare type RenderBlockCallback<T extends BlockProps = BlockProps> = (
  blockProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderBlockCallback_2<T extends BlockProps_2 = BlockProps_2> = (
  blockProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * Function for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type RenderCustomMarkers = (markers: PortableTextMarker[]) => ReactNode

/**
 * Function for rendering custom block markers
 *
 * @public
 * @hidden
 * @deprecated use `renderBlock`, `renderInlineBlock`, `renderAnnotation` interfaces instead
 */
declare type RenderCustomMarkers_2 = (markers: PortableTextMarker_2[]) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderFieldCallback<T extends FieldProps = FieldProps> = (
  fieldProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderFieldCallback_2<T extends FieldProps_2 = FieldProps_2> = (
  fieldProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderInputCallback<T extends InputProps = InputProps> = (
  inputProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderInputCallback_2<T extends InputProps_2 = InputProps_2> = (
  inputProps: Omit<T, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderItemCallback = (
  itemProps: Omit<ObjectItemProps, 'renderDefault'> | Omit<PrimitiveItemProps, 'renderDefault'>,
) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderPreviewCallback = (props: RenderPreviewCallbackProps) => ReactNode

/**
 * @hidden
 * @public */
declare type RenderPreviewCallback_2 = (props: RenderPreviewCallbackProps_2) => ReactNode

/**
 *
 * @hidden
 * @public
 */
declare interface RenderPreviewCallbackProps<TLayoutKey = PreviewLayoutKey> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  error?: Error | null
  fallbackTitle?: ReactNode
  isPlaceholder?: boolean
  layout?: TLayoutKey
  mediaDimensions?: PreviewMediaDimensions
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  value: unknown
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType: SchemaType
  skipVisibilityCheck?: boolean
  style?: CSSProperties
}

/**
 *
 * @hidden
 * @public
 */
declare interface RenderPreviewCallbackProps_2<TLayoutKey = PreviewLayoutKey_2> {
  actions?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  children?: ReactNode
  error?: Error | null
  fallbackTitle?: ReactNode
  isPlaceholder?: boolean
  layout?: TLayoutKey
  mediaDimensions?: PreviewMediaDimensions_2
  progress?: number
  status?:
    | ReactNode
    | ComponentType<{
        layout: TLayoutKey
      }>
  value: unknown
  withBorder?: boolean
  withRadius?: boolean
  withShadow?: boolean
  schemaType: SchemaType
  skipVisibilityCheck?: boolean
  style?: CSSProperties
}

/**
 * A subset of the History API is used, and explicitly declared so it's possible to write a custom
 * history implementation that can be used to integrate the router in a variety of parent routers.
 * @internal
 */
declare type RequiredHistory = Pick<History_2, 'listen' | 'location' | 'push' | 'replace'>

declare interface ResizerElement {
  id: string
  order: number
  type: 'resizer'
  el: RefObject<HTMLDivElement | null>
}

/**
 * @internal
 */
export declare const ResolvedPanesContext: Context<Panes | null>

/**
 * @internal
 */
export declare function ResolvedPanesProvider({
  children,
  value,
}: {
  children: ReactNode
  value: Panes
}): JSX.Element

/** @internal */
declare interface ResolvePreviewModeUrlInput {
  previewUrlSecret: string
  resolvedPreviewMode: PreviewUrlPreviewMode
  initialUrl: URL
}

/**
 * @hidden
 * @beta
 */
declare interface ResolveProductionUrlContext extends ConfigContext {
  document: SanityDocumentLike
}

/**
 * @hidden
 * @beta
 */
declare interface ResolveProductionUrlContext_2 extends ConfigContext_2 {
  document: SanityDocumentLike
}

/** @internal */
declare interface ResourceCache {
  get<T = unknown>(options: {namespace: string; dependencies: (object | null)[]}): T | undefined
  set(options: {namespace: string; dependencies: (object | null)[]; value: unknown}): void
}

/**
 * @internal
 */
export declare const ResourceCacheContext: Context<ResourceCache | null>

/** @internal */
export declare const ReviewChangesContext: Context<ConnectorContextValue>

/**
 * @internal
 */
export declare const RouterContext: Context<RouterContextValue | null>

/**
 * @public
 */
declare interface RouterContextValue {
  /**
   * Resolves the path from the given router state. See {@link RouterState}
   *
   * When state is null, it will resolve the path from the current state
   * and navigate to the root path.
   */
  resolvePathFromState: (state: RouterState_2 | null) => string
  /**
   * Resolves the intent link for the given intent name and parameters.
   * See {@link IntentParameters}
   */
  resolveIntentLink: (
    intentName: string,
    params?: IntentParameters_2,
    searchParams?: SearchParam_2[],
  ) => string
  /**
   * Navigates to the given URL.
   * The function requires an object that has a path and an optional replace property.
   */
  navigateUrl: (opts: {path: string; replace?: boolean}) => void
  /**
   * @deprecated Use `navigate({stickyParams: params, ...options})` instead
   */
  navigateStickyParams: (
    params: NavigateOptions['stickyParams'],
    options?: NavigateBaseOptions,
  ) => void
  /**
   * Updates the router state and navigates to a new path.
   * Allows specifying new state values and optionally merging sticky parameters.
   *
   * See {@link RouterState} and {@link NavigateOptions}
   *
   * @public
   *
   * @example Navigate with sticky params only, staying on the current path
   * ```tsx
   * router.navigate({stickyParams: {baz: 'qux'}})
   * ```
   * @remarks `null` sticky parameter value will remove the sticky parameter from the url
   *
   * @example Navigate with state and sticky params
   * ```tsx
   * router.navigate({stickyParams: {baz: 'qux'}, state: {foo: 'bar'}})
   * ```
   *
   * @example Navigate to root path
   * ```tsx
   * router.navigate({stickyParams: {baz: 'qux'}, state: null})
   * ```
   */
  navigate: {
    (nextState: RouterState_2, options?: NavigateOptions): void
    (
      options: NavigateOptions & {
        state?: RouterState_2 | null
      },
    ): void
  }
  /**
   * Navigates to the given intent.
   * See {@link RouterState} and {@link NavigateBaseOptions}
   */
  navigateIntent: (
    intentName: string,
    params?: IntentParameters_2,
    options?: NavigateBaseOptions,
  ) => void
  /**
   * The current router state. See {@link RouterState}
   */
  state: RouterState_2
  /**
   * The current router state. See {@link RouterState}
   */
  stickyParams: Record<string, string | undefined | null>
}

/**
 * The history context is either one of the implementations from the `history` package, or a custom one that only implements
 * the subset of the History API that is used by the router, documented in `RequiredHistory`.
 * @internal
 */
declare type RouterHistory = BrowserHistory | MemoryHistory | HashHistory | RequiredHistory

/**
 * Internal use only. Userland should leverage the public `useRouter` APIs.
 * @internal
 */
export declare const RouterHistoryContext: Context<RouterHistory | null>

/**
 * Represents a "pane group" in the router.
 *
 * @see RouterPanes
 *
 *
 * @hidden
 * @beta
 */
declare type RouterPaneGroup = RouterPaneSibling[]

/**
 * Represents the state of the `panes` inside the structure-tool router
 *
 * - The structure tool stores the state of the current panes inside of the router.
 * - The panes are stored in groups delimited in the URL by `;`.
 * - In each group, there can be one or more sibling (aka split) panes delimited
 *   by `|`.
 * - Each item pane can contain it's own parameters and payloads
 * - Per item pane in each group, if not specified separately, the ID, params,
 *   and payload will be inherited from the first item pane in the pane group
 *   (unless it's an `exclusiveParam`)
 *
 * E.g. `/structure/books;book-123|,view=preview` will parse to:
 *
 * ```js
 * [
 *   // first pane group
 *   [{id: 'book'}],
 *
 *   // second pane group
 *   [
 *     [
 *       // first pane item
 *       {id: 'book-123'},
 *       // second pane item
 *       {id: 'book-123', params: {view: 'preview'}},
 *     ],
 *   ],
 * ]
 * ```
 *
 * @hidden
 * @beta
 */
declare type RouterPanes = RouterPaneGroup[]

/**
 * Represents a "sibling pane" or "split pane" in the router.
 *
 * @see RouterPanes
 *
 *
 * @hidden
 * @beta
 */
declare interface RouterPaneSibling {
  id: string
  params?: Record<string, string | undefined>
  payload?: unknown
}

/**
 * Passed as the second argument to the item of resolving pane children
 *
 * @see RouterPanes
 *
 * @internal
 */
declare interface RouterPaneSiblingContext {
  id: string
  parent: PaneNode | null
  index: number
  splitIndex: number
  path: string[]
  params: Record<string, string | undefined>
  payload: unknown
  structureContext: StructureContext
  serializeOptions?: {
    path: (string | number)[]
    index?: number
    hint?: string
  }
}

/**
 * @public
 */
declare type RouterState_2 = Record<string, unknown> & {
  _searchParams?: SearchParam_2[]
}

/**
 * @internal
 */
export declare const SanityCreateConfigContext: Context<SanityCreateConfigContextValue>

/**
 * @internal
 */
declare interface SanityCreateConfigContextValue {
  /**
   * A boolean indicating whether "Start in Create" new document pane footer should be shown, when available.
   */
  startInCreateEnabled: boolean
  fallbackStudioOrigin?: string
  appIdCache?: AppIdCache
  components?: {
    documentLinkedBannerContent: ComponentType<CreateLinkedDocumentBannerContentProps> | undefined
    documentLinkedActions: ComponentType<CreateLinkedActionsProps> | undefined
  }
}

declare type SanityDefinedAction =
  | 'delete'
  | 'discardChanges'
  | 'discardVersion'
  | 'duplicate'
  | 'restore'
  | 'publish'
  | 'unpublish'
  | 'unpublishVersion'
  | 'linkToCanvas'
  | 'editInCanvas'
  | 'unlinkFromCanvas'
  | 'schedule'

declare type SanityDefinedAction_2 =
  | 'delete'
  | 'discardChanges'
  | 'discardVersion'
  | 'duplicate'
  | 'restore'
  | 'publish'
  | 'unpublish'
  | 'unpublishVersion'
  | 'linkToCanvas'
  | 'editInCanvas'
  | 'unlinkFromCanvas'
  | 'schedule'

/**
 * @public
 */
declare interface SanityFormConfig {
  /**
   * these have not been migrated over
   *
   *
   * @hidden
   * @beta
   */
  unstable?: {
    CustomMarkers?: FormBuilderCustomMarkersComponent
    Markers?: FormBuilderMarkersComponent
  }
  /**
   * Components for the form.
   * @hidden
   * @beta
   */
  components?: FormComponents
  file?: {
    /**
     * @hidden
     * @beta
     */
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
  /**
   * @hidden
   * @beta
   */
  image?: {
    assetSources?: AssetSource[] | AssetSourceResolver
    directUploads?: boolean
  }
}

/**
 * @public
 */
declare interface SanityFormConfig_2 {
  /**
   * these have not been migrated over
   *
   *
   * @hidden
   * @beta
   */
  unstable?: {
    CustomMarkers?: FormBuilderCustomMarkersComponent_2
    Markers?: FormBuilderMarkersComponent_2
  }
  /**
   * Components for the form.
   * @hidden
   * @beta
   */
  components?: FormComponents_2
  file?: {
    /**
     * @hidden
     * @beta
     */
    assetSources?: AssetSource[] | AssetSourceResolver_2
    directUploads?: boolean
  }
  /**
   * @hidden
   * @beta
   */
  image?: {
    assetSources?: AssetSource[] | AssetSourceResolver_2
    directUploads?: boolean
  }
}

declare interface Schedule {
  author: string
  action: ScheduleAction
  createdAt: string
  dataset: string
  description: string
  documents: {
    documentId: string
    documentType?: string
  }[]
  executeAt: string | null
  executedAt?: string
  id: string
  name: string
  projectId: string
  state: ScheduleState
  stateReason: string
}

declare type ScheduleAction = 'publish' | 'unpublish'

/**
 * @hidden
 * @beta
 */
declare interface ScheduleDocumentVersionEvent extends BaseEvent {
  type: 'scheduleDocumentVersion'
  documentId: string
  releaseId: string
  versionId: string
  versionRevisionId: string
  /** The _current_ state of this schedule. */
  state: 'pending' | 'unscheduled' | 'published'
  author: string
  publishAt: string
}

/**
 * @hidden
 * @beta
 */
declare interface ScheduleDocumentVersionEvent_2 extends BaseEvent_2 {
  type: 'scheduleDocumentVersion'
  documentId: string
  releaseId: string
  versionId: string
  versionRevisionId: string
  /** The _current_ state of this schedule. */
  state: 'pending' | 'unscheduled' | 'published'
  author: string
  publishAt: string
}

/**
 * @internal
 */
export declare const ScheduledPublishingEnabledContext: Context<ScheduledPublishingEnabledContextValue>

/**
 * @internal
 */
export declare type ScheduledPublishingEnabledContextValue =
  | {
      enabled: false
      mode: null
      hasUsedScheduledPublishing: HasUsedScheduledPublishing
    }
  | {
      enabled: true
      mode: 'default' | 'upsell'
      hasUsedScheduledPublishing: HasUsedScheduledPublishing
    }

/**
 * Config for the Scheduled Publishing plugin.
 * @public
 */
declare interface ScheduledPublishingPluginOptions {
  /**
   * Whether scheduled publishing is enabled for this workspace.
   */
  enabled: boolean
  /**
   * Date format to use for input fields. This must be a valid `date-fns` {@link https://date-fns.org/docs/format | formatted string}.
   * @defaultValue 'dd/MM/yyyy HH:mm' make sure to specify minutes and hours if you are specifying a custom format
   */
  inputDateTimeFormat?: string
  /**
   * @hidden
   * Whether scheduled publishing is enabled by the workspace.
   * Sanity is enabling it by default in the config, {@link "../scheduledPublishing/constants.ts"}
   */
  __internal__workspaceEnabled?: boolean
  /**
   * Whether to show the use releases warning banner in the tool.
   * @deprecated The banner this controls is no longer being used
   */
  showReleasesBanner?: boolean
}

/**
 * Config for the Scheduled Publishing plugin.
 * @public
 */
declare interface ScheduledPublishingPluginOptions_2 {
  /**
   * Whether scheduled publishing is enabled for this workspace.
   */
  enabled: boolean
  /**
   * Date format to use for input fields. This must be a valid `date-fns` {@link https://date-fns.org/docs/format | formatted string}.
   * @defaultValue 'dd/MM/yyyy HH:mm' make sure to specify minutes and hours if you are specifying a custom format
   */
  inputDateTimeFormat?: string
  /**
   * @hidden
   * Whether scheduled publishing is enabled by the workspace.
   * Sanity is enabling it by default in the config, {@link "../scheduledPublishing/constants.ts"}
   */
  __internal__workspaceEnabled?: boolean
  /**
   * Whether to show the use releases warning banner in the tool.
   * @deprecated The banner this controls is no longer being used
   */
  showReleasesBanner?: boolean
}

/**
 * @internal
 */
export declare const SchedulePublishUpsellContext: Context<SchedulePublishUpsellContextValue>

/**
 * @internal
 */
export declare interface SchedulePublishUpsellContextValue {
  upsellDialogOpen: boolean
  handleOpenDialog: (source: UpsellDialogViewedInfo['source']) => void
  handleClose: () => void
  upsellData: UpsellData | null
  telemetryLogs: {
    dialogSecondaryClicked: () => void
    dialogPrimaryClicked: () => void
    panelViewed: (source: UpsellDialogViewedInfo['source']) => void
    panelDismissed: () => void
    panelPrimaryClicked: () => void
    panelSecondaryClicked: () => void
  }
}

/**
 * @deprecated we will be dropping support for scheduled publishing on a future major version
 * @internal
 */
export declare const SchedulesContext: Context<SchedulesContextValue | undefined>

/**
 * @internal
 */
declare interface SchedulesContextValue {
  activeSchedules: Schedule[]
  schedules: Schedule[]
  schedulesByDate: (date: Date) => Schedule[]
  scheduleState?: ScheduleState
  selectedDate?: Date
  setSortBy: (sortBy: ScheduleSort) => void
  sortBy?: ScheduleSort
}

declare type ScheduleSort = 'createdAt' | 'executeAt'

declare type ScheduleState = 'cancelled' | 'scheduled' | 'succeeded'

/**
 * @hidden
 * @beta
 */
declare interface SchemaPluginOptions {
  name?: string
  types?:
    | SchemaTypeDefinition[]
    | ComposableOption<
        SchemaTypeDefinition[],
        Omit<ConfigContext, 'schema' | 'currentUser' | 'getClient' | 'client' | 'i18n'>
      >
  templates?: Template[] | TemplateResolver
}

/**
 * @hidden
 * @beta
 */
declare interface SchemaPluginOptions_2 {
  name?: string
  types?:
    | SchemaTypeDefinition[]
    | ComposableOption_2<
        SchemaTypeDefinition[],
        Omit<ConfigContext_2, 'schema' | 'currentUser' | 'getClient' | 'client' | 'i18n'>
      >
  templates?: Template_2[] | TemplateResolver_2
}

/**
 * @internal
 */
export declare const ScrollContext: Context<PubSub<Event> | null>

declare type SearchAction =
  | FiltersVisibleSet
  | LastActiveIndexSet
  | OrderingReset
  | OrderingSet
  | PageIncrement
  | SearchClear
  | SearchRequestComplete
  | SearchRequestError
  | SearchRequestStart
  | TermsFiltersAdd
  | TermsFiltersClear
  | TermsFiltersSetOperator
  | TermsFiltersRemove
  | TermsFiltersSetValue
  | TermsQuerySet
  | TermsSet
  | TermsTypeAdd
  | TermsTypeRemove
  | TermsTypesClear

declare type SearchClear = {
  type: 'SEARCH_CLEAR'
}

/**
 * @internal
 */
export declare const SearchContext: Context<SearchContextValue | undefined>

/**
 * @internal
 */
declare interface SearchContextValue {
  dispatch: Dispatch<SearchAction>
  onClose: (() => void) | null
  searchCommandList: CommandListHandle | null
  setSearchCommandList: Dispatch<SetStateAction<CommandListHandle | null>>
  setOnClose: (onClose: () => void) => void
  state: SearchReducerState
}

declare interface SearchDefinitions {
  fields: SearchFieldDefinitionDictionary
  filters: SearchFilterDefinitionDictionary
  operators: SearchOperatorDefinitionDictionary
}

/**
 * @internal
 */
declare interface SearchFieldDefinition {
  documentTypes: string[]
  fieldPath: string
  filterName: string
  id: string
  name: string
  title: string
  titlePath: string[]
  type: string
}

/**
 * @internal
 */
declare interface SearchFieldDefinition_2 {
  documentTypes: string[]
  fieldPath: string
  filterName: string
  id: string
  name: string
  title: string
  titlePath: string[]
  type: string
}

/**
 * @internal
 */
declare type SearchFieldDefinitionDictionary = Record<
  SearchFieldDefinition['id'],
  SearchFieldDefinition
>

/**
 * @internal
 */
declare interface SearchFilter {
  fieldId?: string
  filterName: string
  operatorType: string
  value?: any
}

declare interface SearchFilterBaseDefinition<TOperators> {
  description?: string
  icon: ComponentType
  name: string
  operators: Operator<TOperators>[]
}

declare interface SearchFilterBaseDefinition_2<TOperators> {
  description?: string
  icon: ComponentType
  name: string
  operators: Operator_2<TOperators>[]
}

/**
 * @beta
 */
declare type SearchFilterDefinition<TOperators = string> =
  | SearchFilterFieldDefinition<TOperators>
  | SearchFilterPinnedDefinition<TOperators>

/**
 * @beta
 */
declare type SearchFilterDefinition_2<TOperators = string> =
  | SearchFilterFieldDefinition_2<TOperators>
  | SearchFilterPinnedDefinition_2<TOperators>

/**
 * @internal
 */
declare type SearchFilterDefinitionDictionary = Record<
  SearchFilterDefinition['name'],
  SearchFilterDefinition
>

declare interface SearchFilterFieldDefinition<
  TOperators = string,
> extends SearchFilterBaseDefinition<TOperators> {
  fieldType: IntrinsicTypeName
  type: 'field'
}

declare interface SearchFilterFieldDefinition_2<
  TOperators = string,
> extends SearchFilterBaseDefinition_2<TOperators> {
  fieldType: IntrinsicTypeName
  type: 'field'
}

declare interface SearchFilterPinnedDefinition<
  TOperators = string,
> extends SearchFilterBaseDefinition<TOperators> {
  fieldPath?: string
  group?: string
  title: string
  type: 'pinned'
}

declare interface SearchFilterPinnedDefinition_2<
  TOperators = string,
> extends SearchFilterBaseDefinition_2<TOperators> {
  fieldPath?: string
  group?: string
  title: string
  type: 'pinned'
}

/**
 * @internal
 */
declare interface SearchHit {
  hit: SanityDocumentLike
}

/**
 * @alpha
 */
declare interface SearchOperatorBase {
  /** i18n resource key for the "name", eg `quantity is` or `contains` */
  nameKey: I18nSearchOperatorNameKey
  /** i18n resource key for the "name", eg `quantity is` or `contains` */
  descriptionKey: I18nSearchOperatorDescriptionKey
  /** icon for explaining the operator (React component) */
  icon?: ComponentType
  /** name/type of operator, eg `arrayCountEqual` or `numberGt` */
  type: string
}

/**
 * @alpha
 */
declare interface SearchOperatorBase_2 {
  /** i18n resource key for the "name", eg `quantity is` or `contains` */
  nameKey: I18nSearchOperatorNameKey_2
  /** i18n resource key for the "name", eg `quantity is` or `contains` */
  descriptionKey: I18nSearchOperatorDescriptionKey_2
  /** icon for explaining the operator (React component) */
  icon?: ComponentType
  /** name/type of operator, eg `arrayCountEqual` or `numberGt` */
  type: string
}

/**
 * @alpha
 */
declare type SearchOperatorButtonValue<TValue> = ComponentType<
  OperatorButtonValueComponentProps<TValue>
>

/**
 * @alpha
 */
declare type SearchOperatorButtonValue_2<TValue> = ComponentType<
  OperatorButtonValueComponentProps_2<TValue>
>

/** @internal */
declare interface SearchOperatorDefinition<TValue = any> extends SearchOperatorBase {
  buttonValueComponent?: SearchOperatorButtonValue<TValue>
  groqFilter: (params: SearchOperatorParams<TValue>) => string | null
  initialValue?: TValue
  inputComponent?: SearchOperatorInput<TValue>
  type: string
}

/** @internal */
declare interface SearchOperatorDefinition_2<TValue = any> extends SearchOperatorBase_2 {
  buttonValueComponent?: SearchOperatorButtonValue_2<TValue>
  groqFilter: (params: SearchOperatorParams_2<TValue>) => string | null
  initialValue?: TValue
  inputComponent?: SearchOperatorInput_2<TValue>
  type: string
}

/** @internal */
declare type SearchOperatorDefinitionDictionary = Record<
  SearchOperatorDefinition['type'],
  SearchOperatorDefinition
>

/**
 * @alpha
 */
declare type SearchOperatorInput<TValue> = ComponentType<OperatorInputComponentProps<TValue>>

/**
 * @alpha
 */
declare type SearchOperatorInput_2<TValue> = ComponentType<OperatorInputComponentProps_2<TValue>>

/**
 * @alpha
 */
declare type SearchOperatorParams<TValue> = {
  fieldPath?: string
  value?: TValue
}

/**
 * @alpha
 */
declare type SearchOperatorParams_2<TValue> = {
  fieldPath?: string
  value?: TValue
}

/**
 * @internal
 */
declare interface SearchOrdering {
  customMeasurementLabel?: string
  ignoreScore?: boolean
  sort?: SearchSort
  /**
   * i18n key for title
   */
  titleKey: `search.ordering.${string}-label`
}

/**
 * @public
 */
declare type SearchParam_2 = [key: string, value: string]

declare type SearchReducerState = PaginationState & {
  currentUser: CurrentUser | null
  debug: boolean
  definitions: SearchDefinitions
  documentTypesNarrowed: string[]
  filters: SearchFilter[]
  filtersVisible: boolean
  fullscreen?: boolean
  lastAddedFilter?: SearchFilter | null
  lastActiveIndex: number
  ordering: SearchOrdering
  result: SearchResult
  terms: RecentSearch | SearchTerms
  strategy?: SearchStrategy
  disabledDocumentIds?: string[]
  canDisableAction?: boolean
}

declare type SearchRequestComplete = {
  type: 'SEARCH_REQUEST_COMPLETE'
  hits: SearchHit[]
  nextCursor: string | undefined
}

declare type SearchRequestError = {
  type: 'SEARCH_REQUEST_ERROR'
  error: Error
}

declare type SearchRequestStart = {
  type: 'SEARCH_REQUEST_START'
}

declare interface SearchResult {
  error: Error | null
  hasLocal: boolean
  hits: SearchHit[]
  loaded: boolean
  loading: boolean
}

/**
 * @internal
 */
declare type SearchSort = {
  direction: SortDirection_2
  field: string
  mapWith?: string
}

/**
 * @internal
 */
declare interface SearchTerms<Type extends SchemaType | CrossDatasetType = SchemaType> {
  filter?: string
  params?: Record<string, unknown>
  query: string
  types: Type[]
}

/**
 * @hidden
 * @beta */
declare type SelectionState = 'inactive' | 'rev' | 'range' | 'loading' | 'invalid'

/**
 *  A interface for serializing a structure node to a plain JavaScript object.
 *
 * @public
 */
declare interface Serializable_2<T> {
  serialize(options: SerializeOptions): T
}

/** @internal */
declare type SerializablePaneNode = {
  serialize(context: RouterPaneSiblingContext): UnresolvedPaneNode
}

/**
 * Interface for seraializing a structure node
 * @public */
declare interface SerializeOptions {
  /** path. See {@link SerializePath} */
  path: SerializePath
  /** index */
  index?: number
  /** hint */
  hint?: string
}

/**
 * Path of a serialized structure node
 *
 * @public
 */
declare type SerializePath = (string | number)[]

declare type SetPreviewSearchParamEvent = {
  type: 'set preview search param'
  previewSearchParam: string | null
}

declare type SidebarTabsIds = 'assigned' | 'subscribed' | 'document'

/**
 * @internal
 */
export declare const SingleDocReleaseContext: Context<SingleDocReleaseContextValue | null>

/**
 * @internal
 */
export declare interface SingleDocReleaseContextValue {
  /**
   * Sets the scheduled draft perspective into the local router params.
   */
  onSetScheduledDraftPerspective: (releaseId: string) => void
}

/**
 * @internal
 */
export declare const SingleDocReleaseEnabledContext: Context<SingleDocReleaseEnabledContextValue>

/**
 * @internal
 */
export declare type SingleDocReleaseEnabledContextValue =
  | {
      enabled: false
      mode: null
    }
  | {
      enabled: true
      mode: 'default' | 'upsell'
    }

/**
 * @internal
 */
export declare const SingleDocReleaseUpsellContext: Context<SingleDocReleaseUpsellContextValue>

/**
 * @internal
 */
export declare interface SingleDocReleaseUpsellContextValue {
  upsellDialogOpen: boolean
  handleOpenDialog: (source: UpsellDialogViewedInfo['source']) => void
  handleClose: () => void
  upsellData: UpsellData | null
  telemetryLogs: {
    dialogSecondaryClicked: () => void
    dialogPrimaryClicked: () => void
    panelViewed: (source: UpsellDialogViewedInfo['source']) => void
    panelDismissed: () => void
    panelPrimaryClicked: () => void
    panelSecondaryClicked: () => void
  }
}

/**
 * @hidden
 * @beta */
declare interface SnapshotEvent {
  type: 'snapshot'
  document: SanityDocument
}

/**
 * @internal
 */
export declare const SortableItemIdContext: Context<string | null>

declare type SortDirection = 'asc' | 'desc'

/**
 * @internal
 */
declare type SortDirection_2 = 'asc' | 'desc'

/**
 * Represents a source.
 * @public
 */
declare interface Source {
  /** The type of the source. */
  type: 'source'
  /** The name of the source. */
  name: string
  /** The title of the source. */
  title: string
  /** The ID of the project. */
  projectId: string
  /** The name of the dataset. */
  dataset: string
  /** The schema of the source. */
  schema: Schema
  /** The templates of the source. */
  templates: Template[]
  /** The tools of the source. */
  tools: Tool[]
  /** The current user of the source. */
  currentUser: CurrentUser | null
  /** Whether the user is authenticated. */
  authenticated: boolean
  /** @internal */
  auth: AuthStore
  /**
   * Returns a client instance.
   * @param clientOptions - Options to pass to the client. See {@link SourceClientOptions}
   */
  getClient: (clientOptions: SourceClientOptions) => SanityClient
  /**
   * Document-related functionality.
   * @hidden
   * @beta
   */
  document: {
    /**
     * Returns an array of actions for the document.
     * @hidden
     * @beta
     */
    actions: (props: PartialContext<DocumentActionsContext>) => DocumentActionComponent[]
    /**
     * Returns an array of badges for the document.
     * @hidden
     * @beta
     */
    badges: (props: PartialContext<DocumentBadgesContext>) => DocumentBadgeComponent[]
    /**
     * Components for the document.
     * @internal
     */
    components?: DocumentComponents
    drafts: {
      /**
       * Whether the workspace provides the draft model for interacting with documents.
       *
       * When switched off, documents may only be edited:
       *
       *  - Inside a release.
       *  - Outside a release if they support live-edit.
       */
      enabled: boolean
    }
    /** @internal */
    unstable_fieldActions: (
      props: PartialContext<DocumentFieldActionsResolverContext>,
    ) => DocumentFieldAction[]
    /**
     * Resolves the production URL for the document.
     * @hidden
     * @beta
     */
    resolveProductionUrl: (
      context: PartialContext<ResolveProductionUrlContext>,
    ) => Promise<string | undefined>
    /**
     * Resolves the new document options.
     * @hidden
     * @beta
     */
    resolveNewDocumentOptions: (context: NewDocumentCreationContext) => InitialValueTemplateItem[]
    /** @alpha */
    unstable_languageFilter: (
      props: PartialContext<DocumentLanguageFilterContext>,
    ) => DocumentLanguageFilterComponent[]
    /**
     * @hidden
     * @beta
     */
    inspectors: (props: PartialContext<DocumentInspectorContext>) => DocumentInspector[]
    /** @deprecated  Use `comments` instead */
    unstable_comments: {
      enabled: (props: DocumentCommentsEnabledContext) => boolean
    }
    /** @internal */
    comments: {
      enabled: (props: DocumentCommentsEnabledContext) => boolean
    }
  }
  /** @internal */
  __internal_tasks?: {
    footerAction: ReactNode
  }
  /**
   * Form-related functionality.
   * @hidden
   * @beta
   */
  form: {
    /**
     * File-related functionality.
     * @hidden
     * @beta
     */
    file: {
      /** The asset sources. */
      assetSources: AssetSource[]
      /** Whether direct uploads are enabled. */
      directUploads: boolean
    }
    /**
     * Image-related functionality.
     * @hidden
     * @beta
     */
    image: {
      /** The asset sources. */
      assetSources: AssetSource[]
      /** Whether direct uploads are enabled. */
      directUploads: boolean
    }
    /**
     * Components for the form.
     * @hidden
     * @beta
     */
    components?: FormComponents
    /**
     * these have not been migrated over and are not merged by the form builder
     *
     * @hidden
     * @beta
     */
    unstable?: {
      CustomMarkers?: FormBuilderCustomMarkersComponent
      Markers?: FormBuilderMarkersComponent
    }
  }
  /**
   * @hidden
   * @beta
   */
  studio?: {
    /**
     * Components for the studio.
     * @hidden
     * @beta
     */
    components?: StudioComponents
  }
  /** @alpha */
  search: {
    filters: SearchFilterDefinition[]
    operators: SearchOperatorDefinition[]
    unstable_partialIndexing?: {
      enabled: boolean
    }
    enableLegacySearch?: boolean
    strategy?: SearchStrategy
  }
  /** @internal */
  i18n: LocaleSource
  /** @internal */
  __internal: {
    /** @internal */
    bifur: BifurClient
    /** @internal */
    staticInitialValueTemplateItems: InitialValueTemplateItem[]
    /** @internal */
    options: SourceOptions
    /**
     * _VERY_ internal, likely to change at any point.
     * @internal
     */
    i18next: i18n
    /**
     * The schema descriptor ID.
     *
     * This can be `undefined` in the case where uploading the schema has been disabled.
     *
     * @internal
     */
    schemaDescriptorId: Promise<string | undefined>
  }
  /** @beta */
  tasks?: WorkspaceOptions['tasks']
  scheduledDrafts?: {
    enabled: boolean
  }
  /** @beta */
  releases?: {
    enabled?: boolean
    /**
     * Limit the number of releases that can be created by this workspace.
     */
    limit?: number
    /**
     * Returns an array of actions for the release.
     */
    actions?: (props: PartialContext<ReleaseActionsContext>) => ReleaseActionComponent[]
  }
  /** @internal */
  __internal_serverDocumentActions?: WorkspaceOptions['__internal_serverDocumentActions']
  /** Configuration for studio features.
   * @internal
   */
  beta?: BetaFeatures
  /** Configuration for error handling.
   * @beta
   */
  onUncaughtError?: (error: Error, errorInfo: ErrorInfo) => void
  /**
   * @hidden
   * @internal
   */
  announcements?: {
    enabled: boolean
  }
  /**
   * Config for the Sanity Media Library asset source integration.
   * @beta
   */
  mediaLibrary?: WorkspaceOptions['mediaLibrary']
  /**
   * Advanced version control provides features such as inline content diffs in Studio to make
   * resolving conflicts across document versions easier.
   *
   * @beta
   */
  advancedVersionControl: {
    /**
     * Control whether advanced version control functionality is enabled.
     *
     * Advanced version control provides features such as inline content diffs in Studio to make
     * resolving conflicts across document versions easier.
     *
     * @beta
     */
    enabled: boolean
  }
}

/**
 * Represents a source.
 * @public
 */
declare interface Source_2 {
  /** The type of the source. */
  type: 'source'
  /** The name of the source. */
  name: string
  /** The title of the source. */
  title: string
  /** The ID of the project. */
  projectId: string
  /** The name of the dataset. */
  dataset: string
  /** The schema of the source. */
  schema: Schema
  /** The templates of the source. */
  templates: Template_2[]
  /** The tools of the source. */
  tools: Tool_2[]
  /** The current user of the source. */
  currentUser: CurrentUser | null
  /** Whether the user is authenticated. */
  authenticated: boolean
  /** @internal */
  auth: AuthStore_2
  /**
   * Returns a client instance.
   * @param clientOptions - Options to pass to the client. See {@link SourceClientOptions}
   */
  getClient: (clientOptions: SourceClientOptions_2) => SanityClient
  /**
   * Document-related functionality.
   * @hidden
   * @beta
   */
  document: {
    /**
     * Returns an array of actions for the document.
     * @hidden
     * @beta
     */
    actions: (props: PartialContext_2<DocumentActionsContext_2>) => DocumentActionComponent_2[]
    /**
     * Returns an array of badges for the document.
     * @hidden
     * @beta
     */
    badges: (props: PartialContext_2<DocumentBadgesContext_2>) => DocumentBadgeComponent_2[]
    /**
     * Components for the document.
     * @internal
     */
    components?: DocumentComponents_2
    drafts: {
      /**
       * Whether the workspace provides the draft model for interacting with documents.
       *
       * When switched off, documents may only be edited:
       *
       *  - Inside a release.
       *  - Outside a release if they support live-edit.
       */
      enabled: boolean
    }
    /** @internal */
    unstable_fieldActions: (
      props: PartialContext_2<DocumentFieldActionsResolverContext_2>,
    ) => DocumentFieldAction_2[]
    /**
     * Resolves the production URL for the document.
     * @hidden
     * @beta
     */
    resolveProductionUrl: (
      context: PartialContext_2<ResolveProductionUrlContext_2>,
    ) => Promise<string | undefined>
    /**
     * Resolves the new document options.
     * @hidden
     * @beta
     */
    resolveNewDocumentOptions: (
      context: NewDocumentCreationContext_2,
    ) => InitialValueTemplateItem_2[]
    /** @alpha */
    unstable_languageFilter: (
      props: PartialContext_2<DocumentLanguageFilterContext_2>,
    ) => DocumentLanguageFilterComponent_2[]
    /**
     * @hidden
     * @beta
     */
    inspectors: (props: PartialContext_2<DocumentInspectorContext_2>) => DocumentInspector_2[]
    /** @deprecated  Use `comments` instead */
    unstable_comments: {
      enabled: (props: DocumentCommentsEnabledContext_2) => boolean
    }
    /** @internal */
    comments: {
      enabled: (props: DocumentCommentsEnabledContext_2) => boolean
    }
  }
  /** @internal */
  __internal_tasks?: {
    footerAction: ReactNode
  }
  /**
   * Form-related functionality.
   * @hidden
   * @beta
   */
  form: {
    /**
     * File-related functionality.
     * @hidden
     * @beta
     */
    file: {
      /** The asset sources. */
      assetSources: AssetSource[]
      /** Whether direct uploads are enabled. */
      directUploads: boolean
    }
    /**
     * Image-related functionality.
     * @hidden
     * @beta
     */
    image: {
      /** The asset sources. */
      assetSources: AssetSource[]
      /** Whether direct uploads are enabled. */
      directUploads: boolean
    }
    /**
     * Components for the form.
     * @hidden
     * @beta
     */
    components?: FormComponents_2
    /**
     * these have not been migrated over and are not merged by the form builder
     *
     * @hidden
     * @beta
     */
    unstable?: {
      CustomMarkers?: FormBuilderCustomMarkersComponent_2
      Markers?: FormBuilderMarkersComponent_2
    }
  }
  /**
   * @hidden
   * @beta
   */
  studio?: {
    /**
     * Components for the studio.
     * @hidden
     * @beta
     */
    components?: StudioComponents_2
  }
  /** @alpha */
  search: {
    filters: SearchFilterDefinition_2[]
    operators: SearchOperatorDefinition_2[]
    unstable_partialIndexing?: {
      enabled: boolean
    }
    enableLegacySearch?: boolean
    strategy?: SearchStrategy
  }
  /** @internal */
  i18n: LocaleSource_2
  /** @internal */
  __internal: {
    /** @internal */
    bifur: BifurClient
    /** @internal */
    staticInitialValueTemplateItems: InitialValueTemplateItem_2[]
    /** @internal */
    options: SourceOptions_2
    /**
     * _VERY_ internal, likely to change at any point.
     * @internal
     */
    i18next: i18n
    /**
     * The schema descriptor ID.
     *
     * This can be `undefined` in the case where uploading the schema has been disabled.
     *
     * @internal
     */
    schemaDescriptorId: Promise<string | undefined>
  }
  /** @beta */
  tasks?: WorkspaceOptions_2['tasks']
  scheduledDrafts?: {
    enabled: boolean
  }
  /** @beta */
  releases?: {
    enabled?: boolean
    /**
     * Limit the number of releases that can be created by this workspace.
     */
    limit?: number
    /**
     * Returns an array of actions for the release.
     */
    actions?: (props: PartialContext_2<ReleaseActionsContext_2>) => ReleaseActionComponent_2[]
  }
  /** @internal */
  __internal_serverDocumentActions?: WorkspaceOptions_2['__internal_serverDocumentActions']
  /** Configuration for studio features.
   * @internal
   */
  beta?: BetaFeatures_2
  /** Configuration for error handling.
   * @beta
   */
  onUncaughtError?: (error: Error, errorInfo: ErrorInfo) => void
  /**
   * @hidden
   * @internal
   */
  announcements?: {
    enabled: boolean
  }
  /**
   * Config for the Sanity Media Library asset source integration.
   * @beta
   */
  mediaLibrary?: WorkspaceOptions_2['mediaLibrary']
  /**
   * Advanced version control provides features such as inline content diffs in Studio to make
   * resolving conflicts across document versions easier.
   *
   * @beta
   */
  advancedVersionControl: {
    /**
     * Control whether advanced version control functionality is enabled.
     *
     * Advanced version control provides features such as inline content diffs in Studio to make
     * resolving conflicts across document versions easier.
     *
     * @beta
     */
    enabled: boolean
  }
}

/** @public */
declare interface SourceClientOptions {
  /**
   * API version to use. See {@link https://www.sanity.io/docs/api-versioning | api-versioning}
   */
  apiVersion: string
}

/** @public */
declare interface SourceClientOptions_2 {
  /**
   * API version to use. See {@link https://www.sanity.io/docs/api-versioning | api-versioning}
   */
  apiVersion: string
}

/**
 * @internal
 */
export declare const SourceContext: Context<Source | null>

/**
 * @hidden
 * @beta
 */
declare interface SourceOptions extends PluginOptions {
  title?: string
  /**
   * Project ID for this source
   */
  projectId: string
  /**
   * Dataset name for this source
   */
  dataset: string
  /**
   * API hostname used for requests. Generally used for custom CNAMEs, allowing businesses to use
   * their own domain for API requests. Must include protocol:
   * eg `https://sanityapi.mycompany.com`
   *
   * Note that (currently) the project ID will be prepended to the passed URL, so the above
   * example would end up as: `https://<projectId>.sanityapi.mycompany.com`
   */
  apiHost?: string
  /**
   * Authentication options for this source.
   */
  auth?: AuthConfig | AuthStore
  /**
   * @hidden
   * @beta
   */
  unstable_clientFactory?: (options: ClientConfig) => SanityClient
}

/**
 * @hidden
 * @beta
 */
declare interface SourceOptions_2 extends PluginOptions_2 {
  title?: string
  /**
   * Project ID for this source
   */
  projectId: string
  /**
   * Dataset name for this source
   */
  dataset: string
  /**
   * API hostname used for requests. Generally used for custom CNAMEs, allowing businesses to use
   * their own domain for API requests. Must include protocol:
   * eg `https://sanityapi.mycompany.com`
   *
   * Note that (currently) the project ID will be prepended to the passed URL, so the above
   * example would end up as: `https://<projectId>.sanityapi.mycompany.com`
   */
  apiHost?: string
  /**
   * Authentication options for this source.
   */
  auth?: AuthConfig_2 | AuthStore_2
  /**
   * @hidden
   * @beta
   */
  unstable_clientFactory?: (options: ClientConfig) => SanityClient
}

declare interface State {
  isOpen: boolean
  viewMode: ViewMode
  selectedTask: null | string
  activeTabId: SidebarTabsIds
  duplicateTaskValues: null | TaskDocument
}

/**
 * @hidden
 * @beta */
declare interface StateTree<T> {
  value?: T | undefined
  children?: {
    [key: string]: StateTree<T>
  }
}

/**
 * @hidden
 * @beta */
declare interface StateTree_2<T> {
  value?: T | undefined
  children?: {
    [key: string]: StateTree_2<T>
  }
}

/**
 * @hidden
 * @public */
declare interface StringFieldProps extends BaseFieldProps {
  schemaType: StringSchemaType
  value: string | undefined
  inputProps: StringInputProps
}

/**
 * @hidden
 * @public */
declare interface StringFieldProps_2 extends BaseFieldProps_2 {
  schemaType: StringSchemaType
  value: string | undefined
  inputProps: StringInputProps_2
}

/** @public */
declare type StringFormNode<S extends StringSchemaType = StringSchemaType> = BaseFormNode<string, S>

/** @public */
declare type StringFormNode_2<S extends StringSchemaType = StringSchemaType> = BaseFormNode_2<
  string,
  S
>

/**
 * @hidden
 * @public */
declare interface StringInputProps<S extends StringSchemaType = StringSchemaType>
  extends BaseInputProps, Omit<StringFormNode<S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch | FormPatch[] | PatchEvent) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps
}

/**
 * @hidden
 * @public */
declare interface StringInputProps_2<S extends StringSchemaType = StringSchemaType>
  extends BaseInputProps_2, Omit<StringFormNode_2<S>, 'displayInlineChanges'> {
  /**
   * @hidden
   * @beta */
  onChange: (patch: FormPatch_2 | FormPatch_2[] | PatchEvent_2) => void
  validationError?: string
  /**
   * @hidden
   * @beta */
  elementProps: PrimitiveInputElementProps_2
}

/**
 * Interface for the structure builder.
 *
 * @public
 */
declare interface StructureBuilder {
  /**
   * @internal
   */
  component: (spec?: ComponentInput | UserComponent) => ComponentBuilder
  /** By giving an object of options with documentID and its schema type receive the the respective Document builder
   * @param options - an object holding the documentId and schemaType for the document node being resolved.
   * @returns a Document builder. See {@link DocumentBuilder}
   */
  defaultDocument: (options: {documentId?: string; schemaType: string}) => DocumentBuilder
  /** Get an array of Item builders that take Initial Value template into consideration
   * @returns an array of initial value template item builders. See {@link ListItemBuilder}
   */
  defaultInitialValueTemplateItems: () => InitialValueTemplateItemBuilder[]
  /** Get the default List builder
   * @returns a List builder. See {@link ListBuilder}
   */
  defaults: () => ListBuilder
  /** Get a structure Divider
   * @returns a DividerBuilder. See {@link DividerBuilder}
   */
  divider: (spec?: Divider) => DividerBuilder
  /** By giving a partial Document Node receive the respective Document Builder
   * @param spec - a partial document node. See {@link PartialDocumentNode}
   * @returns a Document builder. See {@link DocumentBuilder}
   */
  document: (spec?: PartialDocumentNode) => DocumentBuilder
  /** By giving a Document List Input receive the respective Document List Builder
   * @param spec - a document list input. See {@link DocumentListInput}
   * @returns a Document List builder. See {@link DocumentListBuilder}
   */
  documentList: (spec?: DocumentListInput) => DocumentListBuilder
  /** By giving a Document List Item Input receive the respective Document List Item builder
   * @param spec - a document list item input. See {@link DocumentListItemInput}
   * @returns a Document List Item builder. See {@link DocumentListItemBuilder}
   */
  documentListItem: (spec?: DocumentListItemInput) => DocumentListItemBuilder
  /** By giving a type name or Document Type List Input receive the respective Document List Builder
   * @param typeNameOrSpec - a type name or a document type list input. See {@link DocumentTypeListInput}
   * @returns a Document List builder. See {@link DocumentListBuilder}
   */
  documentTypeList: (typeNameOrSpec: string | DocumentTypeListInput) => DocumentListBuilder
  /** By providing a type name receive a List Item builder
   * @param typeName - a type name
   * @returns a List Item builder. See {@link ListItemBuilder}
   */
  documentTypeListItem: (typeName: string) => ListItemBuilder
  /** Get an array of List Item builders
   * @returns an array of list item builders. See {@link ListItemBuilder}
   */
  documentTypeListItems: () => ListItemBuilder[]
  /** By giving a templateID and a set of parameters receive a Document builder that takes InitialValueTemplate into account
   * @param templateId - a template ID
   * @param parameters - an object of parameters
   * @returns a Document builder. See {@link DocumentBuilder}
   */
  documentWithInitialValueTemplate: (
    templateId: string,
    parameters?: Record<string, unknown>,
  ) => DocumentBuilder
  /** By giving a Editor Node receive the respective Document Builder
   * @param spec - an editor node. See {@link EditorNode}
   * @returns a Document builder. See {@link DocumentBuilder}
   */
  editor: (spec?: EditorNode) => DocumentBuilder
  /** By giving a templateID and a set of parameters receive an Item Builder that takes InitialValueTemplate into account
   * @param templateId - a template ID
   * @param parameters - an object of parameters
   * @returns an Item builder. See {@link ListItemBuilder}
   */
  initialValueTemplateItem: (
    templateId: string,
    parameters?: Record<string, any>,
  ) => InitialValueTemplateItemBuilder
  /** By giving a List Input receive the respective Builder, otherwise return default ListBuilder builder
   * @param spec - a list input. See {@link ListInput}
   * @returns a List builder. See {@link ListBuilder}
   */
  list: (spec?: ListInput) => ListBuilder
  /** By giving a List Item Input receive the respective Builder, otherwise return default ListItem builder
   * @param spec - a list item input. See {@link ListItemInput}
   * @returns a List Item builder. See {@link ListItemBuilder}
   */
  listItem: (spec?: ListItemInput) => ListItemBuilder
  /** By giving a Menu Item receive the respective Builder, otherwise return default MenuItem builder
   * @param spec - a menu item. See {@link MenuItem}
   * @returns a Menu Item builder. See {@link MenuItemBuilder}
   */
  menuItem: (spec?: MenuItem) => MenuItemBuilder
  /** By giving a Menu Item Group receive the respective Builder
   * @param spec - a menu item group. See {@link MenuItemGroup}
   * @returns a Menu Item Group builder. See {@link MenuItemGroupBuilder}
   */
  menuItemGroup: (spec?: MenuItemGroup) => MenuItemGroupBuilder
  /** By giving an array of initial value template receive an array of Menu Items, otherwise return default MenuItem builder
   * @param templateItems - an array of initial value template items. See {@link InitialValueTemplateItem}
   * @returns an array of Menu Items. See {@link MenuItem}
   */
  menuItemsFromInitialValueTemplateItems: (
    templateItems: InitialValueTemplateItem_2[],
  ) => MenuItem[]
  /** By giving a sort ordering object receive a Menu Item Builder
   * @param ordering - a sort ordering object. See {@link SortOrdering}
   * @returns a Menu Item builder. See {@link MenuItemBuilder}
   */
  orderingMenuItem: (ordering: SortOrdering) => MenuItemBuilder
  /** By giving a type receive a list of Menu Items ordered by it
   * @param type - a type
   * @returns an array of Menu Items. See {@link MenuItem}
   */
  orderingMenuItemsForType: (type: string) => MenuItemBuilder[]
  /** View for structure */
  view: {
    /** form for view
     * @param spec - a partial form view. See {@link FormView}
     * @returns a Form View builder. See {@link FormViewBuilder}
     */
    form: (spec?: Partial<FormView>) => FormViewBuilder
    /** component for view
     * @param componentOrSpec - a partial component view or a React component. See {@link ComponentView}
     * @returns a Component View builder. See {@link ComponentViewBuilder}
     */
    component: (
      componentOrSpec?: Partial<ComponentView> | React.ComponentType<any>,
    ) => ComponentViewBuilder
  }
  /** Context for the structure builder. See {@link StructureContext} */
  context: StructureContext
}

/**
 * Interface for the structure builder context.
 *
 * @public
 */
declare interface StructureContext extends Source_2 {
  /** Resolve document method
   * @returns a document node builder, or null/undefined if no document node should be returned.
   * See {@link DocumentBuilder}
   */
  resolveDocumentNode: (
    /** an object holding the documentId and schemaType for the document node being resolved. */
    options: {
      documentId?: string
      schemaType: string
    },
  ) => DocumentBuilder
  /** Get structure builder
   * @returns a structure builder. See {@link StructureBuilder}
   */
  getStructureBuilder: () => StructureBuilder
  /**
   * The stacked array of perspective ids ordered chronologically to represent the state of documents at the given point in time.
   * It can be used as the perspective param in the client to get the correct view of the documents.
   * ["published"] | ["drafts"] | ["releaseId2", "releaseId1", "drafts"]
   * See {@link PerspectiveStack}
   */
  perspectiveStack: PerspectiveStack_2
}

/**
 * Document Pane specific URL search parameters, they should not persist when
 * navigating between the document pane and document list pane
 * @public
 */
declare interface StructureDocumentPaneParams extends InspectorTab {
  inspect?: string
  parentRefPath?: string
  path?: string
  rev?: string
  since?: string
  template?: string
  templateParams?: string
  version?: string
  view?: string
  pathKey?: string
  instruction?: string
  comment?: string
  scheduledDraft?: string
}

/**
 * Interface for the structure builder node.
 *
 * @public
 */
declare interface StructureNode {
  /** Node ID */
  id: string
  /** Node ID */
  title?: string
  i18n?: I18nTextRecord<'title'>
  /** Node type */
  type?: string
}

/**
 * @internal
 */
export declare const StructureToolContext: Context<StructureToolContextValue | null>

/** @internal */
declare interface StructureToolContextValue {
  features: StructureToolFeatures
  layoutCollapsed: boolean
  setLayoutCollapsed: (layoutCollapsed: boolean) => void
  rootPaneNode: UnresolvedPaneNode
  structureContext: StructureContext
}

/** @internal */
declare interface StructureToolFeatures {
  /**
   * @hidden
   * @beta
   */
  backButton: boolean
  resizablePanes: boolean
  reviewChanges: boolean
  splitPanes: boolean
  splitViews: boolean
}

/**
 * @internal
 */
export declare const StudioAnnouncementContext: Context<StudioAnnouncementsContextValue | undefined>

declare interface StudioAnnouncementDocument {
  _id: string
  _type: 'productAnnouncement'
  _rev: string
  _createdAt: string
  _updatedAt: string
  title: string
  name: string
  body: PortableTextBlock[]
  announcementType: 'whats-new'
  publishedDate: string
  expiryDate?: string
  audience:
    | 'everyone'
    | 'specific-version'
    | 'greater-than-or-equal-version'
    | 'less-than-or-equal-version'
  audienceRole?: AudienceRole[] | undefined
  studioVersion?: string
  preHeader: string
}

declare interface StudioAnnouncementsContextValue {
  studioAnnouncements: StudioAnnouncementDocument[]
  unseenAnnouncements: StudioAnnouncementDocument[]
  onDialogOpen: (mode: DialogMode) => void
}

declare interface StudioApp extends StudioAppResponse {
  studioUrl: string
}

declare interface StudioAppResponse {
  id: string
  title?: string
  type: 'studio' | string
  urlType: 'internal' | 'external' | string
  appHost: string
}

/**
 * Used to specify light or dark mode, or to respect system settings (prefers-color-scheme media
 * query) use 'system'
 * @public
 */
declare type StudioColorScheme = ThemeColorSchemeKey | 'system'

/**
 * @hidden
 * @beta */
declare interface StudioComponents {
  layout: ComponentType<Omit<LayoutProps, 'renderDefault'>>
  /**
   * @deprecated Add custom icons on a per-workspace basis by customizing workspace `icon` instead.
   * @see {@link https://www.sanity.io/docs/workspaces}
   */
  logo: ComponentType<Omit<LogoProps, 'renderDefault'>>
  navbar: ComponentType<Omit<NavbarProps, 'renderDefault'>>
  toolMenu: ComponentType<Omit<ToolMenuProps, 'renderDefault'>>
}

/**
 * @hidden
 * @beta */
declare interface StudioComponents_2 {
  layout: ComponentType<Omit<LayoutProps_2, 'renderDefault'>>
  /**
   * @deprecated Add custom icons on a per-workspace basis by customizing workspace `icon` instead.
   * @see {@link https://www.sanity.io/docs/workspaces}
   */
  logo: ComponentType<Omit<LogoProps_2, 'renderDefault'>>
  navbar: ComponentType<Omit<NavbarProps_2, 'renderDefault'>>
  toolMenu: ComponentType<Omit<ToolMenuProps_2, 'renderDefault'>>
}

/**
 * @hidden
 * @beta */
declare interface StudioComponentsPluginOptions {
  activeToolLayout?: ComponentType<ActiveToolLayoutProps>
  layout?: ComponentType<LayoutProps>
  /**
   * @deprecated Add custom icons on a per-workspace basis by customizing workspace `icon` instead.
   * @see {@link https://www.sanity.io/docs/workspaces}
   */
  logo?: ComponentType<LogoProps>
  navbar?: ComponentType<NavbarProps>
  toolMenu?: ComponentType<ToolMenuProps>
}

/**
 * @hidden
 * @beta */
declare interface StudioComponentsPluginOptions_2 {
  activeToolLayout?: ComponentType<ActiveToolLayoutProps_2>
  layout?: ComponentType<LayoutProps_2>
  /**
   * @deprecated Add custom icons on a per-workspace basis by customizing workspace `icon` instead.
   * @see {@link https://www.sanity.io/docs/workspaces}
   */
  logo?: ComponentType<LogoProps_2>
  navbar?: ComponentType<NavbarProps_2>
  toolMenu?: ComponentType<ToolMenuProps_2>
}

/** @public
 * @deprecated  Will be removed in upcoming major version
 * */
declare interface StudioTheme extends Omit<
  RootTheme,
  | 'avatar'
  | 'button'
  | 'container'
  | 'focusRing'
  | 'input'
  | 'layer'
  | 'media'
  | 'radius'
  | 'shadows'
  | 'space'
  | 'styles'
  | 'color'
  | 'fonts'
> {
  /** @internal */
  __dark?: boolean
  /** @internal */
  __legacy?: boolean
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  avatar?: RootTheme['avatar']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  button?: RootTheme['button']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  container?: RootTheme['container']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  focusRing?: RootTheme['focusRing']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  input?: RootTheme['input']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  layer?: RootTheme['layer']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  media?: RootTheme['media']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  radius?: RootTheme['radius']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  shadows?: RootTheme['shadows']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  space?: RootTheme['space']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  styles?: RootTheme['styles']
  color?: RootTheme['color']
  fonts?: RootTheme['fonts']
}

/** @public
 * @deprecated  Will be removed in upcoming major version
 * */
declare interface StudioTheme_2 extends Omit<
  RootTheme,
  | 'avatar'
  | 'button'
  | 'container'
  | 'focusRing'
  | 'input'
  | 'layer'
  | 'media'
  | 'radius'
  | 'shadows'
  | 'space'
  | 'styles'
  | 'color'
  | 'fonts'
> {
  /** @internal */
  __dark?: boolean
  /** @internal */
  __legacy?: boolean
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  avatar?: RootTheme['avatar']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  button?: RootTheme['button']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  container?: RootTheme['container']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  focusRing?: RootTheme['focusRing']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  input?: RootTheme['input']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  layer?: RootTheme['layer']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  media?: RootTheme['media']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  radius?: RootTheme['radius']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  shadows?: RootTheme['shadows']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  space?: RootTheme['space']
  /**
   * @deprecated this theme property is not configurable within the studio
   */
  styles?: RootTheme['styles']
  color?: RootTheme['color']
  fonts?: RootTheme['fonts']
}

/**
 * Used to specify light or dark mode, or to respect system settings (prefers-color-scheme media
 * query) use 'system'
 * @public
 * @deprecated Use `StudioColorScheme` instead
 */
declare type StudioThemeColorSchemeKey = StudioColorScheme

/**
 * System bundles are sets of documents owned by the system.
 *
 * - Draft documents contain data that has not yet been published. These documents all exist in the "drafts" path.
 * - Published documents contain data that has been published. These documents all exist in the root path.
 *
 * These differ to user bundles, which are created when a user establishes a custom set of documents
 * (e.g. by creating a release).
 *
 * @public
 */
declare type SystemBundle = 'drafts' | 'published'

/**
 * System bundles are sets of documents owned by the system.
 *
 * - Draft documents contain data that has not yet been published. These documents all exist in the "drafts" path.
 * - Published documents contain data that has been published. These documents all exist in the root path.
 *
 * These differ to user bundles, which are created when a user establishes a custom set of documents
 * (e.g. by creating a release).
 *
 * @public
 */
declare type SystemBundle_2 = 'drafts' | 'published'

/**
 * @internal
 */
export declare const TableContext: Context<TableContextValue | null>

/**
 * @internal
 */
declare interface TableContextValue {
  searchTerm: string | null
  setSearchTerm: (searchTerm: string) => void
  sort: TableSort | null
  setSortColumn: (column: string) => void
}

declare interface TableSort {
  column: string
  direction: SortDirection
}

declare interface Tag {
  _type: 'tag'
  _key: string
  tag: string
}

/**
 * A value representing a perspective, including the data describing it. This is either the name of a
 * system bundle, or a document describing a release.
 *
 * @public
 */
declare type TargetPerspective = ReleaseDocument | SystemBundle

/**
 * A value representing a perspective, including the data describing it. This is either the name of a
 * system bundle, or a document describing a release.
 *
 * @public
 */
declare type TargetPerspective_2 = ReleaseDocument | SystemBundle_2

/**
 * @beta
 * @hidden
 */
declare interface TaskContext {
  tool?: string
  payload?: Record<string, unknown>
  notification?: {
    url: string
    workspaceTitle: string
    targetContentTitle: string | null
    targetContentImageUrl: string | null
  }
}

declare interface TaskCreateFailedState {
  type: 'createError'
  error: Error
}

declare interface TaskCreateRetryingState {
  type: 'createRetrying'
}

/**
 * @beta
 * @hidden
 */
declare interface TaskDocument {
  _type: 'tasks.task'
  _createdAt: string
  _updatedAt: string
  _id: string
  _rev: string
  _state?: TaskState
  title: string
  description?: TaskMessage
  status: TaskStatus
  lastEditedAt?: string
  context?: TaskContext
  authorId: string
  dueBy?: string
  assignedTo?: string
  subscribers?: string[]
  target?: TaskTarget
  /**
   * Date representing when the task was created by the user and not by the system. When the `create task` button was clicked.
   */
  createdByUser?: string
}

/**
 * @beta
 * @hidden
 */
declare type TaskMessage = PortableTextBlock[] | null

/**
 * @internal
 */
export declare const TasksContext: Context<TasksContextValue | null>

/**
 * @beta
 * @hidden
 */
declare interface TasksContextValue {
  activeDocument: ActiveDocument | null
  setActiveDocument: (document: ActiveDocument | null) => void
  data: TaskDocument[]
  isLoading: boolean
}

/**
 * @internal
 */
export declare const TasksEnabledContext: Context<TasksEnabledContextValue>

/**
 * @internal
 */
declare type TasksEnabledContextValue =
  | {
      enabled: false
      mode: null
    }
  | {
      enabled: true
      mode: 'default' | 'upsell'
    }

/**
 * @internal
 */
export declare const TasksNavigationContext: Context<TasksNavigationContextValue | null>

declare type TasksNavigationContextValue = {
  state: State
  setActiveTab: (id: SidebarTabsIds) => void
  setViewMode: (options: ViewModeOptions) => void
  handleCloseTasks: () => void
  handleCopyLinkToTask: () => void
  handleOpenTasks: () => void
}

/**
 * The state is used to track the state of the task (e.g. if it failed to be created, etc.)
 * It is a local value and is not stored on the server.
 * When there's no state, the task is considered to be in a "normal" state (e.g. created successfully).
 *
 * The state value is primarily used to update the UI. That is, to show an error message or retry button.
 */
declare type TaskState = TaskCreateFailedState | TaskCreateRetryingState | undefined

/**
 * @beta
 * @hidden
 */
declare type TaskStatus = 'open' | 'closed'

/**
 * @beta
 * @hidden
 */
export declare const TasksUpsellContext: Context<TasksUpsellContextValue | null>

declare interface TasksUpsellContextValue {
  upsellDialogOpen: boolean
  handleOpenDialog: (source: UpsellDialogViewedInfo['source']) => void
  handleClose: () => void
  upsellData: UpsellData | null
  telemetryLogs: {
    dialogSecondaryClicked: () => void
    dialogPrimaryClicked: () => void
    panelViewed: (source: UpsellDialogViewedInfo['source']) => void
    panelDismissed: () => void
    panelPrimaryClicked: () => void
    panelSecondaryClicked: () => void
  }
}

declare interface TaskTarget {
  documentType: string
  document: {
    _dataset: string
    _projectId: string
    _ref: string
    _type: 'crossDatasetReference'
    _weak: boolean
  }
}

/**
 * An initial value template is a template that can be used to create a new documents.
 *
 * This allows a document type to have multiple different starting values while having the same
 * shared schema definition. Using parameters allows for dynamic template values.
 *
 * As the name implies, these are _initial_ values, not _default_ values. The distinction is that
 * the initial value is only set when the document is created - it is not "merged" into existing
 * documents that may lack values for fields.
 *
 * All document types will by default (automatically, behind the scenes) have an initial value
 * template generated for them, which will have the same ID as the schema type name. The value of
 * this template will be the value of the `initialValue` property on the schema type definition,
 * or an empty object if none is set.
 *
 * @public
 */
declare interface Template<Params = any, Value = any> {
  /**
   * Template ID. Automatically generated templates will have the same ID as the schema type name.
   */
  id: string
  /**
   * Template title.
   */
  title: string
  i18n?: I18nTextRecord<'title'>
  /**
   * Schema type name the template belongs to. For the automatically generated templates,
   * this will be equal to the `id` property.
   */
  schemaType: string
  /**
   * Template icon. Rendered in places such as the "new document" dialog. Optional.
   * Inferred from the schema type icon if not set.
   */
  icon?: SchemaType['icon']
  /**
   * Value to use as initial value. Can either be a static object value, or a function that
   * resolves _to_ an object value. If using a function, it can be given a set of parameters,
   * which can then determine the value that is returned.
   */
  value: InitialValueProperty<Params, Value>
  /**
   * Array of parameters the template accepts. Currently not used (any parameters are accepted),
   * but by defining parameters, the templates that require parameters can be identified and
   * excluded from UIs that do not provide them.
   */
  parameters?: TemplateParameter[]
  /**
   * Template description. Rendered in places such as the "new document" dialog. Optional.
   *
   * @deprecated No longer used
   */
  description?: string
}

/**
 * An initial value template is a template that can be used to create a new documents.
 *
 * This allows a document type to have multiple different starting values while having the same
 * shared schema definition. Using parameters allows for dynamic template values.
 *
 * As the name implies, these are _initial_ values, not _default_ values. The distinction is that
 * the initial value is only set when the document is created - it is not "merged" into existing
 * documents that may lack values for fields.
 *
 * All document types will by default (automatically, behind the scenes) have an initial value
 * template generated for them, which will have the same ID as the schema type name. The value of
 * this template will be the value of the `initialValue` property on the schema type definition,
 * or an empty object if none is set.
 *
 * @public
 */
declare interface Template_2<Params = any, Value = any> {
  /**
   * Template ID. Automatically generated templates will have the same ID as the schema type name.
   */
  id: string
  /**
   * Template title.
   */
  title: string
  i18n?: I18nTextRecord<'title'>
  /**
   * Schema type name the template belongs to. For the automatically generated templates,
   * this will be equal to the `id` property.
   */
  schemaType: string
  /**
   * Template icon. Rendered in places such as the "new document" dialog. Optional.
   * Inferred from the schema type icon if not set.
   */
  icon?: SchemaType['icon']
  /**
   * Value to use as initial value. Can either be a static object value, or a function that
   * resolves _to_ an object value. If using a function, it can be given a set of parameters,
   * which can then determine the value that is returned.
   */
  value: InitialValueProperty<Params, Value>
  /**
   * Array of parameters the template accepts. Currently not used (any parameters are accepted),
   * but by defining parameters, the templates that require parameters can be identified and
   * excluded from UIs that do not provide them.
   */
  parameters?: TemplateParameter_2[]
  /**
   * Template description. Rendered in places such as the "new document" dialog. Optional.
   *
   * @deprecated No longer used
   */
  description?: string
}

/** @public */
declare type TemplateArrayFieldDefinition = TemplateFieldDefinition & {
  type: 'array'
  /** Defines items that are definition of. See {@link TemplateReferenceTarget} and {@link TypeTarget} */
  of: (TemplateReferenceTarget | TypeTarget)[]
}

/** @public */
declare type TemplateArrayFieldDefinition_2 = TemplateFieldDefinition_2 & {
  type: 'array'
  /** Defines items that are definition of. See {@link TemplateReferenceTarget} and {@link TypeTarget} */
  of: (TemplateReferenceTarget_2 | TypeTarget_2)[]
}

/**
 * Field definition for a template parameter.
 * Closely resembles API used to define fields for object schema types.
 *
 * @public
 */
declare interface TemplateFieldDefinition {
  /**
   * Parameter name. Must be unique within the template.
   */
  name: string
  /**
   * Parameter type, eg `string`, `number`, `boolean` etc.
   */
  type: string
  /**
   * Parameter type. Will be attempted to be automatically set if not given,
   * by title-casing the `name` property.
   */
  title?: string
  /**
   * Description for the parameter. Optional.
   * May be used in the future to explain the parameter in UIs.
   */
  description?: string
  /**
   * Optional bag of options for the parameter. Currently unused.
   */
  options?: {
    [key: string]: any
  }
}

/**
 * Field definition for a template parameter.
 * Closely resembles API used to define fields for object schema types.
 *
 * @public
 */
declare interface TemplateFieldDefinition_2 {
  /**
   * Parameter name. Must be unique within the template.
   */
  name: string
  /**
   * Parameter type, eg `string`, `number`, `boolean` etc.
   */
  type: string
  /**
   * Parameter type. Will be attempted to be automatically set if not given,
   * by title-casing the `name` property.
   */
  title?: string
  /**
   * Description for the parameter. Optional.
   * May be used in the future to explain the parameter in UIs.
   */
  description?: string
  /**
   * Optional bag of options for the parameter. Currently unused.
   */
  options?: {
    [key: string]: any
  }
}

/**
 * Represents the items that can appear in different parts of the Sanity studio when creating
 * new documents - examples being the "New document" button in the navigation bar,
 * the corresponding button in panes, as well as the "Create new" button on references.
 *
 * Differs from an actual _template_ in that a single template can be pointed at by multiple
 * different items. This is useful when the template can create different values based on
 * passed parameters.
 *
 * @public
 */
declare interface TemplateItem {
  /**
   * ID for the template. Must be unique within the set of templates.
   */
  templateId: string
  /**
   * Title for the item.
   * Defaults to the title of the associated template.
   */
  title?: string
  i18n?: I18nTextRecord<'title'>
  /**
   * Parameters for the template - an object of any JSON-serializable values
   */
  parameters?: {
    [key: string]: any
  }
  /**
   * React icon for the item, if any.
   * Defaults to the icon for the associated template.
   */
  icon?: React.ElementType | React.JSX.Element
  /**
   * Experimental: not fully supported yet
   * Hints at what the document ID for the new document should be.
   * Leave undefined to let the system decide.
   *
   * @experimental
   * @beta
   * @hidden
   */
  initialDocumentId?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  subtitle?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  description?: string
}

/**
 * Represents the items that can appear in different parts of the Sanity studio when creating
 * new documents - examples being the "New document" button in the navigation bar,
 * the corresponding button in panes, as well as the "Create new" button on references.
 *
 * Differs from an actual _template_ in that a single template can be pointed at by multiple
 * different items. This is useful when the template can create different values based on
 * passed parameters.
 *
 * @public
 */
declare interface TemplateItem_2 {
  /**
   * ID for the template. Must be unique within the set of templates.
   */
  templateId: string
  /**
   * Title for the item.
   * Defaults to the title of the associated template.
   */
  title?: string
  i18n?: I18nTextRecord<'title'>
  /**
   * Parameters for the template - an object of any JSON-serializable values
   */
  parameters?: {
    [key: string]: any
  }
  /**
   * React icon for the item, if any.
   * Defaults to the icon for the associated template.
   */
  icon?: React.ElementType | React.JSX.Element
  /**
   * Experimental: not fully supported yet
   * Hints at what the document ID for the new document should be.
   * Leave undefined to let the system decide.
   *
   * @experimental
   * @beta
   * @hidden
   */
  initialDocumentId?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  subtitle?: string
  /**
   * @deprecated No longer used anywhere
   * @hidden
   */
  description?: string
}

/** @internal */
declare interface TemplateOption {
  id: string
  params?: Record<string, string | number | boolean>
}

/**
 * Parameter for a template. Closely resembles API used to define fields for object schema types.
 * See {@link TemplateFieldDefinition} and {@link TemplateArrayFieldDefinition}
 * @public
 */
declare type TemplateParameter = TemplateFieldDefinition | TemplateArrayFieldDefinition

/**
 * Parameter for a template. Closely resembles API used to define fields for object schema types.
 * See {@link TemplateFieldDefinition} and {@link TemplateArrayFieldDefinition}
 * @public
 */
declare type TemplateParameter_2 = TemplateFieldDefinition_2 | TemplateArrayFieldDefinition_2

/** @internal */
declare interface TemplatePermissionsResult<TInitialValue = Record<string, unknown>>
  extends PermissionCheckResult_2, InitialValueTemplateItem {
  granted: boolean
  reason: string
  resolvedInitialValue: TInitialValue
  subtitle?: string
  template: Template
}

/** @public */
declare interface TemplateReferenceTarget {
  type: 'reference'
  /** Type to reference. See {@link TypeTarget} */
  to: TypeTarget | TypeTarget[]
}

/** @public */
declare interface TemplateReferenceTarget_2 {
  type: 'reference'
  /** Type to reference. See {@link TypeTarget} */
  to: TypeTarget_2 | TypeTarget_2[]
}

/** @public */
declare type TemplateResolver = ComposableOption<Template[], ConfigContext>

/** @public */
declare type TemplateResolver_2 = ComposableOption_2<Template_2[], ConfigContext_2>

declare type TermsFiltersAdd = {
  filter: SearchFilter
  type: 'TERMS_FILTERS_ADD'
}

declare type TermsFiltersClear = {
  type: 'TERMS_FILTERS_CLEAR'
}

declare type TermsFiltersRemove = {
  filterKey: string
  type: 'TERMS_FILTERS_REMOVE'
}

declare type TermsFiltersSetOperator = {
  filterKey: string
  operatorType: string
  type: 'TERMS_FILTERS_SET_OPERATOR'
}

declare type TermsFiltersSetValue = {
  filterKey: string
  type: 'TERMS_FILTERS_SET_VALUE'
  value?: any
}

declare type TermsQuerySet = {
  type: 'TERMS_QUERY_SET'
  query: string
}

declare type TermsSet = {
  type: 'TERMS_SET'
  filters?: SearchFilter[]
  terms: SearchTerms
}

declare type TermsTypeAdd = {
  type: 'TERMS_TYPE_ADD'
  schemaType: SchemaType
}

declare type TermsTypeRemove = {
  type: 'TERMS_TYPE_REMOVE'
  schemaType: SchemaType
}

declare type TermsTypesClear = {
  type: 'TERMS_TYPES_CLEAR'
}

/**
 * Timeline maintains information about the history of a document:
 * Grouping raw translog entries into sensible groups, replaying and
 * reconstructing different versions and abstract other details.
 *
 * Note that this class by itself is not capable of _fetching_ information,
 * but will only organize and structure the incoming translog entries.
 *
 *
 * @hidden
 * @beta
 */
declare class Timeline {
  reachedEarliestEntry: boolean
  publishedId: string
  draftId: string
  private _transactions
  private _chunks
  private _possiblePendingTransactions
  private _recreateTransactionsFrom?
  private _trace?
  constructor(opts: TimelineOptions)
  get chunkCount(): number
  /** Maps over the chunk from newest to oldest. */
  mapChunks<T>(mapper: (chunk: Chunk, idx: number) => T): T[]
  reset(): void
  /**
   * Adds a remote mutation to the timeline. This methods assumes that the remote mutations
   * come in correct order for their respective version, but has no ordering requirements
   * across draft/published.
   *
   * Example: [D1, D2, P1] (where D1 and P1 were mutations done to the draft and published
   * version in the same transaction) is a valid input. [P1, D2, D1] is _not_ valid since
   * the mutation for the draft is out of order.
   */
  addRemoteMutation(entry: DocumentRemoteMutationVersionEvent): void
  addTranslogEntry(event: TransactionLogEventWithEffects): void
  /** Mark that we've reached the earliest entry. */
  didReachEarliestEntry(): void
  /**
   * updateChunks synchronizes the chunks to match the current state
   * of the transactions array. After calling this method you need
   * to invalidate all Chunks.
   */
  updateChunks(): void
  private _removeInvalidatedChunks
  private _addChunksFromTransactions
  private _invalidateTransactionFrom
  private _createInitialChunk
  /**
   * Resolves a time reference.
   *
   * Note that the chunk returned is only valid if the timeline stays constant.
   * Once the timeline is updated, you must re-parse all references.
   */
  parseTimeId(id: string): ParsedTimeRef
  findLastPublishedBefore(chunk: Chunk | null): ParsedTimeRef
  isLatestChunk(chunk: Chunk): boolean
  createTimeId(chunk: Chunk): string
  lastChunk(): Chunk
  transactionByIndex(idx: number): Transaction | null
  chunkByTransactionIndex(idx: number, startChunkIdx?: number): Chunk
  replayBackwardsBetween(firstIdx: number, lastIdx: number, doc: CombinedDocument): CombinedDocument
  replayBackwardsUntil(firstIdx: number, doc: CombinedDocument): CombinedDocument
  calculateDiff(
    initialDoc: CombinedDocument,
    finalDoc: CombinedDocument,
    firstIdx: number,
    lastIdx: number,
  ): Diff<Annotation_2>
}

/**
 * The controller is responsible for fetching information
 * about a document and maintaining a Timeline.
 *
 *
 * @hidden
 * @beta
 */
declare class TimelineController {
  timeline: Timeline
  client: SanityClient
  handler: TimelineControllerOptions['handler']
  version: number
  /**
   * The selection state represents the  different states of the current selection:
   * - inactive: No selection is active.
   * - rev: A selection is active for a single revision.
   * - range: A selection is active for a range and we have all the data needed to render it.
   * - loading: A selection is active, but we don't have the entries yet.
   * - invalid: The selection picked is invalid.
   */
  selectionState: SelectionState
  constructor(options: TimelineControllerOptions)
  private _aligner
  private _fetchMore
  private _fetchAtLeast
  private _isRunning
  private _isSuspended
  private _didErr
  private _since
  private _sinceTime
  private _rev
  private _revTime
  private _reconstruction?
  setHandler(handler: TimelineControllerOptions['handler']): void
  clearRange(): void
  setRange(since: string | null, rev: string | null): void
  setLoadMore(flag: boolean): void
  get sinceTime(): Chunk | null
  get revTime(): Chunk | null
  get isLoading(): boolean
  get realRevChunk(): Chunk
  /** Returns true when there's an older revision we want to render. */
  onOlderRevision(): boolean
  findRangeForNewRev(rev: Chunk): [string | null, string | null]
  findRangeForNewSince(since: Chunk): [string, string | null]
  setRevTime(rev: string | null): void
  setSinceTime(since: string | null): void
  sinceAttributes(): Record<string, unknown> | null
  displayed(): Record<string, unknown> | null
  setReconstruction(since: Chunk | null, rev: Chunk): void
  currentDiff(): Diff<Annotation_2> | null
  currentObjectDiff(): ObjectDiff_2<Annotation_2> | null
  handleRemoteMutation(ev: RemoteSnapshotVersionEvent): void
  start(): void
  resume(): void
  suspend(): void
  private tick
  private fetchMoreTransactions
  private markChange
}

/**
 * @hidden
 * @beta */
declare type TimelineControllerOptions = {
  timeline: Timeline
  client: SanityClient
  documentId: string
  documentType: string
  handler?: (err: Error | null, controller: TimelineController) => void
}

/**
 * @hidden
 * @beta */
declare interface TimelineOptions {
  publishedId: string
  enableTrace?: boolean
}

/** @internal */
declare interface TimelineState {
  chunks: Chunk[]
  diff: ObjectDiff_2<Annotation_2, Record<string, any>> | null
  /** null is used here when the chunks hasn't loaded / is not known */
  hasMoreChunks: boolean | null
  isLoading: boolean
  /**
   * Whether this timeline is fully loaded and completely empty (true for new documents)
   * It can be `null` when the chunks hasn't loaded / is not known
   */
  isPristine: boolean | null
  lastNonDeletedRevId: string | null
  onOlderRevision: boolean
  realRevChunk: Chunk | null
  revTime: Chunk | null
  selectionState: SelectionState
  sinceAttributes: Record<string, unknown> | null
  sinceTime: Chunk | null
  timelineDisplayed: Record<string, unknown> | null
  timelineReady: boolean
}

/** @internal */
declare interface TimelineStore {
  findRangeForRev: TimelineController['findRangeForNewRev']
  findRangeForSince: TimelineController['findRangeForNewSince']
  loadMore: () => void
  getSnapshot: () => TimelineState
  subscribe: (callback: () => void) => () => void
}

/**
 * A tool can be thought of as a top-level "view" or "app".
 * They are available through the global menu bar, and has a URL route associated with them.
 *
 * In essence, a tool is a React component that is rendered when the tool is active,
 * along with a title, name (URL segment) and icon.
 *
 * Tools can handle {@link structure.Intent | intents} such as "edit" or "create" by defining a
 * function for the `canHandleIntent` property, as well as the `getIntentState` property,
 * which defines what an intent will be mapped to in terms of the tool's URL state.
 *
 * @public
 */
declare interface Tool<Options = any> {
  /**
   * The React component that renders the tool.
   */
  component: ComponentType<{
    tool: Tool<Options>
  }>
  /**
   * React component for the icon representing the tool.
   */
  icon?: ComponentType
  /**
   * The name of the tool, used as part of the URL.
   */
  name: string
  /**
   * Options are passed through from the configuration to the component defined by the `component`
   */
  options?: Options
  /**
   * The router for the tool. See {@link router.Router}
   */
  router?: Router
  /**
   * Title of the tool - used for the navigation menu item, along with the icon.
   */
  title: string
  /**
   * Determines whether the tool will control the `document.title`.
   */
  controlsDocumentTitle?: boolean
  /**
   * Gets the state for the given intent.
   *
   * @param intent - The intent to get the state for.
   * @param params - The parameters for the intent.
   * @param routerState - The current router state. See {@link router.RouterState}
   * @param payload - The payload for the intent.
   * @returns The state for the intent.
   */
  getIntentState?: (
    intent: string,
    params: Record<string, string>,
    routerState: RouterState | undefined,
    payload: unknown,
  ) => unknown
  /**
   * Determines whether the tool can handle the given intent.
   *
   * Can either return a boolean, or an object where the keys represent the parameters that
   * can/can not be handled. This will be used to determine whether or not a tool is the best
   * suited to handle an intent. Note that an object of only `false` values (or an empty object)
   * is treated as `true`, so you want to explicitly return `false` if you know the intent cannot
   * fulfill the intent request.
   *
   * @param intent - The intent to check.
   * @param params - The parameters for the intent.
   * @param payload - The payload for the intent.
   * @returns Boolean: whether it can handle the intent. Object: Values representing what specific parameters can be handled.
   */
  canHandleIntent?: (
    intent: string,
    params: Record<string, unknown>,
    payload: unknown,
  ) =>
    | boolean
    | {
        [key: string]: boolean
      }
  /**
   * Internal application type identifier used to classify system tools.
   *
   * @internal
   */
  __internalApplicationType?: string
}

/**
 * A tool can be thought of as a top-level "view" or "app".
 * They are available through the global menu bar, and has a URL route associated with them.
 *
 * In essence, a tool is a React component that is rendered when the tool is active,
 * along with a title, name (URL segment) and icon.
 *
 * Tools can handle {@link structure.Intent | intents} such as "edit" or "create" by defining a
 * function for the `canHandleIntent` property, as well as the `getIntentState` property,
 * which defines what an intent will be mapped to in terms of the tool's URL state.
 *
 * @public
 */
declare interface Tool_2<Options = any> {
  /**
   * The React component that renders the tool.
   */
  component: ComponentType<{
    tool: Tool_2<Options>
  }>
  /**
   * React component for the icon representing the tool.
   */
  icon?: ComponentType
  /**
   * The name of the tool, used as part of the URL.
   */
  name: string
  /**
   * Options are passed through from the configuration to the component defined by the `component`
   */
  options?: Options
  /**
   * The router for the tool. See {@link router.Router}
   */
  router?: Router
  /**
   * Title of the tool - used for the navigation menu item, along with the icon.
   */
  title: string
  /**
   * Determines whether the tool will control the `document.title`.
   */
  controlsDocumentTitle?: boolean
  /**
   * Gets the state for the given intent.
   *
   * @param intent - The intent to get the state for.
   * @param params - The parameters for the intent.
   * @param routerState - The current router state. See {@link router.RouterState}
   * @param payload - The payload for the intent.
   * @returns The state for the intent.
   */
  getIntentState?: (
    intent: string,
    params: Record<string, string>,
    routerState: RouterState | undefined,
    payload: unknown,
  ) => unknown
  /**
   * Determines whether the tool can handle the given intent.
   *
   * Can either return a boolean, or an object where the keys represent the parameters that
   * can/can not be handled. This will be used to determine whether or not a tool is the best
   * suited to handle an intent. Note that an object of only `false` values (or an empty object)
   * is treated as `true`, so you want to explicitly return `false` if you know the intent cannot
   * fulfill the intent request.
   *
   * @param intent - The intent to check.
   * @param params - The parameters for the intent.
   * @param payload - The payload for the intent.
   * @returns Boolean: whether it can handle the intent. Object: Values representing what specific parameters can be handled.
   */
  canHandleIntent?: (
    intent: string,
    params: Record<string, unknown>,
    payload: unknown,
  ) =>
    | boolean
    | {
        [key: string]: boolean
      }
  /**
   * Internal application type identifier used to classify system tools.
   *
   * @internal
   */
  __internalApplicationType?: string
}

/**
 * @hidden
 * @beta */
declare interface ToolMenuProps {
  activeToolName?: string
  closeSidebar: () => void
  context: 'sidebar' | 'topbar'
  isSidebarOpen: boolean
  tools: Tool[]
  renderDefault: (props: ToolMenuProps) => React.JSX.Element
}

/**
 * @hidden
 * @beta */
declare interface ToolMenuProps_2 {
  activeToolName?: string
  closeSidebar: () => void
  context: 'sidebar' | 'topbar'
  isSidebarOpen: boolean
  tools: Tool_2[]
  renderDefault: (props: ToolMenuProps_2) => React.JSX.Element
}

/** @internal */
declare interface TrackedChange {
  element: HTMLElement | null
  path: Path
  isChanged: boolean
  hasFocus: boolean
  hasHover: boolean
  hasRevertHover: boolean
  zIndex: number
}

/** @internal */
declare type TrackerContextGetSnapshot<Value> = [string, Value][]

/** @internal */
declare interface TrackerContextStore<Value> {
  add: (id: string, value: Value) => void
  update: (id: string, value: Value) => void
  remove: (id: string) => void
}

/**
 * @hidden
 * @beta */
declare interface Transaction {
  index: number
  id: string
  author: string
  timestamp: string
  draftEffect?: MendozaEffectPair
  publishedEffect?: MendozaEffectPair
}

declare interface TransactionSyncLockState {
  enabled: boolean
}

declare interface TransactionSyncLockState_2 {
  enabled: boolean
}

/**
 * This error may happen if the _type of the value is different from the declared schema type
 * It represents a case where we encounter field value that is structurally compatible with the field's defined schema type
 * (e.g. they are both json objects), but the _type name is different from what the schema type expects
 *
 * Note on compatibility: The schema of a field may be defined as an object with fields (a, b, c), but the value is an object with (d, e, f)
 * These are still structurally compatible because (d, e, f) will be considered undeclared members
 *
 * @public
 */
declare type TypeAnnotationMismatchError = {
  type: 'TYPE_ANNOTATION_MISMATCH'
  expectedSchemaType: SchemaType
  resolvedValueType: string
}

/**
 * This error may happen if the _type of the value is different from the declared schema type
 * It represents a case where we encounter field value that is structurally compatible with the field's defined schema type
 * (e.g. they are both json objects), but the _type name is different from what the schema type expects
 *
 * Note on compatibility: The schema of a field may be defined as an object with fields (a, b, c), but the value is an object with (d, e, f)
 * These are still structurally compatible because (d, e, f) will be considered undeclared members
 *
 * @public
 */
declare type TypeAnnotationMismatchError_2 = {
  type: 'TYPE_ANNOTATION_MISMATCH'
  expectedSchemaType: SchemaType
  resolvedValueType: string
}

/**
 * @public
 */
declare interface TypeTarget {
  type: string
}

/**
 * @public
 */
declare interface TypeTarget_2 {
  type: string
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type UndeclaredMembersError = {
  type: 'UNDECLARED_MEMBERS'
  schemaType: ArraySchemaType
}

/**
 * This error may happen for objects if we encounter fields that are not declared in the schema
 *
 * @public
 */
declare type UndeclaredMembersError_2 = {
  type: 'UNDECLARED_MEMBERS'
  schemaType: ArraySchemaType
}

/**
 * @hidden
 * @beta
 */
declare interface UnpublishDocumentEvent extends BaseEvent {
  type: 'unpublishDocument'
  documentId: string
  /** The version that was created based on it */
  versionId: string
  versionRevisionId: string
  releaseId?: string
  author: string
}

/**
 * @hidden
 * @beta
 */
declare interface UnpublishDocumentEvent_2 extends BaseEvent_2 {
  type: 'unpublishDocument'
  documentId: string
  /** The version that was created based on it */
  versionId: string
  versionRevisionId: string
  releaseId?: string
  author: string
}

/** @internal */
declare type UnresolvedPaneNode =
  | PaneNodeResolver
  | SerializablePaneNode
  | Observable<UnresolvedPaneNode>
  | PromiseLike<UnresolvedPaneNode>
  | PaneNode

/**
 * @hidden
 * @beta
 */
declare interface UnscheduleDocumentVersionEvent extends BaseEvent {
  type: 'unscheduleDocumentVersion'
  documentId: string
  releaseId: string
  versionId: string
  versionRevisionId: string
  author: string
}

/**
 * @hidden
 * @beta
 */
declare interface UnscheduleDocumentVersionEvent_2 extends BaseEvent_2 {
  type: 'unscheduleDocumentVersion'
  documentId: string
  releaseId: string
  versionId: string
  versionRevisionId: string
  author: string
}

/**
 * Interface for unserialized list items.
 *
 * @public
 */
declare interface UnserializedListItem {
  /** List item ID */
  id: string
  /** List item title */
  title: string
  /**
   * The i18n key and namespace used to populate the localized title. This is
   * the recommend way to set the title if you are localizing your studio.
   */
  i18n?: I18nTextRecord<'title'>
  /** List item icon */
  icon?: React.ComponentType | React.ReactNode
  /** List item child. See {@link UnserializedListItemChild} */
  child?: UnserializedListItemChild
  /** List item display options. See {@link ListItemDisplayOptions} */
  displayOptions?: ListItemDisplayOptions
  /** List item schema. See {@link SchemaType} */
  schemaType?: SchemaType | string
}

/**
 * Unserialized list item child.
 * See {@link Collection}, {@link CollectionBuilder}, {@link ChildResolver} and {@link ItemChild}
 *
 * @public
 */
declare type UnserializedListItemChild =
  | Collection
  | CollectionBuilder
  | ChildResolver
  | Observable<ItemChild>

/**
 * @hidden
 * @beta
 */
declare interface UpdateLiveDocumentEvent extends BaseEvent {
  type: 'updateLiveDocument'
  documentId: string
  revisionId: string
  author: string
}

/**
 * @hidden
 * @beta
 */
declare interface UpdateLiveDocumentEvent_2 extends BaseEvent_2 {
  type: 'updateLiveDocument'
  documentId: string
  revisionId: string
  author: string
}

/**
 *
 * @hidden
 * @beta
 */
declare type Uploader<S extends SchemaType = SchemaType> = {
  type: string
  accepts: string
  upload: (
    client: SanityClient,
    file: File,
    type: S,
    options?: UploadOptions,
  ) => Observable<UploadProgressEvent>
  priority: number
}

/**
 *
 * @hidden
 * @beta
 */
declare type Uploader_2<S extends SchemaType = SchemaType> = {
  type: string
  accepts: string
  upload: (
    client: SanityClient,
    file: File,
    type: S,
    options?: UploadOptions_2,
  ) => Observable<UploadProgressEvent_2>
  priority: number
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploaderResolver<S extends SchemaType = SchemaType> = (
  type: S,
  file: FileLike,
) => Uploader<S> | null

/**
 *
 * @hidden
 * @beta
 */
declare type UploaderResolver_2<S extends SchemaType = SchemaType> = (
  type: S,
  file: FileLike_2,
) => Uploader_2<S> | null

/**
 * @hidden
 * @beta */
declare interface UploadEvent {
  file: File
  schemaType: SchemaType
  uploader: Uploader
}

/**
 * @hidden
 * @beta */
declare interface UploadEvent_2 {
  file: File
  schemaType: SchemaType
  uploader: Uploader_2
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadOptions = {
  metadata?: AssetMetadataType[]
  storeOriginalFilename?: boolean
  label?: string
  title?: string
  description?: string
  creditLine?: string
  source?: AssetSourceSpec
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadOptions_2 = {
  metadata?: AssetMetadataType[]
  storeOriginalFilename?: boolean
  label?: string
  title?: string
  description?: string
  creditLine?: string
  source?: AssetSourceSpec
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadProgressEvent = {
  type: 'uploadProgress'
  patches: FormPatch[] | null
}

/**
 *
 * @hidden
 * @beta
 */
declare type UploadProgressEvent_2 = {
  type: 'uploadProgress'
  patches: FormPatch_2[] | null
}

/**
 * @beta
 * @hidden
 */
declare interface UpsellData {
  _createdAt: string
  _id: string
  _rev: string
  _type: string
  _updatedAt: string
  id: string
  image: {
    asset: {
      url: string
      altText: string | null
    }
  } | null
  descriptionText: PortableTextBlock[]
  ctaButton: {
    text: string
    url: string
  }
  secondaryButton: {
    url: string
    text: string
  }
}

declare interface UpsellDialogActionsInfo {
  feature: 'comments' | 'scheduled_publishing' | 'ai_assist' | 'tasks'
  type: 'modal' | 'inspector'
}

/** @internal */
declare interface UpsellDialogViewedInfo extends UpsellDialogActionsInfo {
  source: 'field_action' | 'document_toolbar' | 'document_action' | 'navbar' | 'link' | 'pte'
}

/**
 * User application from the API
 * @internal
 */
declare interface UserApplication {
  id: string
  type: string
  projectId?: string
  organizationId?: string
  title?: string
  urlType: 'internal' | 'external'
  appHost: string
}

/**
 * Cache for user applications fetched from the API.
 * Caches by projectId to avoid duplicate fetches.
 * @internal
 */
declare interface UserApplicationCache {
  /**
   * Get user applications for a project.
   * Returns cached results if available, otherwise fetches from API.
   */
  get: (client: SanityClient) => Promise<UserApplication[]>
}

/**
 * @internal
 */
export declare const UserApplicationCacheContext: Context<UserApplicationCache | null>

/** @internal */
declare interface UserColor {
  name: ColorHueKey
  background: HexColor
  border: HexColor
  text: HexColor
  tints: ColorTints
}

/** @internal */
declare interface UserColorManager {
  get: (userId: UserId | null) => UserColor
  listen: (userId: UserId) => Observable<UserColor>
}

/**
 * @internal
 */
export declare const UserColorManagerContext: Context<UserColorManager | null>

/**
 * User defined component
 *
 * @public
 */
declare type UserComponent = React.ComponentType<{
  /** Component child. See {@link ComponentBuilder} */
  child?: ComponentBuilder
  /** Component child item ID */
  childItemId?: string
  /** Component ID */
  id: string
  /** Is component active */
  isActive?: boolean
  /** Is component selected */
  isSelected?: boolean
  /** item ID */
  itemId: string
  /** Component options */
  options?: Record<string, unknown>
  /** Pane key */
  paneKey: string
  /** URL parameters */
  urlParams: Record<string, string | undefined> | undefined
}>

/** @internal */
declare type UserId = string

/**
 * @beta
 * @hidden
 */
declare type UserListWithPermissionsHookValue = Loadable<UserWithPermission[]> & {
  /** when true, comments has mention feature disabled
   * @internal
   * */
  disabled?: boolean
}

/**
 * User view component
 *
 * @public */
declare type UserViewComponent<TOptions = Record<string, any>> = React.ComponentType<{
  document: {
    draft: SanityDocument | null
    displayed: Partial<SanityDocument>
    historical: Partial<SanityDocument> | null
    published: SanityDocument | null
  }
  documentId: string
  options: TOptions
  schemaType: SchemaType
}>

/**
 * @beta
 * @hidden
 */
declare interface UserWithPermission extends User {
  granted: boolean
}

/**
 * @internal
 */
export declare const ValidationContext: Context<ValidationMarker[]>

/**
 * @hidden
 * @beta */
declare interface ValidationStatus {
  isValidating: boolean
  validation: ValidationMarker[]
  revision?: string
}

/**
 * @hidden
 * @beta */
declare interface ValidationStatus_2 {
  isValidating: boolean
  validation: ValidationMarker[]
  revision?: string
}

/**
 * View. See {@link FormView} and {@link ComponentView}
 *
 * @public
 */
declare type View = FormView | ComponentView

/**
 * View builder. See {@link ComponentViewBuilder} and {@link FormViewBuilder}
 *
 * @public
 */
declare type ViewBuilder = ComponentViewBuilder | FormViewBuilder

declare type ViewMode = 'create' | 'edit' | 'list' | 'draft' | 'duplicate'

declare type ViewModeOptions =
  | {
      type: 'list' | 'create'
    }
  | {
      type: 'edit'
      id: string
    }
  | {
      type: 'duplicate'
      duplicateTaskValues: TaskDocument
    }
  | {
      type: 'draft'
      id: string
    }

/**
 * @internal
 */
declare interface VirtualizerScrollInstance {
  /**
   * The parent that has the overflow scroll
   */
  scrollElement: HTMLElement | null
  /**
   * The container that wraps the array items
   */
  containerElement: MutableRefObject<HTMLElement | null>
}

/**
 * This is used to store the reference to the scroll element for virtualizer
 * @internal
 */
export declare const VirtualizerScrollInstanceContext: Context<VirtualizerScrollInstance | null>

/** @beta */
declare interface WelcomeEvent {
  type: 'welcome'
  listenerName: string
}

/**
 * @hidden
 * @beta */
declare type WithVersion<T> = T & {
  version: DocumentVariantType_2
}

/**
 * Definition for Workspace
 *
 * @public
 */
declare interface Workspace extends Omit<Source, 'type'> {
  type: 'workspace'
  /**
   * URL base path to use, for instance `/myWorkspace`
   * Note that this will be prepended with any _studio_ base path, eg `/studio/myWorkspace`,
   * and is a client-side routing feature. If you're looking to serve your studio from a subpath,
   * you're probably looking for the `basePath` property in `sanity.cli.ts`/`sanity.cli.js`.
   */
  basePath: string
  /** Subtitle to show under the name of the workspace */
  subtitle?: string
  /** React component to use as icon for this workspace */
  icon: ReactNode
  /**
   *
   * @hidden
   * @beta
   */
  unstable_sources: Source[]
  scheduledPublishing: ScheduledPublishingPluginOptions
  apps?: AppsOptions
}

/**
 * @internal
 */
export declare const WorkspaceContext: Context<Workspace | null>

/**
 * @hidden
 * @beta
 */
declare interface WorkspaceOptions extends SourceOptions {
  basePath: string
  subtitle?: string
  /**
   * The workspace logo
   *
   * @deprecated Custom logo components are no longer supported.
   * Users are encouraged to provide custom components for individual workspace icons instead.
   */
  logo?: ComponentType
  icon?: ComponentType
  /**
   * @hidden
   * @beta
   */
  theme?: StudioTheme
  /**
   * @hidden
   * @beta
   */
  unstable_sources?: SourceOptions[]
  /**
   * @deprecated Use `tasks` instead
   */
  unstable_tasks?: DefaultPluginsWorkspaceOptions['tasks']
  /**
   * @internal
   */
  tasks?: DefaultPluginsWorkspaceOptions['tasks']
  /**
   * @internal
   */
  releases?: DefaultPluginsWorkspaceOptions['releases']
  /**
   * @internal
   */
  mediaLibrary?: DefaultPluginsWorkspaceOptions['mediaLibrary']
  apps?: AppsOptions
  /**
   * @hidden
   * @internal
   */
  __internal_serverDocumentActions?: {
    /**
     * @deprecated The Mutations API integration will be removed in a future release.
     */
    enabled?: boolean
  }
  scheduledDrafts?: DefaultPluginsWorkspaceOptions['scheduledDrafts']
  /**
   * @beta
   */
  [DECISION_PARAMETERS_SCHEMA]?: DecisionParametersConfig
  scheduledPublishing?: DefaultPluginsWorkspaceOptions['scheduledPublishing']
}

/**
 * @hidden
 * @beta
 */
declare interface WorkspaceOptions_2 extends SourceOptions_2 {
  basePath: string
  subtitle?: string
  /**
   * The workspace logo
   *
   * @deprecated Custom logo components are no longer supported.
   * Users are encouraged to provide custom components for individual workspace icons instead.
   */
  logo?: ComponentType
  icon?: ComponentType
  /**
   * @hidden
   * @beta
   */
  theme?: StudioTheme_2
  /**
   * @hidden
   * @beta
   */
  unstable_sources?: SourceOptions_2[]
  /**
   * @deprecated Use `tasks` instead
   */
  unstable_tasks?: DefaultPluginsWorkspaceOptions_2['tasks']
  /**
   * @internal
   */
  tasks?: DefaultPluginsWorkspaceOptions_2['tasks']
  /**
   * @internal
   */
  releases?: DefaultPluginsWorkspaceOptions_2['releases']
  /**
   * @internal
   */
  mediaLibrary?: DefaultPluginsWorkspaceOptions_2['mediaLibrary']
  apps?: AppsOptions_2
  /**
   * @hidden
   * @internal
   */
  __internal_serverDocumentActions?: {
    /**
     * @deprecated The Mutations API integration will be removed in a future release.
     */
    enabled?: boolean
  }
  scheduledDrafts?: DefaultPluginsWorkspaceOptions_2['scheduledDrafts']
  /**
   * @beta
   */
  [DECISION_PARAMETERS_SCHEMA_2]?: DecisionParametersConfig_2
  scheduledPublishing?: DefaultPluginsWorkspaceOptions_2['scheduledPublishing']
}

/** @internal */
export declare const WorkspacesContext: Context<WorkspacesContextValue | null>

/** @internal */
declare type WorkspacesContextValue = WorkspaceSummary[]

/** @internal */
declare interface WorkspaceSummary extends DefaultPluginsWorkspaceOptions {
  type: 'workspace-summary'
  name: string
  title: string
  /**
   * User supplied component if provided, otherwise falls back to
   * an automatically generated default icon.
   */
  icon: ReactNode
  /** Returns true if a custom icon has been provided in studio config */
  customIcon: boolean
  subtitle?: string
  basePath: string
  auth: AuthStore
  projectId: string
  dataset: string
  /**
   * API hostname used for requests. Used to determine if the workspace
   * points to staging or production environment.
   * @internal
   */
  apiHost?: string
  theme: StudioTheme
  schema: Schema
  i18n: LocaleSource
  /**
   * @internal
   * @deprecated not actually deprecated but don't use or you'll be fired
   */
  __internal: {
    sources: Array<{
      name: string
      projectId: string
      dataset: string
      title: string
      auth: AuthStore
      schema: Schema
      i18n: LocaleSource
      source: Observable<Source>
    }>
  }
}

/**
 * TODO: Rename to `ZOffsetsContext`
 *
 * @internal
 */
export declare const ZIndexContext: Context<ZIndexContextValue>

/**
 * @internal
 */
export declare const zIndexContextDefaults: ZIndexContextValue

/**
 * TODO: Rename to `ZOffsetsContextValue`
 *
 * @internal
 */
declare interface ZIndexContextValue {
  /** Used by: Navbar */
  navbar: number | number[]
  navbarPopover: number | number[]
  navbarDialog: number | number[]
  /** Used by: DefaultPane, DocumentPane */
  pane: number | number[]
  paneHeader: number | number[]
  paneFooter: number | number[]
  paneResizer: number | number[]
  paneDialog: number | number[]
  /** Used by: EditItemFoldOut, Spinner, ConnectorsOverlay, tippy.css, BaseDateTimeInput */
  portal: number | number[]
  /** Used by: Tooltip */
  popover: number | number[]
  /** Used by: `@sanity/google-maps-input` */
  modal: number | number[]
  /** TODO this path does not seem to be correct - fix?  */
  /** Used by: `movingItem` in packages/sanity/src/styles/layout/helpers.css */
  movingItem: number | number[]
  /** Used for shadow behind the navbar search, and behind sidemenu */
  drawershade: number | number[]
  /** Used by: Snackbar */
  drawer: number | number[]
  /** Used for UI that sits on top of the entire application */
  fullscreen: number | number[]
  /** Used for toasts */
  toast: number | number[]
  dropdown: number | number[]
  navbarFixed: number | number[]
  fullscreenEdit: number | number[]
  popoverBackground: number | number[]
  tooltip: number | number[]
  modalBackground: number | number[]
  spinner: number | number[]
}

export {}

declare module '@sanity/types' {
  /**
   * Extended validation context that includes internationalization
   *
   * Why is this not directly part of `@sanity/types`, you ask?
   * Because `@sanity/types` shouldn't need to depend on the `i18next` package, which it needs
   * for the `TFunction` type. The `ValidationContext` should never have been part of the types
   * module in the first place, but is now unfortunately part of the public API and thus cannot
   * be changed easily.
   *
   * This is a temporary solution until we can remove the `ValidationContext` from the types module,
   * which is likely to happen at the next major version.
   *
   * @public
   */
  interface ValidationContext {
    /**
     * Internationalization utilities, for translation of validation messages
     *
     * See {@link LocaleSource} for details.
     */
    i18n: LocaleSource
  }
}

declare module '@sanity/types' {
  /**
   *
   * @hidden
   * @beta
   */
  interface ArrayOfObjectsComponents {
    annotation?: ComponentType<BlockAnnotationProps>
    block?: ComponentType<BlockProps>
    diff?: ComponentType<any>
    field?: ComponentType<ArrayFieldProps>
    inlineBlock?: ComponentType<BlockProps>
    input?: ComponentType<ArrayOfObjectsInputProps>
    item?: ComponentType<ObjectItemProps>
    preview?: ComponentType<PreviewProps>
    portableText?: {
      plugins: ComponentType<PortableTextPluginsProps>
    }
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface ArrayOfPrimitivesComponents {
    diff?: ComponentType<any>
    field?: ComponentType<ArrayOfPrimitivesFieldProps>
    input?: ComponentType<ArrayOfPrimitivesInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface BooleanComponents {
    diff?: ComponentType<any>
    field?: ComponentType<BooleanFieldProps>
    input?: ComponentType<BooleanInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface DateComponents {
    diff?: ComponentType<any>
    field?: ComponentType<StringFieldProps>
    input?: ComponentType<StringInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface DatetimeComponents {
    diff?: ComponentType<any>
    field?: ComponentType<StringFieldProps>
    input?: ComponentType<StringInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface DocumentComponents {
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps>
    input?: ComponentType<ObjectInputProps>
    item?: ComponentType<ObjectItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface FileComponents {
    annotation?: ComponentType<BlockAnnotationProps>
    block?: ComponentType<BlockProps>
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps<FileValue>>
    inlineBlock?: ComponentType<BlockProps>
    input?: ComponentType<ObjectInputProps<FileValue>>
    item?: ComponentType<ObjectItemProps<FileValue & ObjectItem>>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface GeopointComponents {
    annotation?: ComponentType<BlockAnnotationProps>
    block?: ComponentType<BlockProps>
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps<GeopointValue>>
    inlineBlock?: ComponentType<BlockProps>
    input?: ComponentType<ObjectInputProps<GeopointValue>>
    item?: ComponentType<ObjectItemProps<GeopointValue & ObjectItem>>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface ImageComponents {
    annotation?: ComponentType<BlockAnnotationProps>
    block?: ComponentType<BlockProps>
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps<ImageValue>>
    inlineBlock?: ComponentType<BlockProps>
    input?: ComponentType<ObjectInputProps<ImageValue>>
    item?: ComponentType<ObjectItemProps<ImageValue & ObjectItem>>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface NumberComponents {
    diff?: ComponentType<any>
    field?: ComponentType<NumberFieldProps>
    input?: ComponentType<NumberInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface ObjectComponents {
    annotation?: ComponentType<BlockAnnotationProps>
    block?: ComponentType<BlockProps>
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps>
    inlineBlock?: ComponentType<BlockProps>
    input?: ComponentType<ObjectInputProps>
    item?: ComponentType<ObjectItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface ReferenceComponents {
    annotation?: ComponentType<BlockAnnotationProps>
    block?: ComponentType<BlockProps>
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps<ReferenceValue>>
    inlineBlock?: ComponentType<BlockProps>
    input?: ComponentType<ReferenceInputProps>
    item?: ComponentType<ObjectItemProps<ReferenceValue & ObjectItem>>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface CrossDatasetReferenceComponents {
    annotation?: ComponentType<BlockAnnotationProps>
    block?: ComponentType<BlockProps>
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps<CrossDatasetReferenceValue>>
    inlineBlock?: ComponentType<BlockProps>
    input?: ComponentType<CrossDatasetReferenceInputProps>
    item?: ComponentType<ObjectItemProps<CrossDatasetReferenceValue & ObjectItem>>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface SlugComponents {
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps<SlugValue>>
    input?: ComponentType<ObjectInputProps<SlugValue>>
    item?: ComponentType<ObjectItemProps<SlugValue & ObjectItem>>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface SpanComponents {
    diff?: ComponentType<any>
    field?: ComponentType<ObjectFieldProps>
    input?: ComponentType<ObjectInputProps>
    item?: ComponentType<ObjectItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface StringComponents {
    diff?: ComponentType<any>
    field?: ComponentType<StringFieldProps>
    input?: ComponentType<StringInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface TextComponents {
    diff?: ComponentType<any>
    field?: ComponentType<StringFieldProps>
    input?: ComponentType<StringInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface UrlComponents {
    diff?: ComponentType<any>
    field?: ComponentType<StringFieldProps>
    input?: ComponentType<StringInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  /**
   *
   * @hidden
   * @beta
   */
  interface EmailComponents {
    diff?: ComponentType<any>
    field?: ComponentType<StringFieldProps>
    input?: ComponentType<StringInputProps>
    item?: ComponentType<PrimitiveItemProps>
    preview?: ComponentType<PreviewProps>
  }
  interface ArrayDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ArrayOfObjectsComponents | ArrayOfPrimitivesComponents
  }
  interface BlockDefinition {
    /**
     * Components for the block schema type
     *
     * @public
     * @remarks - This only applies to the block text type, and not block object types (like images).
     * - Don't render arbitrary text nodes inside regular text blocks, as this will confuse the editor with
     * what is editable text and not. Make sure to wrap all nodes which are NOT part of the edited text inside a
     * container with `contentEditable={false}` and with `style={{userSelection: 'none'}}` so that
     * the editor can distinguish between editable text and non-editable text.
     * @example Example of custom block component with delete button next to it that removes the block.
     * ```ts
     * {
     *   block: (blockProps) => {
     *     return (
     *       <Flex>
     *         <Box flex={1}>{blockProps.renderDefault(blockProps)}</Box>
     *         <Box contentEditable={false} style={{userSelect: 'none'}}>
     *           <Button
     *             icon={TrashIcon}
     *             onClick={(event) => {
     *               event.preventDefault()
     *               blockProps.onRemove()
     *              }}
     *             />
     *         </Box>
     *       </Flex>
     *     )
     *   },
     * },
     * ```
     */
    components?: {
      block?: ComponentType<BlockProps>
    }
  }
  interface BlockDecoratorDefinition {
    /**
     * Component for rendering a decorator.
     *
     * See also {@link BlockDecoratorProps | BlockDecoratorProps}
     *
     * @public
     * @remarks - Try not to hard code CSS properties that could be derived from `@sanity/ui`.
     * This will make sure your rendering looks good independent of the theme context it appears in.
     * - Don't render arbitrary text nodes as this will confuse the editor with
     * what is editable text and not. If you need arbitrary text, make sure to wrap them in in a
     * container with `contentEditable={false}`.
     * @example Example of rendering custom decorator that highlights text.
     * ```ts
     * const Highlight = (props: BlockDecoratorProps) => (
     *   <span style={{backgroundColor: '#ff0'}}>
     *     {props.children}
     *   </span>
     * )
     * ```
     */
    component?: ComponentType<BlockDecoratorProps>
  }
  interface BlockStyleDefinition {
    /**
     * Component for rendering a text style.
     *
     * See also {@link BlockStyleProps | BlockStyleProps}
     *
     * @public
     * @remarks - Try not to hard code CSS properties that could be derived from `@sanity/ui`.
     * This will make sure your rendering looks good independent of the theme context it appears in.
     * - Don't render arbitrary text nodes as this will confuse the editor with
     * what is editable text and not. If you need arbitrary text, make sure to wrap them in in a
     * container with `contentEditable={false}`.
     * @example Example of rendering a custom style for article leads which is bigger,
     * and bolder, but will adapt to what the current `@sanity/ui` theme has defined
     * as actual values for weight "bold" and `size={3}`.
     * ```ts
     * import {Text} from '@sanity/ui'
     *
     * const LeadStyle = (props: BlockStyleProps) => (
     *   <Text weight="bold" size={3}>
     *     {props.children}
     *   </Text>
     * )
     * ```
     */
    component?: ComponentType<BlockStyleProps>
  }
  interface BlockListDefinition {
    /**
     * Component for rendering a block as a list item
     *
     * See also {@link BlockListItemProps | BlockListItemProps}
     *
     * @public
     * @remarks - Try not to hard code CSS properties that could be derived from `@sanity/ui`.
     * This will make sure your rendering looks good independent of the theme context it appears in.
     * - Don't render arbitrary text nodes as this will confuse the editor with
     * what is editable text and not. If you need arbitrary text, make sure to wrap them in in a
     * container with `contentEditable={false}`.
     */
    component?: ComponentType<BlockListItemProps>
  }
  interface BlockAnnotationDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: {
      annotation?: ComponentType<BlockAnnotationProps>
    }
  }
  interface BooleanDefinition {
    components?: BooleanComponents
  }
  interface DateDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: DateComponents
  }
  interface DatetimeDefinition {
    components?: DatetimeComponents
  }
  interface DocumentDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: DocumentComponents
  }
  interface FileDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: FileComponents
  }
  interface GeopointDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: GeopointComponents
  }
  interface ImageDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ImageComponents
  }
  interface NumberDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: NumberComponents
  }
  interface ObjectDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ObjectComponents
  }
  interface ReferenceDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: ReferenceComponents
  }
  interface CrossDatasetReferenceDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: CrossDatasetReferenceComponents
  }
  interface SlugDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: SlugComponents
  }
  interface SpanDefinition {
    components?: SpanComponents
  }
  interface StringDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: StringComponents
  }
  interface TextDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: TextComponents
  }
  interface UrlDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: UrlComponents
  }
  interface EmailDefinition {
    /**
     *
     * @hidden
     * @beta
     */
    components?: EmailComponents
  }
}
