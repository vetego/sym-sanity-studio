{"version":3,"file":"index.js","sources":["../src/key-generator.ts","../src/from-portable-text/build-list-index-map.ts","../src/from-portable-text/render-node.ts","../src/from-portable-text/renderers/block-spacing.ts","../src/from-portable-text/renderers/hard-break.ts","../src/from-portable-text/renderers/list-item.ts","../src/escape.ts","../src/from-portable-text/renderers/marks.ts","../src/from-portable-text/renderers/style.ts","../src/from-portable-text/renderers/type.ts","../src/from-portable-text/portable-text-to-markdown.ts","../src/default-schema.ts","../src/to-portable-text/matchers.ts","../src/to-portable-text/markdown-to-portable-text.ts"],"sourcesContent":["export function defaultKeyGenerator() {\n  return randomKey(12)\n}\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  crypto.getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import {\n  compileSchema,\n  defineSchema,\n  isTextBlock,\n  type PortableTextBlock,\n} from '@portabletext/schema'\nimport type {ArbitraryTypedObject, TypedObject} from '@portabletext/types'\nimport {defaultKeyGenerator} from '../key-generator'\n\nconst schema = compileSchema(defineSchema({}))\n\n/**\n * Builds a map of list item `_key`s to their index.\n *\n * Mutates the blocks in place by adding a `_key` if necessary.\n */\nexport function buildListIndexMap<\n  Block extends TypedObject = PortableTextBlock | ArbitraryTypedObject,\n>(blocks: Array<Block>): Map<string, number> {\n  const levelIndexMaps = new Map<string, Map<number, number>>()\n  const listIndexMap = new Map<string, number>()\n\n  let previousListItem:\n    | {\n        listItem: string\n        level: number\n      }\n    | undefined\n\n  for (let blockIndex = 0; blockIndex < blocks.length; blockIndex++) {\n    const block = blocks.at(blockIndex)\n\n    if (block === undefined) {\n      continue\n    }\n\n    if (!block._key) {\n      block._key = defaultKeyGenerator()\n    }\n\n    // Clear the state if we encounter a non-text block\n    if (!isTextBlock({schema}, block)) {\n      levelIndexMaps.clear()\n      previousListItem = undefined\n\n      continue\n    }\n\n    // Clear the state if we encounter a non-list text block\n    if (block.listItem === undefined || block.level === undefined) {\n      levelIndexMaps.clear()\n      previousListItem = undefined\n\n      continue\n    }\n\n    // If we encounter a new list item, we set the initial index to 1 for the\n    // list type on that level.\n    if (!previousListItem) {\n      const listIndex = 1\n      const levelIndexMap =\n        levelIndexMaps.get(block.listItem) ?? new Map<number, number>()\n      levelIndexMap.set(block.level, listIndex)\n      levelIndexMaps.set(block.listItem, levelIndexMap)\n\n      listIndexMap.set(block._key, listIndex)\n\n      previousListItem = {\n        listItem: block.listItem,\n        level: block.level,\n      }\n\n      continue\n    }\n\n    // If the previous list item is of the same type but on a lower level, we\n    // need to reset the level index map for that type.\n    if (\n      previousListItem.listItem === block.listItem &&\n      previousListItem.level < block.level\n    ) {\n      const listIndex = 1\n      const levelIndexMap =\n        levelIndexMaps.get(block.listItem) ?? new Map<number, number>()\n      levelIndexMap.set(block.level, listIndex)\n      levelIndexMaps.set(block.listItem, levelIndexMap)\n\n      listIndexMap.set(block._key, listIndex)\n\n      previousListItem = {\n        listItem: block.listItem,\n        level: block.level,\n      }\n\n      continue\n    }\n\n    // Reset other list types at current level and deeper\n    levelIndexMaps.forEach((levelIndexMap, listItem) => {\n      if (listItem === block.listItem) {\n        return\n      }\n\n      // Reset all levels that are >= current level\n      const levelsToDelete: number[] = []\n\n      levelIndexMap.forEach((_, level) => {\n        if (level >= block.level!) {\n          levelsToDelete.push(level)\n        }\n      })\n\n      levelsToDelete.forEach((level) => {\n        levelIndexMap.delete(level)\n      })\n    })\n\n    const levelIndexMap =\n      levelIndexMaps.get(block.listItem) ?? new Map<number, number>()\n    const levelCounter = levelIndexMap.get(block.level) ?? 0\n    levelIndexMap.set(block.level, levelCounter + 1)\n    levelIndexMaps.set(block.listItem, levelIndexMap)\n\n    listIndexMap.set(block._key, levelCounter + 1)\n\n    previousListItem = {\n      listItem: block.listItem,\n      level: block.level,\n    }\n  }\n\n  return listIndexMap\n}\n","import {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  spanToPlainText,\n  type ToolkitNestedPortableTextSpan,\n  type ToolkitTextNode,\n} from '@portabletext/toolkit'\nimport type {\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\nimport {defaultKeyGenerator} from '../key-generator'\nimport type {PortableTextRenderers, RenderNode, Serializable} from './types'\n\ninterface SerializedBlock {\n  _key: string\n  children: string\n  index: number\n  isInline: boolean\n  node: PortableTextBlock | PortableTextListItemBlock\n}\n\nexport const createRenderNode = (\n  renderers: PortableTextRenderers,\n  listIndexMap: Map<string, number>,\n): RenderNode => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): string {\n    const {node, index, isInline} = options\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node)\n    }\n\n    return renderCustomBlock(node, index, isInline)\n  }\n\n  function renderListItem(\n    node: PortableTextListItemBlock<\n      PortableTextMarkDefinition,\n      PortableTextSpan\n    >,\n    index: number,\n  ): string {\n    const renderer = renderers.listItem\n    const handler =\n      typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const itemHandler = handler || renderers.unknownListItem\n\n    // Build the text content from the block\n    const tree = buildMarksTree(node)\n    const textContent = tree\n      .map((child, i) => {\n        return renderNode({node: child, isInline: true, index: i, renderNode})\n      })\n      .join('')\n\n    let children = textContent\n\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block component says to use\n      const {listItem: _listItem, ...blockNode} = node\n      children = renderNode({\n        node: blockNode,\n        index,\n        isInline: false,\n        renderNode,\n      })\n      // Strip trailing newlines from block styles - list item component handles spacing\n      children = children.replace(/\\n+$/, '')\n    }\n\n    return itemHandler({\n      value: node,\n      index,\n      listIndex: node._key ? listIndexMap.get(node._key) : undefined,\n      isInline: false,\n      renderNode,\n      children,\n    })\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan): string {\n    const {markDef, markType, markKey} = node\n    const span = renderers.marks[markType] || renderers.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode}),\n    )\n\n    return span({\n      text: spanToPlainText(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(''),\n    })\n  }\n\n  function renderBlock(\n    node: PortableTextBlock,\n    index: number,\n    isInline: boolean,\n  ): string {\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof renderers.block === 'function'\n        ? renderers.block\n        : renderers.block[style]\n    const block = handler || renderers.unknownBlockStyle\n\n    return block({...props, value: props.node, renderNode})\n  }\n\n  function renderText(node: ToolkitTextNode): string {\n    if (node.text === '\\n') {\n      return renderers.hardBreak()\n    }\n\n    return node.text\n  }\n\n  function renderCustomBlock(\n    value: TypedObject,\n    index: number,\n    isInline: boolean,\n  ): string {\n    const component = renderers.types[value._type] ?? renderers.unknownType\n\n    return component({\n      value,\n      isInline,\n      index,\n      renderNode,\n    })\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(\n  options: Serializable<PortableTextBlock>,\n): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n\n  const renderedChildren = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || defaultKeyGenerator(),\n    children: renderedChildren.join(''),\n    index,\n    isInline,\n    node,\n  }\n}\n","import {\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n} from '@portabletext/toolkit'\nimport type {TypedObject} from '@portabletext/types'\n\n/**\n * @public\n */\nexport type BlockSpacingRenderer = (options: {\n  current: TypedObject\n  next: TypedObject\n}) => string | undefined\n\n/**\n * @public\n */\nexport const DefaultBlockSpacingRenderer: BlockSpacingRenderer = ({\n  current,\n  next,\n}) => {\n  if (\n    isPortableTextListItemBlock(current) &&\n    isPortableTextListItemBlock(next)\n  ) {\n    return '\\n'\n  }\n\n  if (\n    isPortableTextBlock(current) &&\n    isPortableTextBlock(next) &&\n    current.style === 'blockquote' &&\n    next.style === 'blockquote'\n  ) {\n    return '\\n>\\n'\n  }\n\n  return '\\n\\n'\n}\n","/**\n * @public\n */\nexport const DefaultHardBreakRenderer = (): string => '  \\n'\n","import type {PortableTextListItemRenderer} from '../types'\n\n/**\n * @public\n */\nexport const DefaultListItemRenderer: PortableTextListItemRenderer = ({\n  children,\n  value,\n  listIndex,\n}) => {\n  const listStyle = value.listItem || 'bullet'\n  const level = value.level || 1\n\n  if (listStyle === 'number') {\n    const indent = '   '.repeat(level - 1)\n\n    return `${indent}${listIndex ?? 1}. ${children}`\n  }\n\n  const indent = '   '.repeat(level - 1)\n\n  return `${indent}- ${children}`\n}\n\n/**\n * @public\n */\nexport const DefaultUnknownListItemRenderer: PortableTextListItemRenderer = ({\n  children,\n}) => {\n  return `- ${children}\\n`\n}\n","/**\n * Escapes special characters in image alt texts and link texts.\n */\nexport function escapeImageAndLinkText(text: string): string {\n  return text.replace(/([[\\]\\\\])/g, '\\\\$1')\n}\n\n/**\n * Unescapes special characters in image alt texts and link texts.\n */\nexport function unescapeImageAndLinkText(text: string): string {\n  return text.replace(/\\\\([!\"#$%&'()*+,\\-./:;<=>?@[\\\\\\]^_`{|}~])/g, '$1')\n}\n\n/**\n * Escapes special characters in image/link titles (the part inside quotes).\n */\nexport function escapeImageAndLinkTitle(text: string): string {\n  return text.replace(/([\\\\\"])/g, '\\\\$1')\n}\n","import type {TypedObject} from '@portabletext/types'\nimport {escapeImageAndLinkText, escapeImageAndLinkTitle} from '../../escape'\nimport type {PortableTextMarkRenderer} from '../types'\n\n/**\n * @public\n */\nexport const DefaultEmRenderer: PortableTextMarkRenderer = ({children}) =>\n  `_${children}_`\n\n/**\n * @public\n */\nexport const DefaultStrongRenderer: PortableTextMarkRenderer = ({children}) =>\n  `**${children}**`\n\n/**\n * @public\n */\nexport const DefaultCodeRenderer: PortableTextMarkRenderer = ({children}) =>\n  `\\`${children}\\``\n\n/**\n * @public\n */\nexport const DefaultUnderlineRenderer: PortableTextMarkRenderer = ({\n  children,\n}) => `<u>${children}</u>`\n\n/**\n * @public\n */\nexport const DefaultStrikeThroughRenderer: PortableTextMarkRenderer = ({\n  children,\n}) => `~~${children}~~`\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n  title: string | undefined\n}\n\n/**\n * @public\n */\nexport const DefaultLinkRenderer: PortableTextMarkRenderer<DefaultLink> = ({\n  children,\n  value,\n}) => {\n  const href = value?.href || ''\n  const title = value?.title || ''\n  const looksSafe = uriLooksSafe(href)\n\n  if (looksSafe) {\n    // Check if the URL looks like an HTML injection attempt\n    // If it has quotes AND angle brackets, or other suspicious patterns, encode more aggressively\n    const looksLikeInjection = /[\"'][^\"']*[<>]|[<>][^<>]*[\"']/.test(href)\n\n    if (looksLikeInjection) {\n      // Encode all special characters that could be used for injection\n      const encodedHref = href.replace(/[\"<>() ]/g, (char) => {\n        return `%${char.charCodeAt(0).toString(16).toUpperCase()}`\n      })\n      return `[${escapeImageAndLinkText(children)}](${encodedHref})`\n    }\n\n    // For normal URLs, don't encode parentheses - Markdown handles balanced parens fine\n    return `[${escapeImageAndLinkText(children)}](${href}${title ? ` \"${escapeImageAndLinkTitle(title)}\"` : ''})`\n  }\n\n  // Return children without link when URL is unsafe\n  return children\n}\n\nfunction uriLooksSafe(uri: string): boolean {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  if (first === '#' || first === '/') {\n    return true\n  }\n\n  const colonIndex = url.indexOf(':')\n  if (colonIndex === -1) {\n    return true\n  }\n\n  const allowedProtocols = ['http', 'https', 'mailto', 'tel']\n  const proto = url.slice(0, colonIndex).toLowerCase()\n  if (allowedProtocols.indexOf(proto) !== -1) {\n    return true\n  }\n\n  const queryIndex = url.indexOf('?')\n  if (queryIndex !== -1 && colonIndex > queryIndex) {\n    return true\n  }\n\n  const hashIndex = url.indexOf('#')\n  if (hashIndex !== -1 && colonIndex > hashIndex) {\n    return true\n  }\n\n  return false\n}\n\n/**\n * @public\n */\nexport const DefaultUnknownMarkRenderer: PortableTextMarkRenderer = ({\n  children,\n}) => {\n  return children\n}\n","import type {PortableTextBlock} from '@portabletext/types'\nimport type {PortableTextRenderer} from '../types'\n\ntype PortableTextBlockRenderer = PortableTextRenderer<PortableTextBlock>\n\n/**\n * @public\n */\nexport const DefaultNormalRenderer: PortableTextBlockRenderer = ({\n  children,\n}) => {\n  // Empty blocks should not add extra spacing\n  if (!children || children.trim() === '') {\n    return ''\n  }\n\n  return children\n}\n\n/**\n * @public\n */\nexport const DefaultBlockquoteRenderer: PortableTextBlockRenderer = ({\n  children,\n}) => {\n  // Prefix each line with \"> \" for proper blockquote formatting\n  // This handles multi-line content and preserves empty lines\n  if (!children) {\n    return '>'\n  }\n\n  return children\n    .split('\\n')\n    .map((line) => `> ${line}`)\n    .join('\\n')\n}\n\n/**\n * @public\n */\nexport const DefaultH1Renderer: PortableTextBlockRenderer = ({children}) =>\n  `# ${children}`\n\n/**\n * @public\n */\nexport const DefaultH2Renderer: PortableTextBlockRenderer = ({children}) =>\n  `## ${children}`\n\n/**\n * @public\n */\nexport const DefaultH3Renderer: PortableTextBlockRenderer = ({children}) =>\n  `### ${children}`\n\n/**\n * @public\n */\nexport const DefaultH4Renderer: PortableTextBlockRenderer = ({children}) =>\n  `#### ${children}`\n\n/**\n * @public\n */\nexport const DefaultH5Renderer: PortableTextBlockRenderer = ({children}) =>\n  `##### ${children}`\n\n/**\n * @public\n */\nexport const DefaultH6Renderer: PortableTextBlockRenderer = ({children}) =>\n  `###### ${children}`\n\n/**\n * @public\n */\nexport const DefaultUnknownStyleRenderer: PortableTextBlockRenderer = ({\n  children,\n}) => {\n  return children ?? ''\n}\n","import type {PortableTextBlock} from '@portabletext/types'\nimport {escapeImageAndLinkText, escapeImageAndLinkTitle} from '../../escape'\nimport type {PortableTextTypeRenderer} from '../types'\n\n/**\n * @public\n */\nexport const DefaultCodeBlockRenderer: PortableTextTypeRenderer<{\n  _type: 'code'\n  code: string\n  language: string | undefined\n}> = ({value}) => {\n  return `\\`\\`\\`${value.language ?? ''}\\n${value.code}\\n\\`\\`\\``\n}\n\n/**\n * @public\n */\nexport const DefaultHorizontalRuleRenderer: PortableTextTypeRenderer = () => {\n  return '---'\n}\n\n/**\n * @public\n */\nexport const DefaultHtmlRenderer: PortableTextTypeRenderer<{\n  _type: 'html'\n  html: string\n}> = ({value}) => {\n  return value.html\n}\n\n/**\n * @public\n */\nexport const DefaultImageRenderer: PortableTextTypeRenderer<{\n  _type: 'image'\n  src: string\n  alt: string | undefined\n  title: string | undefined\n}> = ({value}) => {\n  const alt = escapeImageAndLinkText(value.alt ?? '')\n  const title = value.title ? ` \"${escapeImageAndLinkTitle(value.title)}\"` : ''\n  return `![${alt}](${value.src}${title})`\n}\n\n/**\n * @public\n */\nexport const DefaultTableRenderer: PortableTextTypeRenderer<{\n  _type: 'table'\n  headerRows: number | undefined\n  rows: Array<{\n    _key: string\n    cells: Array<{\n      _key: string\n      value: Array<PortableTextBlock>\n    }>\n  }>\n}> = ({value, renderNode}) => {\n  const headerRows = value.headerRows || 0\n  const rows = value.rows as Array<{\n    _key: string\n    _type: 'row'\n    cells: Array<{\n      _type: 'cell'\n      _key: string\n      value: Array<{_type: string; children?: Array<unknown>}>\n    }>\n  }>\n  const lines: string[] = []\n\n  // Helper to extract text from cell blocks\n  const getCellText = (\n    cellBlocks: Array<{_type: string; children?: Array<unknown>}>,\n  ): string => {\n    return cellBlocks\n      .map((block, index) =>\n        renderNode({\n          node: block as {_type: string},\n          index,\n          isInline: false,\n          renderNode,\n        }),\n      )\n      .join(' ')\n      .trim()\n  }\n\n  // Add header rows\n  for (let i = 0; i < headerRows; i++) {\n    const row = rows[i]\n    if (row) {\n      const cellTexts = row.cells.map((cell) => getCellText(cell.value))\n      lines.push(`| ${cellTexts.join(' | ')} |`)\n    }\n  }\n\n  // Add separator line if there are headers\n  if (headerRows > 0 && rows[0]) {\n    const separators = rows[0].cells.map(() => ' --- ')\n    lines.push(`|${separators.join('|')}|`)\n  }\n\n  // Add body rows\n  for (let i = headerRows; i < rows.length; i++) {\n    const row = rows[i]\n    if (row) {\n      const cellTexts = row.cells.map((cell) => getCellText(cell.value))\n      lines.push(`| ${cellTexts.join(' | ')} |`)\n    }\n  }\n\n  return lines.join('\\n')\n}\n\n/**\n * @public\n */\nexport const DefaultUnknownTypeRenderer: PortableTextTypeRenderer = ({\n  value,\n  isInline,\n}) => {\n  const json = `\\`\\`\\`json\\n${JSON.stringify(value, null, 2)}\\n\\`\\`\\``\n  // For inline unknown types, add newlines to break them out of the text flow\n  return isInline ? `\\n${json}\\n` : json\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  TypedObject,\n} from '@portabletext/types'\nimport {buildListIndexMap} from './build-list-index-map'\nimport {createRenderNode} from './render-node'\nimport {\n  DefaultBlockSpacingRenderer,\n  type BlockSpacingRenderer,\n} from './renderers/block-spacing'\nimport {DefaultHardBreakRenderer} from './renderers/hard-break'\nimport {\n  DefaultListItemRenderer,\n  DefaultUnknownListItemRenderer,\n} from './renderers/list-item'\nimport {\n  DefaultCodeRenderer,\n  DefaultEmRenderer,\n  DefaultLinkRenderer,\n  DefaultStrikeThroughRenderer,\n  DefaultStrongRenderer,\n  DefaultUnderlineRenderer,\n  DefaultUnknownMarkRenderer,\n} from './renderers/marks'\nimport {\n  DefaultBlockquoteRenderer,\n  DefaultH1Renderer,\n  DefaultH2Renderer,\n  DefaultH3Renderer,\n  DefaultH4Renderer,\n  DefaultH5Renderer,\n  DefaultH6Renderer,\n  DefaultNormalRenderer,\n  DefaultUnknownStyleRenderer,\n} from './renderers/style'\nimport {DefaultUnknownTypeRenderer} from './renderers/type'\nimport type {PortableTextRenderers} from './types'\n\nconst defaultRenderers: PortableTextRenderers = {\n  types: {},\n\n  block: {\n    normal: DefaultNormalRenderer,\n    blockquote: DefaultBlockquoteRenderer,\n    h1: DefaultH1Renderer,\n    h2: DefaultH2Renderer,\n    h3: DefaultH3Renderer,\n    h4: DefaultH4Renderer,\n    h5: DefaultH5Renderer,\n    h6: DefaultH6Renderer,\n  },\n  marks: {\n    'em': DefaultEmRenderer,\n    'strong': DefaultStrongRenderer,\n    'code': DefaultCodeRenderer,\n    'underline': DefaultUnderlineRenderer,\n    'strike-through': DefaultStrikeThroughRenderer,\n    'link': DefaultLinkRenderer,\n  },\n  listItem: DefaultListItemRenderer,\n  hardBreak: DefaultHardBreakRenderer,\n\n  unknownType: DefaultUnknownTypeRenderer,\n  unknownMark: DefaultUnknownMarkRenderer,\n  unknownListItem: DefaultUnknownListItemRenderer,\n  unknownBlockStyle: DefaultUnknownStyleRenderer,\n}\n\ntype Options = Partial<PortableTextRenderers> & {\n  blockSpacing?: BlockSpacingRenderer\n}\n\n/**\n * @public\n */\nexport function portableTextToMarkdown<\n  Block extends TypedObject = PortableTextBlock | ArbitraryTypedObject,\n>(blocks: Array<Block>, options: Options = {}): string {\n  const renderers = {\n    block: {\n      ...defaultRenderers.block,\n      ...options.block,\n    },\n    listItem: options.listItem ?? defaultRenderers.listItem,\n    marks: {\n      ...defaultRenderers.marks,\n      ...options.marks,\n    },\n    types: {\n      ...defaultRenderers.types,\n      ...options.types,\n    },\n    hardBreak: options.hardBreak ?? defaultRenderers.hardBreak,\n    unknownType: options.unknownType ?? defaultRenderers.unknownType,\n    unknownBlockStyle:\n      options.unknownBlockStyle ?? defaultRenderers.unknownBlockStyle,\n    unknownListItem:\n      options.unknownListItem ?? defaultRenderers.unknownListItem,\n    unknownMark: options.unknownMark ?? defaultRenderers.unknownMark,\n  }\n  const renderBlockSpacing = options.blockSpacing ?? DefaultBlockSpacingRenderer\n\n  const listIndexMap = buildListIndexMap(blocks)\n  const renderNode = createRenderNode(renderers, listIndexMap)\n\n  return blocks\n    .map((node, index) => {\n      const renderedNode = renderNode({\n        node,\n        index,\n        isInline: false,\n        renderNode,\n      })\n\n      if (index === blocks.length - 1) {\n        return renderedNode\n      }\n\n      const nextNode = blocks.at(index + 1)\n\n      if (!nextNode) {\n        return renderedNode\n      }\n\n      const blockSpacing =\n        renderBlockSpacing({\n          current: node,\n          next: nextNode,\n        }) ?? '\\n\\n'\n\n      return `${renderedNode}${blockSpacing}`\n    })\n    .join('')\n}\n","import {\n  compileSchema,\n  defineSchema,\n  type AnnotationDefinition,\n  type BlockObjectDefinition,\n  type DecoratorDefinition,\n  type ListDefinition,\n  type StyleDefinition,\n} from '@portabletext/schema'\n\n/********************\n * Default style definitions\n ********************/\n\nexport const normalStyleDefinition = {\n  name: 'normal',\n} as const satisfies StyleDefinition\n\nexport const h1StyleDefinition = {\n  name: 'h1',\n} as const satisfies StyleDefinition\n\nexport const h2StyleDefinition = {\n  name: 'h2',\n} as const satisfies StyleDefinition\n\nexport const h3StyleDefinition = {\n  name: 'h3',\n} as const satisfies StyleDefinition\n\nexport const h4StyleDefinition = {\n  name: 'h4',\n} as const satisfies StyleDefinition\n\nexport const h5StyleDefinition = {\n  name: 'h5',\n} as const satisfies StyleDefinition\n\nexport const h6StyleDefinition = {\n  name: 'h6',\n} as const satisfies StyleDefinition\n\nexport const blockquoteStyleDefinition = {\n  name: 'blockquote',\n} as const satisfies StyleDefinition\n\n/********************\n * Default list definitions\n ********************/\n\nexport const defaultOrderedListItemDefinition = {\n  name: 'number',\n} as const satisfies ListDefinition\n\nexport const defaultUnorderedListItemDefinition = {\n  name: 'bullet',\n} as const satisfies ListDefinition\n\n/********************\n * Default decorator definitions\n ********************/\n\nexport const defaultStrongDecoratorDefinition = {\n  name: 'strong',\n} as const satisfies DecoratorDefinition\n\nexport const defaultEmDecoratorDefinition = {\n  name: 'em',\n} as const satisfies DecoratorDefinition\n\nexport const defaultCodeDecoratorDefinition = {\n  name: 'code',\n} as const satisfies DecoratorDefinition\n\nexport const defaultStrikeThroughDecoratorDefinition = {\n  name: 'strike-through',\n} as const satisfies DecoratorDefinition\n\n/********************\n * Default annotation definitions\n ********************/\n\nexport const defaultLinkObjectDefinition = {\n  name: 'link',\n  fields: [\n    {name: 'href', type: 'string'},\n    {name: 'title', type: 'string'},\n  ],\n} as const satisfies AnnotationDefinition\n\n/********************\n * Default object definitions\n ********************/\n\nexport const defaultCodeObjectDefinition = {\n  name: 'code',\n  fields: [\n    {name: 'language', type: 'string'},\n    {name: 'code', type: 'string'},\n  ],\n} as const satisfies BlockObjectDefinition\n\nexport const defaultImageObjectDefinition = {\n  name: 'image',\n  fields: [\n    {name: 'src', type: 'string'},\n    {name: 'alt', type: 'string'},\n    {name: 'title', type: 'string'},\n  ],\n} as const satisfies BlockObjectDefinition\n\nexport const defaultHorizontalRuleObjectDefinition = {\n  name: 'horizontal-rule',\n} as const satisfies BlockObjectDefinition\n\nexport const defaultHtmlObjectDefinition = {\n  name: 'html',\n  fields: [{name: 'html', type: 'string'}],\n} as const satisfies BlockObjectDefinition\n\nexport const defaultTableObjectDefinition = {\n  name: 'table',\n  fields: [\n    {name: 'headerRows', type: 'number'},\n    {name: 'rows', type: 'array'},\n  ],\n} as const satisfies BlockObjectDefinition\n\n/**\n * The default schema for converting markdown to Portable Text.\n *\n * @public\n */\nexport const defaultSchema = compileSchema(\n  defineSchema({\n    styles: [\n      normalStyleDefinition,\n      h1StyleDefinition,\n      h2StyleDefinition,\n      h3StyleDefinition,\n      h4StyleDefinition,\n      h5StyleDefinition,\n      h6StyleDefinition,\n      blockquoteStyleDefinition,\n    ],\n    lists: [\n      defaultOrderedListItemDefinition,\n      defaultUnorderedListItemDefinition,\n    ],\n    decorators: [\n      defaultStrongDecoratorDefinition,\n      defaultEmDecoratorDefinition,\n      defaultCodeDecoratorDefinition,\n      defaultStrikeThroughDecoratorDefinition,\n    ],\n    annotations: [defaultLinkObjectDefinition],\n    blockObjects: [\n      defaultCodeObjectDefinition,\n      defaultHorizontalRuleObjectDefinition,\n      defaultImageObjectDefinition,\n      defaultHtmlObjectDefinition,\n      defaultTableObjectDefinition,\n    ],\n    inlineObjects: [defaultImageObjectDefinition],\n  }),\n)\n","import type {\n  PortableTextObject,\n  Schema,\n  SchemaDefinition,\n} from '@portabletext/schema'\n\n/**\n * Matcher function for mapping markdown elements to Portable Text block styles.\n *\n * @public\n */\nexport type StyleMatcher = ({\n  context,\n}: {\n  context: {schema: Schema}\n}) => string | undefined\n\nexport function buildStyleMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): StyleMatcher {\n  return ({context}) => {\n    const schemaDefinition = context.schema.styles.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    return schemaDefinition.name\n  }\n}\n\n/**\n * Matcher function for mapping markdown list items to Portable Text list types.\n *\n * @public\n */\nexport type ListItemMatcher = ({\n  context,\n}: {\n  context: {schema: Schema}\n}) => string | undefined\n\nexport function buildListItemMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): ListItemMatcher {\n  return ({context}) => {\n    const schemaDefinition = context.schema.lists.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    return schemaDefinition.name\n  }\n}\n\n/**\n * Matcher function for mapping markdown inline formatting to Portable Text decorators.\n *\n * @public\n */\nexport type DecoratorMatcher = ({\n  context,\n}: {\n  context: {schema: Schema}\n}) => string | undefined\n\nexport function buildDecoratorMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): DecoratorMatcher {\n  return ({context}) => {\n    const schemaDefinition = context.schema.decorators.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    return schemaDefinition.name\n  }\n}\n\n/**\n * Matcher function for mapping markdown links to Portable Text annotations.\n *\n * @public\n */\nexport type AnnotationMatcher<\n  TValue extends Record<string, unknown> = Record<string, never>,\n> = ({\n  context,\n  value,\n}: {\n  context: {schema: Schema; keyGenerator: () => string}\n  value: TValue\n}) => PortableTextObject | undefined\n\nexport function buildAnnotationMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): AnnotationMatcher<ExtractValue<TDefinition>> {\n  return ({context, value}) => {\n    const schemaDefinition = context.schema.annotations.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    const filteredValue = schemaDefinition.fields.reduce<\n      Record<string, unknown>\n    >((filteredValue, field) => {\n      const fieldValue = value[field.name as keyof typeof value]\n\n      if (fieldValue !== undefined) {\n        filteredValue[field.name] = fieldValue\n      }\n\n      return filteredValue\n    }, {})\n\n    return {\n      _key: context.keyGenerator(),\n      _type: schemaDefinition.name,\n      ...filteredValue,\n    }\n  }\n}\n\n/**\n * Matcher function for mapping markdown objects to Portable Text block or inline objects.\n *\n * @public\n */\nexport type ObjectMatcher<\n  TValue extends Record<string, unknown> = Record<string, never>,\n> = ({\n  context,\n  value,\n  isInline,\n}: {\n  context: {schema: Schema; keyGenerator: () => string}\n  value: TValue\n  isInline: boolean\n}) => PortableTextObject | undefined\n\nexport function buildObjectMatcher<TDefinition extends {name: string}>(\n  definition: TDefinition,\n): ObjectMatcher<ExtractValue<TDefinition>> {\n  return ({context, value, isInline}) => {\n    const schemaCollection = isInline\n      ? context.schema.inlineObjects\n      : context.schema.blockObjects\n\n    const schemaDefinition = schemaCollection.find(\n      (item) => item.name === definition.name,\n    )\n\n    if (!schemaDefinition) {\n      return undefined\n    }\n\n    const filteredValue = schemaDefinition.fields.reduce<\n      Record<string, unknown>\n    >((filteredValue, field) => {\n      const fieldValue = value[field.name as keyof typeof value]\n\n      if (fieldValue !== undefined) {\n        filteredValue[field.name] = fieldValue\n      }\n\n      return filteredValue\n    }, {})\n\n    return {\n      _key: context.keyGenerator(),\n      _type: schemaDefinition.name,\n      ...filteredValue,\n    }\n  }\n}\n\nexport type ExtractValue<\n  TDefinition extends NonNullable<SchemaDefinition['blockObjects']>[0],\n> = TDefinition extends {fields: ReadonlyArray<{name: infer TNames}>}\n  ? Record<TNames & string, unknown>\n  : Record<string, never>\n","import {\n  isSpan,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextTextBlock,\n  type Schema,\n} from '@portabletext/schema'\nimport markdownit from 'markdown-it'\nimport {\n  blockquoteStyleDefinition,\n  defaultCodeDecoratorDefinition,\n  defaultCodeObjectDefinition,\n  defaultEmDecoratorDefinition,\n  defaultHorizontalRuleObjectDefinition,\n  defaultHtmlObjectDefinition,\n  defaultImageObjectDefinition,\n  defaultLinkObjectDefinition,\n  defaultOrderedListItemDefinition,\n  defaultSchema,\n  defaultStrikeThroughDecoratorDefinition,\n  defaultStrongDecoratorDefinition,\n  defaultUnorderedListItemDefinition,\n  h1StyleDefinition,\n  h2StyleDefinition,\n  h3StyleDefinition,\n  h4StyleDefinition,\n  h5StyleDefinition,\n  h6StyleDefinition,\n  normalStyleDefinition,\n} from '../default-schema'\nimport {unescapeImageAndLinkText} from '../escape'\nimport {defaultKeyGenerator} from '../key-generator'\nimport {\n  buildAnnotationMatcher,\n  buildDecoratorMatcher,\n  buildListItemMatcher,\n  buildObjectMatcher,\n  buildStyleMatcher,\n  type AnnotationMatcher,\n  type DecoratorMatcher,\n  type ExtractValue,\n  type ListItemMatcher,\n  type ObjectMatcher,\n  type StyleMatcher,\n} from './matchers'\n\ntype Options = {\n  schema?: Schema\n  keyGenerator?: () => string\n  marks?: {\n    strong?: DecoratorMatcher\n    em?: DecoratorMatcher\n    code?: DecoratorMatcher\n    strikeThrough?: DecoratorMatcher\n    link?: AnnotationMatcher<{href: string; title: string | undefined}>\n  }\n  block?: {\n    normal?: StyleMatcher\n    blockquote?: StyleMatcher\n    h1?: StyleMatcher\n    h2?: StyleMatcher\n    h3?: StyleMatcher\n    h4?: StyleMatcher\n    h5?: StyleMatcher\n    h6?: StyleMatcher\n  }\n  listItem?: {\n    number?: ListItemMatcher\n    bullet?: ListItemMatcher\n  }\n  types?: {\n    code?: ObjectMatcher<{language: string | undefined; code: string}>\n    horizontalRule?: ObjectMatcher\n    html?: ObjectMatcher<{html: string}>\n    table?: ObjectMatcher<{\n      headerRows: number | undefined\n      rows: Array<{\n        _key: string\n        _type: 'row'\n        cells: Array<{\n          _type: 'cell'\n          _key: string\n          value: Array<PortableTextBlock>\n        }>\n      }>\n    }>\n    image?: ObjectMatcher<{src: string; alt: string; title: string | undefined}>\n  }\n  html?: {\n    /**\n     * How to handle inline HTML.\n     * - 'skip': Ignore inline HTML (default)\n     * - 'text': Convert inline HTML to plain text\n     *\n     * @defaultValue 'skip'\n     */\n    inline?: 'skip' | 'text'\n  }\n}\n\nconst codeBlockMatcher: ObjectMatcher<\n  ExtractValue<typeof defaultCodeObjectDefinition>\n> = ({context, value, isInline}) => {\n  const defaultMatcher = buildObjectMatcher(defaultCodeObjectDefinition)\n  const codeObject = defaultMatcher({context, value, isInline})\n\n  if (!codeObject) {\n    return undefined\n  }\n\n  if (!('code' in codeObject)) {\n    return undefined\n  }\n\n  return codeObject\n}\n\nconst imageBlockMatcher: ObjectMatcher<\n  ExtractValue<typeof defaultImageObjectDefinition>\n> = ({context, value, isInline}) => {\n  const defaultMatcher = buildObjectMatcher(defaultImageObjectDefinition)\n  const imageObject = defaultMatcher({context, value, isInline})\n\n  if (!imageObject) {\n    return undefined\n  }\n\n  if (!('src' in imageObject)) {\n    return undefined\n  }\n\n  return imageObject\n}\n\nconst defaultOptions = {\n  schema: defaultSchema,\n  keyGenerator: defaultKeyGenerator,\n  html: {\n    inline: 'skip',\n  },\n  block: {\n    normal: buildStyleMatcher(normalStyleDefinition),\n    blockquote: buildStyleMatcher(blockquoteStyleDefinition),\n    h1: buildStyleMatcher(h1StyleDefinition),\n    h2: buildStyleMatcher(h2StyleDefinition),\n    h3: buildStyleMatcher(h3StyleDefinition),\n    h4: buildStyleMatcher(h4StyleDefinition),\n    h5: buildStyleMatcher(h5StyleDefinition),\n    h6: buildStyleMatcher(h6StyleDefinition),\n  },\n  listItem: {\n    number: buildListItemMatcher(defaultOrderedListItemDefinition),\n    bullet: buildListItemMatcher(defaultUnorderedListItemDefinition),\n  },\n  marks: {\n    strong: buildDecoratorMatcher(defaultStrongDecoratorDefinition),\n    em: buildDecoratorMatcher(defaultEmDecoratorDefinition),\n    code: buildDecoratorMatcher(defaultCodeDecoratorDefinition),\n    strikeThrough: buildDecoratorMatcher(\n      defaultStrikeThroughDecoratorDefinition,\n    ),\n    link: buildAnnotationMatcher(defaultLinkObjectDefinition),\n  },\n  types: {\n    code: codeBlockMatcher,\n    horizontalRule: buildObjectMatcher(defaultHorizontalRuleObjectDefinition),\n    html: buildObjectMatcher(defaultHtmlObjectDefinition),\n    image: imageBlockMatcher,\n  },\n} as const satisfies Options\n\n/**\n * Flattens a table structure by lifting all blocks from all cells.\n */\nfunction flattenTable(\n  table: {\n    rows: Array<{\n      _key: string\n      _type: 'row'\n      cells: Array<{\n        _type: 'cell'\n        _key: string\n        value: Array<PortableTextBlock>\n      }>\n    }>\n    headerRows: number\n  },\n  portableText: Array<PortableTextBlock>,\n): void {\n  // Flatten the table by lifting all blocks from all cells\n  for (const row of table.rows) {\n    for (const cell of row.cells) {\n      for (const block of cell.value) {\n        portableText.push(block)\n      }\n    }\n  }\n}\n\n/**\n * Converts a markdown string to an array of Portable Text blocks.\n *\n * @public\n */\nexport function markdownToPortableText(\n  markdown: string,\n  options?: Options,\n): Array<PortableTextBlock> {\n  const consolidatedOptions = {\n    schema: options?.schema ?? defaultSchema,\n    keyGenerator: options?.keyGenerator ?? defaultKeyGenerator,\n    html: {\n      inline: options?.html?.inline ?? 'skip',\n    },\n    marks: {\n      ...defaultOptions.marks,\n      ...options?.marks,\n    },\n    block: {\n      ...defaultOptions.block,\n      ...options?.block,\n    },\n    listItem: {\n      ...defaultOptions.listItem,\n      ...options?.listItem,\n    },\n    types: {\n      ...defaultOptions.types,\n      ...options?.types,\n    },\n  }\n\n  const md = markdownit({\n    html: true,\n    linkify: true,\n    typographer: true,\n  }).enable(['strikethrough', 'table'])\n\n  const tokens = md.parse(markdown, {})\n\n  const portableText: Array<PortableTextBlock> = []\n\n  // State\n  let currentBlock: PortableTextTextBlock | null = null\n  const currentListStack: Array<string | null> = []\n  const markDefRefs: Array<string> = [] // mark keys: 'strong', 'em', 'code', or link keys\n  let currentMarkDefs: Array<PortableTextObject> = []\n  let currentBlockquoteStyle: string | null = null // Track blockquote style when inside blockquote\n  let inListItem = false // Track if we're inside a list item\n\n  // Table state\n  let currentTable: {\n    rows: Array<{\n      _key: string\n      _type: 'row'\n      cells: Array<{\n        _type: 'cell'\n        _key: string\n        value: Array<PortableTextBlock>\n      }>\n    }>\n    headerRows: number\n  } | null = null\n  let currentTableRow: Array<{\n    _type: 'cell'\n    _key: string\n    value: Array<PortableTextBlock>\n  }> | null = null\n  let inTableHead = false\n\n  const startBlock = (style: string) => {\n    flushBlock()\n    currentBlock = {\n      _type: 'block' as const,\n      style,\n      children: [],\n      _key: consolidatedOptions.keyGenerator(),\n      markDefs: [],\n    }\n    currentMarkDefs = []\n  }\n\n  const flushBlock = () => {\n    if (!currentBlock) {\n      return\n    }\n\n    // Text blocks must have at least one child span\n    if (currentBlock.children.length === 0) {\n      currentBlock.children.push({\n        _type: consolidatedOptions.schema.span.name,\n        _key: consolidatedOptions.keyGenerator(),\n        text: '',\n        marks: [],\n      })\n    }\n\n    // Assign accumulated markDefs to the block\n    currentBlock.markDefs = currentMarkDefs\n\n    portableText.push(currentBlock)\n\n    currentBlock = null\n    currentMarkDefs = []\n  }\n\n  const addSpan = (text: string) => {\n    if (text.length === 0) {\n      return\n    }\n\n    if (!currentBlock) {\n      const style =\n        currentBlockquoteStyle ??\n        consolidatedOptions.block.normal({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n      if (!style) {\n        console.warn('No default style found, using \"normal\"')\n        startBlock('normal')\n      } else {\n        startBlock(style)\n      }\n    }\n\n    if (!currentBlock) {\n      throw new Error('Expected current block')\n    }\n\n    const lastChild = currentBlock.children.at(-1)\n\n    if (\n      isSpan({schema: consolidatedOptions.schema}, lastChild) &&\n      lastChild.marks?.every((mark) => markDefRefs.includes(mark)) &&\n      markDefRefs.every((mark) => lastChild.marks?.includes(mark))\n    ) {\n      // Merge with previous span if marks match\n      lastChild.text += text\n    } else {\n      currentBlock.children.push({\n        _type: consolidatedOptions.schema.span.name,\n        _key: consolidatedOptions.keyGenerator(),\n        text: text,\n        marks: [...markDefRefs],\n      })\n    }\n  }\n\n  // Helpers for lists\n  const listLevel = () => currentListStack.length\n  const ensureListBlock = (listItem: string) => {\n    if (!currentBlock) {\n      // Use blockquote style if inside a blockquote, otherwise use normal style\n      const style =\n        currentBlockquoteStyle ??\n        consolidatedOptions.block.normal({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n      if (!style) {\n        console.warn('No default style found, using \"normal\"')\n        startBlock('normal')\n      } else {\n        startBlock(style)\n      }\n    }\n\n    if (!currentBlock) {\n      throw new Error('Expected current block')\n    }\n\n    if (\n      currentBlock.listItem !== listItem ||\n      currentBlock.level !== listLevel()\n    ) {\n      currentBlock.listItem = listItem\n      currentBlock.level = listLevel()\n    }\n  }\n\n  // Walk tokens\n  for (const token of tokens) {\n    switch (token.type) {\n      // Paragraphs\n      case 'paragraph_open': {\n        // If we're in a list item but have no current block (e.g., after a code block),\n        // we need to create a new list item block\n        if (inListItem) {\n          if (!currentBlock) {\n            const listType = currentListStack.at(-1)\n\n            if (listType) {\n              ensureListBlock(listType)\n            }\n          }\n\n          break\n        }\n\n        // Use blockquote style if inside a blockquote, otherwise use normal style\n        const style =\n          currentBlockquoteStyle ??\n          consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n        if (!style) {\n          console.warn('No default style found, using \"normal\"')\n          startBlock('normal')\n          break\n        }\n\n        startBlock(style)\n        break\n      }\n      case 'paragraph_close':\n        // Skip flushing if we're inside a list item (list_item_close will flush)\n        if (inListItem) {\n          break\n        }\n        flushBlock()\n        break\n\n      // Headings\n      case 'heading_open': {\n        const level = Number(token?.tag?.slice(1))\n\n        // Map level to the appropriate heading matcher\n        const headingMatchers = {\n          1: consolidatedOptions.block.h1,\n          2: consolidatedOptions.block.h2,\n          3: consolidatedOptions.block.h3,\n          4: consolidatedOptions.block.h4,\n          5: consolidatedOptions.block.h5,\n          6: consolidatedOptions.block.h6,\n        } as const\n\n        const headingMatcher =\n          headingMatchers[level as keyof typeof headingMatchers]\n\n        const style =\n          headingMatcher?.({\n            context: {schema: consolidatedOptions.schema},\n          }) ??\n          consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n        if (!style) {\n          console.warn('No heading style found, using \"normal\"')\n          startBlock('normal')\n          break\n        }\n\n        startBlock(style)\n        break\n      }\n      case 'heading_close':\n        flushBlock()\n        break\n\n      // Blockquote\n      case 'blockquote_open': {\n        // Flush any current block before entering blockquote\n        flushBlock()\n\n        // Set the blockquote style for paragraphs inside the blockquote\n        const style =\n          consolidatedOptions.block.blockquote({\n            context: {schema: consolidatedOptions.schema},\n          }) ??\n          consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n        currentBlockquoteStyle = style ?? 'normal'\n        break\n      }\n      case 'blockquote_close': {\n        // Flush any blockquote content before exiting\n        flushBlock()\n        currentBlockquoteStyle = null\n        break\n      }\n      // Lists\n      case 'bullet_list_open': {\n        const listItem = consolidatedOptions.listItem.bullet({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n        if (!listItem) {\n          // No list definition in schema, push null to indicate we should skip list properties\n          currentListStack.push(null)\n          break\n        }\n\n        currentListStack.push(listItem)\n        break\n      }\n      case 'ordered_list_open': {\n        const listItem = consolidatedOptions.listItem.number({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n        if (!listItem) {\n          // No list definition in schema, push null to indicate we should skip list properties\n          currentListStack.push(null)\n          break\n        }\n\n        currentListStack.push(listItem)\n        break\n      }\n      case 'bullet_list_close':\n      case 'ordered_list_close':\n        currentListStack.pop()\n        break\n      case 'list_item_open': {\n        const listType = currentListStack.at(-1)\n\n        if (listType === undefined) {\n          throw new Error('Expected an open list')\n        }\n\n        // Flush any previous list item block before starting a new one\n        // This is needed for proper separation of list items\n        if (currentBlock) {\n          flushBlock()\n        }\n\n        // If listType is null, it means there's no list definition in the schema\n        // Just create a normal block without list properties\n        if (listType === null) {\n          // Use blockquote style if inside a blockquote, otherwise use normal style\n          const style =\n            currentBlockquoteStyle ??\n            consolidatedOptions.block.normal({\n              context: {schema: consolidatedOptions.schema},\n            })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n          inListItem = true\n          break\n        }\n\n        ensureListBlock(listType)\n        inListItem = true\n        break\n      }\n      case 'list_item_close':\n        inListItem = false\n        flushBlock()\n        break\n\n      // Code fences / blocks\n      case 'fence': {\n        flushBlock()\n\n        const language = token.info.trim() || undefined\n        // Remove trailing newline from code content\n        const code = token.content.replace(/\\n$/, '')\n\n        const codeObject = consolidatedOptions.types.code({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {language, code},\n          isInline: false,\n        })\n\n        if (!codeObject) {\n          // Code block not in schema, fall back to text block\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan(code)\n          flushBlock()\n          break\n        }\n\n        portableText.push(codeObject)\n\n        break\n      }\n\n      // Horizontal rule\n      case 'hr': {\n        flushBlock()\n\n        const hrObject = consolidatedOptions.types.horizontalRule({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {},\n          isInline: false,\n        })\n\n        if (!hrObject) {\n          // If there's no break definition in the schema, parse as text\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan('---')\n          flushBlock()\n          break\n        }\n\n        portableText.push(hrObject)\n\n        break\n      }\n\n      // HTML block\n      case 'html_block': {\n        flushBlock()\n\n        const htmlContent = token.content.trim()\n\n        if (!htmlContent) {\n          break\n        }\n\n        const htmlObject = consolidatedOptions.types.html({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {html: htmlContent},\n          isInline: false,\n        })\n\n        if (!htmlObject) {\n          // If there's no HTML block definition in the schema, parse as text\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan(htmlContent)\n          flushBlock()\n          break\n        }\n\n        portableText.push(htmlObject)\n\n        break\n      }\n\n      case 'code_block': {\n        flushBlock()\n\n        // Remove trailing newline from code content\n        const code = token.content.replace(/\\n$/, '')\n\n        const codeObject = consolidatedOptions.types.code({\n          context: {\n            schema: consolidatedOptions.schema,\n            keyGenerator: consolidatedOptions.keyGenerator,\n          },\n          value: {language: undefined, code},\n          isInline: false,\n        })\n\n        if (!codeObject) {\n          // Code block not in schema, fall back to text block\n          const style = consolidatedOptions.block.normal({\n            context: {schema: consolidatedOptions.schema},\n          })\n\n          if (!style) {\n            console.warn('No default style found, using \"normal\"')\n            startBlock('normal')\n          } else {\n            startBlock(style)\n          }\n\n          addSpan(code)\n          flushBlock()\n        } else {\n          portableText.push(codeObject)\n        }\n\n        break\n      }\n\n      // Tables\n      case 'table_open':\n        flushBlock()\n        currentTable = {rows: [], headerRows: 0}\n        break\n\n      case 'table_close': {\n        if (!currentTable) {\n          break\n        }\n\n        // Only create table object if table type is defined\n        if (consolidatedOptions.types.table) {\n          const tableObject = consolidatedOptions.types.table({\n            context: {\n              schema: consolidatedOptions.schema,\n              keyGenerator: consolidatedOptions.keyGenerator,\n            },\n            value: {\n              rows: currentTable.rows,\n              headerRows:\n                currentTable.headerRows > 0\n                  ? currentTable.headerRows\n                  : undefined,\n            },\n            isInline: false,\n          })\n\n          if (tableObject) {\n            portableText.push(tableObject)\n          } else {\n            // If table object couldn't be created, flatten the table\n            flattenTable(currentTable, portableText)\n          }\n        } else {\n          // If there's no table definition in the schema, flatten the table\n          flattenTable(currentTable, portableText)\n        }\n\n        currentTable = null\n        break\n      }\n\n      case 'thead_open':\n        inTableHead = true\n        break\n\n      case 'thead_close':\n        inTableHead = false\n        break\n\n      case 'tbody_open':\n      case 'tbody_close':\n        // Just markers, no action needed\n        break\n\n      case 'tr_open':\n        currentTableRow = []\n        break\n\n      case 'tr_close':\n        if (currentTable && currentTableRow) {\n          currentTable.rows.push({\n            _key: consolidatedOptions.keyGenerator(),\n            _type: 'row',\n            cells: currentTableRow,\n          })\n          if (inTableHead) {\n            currentTable.headerRows++\n          }\n        }\n        currentTableRow = null\n        break\n\n      case 'th_open':\n      case 'td_open': {\n        // Start a new block for the table cell\n        const style = consolidatedOptions.block.normal({\n          context: {schema: consolidatedOptions.schema},\n        })\n\n        if (!style) {\n          console.warn('No default style found, using \"normal\"')\n          startBlock('normal')\n        } else {\n          startBlock(style)\n        }\n        break\n      }\n\n      case 'th_close':\n      case 'td_close': {\n        // Flush the current block into the cell\n        flushBlock()\n\n        // Get all blocks that were added since this cell started\n        // We need to extract them from portableText array\n        const cellBlocks: Array<PortableTextBlock> = []\n\n        // Check if we have blocks to extract (added after table_open)\n        if (portableText.length > 0) {\n          const lastBlock = portableText.at(-1)\n          if (lastBlock && lastBlock._type === 'block') {\n            cellBlocks.push(portableText.pop()!)\n          }\n        }\n\n        // If no blocks were created (empty cell), create an empty block\n        if (cellBlocks.length === 0) {\n          cellBlocks.push({\n            _type: 'block' as const,\n            style:\n              consolidatedOptions.block.normal({\n                context: {schema: consolidatedOptions.schema},\n              }) || 'normal',\n            children: [\n              {\n                _type: consolidatedOptions.schema.span.name,\n                _key: consolidatedOptions.keyGenerator(),\n                text: '',\n                marks: [],\n              },\n            ],\n            _key: consolidatedOptions.keyGenerator(),\n            markDefs: [],\n          })\n        }\n\n        // Check if the cell contains a single block with a single image child\n        // If so, extract the image as a block-level image\n        const firstBlock = cellBlocks[0]\n        if (\n          cellBlocks.length === 1 &&\n          firstBlock &&\n          firstBlock._type === 'block' &&\n          'children' in firstBlock &&\n          Array.isArray(firstBlock.children) &&\n          firstBlock.children.length === 1\n        ) {\n          const onlyChild = firstBlock.children[0]\n          // Check if it's an image object (not a span)\n          if (\n            typeof onlyChild === 'object' &&\n            onlyChild !== null &&\n            '_type' in onlyChild &&\n            onlyChild._type !== consolidatedOptions.schema.span.name &&\n            onlyChild._type === 'image'\n          ) {\n            // Replace the block with just the image\n            cellBlocks[0] = onlyChild as PortableTextBlock\n          }\n        }\n\n        if (currentTableRow !== null) {\n          currentTableRow.push({\n            _type: 'cell',\n            _key: consolidatedOptions.keyGenerator(),\n            value: cellBlocks,\n          })\n        }\n        break\n      }\n\n      // Inline container\n      case 'inline': {\n        // Check if we're in a table cell\n        const inTableCell = currentTableRow !== null\n\n        // Check if this is a standalone image (paragraph with only an image)\n        if (\n          token.children?.length === 1 &&\n          token.children[0]?.type === 'image'\n        ) {\n          const imageToken = token.children[0]\n          if (!imageToken) {\n            break\n          }\n\n          const src =\n            imageToken.attrs?.find(([name]) => name === 'src')?.at(1) || ''\n          const alt = unescapeImageAndLinkText(imageToken.content || '')\n          const title =\n            imageToken.attrs?.find(([name]) => name === 'title')?.at(1) ||\n            undefined\n\n          const blockImageObject = consolidatedOptions.types.image({\n            context: {\n              schema: consolidatedOptions.schema,\n              keyGenerator: consolidatedOptions.keyGenerator,\n            },\n            value: {src, alt, title},\n            isInline: false,\n          })\n\n          if (blockImageObject) {\n            if (inTableCell) {\n              // In table cells, we can't push to portableText directly\n              // The block image will be handled in th_close/td_close extraction logic\n              // For now, add it as a child of the current block\n              if (currentBlock && 'children' in currentBlock) {\n                ;(currentBlock as PortableTextTextBlock).children.push(\n                  blockImageObject as PortableTextObject,\n                )\n              }\n            } else {\n              // If the current block has content, flush it before adding the block image\n              // Otherwise, discard the empty block that was created by paragraph_open\n              const hasContent =\n                currentBlock &&\n                'children' in currentBlock &&\n                (currentBlock as PortableTextTextBlock).children.length > 0\n\n              if (hasContent) {\n                flushBlock()\n              } else {\n                currentBlock = null\n                currentMarkDefs = []\n              }\n              portableText.push(blockImageObject)\n            }\n            break\n          }\n\n          // Block image not supported, try inline image as fallback\n          const inlineImageObject = consolidatedOptions.types.image({\n            context: {\n              schema: consolidatedOptions.schema,\n              keyGenerator: consolidatedOptions.keyGenerator,\n            },\n            value: {src, alt, title},\n            isInline: true,\n          })\n\n          if (inlineImageObject) {\n            // Ensure we have a block to add the inline image to\n            if (!currentBlock) {\n              if (inListItem) {\n                const listType = currentListStack.at(-1)\n\n                if (listType) {\n                  ensureListBlock(listType)\n                }\n              } else {\n                const style = consolidatedOptions.block.normal({\n                  context: {schema: consolidatedOptions.schema},\n                })\n\n                if (style) {\n                  startBlock(style)\n                }\n              }\n            }\n\n            if (currentBlock && 'children' in currentBlock) {\n              ;(currentBlock as PortableTextTextBlock).children.push(\n                inlineImageObject as PortableTextObject,\n              )\n            }\n            break\n          }\n\n          // Neither block nor inline image supported, fall back to text\n          addSpan(`![${alt}](${src})`)\n          break\n        }\n\n        // Walk its children for text/marks/links\n        for (const childToken of token.children ?? []) {\n          switch (childToken.type) {\n            case 'text':\n              addSpan(childToken.content)\n              break\n            case 'softbreak':\n            case 'hardbreak':\n              addSpan('\\n')\n              break\n            case 'code_inline': {\n              const decorator = consolidatedOptions.marks.code({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                // No code decorator defined, just add the content without marks\n                addSpan(childToken.content)\n                break\n              }\n\n              markDefRefs.push(decorator)\n              addSpan(childToken.content)\n\n              // code_inline is self-contained, so we need to pop the decorator\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 'strong_open': {\n              const decorator = consolidatedOptions.marks.strong({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              markDefRefs.push(decorator)\n              break\n            }\n            case 'strong_close': {\n              const decorator = consolidatedOptions.marks.strong({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 'em_open': {\n              const decorator = consolidatedOptions.marks.em({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              markDefRefs.push(decorator)\n\n              break\n            }\n            case 'em_close': {\n              const decorator = consolidatedOptions.marks.em({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 's_open': {\n              const decorator = consolidatedOptions.marks.strikeThrough({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              markDefRefs.push(decorator)\n\n              break\n            }\n            case 's_close': {\n              const decorator = consolidatedOptions.marks.strikeThrough({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (!decorator) {\n                break\n              }\n\n              const index = markDefRefs.lastIndexOf(decorator)\n\n              if (index !== -1) {\n                markDefRefs.splice(index, 1)\n              }\n\n              break\n            }\n            case 'link_open': {\n              const href = childToken.attrs\n                ?.find(([name]) => name === 'href')\n                ?.at(1)\n\n              if (!href) {\n                break\n              }\n\n              const title = childToken.attrs\n                ?.find(([name]) => name === 'title')\n                ?.at(1)\n\n              const linkObject = consolidatedOptions.marks.link({\n                context: {\n                  schema: consolidatedOptions.schema,\n                  keyGenerator: consolidatedOptions.keyGenerator,\n                },\n                value: {href, title},\n              })\n\n              if (!linkObject) {\n                break\n              }\n\n              currentMarkDefs.push(linkObject)\n              markDefRefs.push(linkObject._key)\n              break\n            }\n            case 'link_close': {\n              // remove the last link key\n              const markDefKeys = new Set(currentMarkDefs.map((d) => d._key))\n              let lastLinkIndex: number | undefined\n\n              for (const markDefRef of markDefRefs.reverse()) {\n                if (markDefKeys.has(markDefRef)) {\n                  lastLinkIndex = markDefRefs.indexOf(markDefRef)\n                  break\n                }\n              }\n\n              if (lastLinkIndex !== undefined) {\n                const realIndex = markDefRefs.length - 1 - lastLinkIndex\n                markDefRefs.splice(realIndex, 1)\n              }\n              break\n            }\n            case 'image': {\n              const src =\n                childToken.attrs?.find(([name]) => name === 'src')?.at(1) || ''\n              const alt = unescapeImageAndLinkText(childToken.content || '')\n\n              // Try to create an inline image first\n              const inlineImageObject = consolidatedOptions.types.image({\n                context: {\n                  schema: consolidatedOptions.schema,\n                  keyGenerator: consolidatedOptions.keyGenerator,\n                },\n                value: {src, alt, title: undefined},\n                isInline: true,\n              })\n\n              if (inlineImageObject) {\n                // Inline image is supported - add it to current block\n                if (!currentBlock) {\n                  const style = consolidatedOptions.block.normal({\n                    context: {schema: consolidatedOptions.schema},\n                  })\n\n                  if (!style) {\n                    console.warn('No default style found, using \"normal\"')\n                    startBlock('normal')\n                  } else {\n                    startBlock(style)\n                  }\n                }\n\n                // At this point currentBlock should exist\n                if (!currentBlock) {\n                  throw new Error('Expected current block after startBlock')\n                }\n\n                // Add the image as an inline object (TypeScript assertion needed for type narrowing)\n                ;(currentBlock as PortableTextTextBlock).children.push(\n                  inlineImageObject as PortableTextObject,\n                )\n                break\n              }\n\n              // Inline image not supported - try block image as fallback\n              const blockImageObject = consolidatedOptions.types.image({\n                context: {\n                  schema: consolidatedOptions.schema,\n                  keyGenerator: consolidatedOptions.keyGenerator,\n                },\n                value: {src, alt, title: undefined},\n                isInline: false,\n              })\n\n              if (!blockImageObject) {\n                // Neither inline nor block image supported\n                addSpan(`![${alt}](${src})`)\n                break\n              }\n\n              // Block image supported - flush current block and add as block-level\n              // Skip if we're in a table cell (images in cells are handled differently)\n              if (inTableCell) {\n                // In table cells, add the image to current block (will be extracted later)\n                if (currentBlock && 'children' in currentBlock) {\n                  ;(currentBlock as PortableTextTextBlock).children.push(\n                    blockImageObject as PortableTextObject,\n                  )\n                }\n                break\n              }\n\n              // Not in table - flush current block, add image as block, start new block\n              flushBlock()\n              portableText.push(blockImageObject)\n\n              // Start a new block for any remaining content\n              const style = consolidatedOptions.block.normal({\n                context: {schema: consolidatedOptions.schema},\n              })\n\n              if (style) {\n                startBlock(style)\n              }\n\n              break\n            }\n            case 'html_inline': {\n              // Handle inline HTML based on configuration\n              if (consolidatedOptions.html.inline === 'text') {\n                addSpan(childToken.content)\n              }\n              // 'skip' - do nothing, ignore the HTML\n              break\n            }\n            default:\n              // Ignore other inline token types by default\n              break\n          }\n        }\n        break\n      }\n\n      default:\n        break\n    }\n  }\n\n  flushBlock()\n\n  return portableText\n}\n"],"names":["levelIndexMap","filteredValue","style"],"mappings":"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"}