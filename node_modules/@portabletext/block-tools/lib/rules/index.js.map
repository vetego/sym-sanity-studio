{"version":3,"file":"index.js","sources":["../../src/rules/flatten-tables.ts"],"sourcesContent":["import {\n  isTextBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type Schema,\n} from '@portabletext/schema'\nimport {flattenNestedBlocks} from '../HtmlDeserializer/flatten-nested-blocks'\nimport {isElement, tagName} from '../HtmlDeserializer/helpers'\nimport type {\n  ArbitraryTypedObject,\n  DeserializerRule,\n  TypedObject,\n} from '../types'\n\n/**\n * An opinionated `DeserializerRule` that flattens tables in a way that repeats\n * the header row for each cell in the row.\n *\n * @example\n * ```html\n * <table>\n *   <thead>\n *     <tr>\n *       <th>Header 1</th>\n *       <th>Header 2</th>\n *     </tr>\n *   </thead>\n *   <tbody>\n *     <tr>\n *       <td>Cell 1</td>\n *       <td>Cell 2</td>\n *     </tr>\n *   </tbody>\n * </table>\n * ```\n * Turns into\n * ```json\n * [\n *   {\n *     _type: 'block',\n *     children: [\n *       {\n *         _type: 'text',\n *         text: 'Header 1'\n *       },\n *       {\n *         _type: 'text',\n *         text: 'Cell 1'\n *       }\n *     ]\n *   },\n *   {\n *     _type: 'block',\n *     children: [\n *       {\n *         _type: 'text',\n *         text: 'Header 2'\n *       },\n *       {\n *         _type: 'text',\n *         text: 'Cell 2'\n *       }\n *     ]\n *   }\n * ]\n * ```\n *\n * Use the `separator` option to control if a child element should separate\n * headers and cells.\n *\n * @beta\n */\nexport function createFlattenTableRule({\n  schema,\n  separator,\n}: {\n  schema: Schema\n  separator?: () =>\n    | (Omit<PortableTextSpan, '_key'> & {_key?: string})\n    | (Omit<PortableTextObject, '_key'> & {_key?: string})\n    | undefined\n}): DeserializerRule {\n  return {\n    deserialize: (node, next) => {\n      if (!isElement(node) || tagName(node) !== 'table') {\n        return undefined\n      }\n\n      const columnCounts = [...node.querySelectorAll('tr')].map((row) => {\n        const cells = row.querySelectorAll('td, th')\n        return cells.length\n      })\n\n      const firstColumnCount = columnCounts[0]\n\n      if (\n        !firstColumnCount ||\n        !columnCounts.every((count) => count === firstColumnCount)\n      ) {\n        // If the column counts are not all the same, we return undefined.\n        return undefined\n      }\n\n      const thead = node.querySelector('thead')\n      const headerRows = thead?.querySelectorAll('tr')\n      const tbody = node.querySelector('tbody')\n      const bodyRows = tbody ? [...tbody.querySelectorAll('tr')] : []\n\n      if (!headerRows || !bodyRows) {\n        return undefined\n      }\n\n      const headerRow = [...headerRows][0]\n\n      if (!headerRow || headerRows.length > 1) {\n        return undefined\n      }\n\n      const headerCells = headerRow.querySelectorAll('th, td')\n      const headerResults = [...headerCells].map((headerCell) =>\n        next(headerCell),\n      )\n\n      // Process tbody rows and combine with headers\n      const rows: TypedObject[] = []\n\n      for (const row of bodyRows) {\n        const cells = row.querySelectorAll('td')\n\n        let cellIndex = 0\n        for (const cell of cells) {\n          const result = next(cell)\n\n          if (!result) {\n            cellIndex++\n            continue\n          }\n\n          const headerResult = headerResults[cellIndex]\n\n          if (!headerResult) {\n            // If we can't find a corresponding header, then we just push\n            // the deserialized cell as is.\n            if (Array.isArray(result)) {\n              rows.push(...result)\n            } else {\n              rows.push(result)\n            }\n            cellIndex++\n            continue\n          }\n\n          const flattenedHeaderResult = flattenNestedBlocks(\n            {schema},\n            (Array.isArray(headerResult)\n              ? headerResult\n              : [headerResult]) as Array<ArbitraryTypedObject>,\n          )\n          const firstFlattenedHeaderResult = flattenedHeaderResult[0]\n          const flattenedResult = flattenNestedBlocks(\n            {schema},\n            (Array.isArray(result)\n              ? result\n              : [result]) as Array<ArbitraryTypedObject>,\n          )\n          const firstFlattenedResult = flattenedResult[0]\n\n          if (\n            flattenedHeaderResult.length === 1 &&\n            isTextBlock({schema}, firstFlattenedHeaderResult) &&\n            flattenedResult.length === 1 &&\n            isTextBlock({schema}, firstFlattenedResult)\n          ) {\n            const separatorChild = separator?.()\n            // If the header result and the cell result are text blocks then\n            //   we merge them together.\n            const mergedTextBlock = {\n              ...firstFlattenedHeaderResult,\n              children: [\n                ...firstFlattenedHeaderResult.children,\n                ...(separatorChild ? [separatorChild] : []),\n                ...firstFlattenedResult.children,\n              ],\n              markDefs: [\n                ...(firstFlattenedHeaderResult.markDefs ?? []),\n                ...(firstFlattenedResult.markDefs ?? []),\n              ],\n            }\n\n            rows.push(mergedTextBlock)\n            cellIndex++\n            continue\n          }\n\n          // Otherwise, we push the header result and the cell result as is.\n          if (Array.isArray(headerResult)) {\n            rows.push(...headerResult)\n          } else {\n            rows.push(headerResult)\n          }\n\n          if (Array.isArray(result)) {\n            rows.push(...result)\n          } else {\n            rows.push(result)\n          }\n\n          cellIndex++\n        }\n      }\n\n      // Return the processed rows as individual text blocks\n      return rows\n    },\n  }\n}\n"],"names":[],"mappings":";;AAwEO,SAAS,uBAAuB;AAAA,EACrC;AAAA,EACA;AACF,GAMqB;AACnB,SAAO;AAAA,IACL,aAAa,CAAC,MAAM,SAAS;AAC3B,UAAI,CAAC,UAAU,IAAI,KAAK,QAAQ,IAAI,MAAM;AACxC;AAGF,YAAM,eAAe,CAAC,GAAG,KAAK,iBAAiB,IAAI,CAAC,EAAE,IAAI,CAAC,QAC3C,IAAI,iBAAiB,QAAQ,EAC9B,MACd,GAEK,mBAAmB,aAAa,CAAC;AAEvC,UACE,CAAC,oBACD,CAAC,aAAa,MAAM,CAAC,UAAU,UAAU,gBAAgB;AAGzD;AAIF,YAAM,aADQ,KAAK,cAAc,OAAO,GACd,iBAAiB,IAAI,GACzC,QAAQ,KAAK,cAAc,OAAO,GAClC,WAAW,QAAQ,CAAC,GAAG,MAAM,iBAAiB,IAAI,CAAC,IAAI,CAAA;AAE7D,UAAI,CAAC,cAAc,CAAC;AAClB;AAGF,YAAM,YAAY,CAAC,GAAG,UAAU,EAAE,CAAC;AAEnC,UAAI,CAAC,aAAa,WAAW,SAAS;AACpC;AAIF,YAAM,gBAAgB,CAAC,GADH,UAAU,iBAAiB,QAAQ,CAClB,EAAE;AAAA,QAAI,CAAC,eAC1C,KAAK,UAAU;AAAA,MAAA,GAIX,OAAsB,CAAA;AAE5B,iBAAW,OAAO,UAAU;AAC1B,cAAM,QAAQ,IAAI,iBAAiB,IAAI;AAEvC,YAAI,YAAY;AAChB,mBAAW,QAAQ,OAAO;AACxB,gBAAM,SAAS,KAAK,IAAI;AAExB,cAAI,CAAC,QAAQ;AACX;AACA;AAAA,UACF;AAEA,gBAAM,eAAe,cAAc,SAAS;AAE5C,cAAI,CAAC,cAAc;AAGb,kBAAM,QAAQ,MAAM,IACtB,KAAK,KAAK,GAAG,MAAM,IAEnB,KAAK,KAAK,MAAM,GAElB;AACA;AAAA,UACF;AAEA,gBAAM,wBAAwB;AAAA,YAC5B,EAAC,OAAA;AAAA,YACA,MAAM,QAAQ,YAAY,IACvB,eACA,CAAC,YAAY;AAAA,UAAA,GAEb,6BAA6B,sBAAsB,CAAC,GACpD,kBAAkB;AAAA,YACtB,EAAC,OAAA;AAAA,YACA,MAAM,QAAQ,MAAM,IACjB,SACA,CAAC,MAAM;AAAA,UAAA,GAEP,uBAAuB,gBAAgB,CAAC;AAE9C,cACE,sBAAsB,WAAW,KACjC,YAAY,EAAC,UAAS,0BAA0B,KAChD,gBAAgB,WAAW,KAC3B,YAAY,EAAC,OAAA,GAAS,oBAAoB,GAC1C;AACA,kBAAM,iBAAiB,YAAA,GAGjB,kBAAkB;AAAA,cACtB,GAAG;AAAA,cACH,UAAU;AAAA,gBACR,GAAG,2BAA2B;AAAA,gBAC9B,GAAI,iBAAiB,CAAC,cAAc,IAAI,CAAA;AAAA,gBACxC,GAAG,qBAAqB;AAAA,cAAA;AAAA,cAE1B,UAAU;AAAA,gBACR,GAAI,2BAA2B,YAAY,CAAA;AAAA,gBAC3C,GAAI,qBAAqB,YAAY,CAAA;AAAA,cAAC;AAAA,YACxC;AAGF,iBAAK,KAAK,eAAe,GACzB;AACA;AAAA,UACF;AAGI,gBAAM,QAAQ,YAAY,IAC5B,KAAK,KAAK,GAAG,YAAY,IAEzB,KAAK,KAAK,YAAY,GAGpB,MAAM,QAAQ,MAAM,IACtB,KAAK,KAAK,GAAG,MAAM,IAEnB,KAAK,KAAK,MAAM,GAGlB;AAAA,QACF;AAAA,MACF;AAGA,aAAO;AAAA,IACT;AAAA,EAAA;AAEJ;"}