import { isTextBlock, isSpan } from "@portabletext/schema";
const objectToString = Object.prototype.toString;
function resolveJsType(val) {
  switch (objectToString.call(val)) {
    case "[object Function]":
      return "function";
    case "[object Date]":
      return "date";
    case "[object RegExp]":
      return "regexp";
    case "[object Arguments]":
      return "arguments";
    case "[object Array]":
      return "array";
    case "[object String]":
      return "string";
  }
  return val === null ? "null" : val === void 0 ? "undefined" : val && typeof val == "object" && "nodeType" in val && val.nodeType === 1 ? "element" : val === Object(val) ? "object" : typeof val;
}
function isEqualMarks(a, b) {
  if (!a || !b)
    return a === b;
  if (a.length !== b.length)
    return !1;
  for (let index = 0; index < a.length; index++)
    if (a[index] !== b[index])
      return !1;
  return !0;
}
function isDeepEqual(data, other) {
  return isDeepEqualImplementation(data, other);
}
function isDeepEqualImplementation(data, other) {
  if (data === other || Object.is(data, other))
    return !0;
  if (typeof data != "object" || typeof other != "object" || data === null || other === null || Object.getPrototypeOf(data) !== Object.getPrototypeOf(other))
    return !1;
  if (Array.isArray(data))
    return isDeepEqualArrays(data, other);
  if (data instanceof Map)
    return isDeepEqualMaps(data, other);
  if (data instanceof Set)
    return isDeepEqualSets(data, other);
  if (data instanceof Date)
    return data.getTime() === other.getTime();
  if (data instanceof RegExp)
    return data.toString() === other.toString();
  if (Object.keys(data).length !== Object.keys(other).length)
    return !1;
  for (const [key, value] of Object.entries(data))
    if (!(key in other) || !isDeepEqualImplementation(
      value,
      // @ts-expect-error [ts7053] - We already checked that `other` has `key`
      other[key]
    ))
      return !1;
  return !0;
}
function isDeepEqualArrays(data, other) {
  if (data.length !== other.length)
    return !1;
  for (const [index, item] of data.entries())
    if (!isDeepEqualImplementation(item, other[index]))
      return !1;
  return !0;
}
function isDeepEqualMaps(data, other) {
  if (data.size !== other.size)
    return !1;
  for (const [key, value] of data.entries())
    if (!other.has(key) || !isDeepEqualImplementation(value, other.get(key)))
      return !1;
  return !0;
}
function isDeepEqualSets(data, other) {
  if (data.size !== other.size)
    return !1;
  const otherCopy = [...other];
  for (const dataItem of data) {
    let isFound = !1;
    for (const [index, otherItem] of otherCopy.entries())
      if (isDeepEqualImplementation(dataItem, otherItem)) {
        isFound = !0, otherCopy.splice(index, 1);
        break;
      }
    if (!isFound)
      return !1;
  }
  return !0;
}
function isArbitraryTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function flattenNestedBlocks(context, blocks) {
  return blocks.flatMap((block) => {
    if (isBlockContainer(block))
      return flattenNestedBlocks(context, [block.block]);
    if (isTextBlock(context, block)) {
      const hasBlockObjects = block.children.some((child) => context.schema.blockObjects.some(
        (blockObject) => blockObject.name === child._type
      )), hasBlocks = block.children.some(
        (child) => child._type === "__block" || child._type === "block"
      );
      if (hasBlockObjects || hasBlocks) {
        const splitChildren = getSplitChildren(context, block);
        return splitChildren.length === 1 && splitChildren[0].type === "children" && isDeepEqual(splitChildren[0].children, block.children) ? [block] : splitChildren.flatMap((slice) => slice.type === "block object" ? [slice.block] : slice.type === "block" ? flattenNestedBlocks(context, [
          slice.block
        ]) : slice.children.length > 0 ? slice.children.every(
          (child) => isSpan(context, child) && child.text.trim() === ""
        ) ? [] : flattenNestedBlocks(context, [
          {
            ...block,
            children: slice.children
          }
        ]) : []);
      }
      return [block];
    }
    return [block];
  });
}
function isBlockContainer(block) {
  return block._type === "__block" && isArbitraryTypedObject(block.block);
}
function getSplitChildren(context, block) {
  return block.children.reduce(
    (slices, child) => {
      const knownInlineObject = context.schema.inlineObjects.some(
        (inlineObject) => inlineObject.name === child._type
      ), knownBlockObject = context.schema.blockObjects.some(
        (blockObject) => blockObject.name === child._type
      ), lastSlice = slices.pop();
      return !isSpan(context, child) && !knownInlineObject && knownBlockObject ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "block object", block: child }
      ] : child._type === "__block" ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        {
          type: "block object",
          block: child.block
        }
      ] : child._type === "block" ? [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "block", block: child }
      ] : lastSlice && lastSlice.type === "children" ? [
        ...slices,
        {
          type: "children",
          children: [...lastSlice.children, child]
        }
      ] : [
        ...slices,
        ...lastSlice ? [lastSlice] : [],
        { type: "children", children: [child] }
      ];
    },
    []
  );
}
const PRESERVE_WHITESPACE_TAGS = ["pre", "textarea", "code"], BLOCK_DEFAULT_STYLE = "normal", DEFAULT_BLOCK = Object.freeze({
  _type: "block",
  markDefs: [],
  style: BLOCK_DEFAULT_STYLE
}), DEFAULT_SPAN = Object.freeze({
  _type: "span",
  marks: []
}), HTML_BLOCK_TAGS = {
  p: DEFAULT_BLOCK,
  blockquote: { ...DEFAULT_BLOCK, style: "blockquote" }
}, HTML_SPAN_TAGS = {
  span: { object: "text" }
}, HTML_LIST_CONTAINER_TAGS = {
  ol: { object: null },
  ul: { object: null }
}, HTML_HEADER_TAGS = {
  h1: { ...DEFAULT_BLOCK, style: "h1" },
  h2: { ...DEFAULT_BLOCK, style: "h2" },
  h3: { ...DEFAULT_BLOCK, style: "h3" },
  h4: { ...DEFAULT_BLOCK, style: "h4" },
  h5: { ...DEFAULT_BLOCK, style: "h5" },
  h6: { ...DEFAULT_BLOCK, style: "h6" }
}, HTML_MISC_TAGS = {
  br: { ...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE }
}, HTML_DECORATOR_TAGS = {
  b: "strong",
  strong: "strong",
  i: "em",
  em: "em",
  u: "underline",
  s: "strike-through",
  strike: "strike-through",
  del: "strike-through",
  code: "code",
  sup: "sup",
  sub: "sub",
  ins: "ins",
  mark: "mark",
  small: "small"
}, HTML_LIST_ITEM_TAGS = {
  li: {
    ...DEFAULT_BLOCK,
    style: BLOCK_DEFAULT_STYLE,
    level: 1,
    listItem: "bullet"
  }
}, ELEMENT_MAP = {
  ...HTML_BLOCK_TAGS,
  ...HTML_SPAN_TAGS,
  ...HTML_LIST_CONTAINER_TAGS,
  ...HTML_LIST_ITEM_TAGS,
  ...HTML_HEADER_TAGS,
  ...HTML_MISC_TAGS
};
[
  ...new Set(
    Object.values(ELEMENT_MAP).filter((tag) => "style" in tag).map((tag) => tag.style)
  )
];
[
  ...new Set(Object.values(HTML_DECORATOR_TAGS))
];
function tagName(el) {
  if (el && "tagName" in el)
    return el.tagName.toLowerCase();
}
function defaultParseHtml() {
  if (resolveJsType(DOMParser) === "undefined")
    throw new Error(
      "The native `DOMParser` global which the `Html` deserializer uses by default is not present in this environment. You must supply the `options.parseHtml` function instead."
    );
  return (html) => new DOMParser().parseFromString(html, "text/html");
}
function ensureRootIsBlocks(schema, objects) {
  return objects.reduce((blocks, node, i, original) => {
    if (node._type === "block")
      return blocks.push(node), blocks;
    if (node._type === "__block")
      return blocks.push(node.block), blocks;
    const lastBlock = blocks[blocks.length - 1];
    if (i > 0 && !isTextBlock({ schema }, original[i - 1]) && isTextBlock({ schema }, lastBlock))
      return lastBlock.children.push(node), blocks;
    const block = {
      ...DEFAULT_BLOCK,
      children: [node]
    };
    return blocks.push(block), blocks;
  }, []);
}
function isNodeList(node) {
  return Object.prototype.toString.call(node) === "[object NodeList]";
}
function isMinimalSpan(node) {
  return node._type === "span";
}
function isMinimalBlock(node) {
  return node._type === "block";
}
function isPlaceholderDecorator(node) {
  return node._type === "__decorator";
}
function isPlaceholderAnnotation(node) {
  return node._type === "__annotation";
}
function isElement(node) {
  return node.nodeType === 1;
}
export {
  BLOCK_DEFAULT_STYLE,
  DEFAULT_BLOCK,
  DEFAULT_SPAN,
  HTML_BLOCK_TAGS,
  HTML_DECORATOR_TAGS,
  HTML_HEADER_TAGS,
  HTML_LIST_CONTAINER_TAGS,
  HTML_LIST_ITEM_TAGS,
  HTML_SPAN_TAGS,
  PRESERVE_WHITESPACE_TAGS,
  defaultParseHtml,
  ensureRootIsBlocks,
  flattenNestedBlocks,
  isElement,
  isEqualMarks,
  isMinimalBlock,
  isMinimalSpan,
  isNodeList,
  isPlaceholderAnnotation,
  isPlaceholderDecorator,
  resolveJsType,
  tagName
};
//# sourceMappingURL=helpers.js.map
