{"version":3,"file":"helpers.js","sources":["../../src/util/resolveJsType.ts","../../src/equality.ts","../../src/types.ts","../../src/HtmlDeserializer/flatten-nested-blocks.ts","../../src/constants.ts","../../src/HtmlDeserializer/helpers.ts"],"sourcesContent":["const objectToString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (objectToString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","export function isEqualMarks(\n  a: Array<string> | undefined,\n  b: Array<string> | undefined,\n): boolean {\n  if (!a || !b) {\n    return a === b\n  }\n\n  if (a.length !== b.length) {\n    return false\n  }\n\n  for (let index = 0; index < a.length; index++) {\n    if (a[index] !== b[index]) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * More or less copied from Remeda (https://github.com/remeda/remeda/blob/main/packages/remeda/src/isDeepEqual.ts)\n */\nexport function isDeepEqual<A, B>(data: A, other: B) {\n  return isDeepEqualImplementation(data, other)\n}\n\nfunction isDeepEqualImplementation<T>(data: unknown, other: T): data is T {\n  if (data === other) {\n    return true\n  }\n\n  if (Object.is(data, other)) {\n    // We want to ignore the slight differences between `===` and `Object.is` as\n    // both of them largely define equality from a semantic point-of-view.\n    return true\n  }\n\n  if (typeof data !== 'object' || typeof other !== 'object') {\n    return false\n  }\n\n  if (data === null || other === null) {\n    return false\n  }\n\n  if (Object.getPrototypeOf(data) !== Object.getPrototypeOf(other)) {\n    // If the objects don't share a prototype it's unlikely that they are\n    // semantically equal. It is technically possible to build 2 prototypes that\n    // act the same but are not equal (at the reference level, checked via\n    // `===`) and then create 2 objects that are equal although we would fail on\n    // them. Because this is so unlikely, the optimization we gain here for the\n    // rest of the function by assuming that `other` is of the same type as\n    // `data` is more than worth it.\n    return false\n  }\n\n  if (Array.isArray(data)) {\n    return isDeepEqualArrays(data, other as unknown as ReadonlyArray<unknown>)\n  }\n\n  if (data instanceof Map) {\n    return isDeepEqualMaps(data, other as unknown as Map<unknown, unknown>)\n  }\n\n  if (data instanceof Set) {\n    return isDeepEqualSets(data, other as unknown as Set<unknown>)\n  }\n\n  if (data instanceof Date) {\n    return data.getTime() === (other as unknown as Date).getTime()\n  }\n\n  if (data instanceof RegExp) {\n    return data.toString() === (other as unknown as RegExp).toString()\n  }\n\n  // At this point we only know that the 2 objects share a prototype and are not\n  // any of the previous types. They could be plain objects (Object.prototype),\n  // they could be classes, they could be other built-ins, or they could be\n  // something weird. We assume that comparing values by keys is enough to judge\n  // their equality.\n\n  if (Object.keys(data).length !== Object.keys(other).length) {\n    return false\n  }\n\n  for (const [key, value] of Object.entries(data)) {\n    if (!(key in other)) {\n      return false\n    }\n\n    if (\n      !isDeepEqualImplementation(\n        value,\n        // @ts-expect-error [ts7053] - We already checked that `other` has `key`\n        other[key],\n      )\n    ) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualArrays(\n  data: ReadonlyArray<unknown>,\n  other: ReadonlyArray<unknown>,\n): boolean {\n  if (data.length !== other.length) {\n    return false\n  }\n\n  for (const [index, item] of data.entries()) {\n    if (!isDeepEqualImplementation(item, other[index])) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualMaps(\n  data: ReadonlyMap<unknown, unknown>,\n  other: ReadonlyMap<unknown, unknown>,\n): boolean {\n  if (data.size !== other.size) {\n    return false\n  }\n\n  for (const [key, value] of data.entries()) {\n    if (!other.has(key)) {\n      return false\n    }\n\n    if (!isDeepEqualImplementation(value, other.get(key))) {\n      return false\n    }\n  }\n\n  return true\n}\n\nfunction isDeepEqualSets(\n  data: ReadonlySet<unknown>,\n  other: ReadonlySet<unknown>,\n): boolean {\n  if (data.size !== other.size) {\n    return false\n  }\n\n  // To ensure we only count each item once we need to \"remember\" which items of\n  // the other set we've already matched against. We do this by creating a copy\n  // of the other set and removing items from it as we find them in the data\n  // set.\n  const otherCopy = [...other]\n\n  for (const dataItem of data) {\n    let isFound = false\n\n    for (const [index, otherItem] of otherCopy.entries()) {\n      if (isDeepEqualImplementation(dataItem, otherItem)) {\n        isFound = true\n        otherCopy.splice(index, 1)\n        break\n      }\n    }\n\n    if (!isFound) {\n      return false\n    }\n  }\n\n  return true\n}\n","import type {PortableTextObject} from '@portabletext/schema'\nimport type {SchemaMatchers} from './schema-matchers'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  _type: string\n  _key?: string\n}\n\n/**\n * @public\n */\nexport interface ArbitraryTypedObject extends TypedObject {\n  [key: string]: unknown\n}\n\nexport function isArbitraryTypedObject(\n  object: unknown,\n): object is ArbitraryTypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\nexport interface MinimalSpan {\n  _type: 'span'\n  _key?: string\n  text: string\n  marks?: string[]\n}\n\nexport interface MinimalBlock extends TypedObject {\n  _type: 'block'\n  children: TypedObject[]\n  markDefs?: TypedObject[]\n  style?: string\n  level?: number\n  listItem?: string\n}\n\nexport interface PlaceholderDecorator {\n  _type: '__decorator'\n  name: string\n  children: TypedObject[]\n}\n\nexport interface PlaceholderAnnotation {\n  _type: '__annotation'\n  markDef: PortableTextObject\n  children: TypedObject[]\n}\n\n/**\n * @public\n */\nexport type HtmlParser = (html: string) => Document\n\n/**\n * @public\n */\nexport type WhiteSpacePasteMode = 'preserve' | 'remove' | 'normalize'\n\n/**\n * @public\n */\nexport interface HtmlDeserializerOptions {\n  keyGenerator?: () => string\n  rules?: DeserializerRule[]\n  parseHtml?: HtmlParser\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n  /**\n   * Custom schema matchers to use when deserializing HTML to Portable Text.\n   * @beta\n   */\n  matchers?: SchemaMatchers\n}\n\nexport interface HtmlPreprocessorOptions {\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n}\n\n/**\n * @public\n */\nexport interface DeserializerRule {\n  deserialize: (\n    el: Node,\n    next: (\n      elements: Node | Node[] | NodeList,\n    ) => TypedObject | TypedObject[] | undefined,\n    createBlock: (props: ArbitraryTypedObject) => {\n      _type: string\n      block: ArbitraryTypedObject\n    },\n  ) => TypedObject | TypedObject[] | undefined\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isDeepEqual} from '../equality'\nimport {\n  isArbitraryTypedObject,\n  type ArbitraryTypedObject,\n  type TypedObject,\n} from '../types'\n\nexport function flattenNestedBlocks(\n  context: {\n    schema: Schema\n  },\n  blocks: Array<ArbitraryTypedObject>,\n): TypedObject[] {\n  const flattened = blocks.flatMap((block) => {\n    if (isBlockContainer(block)) {\n      return flattenNestedBlocks(context, [block.block])\n    }\n\n    if (isTextBlock(context, block)) {\n      const hasBlockObjects = block.children.some((child) => {\n        const knownBlockObject = context.schema.blockObjects.some(\n          (blockObject) => blockObject.name === child._type,\n        )\n        return knownBlockObject\n      })\n      const hasBlocks = block.children.some(\n        (child) => child._type === '__block' || child._type === 'block',\n      )\n\n      if (hasBlockObjects || hasBlocks) {\n        const splitChildren = getSplitChildren(context, block)\n\n        if (\n          splitChildren.length === 1 &&\n          splitChildren[0].type === 'children' &&\n          isDeepEqual(splitChildren[0].children, block.children)\n        ) {\n          return [block]\n        }\n\n        return splitChildren.flatMap((slice) => {\n          if (slice.type === 'block object') {\n            return [slice.block]\n          }\n\n          if (slice.type === 'block') {\n            return flattenNestedBlocks(context, [\n              slice.block as ArbitraryTypedObject,\n            ])\n          }\n\n          if (slice.children.length > 0) {\n            if (\n              slice.children.every(\n                (child) => isSpan(context, child) && child.text.trim() === '',\n              )\n            ) {\n              return []\n            }\n\n            return flattenNestedBlocks(context, [\n              {\n                ...block,\n                children: slice.children,\n              },\n            ])\n          }\n\n          return []\n        })\n      }\n\n      return [block]\n    }\n\n    return [block]\n  })\n\n  return flattened\n}\n\nfunction isBlockContainer(\n  block: ArbitraryTypedObject,\n): block is BlockContainer {\n  return block._type === '__block' && isArbitraryTypedObject(block.block)\n}\n\ntype BlockContainer = {\n  _type: '__block'\n  block: ArbitraryTypedObject\n}\n\nfunction getSplitChildren(\n  context: {schema: Schema},\n  block: PortableTextTextBlock,\n) {\n  return block.children.reduce(\n    (slices, child) => {\n      const knownInlineObject = context.schema.inlineObjects.some(\n        (inlineObject) => inlineObject.name === child._type,\n      )\n      const knownBlockObject = context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type,\n      )\n\n      const lastSlice = slices.pop()\n\n      if (!isSpan(context, child) && !knownInlineObject) {\n        if (knownBlockObject) {\n          return [\n            ...slices,\n            ...(lastSlice ? [lastSlice] : []),\n            {type: 'block object' as const, block: child},\n          ]\n        }\n      }\n\n      if (child._type === '__block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {\n            type: 'block object' as const,\n            block: (child as any).block,\n          },\n        ]\n      }\n\n      if (child._type === 'block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {type: 'block' as const, block: child},\n        ]\n      }\n\n      if (lastSlice) {\n        if (lastSlice.type === 'children') {\n          return [\n            ...slices,\n            {\n              type: 'children' as const,\n              children: [...lastSlice.children, child],\n            },\n          ]\n        }\n      }\n\n      return [\n        ...slices,\n        ...(lastSlice ? [lastSlice] : []),\n        {type: 'children' as const, children: [child]},\n      ]\n    },\n    [] as Array<\n      | {\n          type: 'children'\n          children: Array<PortableTextSpan | PortableTextObject>\n        }\n      | {type: 'block object'; block: PortableTextObject}\n      | {type: 'block'; block: PortableTextBlock}\n    >,\n  )\n}\n","export interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<\n  string,\n  {object: null} | undefined\n> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = [\n  ...new Set(\n    Object.values(ELEMENT_MAP)\n      .filter((tag): tag is PartialBlock => 'style' in tag)\n      .map((tag) => tag.style),\n  ),\n]\n\nexport const DEFAULT_SUPPORTED_DECORATORS = [\n  ...new Set(Object.values(HTML_DECORATOR_TAGS)),\n]\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","import type {Schema} from '@portabletext/schema'\nimport {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport {DEFAULT_BLOCK} from '../constants'\nimport type {\n  ArbitraryTypedObject,\n  HtmlParser,\n  MinimalBlock,\n  MinimalSpan,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {resolveJsType} from '../util/resolveJsType'\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nexport function ensureRootIsBlocks(\n  schema: Schema,\n  objects: Array<ArbitraryTypedObject>,\n): ArbitraryTypedObject[] {\n  return objects.reduce((blocks, node, i, original) => {\n    if (node._type === 'block') {\n      blocks.push(node)\n      return blocks\n    }\n\n    if (node._type === '__block') {\n      blocks.push((node as any).block)\n      return blocks\n    }\n\n    const lastBlock = blocks[blocks.length - 1]\n    if (\n      i > 0 &&\n      !isTextBlock({schema}, original[i - 1]) &&\n      isTextBlock({schema}, lastBlock)\n    ) {\n      lastBlock.children.push(node as PortableTextObject)\n      return blocks\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    blocks.push(block)\n    return blocks\n  }, [] as ArbitraryTypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) === '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(\n  node: TypedObject,\n): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(\n  node: TypedObject,\n): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n"],"names":[],"mappings":"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"}