function compileSchema(definition) {
  const styles = (definition.styles ?? []).map((style) => ({
    ...style,
    value: style.name
  })), blockFields = [];
  if (definition.block?.fields)
    for (const field of definition.block.fields) {
      if (field.name === "_type" || field.name === "_key" || field.name === "children" || field.name === "markDefs" || field.name === "style" || field.name === "listItem" || field.name === "level") {
        console.warn(
          `"${field.name}" is a reserved field name on Portable Text blocks`
        );
        continue;
      }
      blockFields.push(field);
    }
  return {
    block: {
      name: definition.block?.name ?? "block",
      ...blockFields.length > 0 ? { fields: blockFields } : {}
    },
    span: {
      name: "span"
    },
    styles: styles.some((style) => style.value === "normal") ? styles : [{ value: "normal", name: "normal", title: "Normal" }, ...styles],
    lists: (definition.lists ?? []).map((list) => ({
      ...list,
      value: list.name
    })),
    decorators: (definition.decorators ?? []).map((decorator) => ({
      ...decorator,
      value: decorator.name
    })),
    annotations: (definition.annotations ?? []).map((annotation) => ({
      ...annotation,
      fields: annotation.fields ?? []
    })),
    blockObjects: (definition.blockObjects ?? []).map((blockObject) => ({
      ...blockObject,
      fields: blockObject.fields ?? []
    })),
    inlineObjects: (definition.inlineObjects ?? []).map((inlineObject) => ({
      ...inlineObject,
      fields: inlineObject.fields ?? []
    }))
  };
}
function defineSchema(definition) {
  return definition;
}
function isTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function isTextBlock(context, block) {
  return !(!isTypedObject(block) || block._type !== context.schema.block.name || !Array.isArray(block.children));
}
function isSpan(context, child) {
  return !(!isTypedObject(child) || child._type !== context.schema.span.name || typeof child.text != "string");
}
export {
  compileSchema,
  defineSchema,
  isSpan,
  isTextBlock,
  isTypedObject
};
//# sourceMappingURL=index.js.map
