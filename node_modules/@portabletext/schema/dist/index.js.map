{"version":3,"file":"index.js","sources":["../src/compile-schema.ts","../src/define-schema.ts","../src/types.ts"],"sourcesContent":["import type {SchemaDefinition} from './define-schema'\nimport type {FieldDefinition, Schema} from './schema'\n\n/**\n * @public\n */\nexport function compileSchema(definition: SchemaDefinition): Schema {\n  const styles = (definition.styles ?? []).map((style) => ({\n    ...style,\n    value: style.name,\n  }))\n\n  const blockFields: Array<FieldDefinition> = []\n\n  if (definition.block?.fields) {\n    for (const field of definition.block.fields) {\n      if (\n        field.name === '_type' ||\n        field.name === '_key' ||\n        field.name === 'children' ||\n        field.name === 'markDefs' ||\n        field.name === 'style' ||\n        field.name === 'listItem' ||\n        field.name === 'level'\n      ) {\n        console.warn(\n          `\"${field.name}\" is a reserved field name on Portable Text blocks`,\n        )\n        continue\n      }\n\n      blockFields.push(field)\n    }\n  }\n\n  return {\n    block: {\n      name: definition.block?.name ?? 'block',\n      ...(blockFields.length > 0 ? {fields: blockFields} : {}),\n    },\n    span: {\n      name: 'span',\n    },\n    styles: !styles.some((style) => style.value === 'normal')\n      ? [{value: 'normal', name: 'normal', title: 'Normal'}, ...styles]\n      : styles,\n    lists: (definition.lists ?? []).map((list) => ({\n      ...list,\n      value: list.name,\n    })),\n    decorators: (definition.decorators ?? []).map((decorator) => ({\n      ...decorator,\n      value: decorator.name,\n    })),\n    annotations: (definition.annotations ?? []).map((annotation) => ({\n      ...annotation,\n      fields: annotation.fields ?? [],\n    })),\n    blockObjects: (definition.blockObjects ?? []).map((blockObject) => ({\n      ...blockObject,\n      fields: blockObject.fields ?? [],\n    })),\n    inlineObjects: (definition.inlineObjects ?? []).map((inlineObject) => ({\n      ...inlineObject,\n      fields: inlineObject.fields ?? [],\n    })),\n  }\n}\n","import type {BaseDefinition, FieldDefinition} from './schema'\n\n/**\n * @public\n */\nexport type SchemaDefinition = {\n  block?: {\n    name?: string\n    fields?: ReadonlyArray<FieldDefinition>\n  }\n  styles?: ReadonlyArray<StyleDefinition>\n  lists?: ReadonlyArray<ListDefinition>\n  decorators?: ReadonlyArray<DecoratorDefinition>\n  annotations?: ReadonlyArray<AnnotationDefinition>\n  blockObjects?: ReadonlyArray<BlockObjectDefinition>\n  inlineObjects?: ReadonlyArray<InlineObjectDefinition>\n}\n\n/**\n * @public\n * A helper wrapper that adds editor support, such as autocomplete and type checking, for a schema definition.\n * @example\n * ```ts\n * import { defineSchema } from '@portabletext/editor'\n *\n * const schemaDefinition = defineSchema({\n *  decorators: [{name: 'strong'}, {name: 'em'}, {name: 'underline'}],\n *  annotations: [{name: 'link'}],\n *  styles: [\n *    {name: 'normal'},\n *    {name: 'h1'},\n *    {name: 'h2'},\n *    {name: 'h3'},\n *    {name: 'blockquote'},\n *  ],\n *  lists: [],\n *  inlineObjects: [],\n *  blockObjects: [],\n * }\n * ```\n */\nexport function defineSchema<const TSchemaDefinition extends SchemaDefinition>(\n  definition: TSchemaDefinition,\n): TSchemaDefinition {\n  return definition\n}\n\n/**\n * @public\n */\nexport type StyleDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type ListDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type DecoratorDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type AnnotationDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type BlockObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type InlineObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n","import type {Schema} from './schema'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  [key: string]: unknown\n  _type: string\n}\n\n/**\n * @public\n */\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type PortableTextBlock = PortableTextTextBlock | PortableTextObject\n\n/**\n * @public\n */\nexport interface PortableTextTextBlock<\n  TChild = PortableTextSpan | PortableTextObject,\n> {\n  _type: string\n  _key: string\n  children: TChild[]\n  markDefs?: PortableTextObject[]\n  listItem?: string\n  style?: string\n  level?: number\n}\n\n/**\n * @public\n */\nexport function isTextBlock(\n  context: {schema: Schema},\n  block: unknown,\n): block is PortableTextTextBlock {\n  if (!isTypedObject(block)) {\n    return false\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return false\n  }\n\n  if (!Array.isArray(block.children)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextSpan {\n  _key: string\n  _type: 'span'\n  text: string\n  marks?: string[]\n}\n\n/**\n * @public\n */\nexport function isSpan(\n  context: {schema: Schema},\n  child: unknown,\n): child is PortableTextSpan {\n  if (!isTypedObject(child)) {\n    return false\n  }\n\n  if (child._type !== context.schema.span.name) {\n    return false\n  }\n\n  if (typeof child.text !== 'string') {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextObject {\n  _type: string\n  _key: string\n  [other: string]: unknown\n}\n\n/**\n * @public\n */\nexport type PortableTextChild = PortableTextSpan | PortableTextObject\n\n/**\n * @public\n */\nexport interface PortableTextListBlock extends PortableTextTextBlock {\n  listItem: string\n  level: number\n}\n"],"names":[],"mappings":"AAMO,SAAS,cAAc,YAAsC;AAClE,QAAM,UAAU,WAAW,UAAU,CAAA,GAAI,IAAI,CAAC,WAAW;AAAA,IACvD,GAAG;AAAA,IACH,OAAO,MAAM;AAAA,EAAA,EACb,GAEI,cAAsC,CAAA;AAE5C,MAAI,WAAW,OAAO;AACpB,eAAW,SAAS,WAAW,MAAM,QAAQ;AAC3C,UACE,MAAM,SAAS,WACf,MAAM,SAAS,UACf,MAAM,SAAS,cACf,MAAM,SAAS,cACf,MAAM,SAAS,WACf,MAAM,SAAS,cACf,MAAM,SAAS,SACf;AACA,gBAAQ;AAAA,UACN,IAAI,MAAM,IAAI;AAAA,QAAA;AAEhB;AAAA,MACF;AAEA,kBAAY,KAAK,KAAK;AAAA,IACxB;AAGF,SAAO;AAAA,IACL,OAAO;AAAA,MACL,MAAM,WAAW,OAAO,QAAQ;AAAA,MAChC,GAAI,YAAY,SAAS,IAAI,EAAC,QAAQ,YAAA,IAAe,CAAA;AAAA,IAAC;AAAA,IAExD,MAAM;AAAA,MACJ,MAAM;AAAA,IAAA;AAAA,IAER,QAAS,OAAO,KAAK,CAAC,UAAU,MAAM,UAAU,QAAQ,IAEpD,SADA,CAAC,EAAC,OAAO,UAAU,MAAM,UAAU,OAAO,SAAA,GAAW,GAAG,MAAM;AAAA,IAElE,QAAQ,WAAW,SAAS,CAAA,GAAI,IAAI,CAAC,UAAU;AAAA,MAC7C,GAAG;AAAA,MACH,OAAO,KAAK;AAAA,IAAA,EACZ;AAAA,IACF,aAAa,WAAW,cAAc,CAAA,GAAI,IAAI,CAAC,eAAe;AAAA,MAC5D,GAAG;AAAA,MACH,OAAO,UAAU;AAAA,IAAA,EACjB;AAAA,IACF,cAAc,WAAW,eAAe,CAAA,GAAI,IAAI,CAAC,gBAAgB;AAAA,MAC/D,GAAG;AAAA,MACH,QAAQ,WAAW,UAAU,CAAA;AAAA,IAAC,EAC9B;AAAA,IACF,eAAe,WAAW,gBAAgB,CAAA,GAAI,IAAI,CAAC,iBAAiB;AAAA,MAClE,GAAG;AAAA,MACH,QAAQ,YAAY,UAAU,CAAA;AAAA,IAAC,EAC/B;AAAA,IACF,gBAAgB,WAAW,iBAAiB,CAAA,GAAI,IAAI,CAAC,kBAAkB;AAAA,MACrE,GAAG;AAAA,MACH,QAAQ,aAAa,UAAU,CAAA;AAAA,IAAC,EAChC;AAAA,EAAA;AAEN;AC1BO,SAAS,aACd,YACmB;AACnB,SAAO;AACT;AChCO,SAAS,cAAc,QAAwC;AACpE,SAAO,SAAS,MAAM,KAAK,OAAO,OAAO,SAAU;AACrD;AAEA,SAAS,SAAS,OAAkD;AAClE,SAAO,CAAC,CAAC,UAAU,OAAO,SAAU,YAAY,OAAO,SAAU;AACnE;AAyBO,SAAS,YACd,SACA,OACgC;AAShC,SARI,EAAA,CAAC,cAAc,KAAK,KAIpB,MAAM,UAAU,QAAQ,OAAO,MAAM,QAIrC,CAAC,MAAM,QAAQ,MAAM,QAAQ;AAKnC;AAeO,SAAS,OACd,SACA,OAC2B;AAS3B,SARI,EAAA,CAAC,cAAc,KAAK,KAIpB,MAAM,UAAU,QAAQ,OAAO,KAAK,QAIpC,OAAO,MAAM,QAAS;AAK5B;"}