{"version":3,"file":"index.js","sources":["../../src/utils/util.block-offset-to-block-selection-point.ts","../../src/utils/util.block-offset-to-selection-point.ts","../../src/utils/util.block-offsets-to-selection.ts","../../src/utils/util.child-selection-point-to-block-offset.ts","../../src/utils/util.is-equal-selections.ts","../../src/utils/util.merge-text-blocks.ts","../../src/utils/util.reverse-selection.ts","../../src/utils/util.selection-point-to-block-offset.ts","../../src/utils/util.split-text-block.ts"],"sourcesContent":["import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function blockOffsetToBlockSelectionPoint({\n  context,\n  blockOffset,\n}: {\n  context: Pick<EditorContext, 'value'>\n  blockOffset: BlockOffset\n}): EditorSelectionPoint | undefined {\n  let selectionPoint: EditorSelectionPoint | undefined\n\n  for (const block of context.value) {\n    if (block._key === blockOffset.path[0]._key) {\n      selectionPoint = {\n        path: [{_key: block._key}],\n        offset: blockOffset.offset,\n      }\n      break\n    }\n  }\n\n  return selectionPoint\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {blockOffsetToSpanSelectionPoint} from './util.block-offset'\nimport {blockOffsetToBlockSelectionPoint} from './util.block-offset-to-block-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetToSelectionPoint({\n  context,\n  blockOffset,\n  direction,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  blockOffset: BlockOffset\n  direction: 'forward' | 'backward'\n}): EditorSelectionPoint | undefined {\n  const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context,\n    blockOffset,\n    direction,\n  })\n\n  if (!spanSelectionPoint) {\n    return blockOffsetToBlockSelectionPoint({\n      context,\n      blockOffset,\n    })\n  }\n\n  return spanSelectionPoint\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {blockOffsetToSelectionPoint} from './util.block-offset-to-selection-point'\n\n/**\n * @public\n */\nexport function blockOffsetsToSelection({\n  context,\n  offsets,\n  backward,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  offsets: {anchor: BlockOffset; focus: BlockOffset}\n  backward?: boolean\n}): EditorSelection {\n  const anchor = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.anchor,\n    direction: backward ? 'backward' : 'forward',\n  })\n  const focus = blockOffsetToSelectionPoint({\n    context,\n    blockOffset: offsets.focus,\n    direction: backward ? 'forward' : 'backward',\n  })\n\n  if (!anchor || !focus) {\n    return null\n  }\n\n  return {\n    anchor,\n    focus,\n    backward,\n  }\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\n/**\n * @public\n */\nexport function childSelectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n  const childKey = getChildKeyFromSelectionPoint(selectionPoint)\n\n  if (!blockKey || !childKey) {\n    return undefined\n  }\n\n  for (const block of context.value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isTextBlock(context, block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (child._key === childKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      if (isSpan(context, child)) {\n        offset += child.text.length\n      }\n    }\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from './util.is-equal-selection-points'\n\n/**\n * @public\n */\nexport function isEqualSelections(a: EditorSelection, b: EditorSelection) {\n  if (!a && !b) {\n    return true\n  }\n\n  if (!a || !b) {\n    return false\n  }\n\n  return (\n    isEqualSelectionPoints(a.anchor, b.anchor) &&\n    isEqualSelectionPoints(a.focus, b.focus)\n  )\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {parseBlock} from './parse-blocks'\n\n/**\n * @beta\n */\nexport function mergeTextBlocks({\n  context,\n  targetBlock,\n  incomingBlock,\n}: {\n  context: Pick<EditorContext, 'keyGenerator' | 'schema'>\n  targetBlock: PortableTextTextBlock\n  incomingBlock: PortableTextTextBlock\n}) {\n  const parsedIncomingBlock = parseBlock({\n    context,\n    block: incomingBlock,\n    options: {\n      normalize: false,\n      removeUnusedMarkDefs: true,\n      validateFields: false,\n    },\n  })\n\n  if (!parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock)) {\n    return targetBlock\n  }\n\n  return {\n    ...targetBlock,\n    children: [...targetBlock.children, ...parsedIncomingBlock.children],\n    markDefs: [\n      ...(targetBlock.markDefs ?? []),\n      ...(parsedIncomingBlock.markDefs ?? []),\n    ],\n  }\n}\n","import type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport function reverseSelection<\n  TEditorSelection extends NonNullable<EditorSelection> | null,\n>(selection: TEditorSelection): TEditorSelection {\n  if (!selection) {\n    return selection\n  }\n\n  if (selection.backward) {\n    return {\n      anchor: selection.focus,\n      focus: selection.anchor,\n      backward: false,\n    } as TEditorSelection\n  }\n\n  return {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: true,\n  } as TEditorSelection\n}\n","import type {EditorContext} from '../editor/editor-snapshot'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {childSelectionPointToBlockOffset} from './util.child-selection-point-to-block-offset'\nimport {getBlockKeyFromSelectionPoint} from './util.selection-point'\n\n/**\n * @public\n */\nexport function selectionPointToBlockOffset({\n  context,\n  selectionPoint,\n}: {\n  context: Pick<EditorContext, 'schema' | 'value'>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint)\n\n  if (selectionPoint.path.length === 1 && blockKey !== undefined) {\n    return {\n      path: [{_key: blockKey}],\n      offset: selectionPoint.offset,\n    }\n  }\n\n  return childSelectionPointToBlockOffset({\n    context,\n    selectionPoint,\n  })\n}\n","import {isSpan, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {sliceTextBlock} from './util.slice-text-block'\n\n/**\n * @beta\n */\nexport function splitTextBlock({\n  context,\n  block,\n  point,\n}: {\n  context: Pick<EditorContext, 'schema'>\n  block: PortableTextTextBlock\n  point: EditorSelectionPoint\n}): {before: PortableTextTextBlock; after: PortableTextTextBlock} | undefined {\n  const firstChild = block.children.at(0)\n  const lastChild = block.children.at(block.children.length - 1)\n\n  if (!firstChild || !lastChild) {\n    return undefined\n  }\n\n  const before = sliceTextBlock({\n    context: {\n      schema: context.schema,\n      selection: {\n        anchor: {\n          path: [{_key: block._key}, 'children', {_key: firstChild._key}],\n          offset: 0,\n        },\n        focus: point,\n      },\n    },\n    block,\n  })\n  const after = sliceTextBlock({\n    context: {\n      schema: context.schema,\n      selection: {\n        anchor: point,\n        focus: {\n          path: [{_key: block._key}, 'children', {_key: lastChild._key}],\n          offset: isSpan(context, lastChild) ? lastChild.text.length : 0,\n        },\n      },\n    },\n    block,\n  })\n\n  return {before, after}\n}\n"],"names":["blockOffsetToBlockSelectionPoint","context","blockOffset","selectionPoint","block","value","_key","path","offset","blockOffsetToSelectionPoint","direction","blockOffsetToSpanSelectionPoint","blockOffsetsToSelection","offsets","backward","anchor","focus","childSelectionPointToBlockOffset","blockKey","getBlockKeyFromSelectionPoint","childKey","getChildKeyFromSelectionPoint","isTextBlock","child","children","isSpan","text","length","isEqualSelections","a","b","isEqualSelectionPoints","mergeTextBlocks","targetBlock","incomingBlock","parsedIncomingBlock","parseBlock","options","normalize","removeUnusedMarkDefs","validateFields","markDefs","reverseSelection","selection","selectionPointToBlockOffset","undefined","splitTextBlock","point","firstChild","at","lastChild","before","sliceTextBlock","schema","after"],"mappings":";;;;;;AAOO,SAASA,iCAAiC;AAAA,EAC/CC;AAAAA,EACAC;AAIF,GAAqC;AACnC,MAAIC;AAEJ,aAAWC,SAASH,QAAQI;AAC1B,QAAID,MAAME,SAASJ,YAAYK,KAAK,CAAC,EAAED,MAAM;AAC3CH,uBAAiB;AAAA,QACfI,MAAM,CAAC;AAAA,UAACD,MAAMF,MAAME;AAAAA,QAAAA,CAAK;AAAA,QACzBE,QAAQN,YAAYM;AAAAA,MAAAA;AAEtB;AAAA,IACF;AAGF,SAAOL;AACT;AClBO,SAASM,4BAA4B;AAAA,EAC1CR;AAAAA,EACAC;AAAAA,EACAQ;AAKF,GAAqC;AAOnC,SAN2BC,gCAAgC;AAAA,IACzDV;AAAAA,IACAC;AAAAA,IACAQ;AAAAA,EAAAA,CACD,KAGQV,iCAAiC;AAAA,IACtCC;AAAAA,IACAC;AAAAA,EAAAA,CACD;AAIL;ACxBO,SAASU,wBAAwB;AAAA,EACtCX;AAAAA,EACAY;AAAAA,EACAC;AAKF,GAAoB;AAClB,QAAMC,SAASN,4BAA4B;AAAA,IACzCR;AAAAA,IACAC,aAAaW,QAAQE;AAAAA,IACrBL,WAAWI,WAAW,aAAa;AAAA,EAAA,CACpC,GACKE,QAAQP,4BAA4B;AAAA,IACxCR;AAAAA,IACAC,aAAaW,QAAQG;AAAAA,IACrBN,WAAWI,WAAW,YAAY;AAAA,EAAA,CACnC;AAED,SAAI,CAACC,UAAU,CAACC,QACP,OAGF;AAAA,IACLD;AAAAA,IACAC;AAAAA,IACAF;AAAAA,EAAAA;AAEJ;ACzBO,SAASG,iCAAiC;AAAA,EAC/ChB;AAAAA,EACAE;AAIF,GAA4B;AAC1B,MAAIK,SAAS;AAEb,QAAMU,WAAWC,8BAA8BhB,cAAc,GACvDiB,WAAWC,8BAA8BlB,cAAc;AAE7D,MAAI,EAAA,CAACe,YAAY,CAACE;AAIlB,eAAWhB,SAASH,QAAQI;AAC1B,UAAID,MAAME,SAASY,YAIdI,YAAYrB,SAASG,KAAK;AAI/B,mBAAWmB,SAASnB,MAAMoB,UAAU;AAClC,cAAID,MAAMjB,SAASc;AACjB,mBAAO;AAAA,cACLb,MAAM,CAAC;AAAA,gBAACD,MAAMF,MAAME;AAAAA,cAAAA,CAAK;AAAA,cACzBE,QAAQA,SAASL,eAAeK;AAAAA,YAAAA;AAIhCiB,iBAAOxB,SAASsB,KAAK,MACvBf,UAAUe,MAAMG,KAAKC;AAAAA,QAEzB;AAAA;AAEJ;AC5CO,SAASC,kBAAkBC,GAAoBC,GAAoB;AACxE,SAAI,CAACD,KAAK,CAACC,IACF,KAGL,CAACD,KAAK,CAACC,IACF,KAIPC,uBAAuBF,EAAEd,QAAQe,EAAEf,MAAM,KACzCgB,uBAAuBF,EAAEb,OAAOc,EAAEd,KAAK;AAE3C;ACZO,SAASgB,gBAAgB;AAAA,EAC9B/B;AAAAA,EACAgC;AAAAA,EACAC;AAKF,GAAG;AACD,QAAMC,sBAAsBC,WAAW;AAAA,IACrCnC;AAAAA,IACAG,OAAO8B;AAAAA,IACPG,SAAS;AAAA,MACPC,WAAW;AAAA,MACXC,sBAAsB;AAAA,MACtBC,gBAAgB;AAAA,IAAA;AAAA,EAClB,CACD;AAED,SAAI,CAACL,uBAAuB,CAACb,YAAYrB,SAASkC,mBAAmB,IAC5DF,cAGF;AAAA,IACL,GAAGA;AAAAA,IACHT,UAAU,CAAC,GAAGS,YAAYT,UAAU,GAAGW,oBAAoBX,QAAQ;AAAA,IACnEiB,UAAU,CACR,GAAIR,YAAYQ,YAAY,CAAA,GAC5B,GAAIN,oBAAoBM,YAAY,CAAA,CAAG;AAAA,EAAA;AAG7C;ACjCO,SAASC,iBAEdC,WAA+C;AAC/C,SAAKA,cAIDA,UAAU7B,WACL;AAAA,IACLC,QAAQ4B,UAAU3B;AAAAA,IAClBA,OAAO2B,UAAU5B;AAAAA,IACjBD,UAAU;AAAA,EAAA,IAIP;AAAA,IACLC,QAAQ4B,UAAU3B;AAAAA,IAClBA,OAAO2B,UAAU5B;AAAAA,IACjBD,UAAU;AAAA,EAAA;AAEd;AChBO,SAAS8B,4BAA4B;AAAA,EAC1C3C;AAAAA,EACAE;AAIF,GAA4B;AAC1B,QAAMe,WAAWC,8BAA8BhB,cAAc;AAE7D,SAAIA,eAAeI,KAAKoB,WAAW,KAAKT,aAAa2B,SAC5C;AAAA,IACLtC,MAAM,CAAC;AAAA,MAACD,MAAMY;AAAAA,IAAAA,CAAS;AAAA,IACvBV,QAAQL,eAAeK;AAAAA,EAAAA,IAIpBS,iCAAiC;AAAA,IACtChB;AAAAA,IACAE;AAAAA,EAAAA,CACD;AACH;ACrBO,SAAS2C,eAAe;AAAA,EAC7B7C;AAAAA,EACAG;AAAAA,EACA2C;AAKF,GAA8E;AAC5E,QAAMC,aAAa5C,MAAMoB,SAASyB,GAAG,CAAC,GAChCC,YAAY9C,MAAMoB,SAASyB,GAAG7C,MAAMoB,SAASG,SAAS,CAAC;AAE7D,MAAI,CAACqB,cAAc,CAACE;AAClB;AAGF,QAAMC,SAASC,eAAe;AAAA,IAC5BnD,SAAS;AAAA,MACPoD,QAAQpD,QAAQoD;AAAAA,MAChBV,WAAW;AAAA,QACT5B,QAAQ;AAAA,UACNR,MAAM,CAAC;AAAA,YAACD,MAAMF,MAAME;AAAAA,UAAAA,GAAO,YAAY;AAAA,YAACA,MAAM0C,WAAW1C;AAAAA,UAAAA,CAAK;AAAA,UAC9DE,QAAQ;AAAA,QAAA;AAAA,QAEVQ,OAAO+B;AAAAA,MAAAA;AAAAA,IACT;AAAA,IAEF3C;AAAAA,EAAAA,CACD,GACKkD,QAAQF,eAAe;AAAA,IAC3BnD,SAAS;AAAA,MACPoD,QAAQpD,QAAQoD;AAAAA,MAChBV,WAAW;AAAA,QACT5B,QAAQgC;AAAAA,QACR/B,OAAO;AAAA,UACLT,MAAM,CAAC;AAAA,YAACD,MAAMF,MAAME;AAAAA,UAAAA,GAAO,YAAY;AAAA,YAACA,MAAM4C,UAAU5C;AAAAA,UAAAA,CAAK;AAAA,UAC7DE,QAAQiB,OAAOxB,SAASiD,SAAS,IAAIA,UAAUxB,KAAKC,SAAS;AAAA,QAAA;AAAA,MAC/D;AAAA,IACF;AAAA,IAEFvB;AAAAA,EAAAA,CACD;AAED,SAAO;AAAA,IAAC+C;AAAAA,IAAQG;AAAAA,EAAAA;AAClB;"}