import { B as EditorSelector, F as BlockOffset, dt as EditorSelection, en as BlockPath, ft as EditorSelectionPoint, nn as KeyedSegment, tn as ChildPath } from "../_chunks-dts/behavior.types.action.js";
import { PortableTextBlock, PortableTextListBlock, PortableTextObject, PortableTextSpan, PortableTextTextBlock } from "@portabletext/schema";
/**
 * @public
 */
declare const getActiveAnnotations: EditorSelector<Array<PortableTextObject>>;
/**
 * @public
 */
declare const getActiveListItem: EditorSelector<PortableTextListBlock['listItem'] | undefined>;
/**
 * @public
 */
declare const getActiveStyle: EditorSelector<PortableTextTextBlock['style']>;
/**
 * @public
 */
declare const getAnchorBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getAnchorChild: EditorSelector<{
  node: PortableTextObject | PortableTextSpan;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getAnchorSpan: EditorSelector<{
  node: PortableTextSpan;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getAnchorTextBlock: EditorSelector<{
  node: PortableTextTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getBlockOffsets: EditorSelector<{
  start: BlockOffset;
  end: BlockOffset;
} | undefined>;
/**
 * @public
 * Returns the selection of the of the word the caret is placed in.
 * Note: Only returns a word selection if the current selection is collapsed
 */
declare const getCaretWordSelection: EditorSelector<EditorSelection>;
/**
 * @public
 */
declare const getFirstBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getFocusBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getFocusBlockObject: EditorSelector<{
  node: PortableTextObject;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getFocusChild: EditorSelector<{
  node: PortableTextObject | PortableTextSpan;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getFocusInlineObject: EditorSelector<{
  node: PortableTextObject;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getFocusListBlock: EditorSelector<{
  node: PortableTextListBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getFocusSpan: EditorSelector<{
  node: PortableTextSpan;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getFocusTextBlock: EditorSelector<{
  node: PortableTextTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getLastBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @beta
 */
type MarkState = {
  state: 'unchanged';
  marks: Array<string>;
} | {
  state: 'changed';
  marks: Array<string>;
  previousMarks: Array<string>;
};
/**
 * Given that text is inserted at the current position, what marks should
 * be applied?
 * @beta
 */
declare const getMarkState: EditorSelector<MarkState | undefined>;
/**
 * @public
 */
declare const getNextBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getNextInlineObject: EditorSelector<{
  node: PortableTextObject;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getNextInlineObjects: EditorSelector<Array<{
  node: PortableTextObject;
  path: ChildPath;
}>>;
/**
 * @public
 */
declare const getNextSpan: EditorSelector<{
  node: PortableTextSpan;
  path: [KeyedSegment, 'children', KeyedSegment];
} | undefined>;
/**
 * @public
 */
declare const getPreviousBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getPreviousInlineObject: EditorSelector<{
  node: PortableTextObject;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getPreviousInlineObjects: EditorSelector<Array<{
  node: PortableTextObject;
  path: ChildPath;
}>>;
/**
 * @public
 */
declare const getPreviousSpan: EditorSelector<{
  node: PortableTextSpan;
  path: [KeyedSegment, 'children', KeyedSegment];
} | undefined>;
/**
 * @public
 */
declare const getSelectedBlocks: EditorSelector<Array<{
  node: PortableTextBlock;
  path: BlockPath;
}>>;
/**
 * @public
 */
declare const getSelectedSpans: EditorSelector<Array<{
  node: PortableTextSpan;
  path: ChildPath;
}>>;
/**
 * @public
 */
declare const getSelectedTextBlocks: EditorSelector<Array<{
  node: PortableTextTextBlock;
  path: BlockPath;
}>>;
/**
 * @public
 */
declare const getSelectedValue: EditorSelector<Array<PortableTextBlock>>;
/**
 * @public
 */
declare const getSelection: EditorSelector<EditorSelection>;
/**
 * @public
 */
declare const getSelectionEndBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getSelectionEndChild: EditorSelector<{
  node: PortableTextSpan | PortableTextObject;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getSelectionEndPoint: EditorSelector<EditorSelectionPoint | undefined>;
/**
 * @public
 */
declare const getSelectionStartBlock: EditorSelector<{
  node: PortableTextBlock;
  path: BlockPath;
} | undefined>;
/**
 * @public
 */
declare const getSelectionStartChild: EditorSelector<{
  node: PortableTextSpan | PortableTextObject;
  path: ChildPath;
} | undefined>;
/**
 * @public
 */
declare const getSelectionStartPoint: EditorSelector<EditorSelectionPoint | undefined>;
/**
 * @public
 */
declare const getSelectionText: EditorSelector<string>;
/**
 * @public
 */
declare const getBlockTextAfter: EditorSelector<string>;
/**
 * @public
 */
declare const getBlockTextBefore: EditorSelector<string>;
/**
 * @public
 */
declare const getValue: EditorSelector<Array<PortableTextBlock>>;
/**
 * Check whether an annotation is active in the given `snapshot`.
 *
 * @public
 */
declare function isActiveAnnotation(annotation: string, options?: {
  /**
   * Choose whether the annotation has to take up the entire selection in the
   * `snapshot` or if the annotation can be partially selected.
   *
   * Defaults to 'full'
   */
  mode?: 'partial' | 'full';
}): EditorSelector<boolean>;
/**
 * @public
 */
declare function isActiveDecorator(decorator: string): EditorSelector<boolean>;
/**
 * @public
 */
declare function isActiveListItem(listItem: string): EditorSelector<boolean>;
/**
 * @public
 */
declare function isActiveStyle(style: string): EditorSelector<boolean>;
/**
 * @public
 */
declare function isAtTheEndOfBlock(block: {
  node: PortableTextBlock;
  path: BlockPath;
}): EditorSelector<boolean>;
/**
 * @public
 */
declare function isAtTheStartOfBlock(block: {
  node: PortableTextBlock;
  path: BlockPath;
}): EditorSelector<boolean>;
/**
 * @public
 */
declare function isOverlappingSelection(selection: EditorSelection): EditorSelector<boolean>;
/**
 * @public
 */
declare function isPointAfterSelection(point: EditorSelectionPoint): EditorSelector<boolean>;
/**
 * @public
 */
declare function isPointBeforeSelection(point: EditorSelectionPoint): EditorSelector<boolean>;
/**
 * @public
 */
declare const isSelectingEntireBlocks: EditorSelector<boolean>;
/**
 * @public
 */
declare const isSelectionCollapsed: EditorSelector<boolean>;
/**
 * @public
 */
declare const isSelectionExpanded: EditorSelector<boolean>;
export { type MarkState, getActiveAnnotations, getActiveListItem, getActiveStyle, getAnchorBlock, getAnchorChild, getAnchorSpan, getAnchorTextBlock, getBlockOffsets, getBlockTextAfter, getBlockTextBefore, getCaretWordSelection, getFirstBlock, getFocusBlock, getFocusBlockObject, getFocusChild, getFocusInlineObject, getFocusListBlock, getFocusSpan, getFocusTextBlock, getLastBlock, getMarkState, getNextBlock, getNextInlineObject, getNextInlineObjects, getNextSpan, getPreviousBlock, getPreviousInlineObject, getPreviousInlineObjects, getPreviousSpan, getSelectedBlocks, getSelectedSpans, getSelectedTextBlocks, getSelectedValue, getSelection, getSelectionEndBlock, getSelectionEndChild, getSelectionEndPoint, getSelectionStartBlock, getSelectionStartChild, getSelectionStartPoint, getSelectionText, getValue, isActiveAnnotation, isActiveDecorator, isActiveListItem, isActiveStyle, isAtTheEndOfBlock, isAtTheStartOfBlock, isOverlappingSelection, isPointAfterSelection, isPointBeforeSelection, isSelectingEntireBlocks, isSelectionCollapsed, isSelectionExpanded };