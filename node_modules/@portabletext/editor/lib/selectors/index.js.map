{"version":3,"file":"index.js","sources":["../../src/selectors/selector.get-anchor-block.ts","../../src/selectors/selector.get-anchor-text-block.ts","../../src/selectors/selector.get-anchor-child.ts","../../src/selectors/selector.get-anchor-span.ts","../../src/selectors/selector.get-block-offsets.ts","../../src/selectors/selector.get-first-block.ts","../../src/selectors/selector.get-next-inline-objects.ts","../../src/selectors/selector.get-previous-inline-objects.ts","../../src/selectors/selector.get-selection.ts","../../src/selectors/selector.get-text-after.ts","../../src/selectors/selector.get-text-before.ts","../../src/selectors/selector.get-value.ts"],"sourcesContent":["import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getAnchorBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = getBlockKeyFromSelectionPoint(snapshot.context.selection.anchor)\n  const index = key ? snapshot.blockIndexMap.get(key) : undefined\n  const node =\n    index !== undefined ? snapshot.context.value.at(index) : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getAnchorBlock} from './selector.get-anchor-block'\n\n/**\n * @public\n */\nexport const getAnchorTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const anchorBlock = getAnchorBlock(snapshot)\n\n  return anchorBlock && isTextBlock(snapshot.context, anchorBlock.node)\n    ? {node: anchorBlock.node, path: anchorBlock.path}\n    : undefined\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getAnchorTextBlock} from './selector.get-anchor-text-block'\n\n/**\n * @public\n */\nexport const getAnchorChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const anchorBlock = getAnchorTextBlock(snapshot)\n\n  if (!anchorBlock) {\n    return undefined\n  }\n\n  const key = getChildKeyFromSelectionPoint(snapshot.context.selection.anchor)\n\n  const node = key\n    ? anchorBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...anchorBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import {isSpan, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getAnchorChild} from './selector.get-anchor-child'\n\n/**\n * @public\n */\nexport const getAnchorSpan: EditorSelector<\n  {node: PortableTextSpan; path: ChildPath} | undefined\n> = (snapshot) => {\n  const anchorChild = getAnchorChild(snapshot)\n\n  return anchorChild && isSpan(snapshot.context, anchorChild.node)\n    ? {node: anchorChild.node, path: anchorChild.path}\n    : undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getBlockOffsets: EditorSelector<\n  {start: BlockOffset; end: BlockOffset} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionStartPoint || !selectionEndPoint) {\n    return undefined\n  }\n\n  const start = spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionStartPoint,\n  })\n  const end = spanSelectionPointToBlockOffset({\n    context: snapshot.context,\n    selectionPoint: selectionEndPoint,\n  })\n\n  return start && end ? {start, end} : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObjects: EditorSelector<\n  Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeyedSegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return []\n  }\n\n  let endPointChildFound = false\n  const inlineObjects: Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }> = []\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObjects.push({\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      })\n      break\n    }\n  }\n\n  return inlineObjects\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousInlineObjects: EditorSelector<\n  Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeyedSegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return []\n  }\n\n  const inlineObjects: Array<{\n    node: PortableTextObject\n    path: ChildPath\n  }> = []\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObjects.push({\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      })\n    }\n  }\n\n  return inlineObjects\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelection: EditorSelector<EditorSelection> = (snapshot) => {\n  return snapshot.context.selection\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusBlock} from './selector.get-focus-block'\nimport {getSelectionText} from './selector.get-selection-text'\n\n/**\n * @public\n */\nexport const getBlockTextAfter: EditorSelector<string> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return ''\n  }\n\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const block = getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n\n  if (!block) {\n    return ''\n  }\n\n  const endOfBlock = getBlockEndPoint({\n    context: snapshot.context,\n    block,\n  })\n\n  return getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endOfBlock,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusBlock} from './selector.get-focus-block'\nimport {getSelectionText} from './selector.get-selection-text'\n\n/**\n * @public\n */\nexport const getBlockTextBefore: EditorSelector<string> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return ''\n  }\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const block = getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n\n  if (!block) {\n    return ''\n  }\n\n  const startOfBlock = getBlockStartPoint({\n    context: snapshot.context,\n    block,\n  })\n\n  return getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startOfBlock,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  return snapshot.context.value\n}\n"],"names":["getAnchorBlock","snapshot","context","selection","key","getBlockKeyFromSelectionPoint","anchor","index","blockIndexMap","get","undefined","node","value","at","path","_key","getAnchorTextBlock","anchorBlock","isTextBlock","getAnchorChild","getChildKeyFromSelectionPoint","children","find","span","getAnchorSpan","anchorChild","isSpan","getBlockOffsets","selectionStartPoint","getSelectionStartPoint","selectionEndPoint","getSelectionEndPoint","start","spanSelectionPointToBlockOffset","selectionPoint","end","getFirstBlock","getNextInlineObjects","focusTextBlock","getFocusTextBlock","selectionEndPointChildKey","isKeyedSegment","endPointChildFound","inlineObjects","child","push","getPreviousInlineObjects","selectionStartPointChildKey","getSelection","getBlockTextAfter","endPoint","block","getFocusBlock","focus","endOfBlock","getBlockEndPoint","getSelectionText","getBlockTextBefore","startPoint","startOfBlock","getBlockStartPoint","getValue"],"mappings":";;;;AAQO,MAAMA,iBAERC,CAAAA,aAAa;AAChB,MAAI,CAACA,SAASC,QAAQC;AACpB;AAGF,QAAMC,MAAMC,8BAA8BJ,SAASC,QAAQC,UAAUG,MAAM,GACrEC,QAAQH,MAAMH,SAASO,cAAcC,IAAIL,GAAG,IAAIM,QAChDC,OACJJ,UAAUG,SAAYT,SAASC,QAAQU,MAAMC,GAAGN,KAAK,IAAIG;AAE3D,SAAOC,QAAQP,MAAM;AAAA,IAACO;AAAAA,IAAMG,MAAM,CAAC;AAAA,MAACC,MAAMX;AAAAA,IAAAA,CAAI;AAAA,EAAA,IAAKM;AACrD,GCbaM,qBAERf,CAAAA,aAAa;AAChB,QAAMgB,cAAcjB,eAAeC,QAAQ;AAE3C,SAAOgB,eAAeC,YAAYjB,SAASC,SAASe,YAAYN,IAAI,IAChE;AAAA,IAACA,MAAMM,YAAYN;AAAAA,IAAMG,MAAMG,YAAYH;AAAAA,EAAAA,IAC3CJ;AACN,GCPaS,iBAMRlB,CAAAA,aAAa;AAChB,MAAI,CAACA,SAASC,QAAQC;AACpB;AAGF,QAAMc,cAAcD,mBAAmBf,QAAQ;AAE/C,MAAI,CAACgB;AACH;AAGF,QAAMb,MAAMgB,8BAA8BnB,SAASC,QAAQC,UAAUG,MAAM,GAErEK,OAAOP,MACTa,YAAYN,KAAKU,SAASC,KAAMC,UAASA,KAAKR,SAASX,GAAG,IAC1DM;AAEJ,SAAOC,QAAQP,MACX;AAAA,IAACO;AAAAA,IAAMG,MAAM,CAAC,GAAGG,YAAYH,MAAM,YAAY;AAAA,MAACC,MAAMX;AAAAA,IAAAA,CAAI;AAAA,EAAA,IAC1DM;AACN,GC3Bac,gBAERvB,CAAAA,aAAa;AAChB,QAAMwB,cAAcN,eAAelB,QAAQ;AAE3C,SAAOwB,eAAeC,OAAOzB,SAASC,SAASuB,YAAYd,IAAI,IAC3D;AAAA,IAACA,MAAMc,YAAYd;AAAAA,IAAMG,MAAMW,YAAYX;AAAAA,EAAAA,IAC3CJ;AACN,GCPaiB,kBAER1B,CAAAA,aAAa;AAChB,MAAI,CAACA,SAASC,QAAQC;AACpB;AAGF,QAAMyB,sBAAsBC,uBAAuB5B,QAAQ,GACrD6B,oBAAoBC,qBAAqB9B,QAAQ;AAEvD,MAAI,CAAC2B,uBAAuB,CAACE;AAC3B;AAGF,QAAME,QAAQC,gCAAgC;AAAA,IAC5C/B,SAASD,SAASC;AAAAA,IAClBgC,gBAAgBN;AAAAA,EAAAA,CACjB,GACKO,MAAMF,gCAAgC;AAAA,IAC1C/B,SAASD,SAASC;AAAAA,IAClBgC,gBAAgBJ;AAAAA,EAAAA,CACjB;AAED,SAAOE,SAASG,MAAM;AAAA,IAACH;AAAAA,IAAOG;AAAAA,EAAAA,IAAOzB;AACvC,GC1Ba0B,gBAERnC,CAAAA,aAAa;AAChB,QAAMU,OAAOV,SAASC,QAAQU,MAAM,CAAC;AAErC,SAAOD,OAAO;AAAA,IAACA;AAAAA,IAAMG,MAAM,CAAC;AAAA,MAACC,MAAMJ,KAAKI;AAAAA,IAAAA,CAAK;AAAA,EAAA,IAAKL;AACpD,GCHa2B,uBAKRpC,CAAAA,aAAa;AAChB,QAAMqC,iBAAiBC,kBAAkBtC,QAAQ,GAC3C6B,oBAAoBC,qBAAqB9B,QAAQ,GACjDuC,4BACJV,qBAAqBW,eAAeX,kBAAkBhB,KAAK,CAAC,CAAC,IACzDgB,kBAAkBhB,KAAK,CAAC,EAAEC,OAC1BL;AAEN,MAAI,CAAC4B,kBAAkB,CAACE;AACtB,WAAO,CAAA;AAGT,MAAIE,qBAAqB;AACzB,QAAMC,gBAGD,CAAA;AAEL,aAAWC,SAASN,eAAe3B,KAAKU,UAAU;AAChD,QAAIuB,MAAM7B,SAASyB,2BAA2B;AAC5CE,2BAAqB;AACrB;AAAA,IACF;AAEA,QAAI,CAAChB,OAAOzB,SAASC,SAAS0C,KAAK,KAAKF,oBAAoB;AAC1DC,oBAAcE,KAAK;AAAA,QACjBlC,MAAMiC;AAAAA,QACN9B,MAAM,CAAC,GAAGwB,eAAexB,MAAM,YAAY;AAAA,UAACC,MAAM6B,MAAM7B;AAAAA,QAAAA,CAAK;AAAA,MAAA,CAC9D;AACD;AAAA,IACF;AAAA,EACF;AAEA,SAAO4B;AACT,GCvCaG,2BAKR7C,CAAAA,aAAa;AAChB,QAAMqC,iBAAiBC,kBAAkBtC,QAAQ,GAC3C2B,sBAAsBC,uBAAuB5B,QAAQ,GACrD8C,8BACJnB,uBAAuBa,eAAeb,oBAAoBd,KAAK,CAAC,CAAC,IAC7Dc,oBAAoBd,KAAK,CAAC,EAAEC,OAC5BL;AAEN,MAAI,CAAC4B,kBAAkB,CAACS;AACtB,WAAO,CAAA;AAGT,QAAMJ,gBAGD,CAAA;AAEL,aAAWC,SAASN,eAAe3B,KAAKU,UAAU;AAChD,QAAIuB,MAAM7B,SAASgC;AACjB;AAGGrB,WAAOzB,SAASC,SAAS0C,KAAK,KACjCD,cAAcE,KAAK;AAAA,MACjBlC,MAAMiC;AAAAA,MACN9B,MAAM,CAAC,GAAGwB,eAAexB,MAAM,YAAY;AAAA,QAACC,MAAM6B,MAAM7B;AAAAA,MAAAA,CAAK;AAAA,IAAA,CAC9D;AAAA,EAEL;AAEA,SAAO4B;AACT,GCxCaK,eAAiD/C,CAAAA,aACrDA,SAASC,QAAQC,WCEb8C,oBAA6ChD,CAAAA,aAAa;AACrE,MAAI,CAACA,SAASC,QAAQC;AACpB,WAAO;AAGT,QAAM+C,WAAWnB,uBAAqB9B,SAASC,QAAQC,SAAS,GAC1DgD,QAAQC,cAAc;AAAA,IAC1B,GAAGnD;AAAAA,IACHC,SAAS;AAAA,MACP,GAAGD,SAASC;AAAAA,MACZC,WAAW;AAAA,QACTG,QAAQ4C;AAAAA,QACRG,OAAOH;AAAAA,MAAAA;AAAAA,IACT;AAAA,EACF,CACD;AAED,MAAI,CAACC;AACH,WAAO;AAGT,QAAMG,aAAaC,iBAAiB;AAAA,IAClCrD,SAASD,SAASC;AAAAA,IAClBiD;AAAAA,EAAAA,CACD;AAED,SAAOK,iBAAiB;AAAA,IACtB,GAAGvD;AAAAA,IACHC,SAAS;AAAA,MACP,GAAGD,SAASC;AAAAA,MACZC,WAAW;AAAA,QACTG,QAAQ4C;AAAAA,QACRG,OAAOC;AAAAA,MAAAA;AAAAA,IACT;AAAA,EACF,CACD;AACH,GCpCaG,qBAA8CxD,CAAAA,aAAa;AACtE,MAAI,CAACA,SAASC,QAAQC;AACpB,WAAO;AAGT,QAAMuD,aAAa7B,yBAAuB5B,SAASC,QAAQC,SAAS,GAC9DgD,QAAQC,cAAc;AAAA,IAC1B,GAAGnD;AAAAA,IACHC,SAAS;AAAA,MACP,GAAGD,SAASC;AAAAA,MACZC,WAAW;AAAA,QACTG,QAAQoD;AAAAA,QACRL,OAAOK;AAAAA,MAAAA;AAAAA,IACT;AAAA,EACF,CACD;AAED,MAAI,CAACP;AACH,WAAO;AAGT,QAAMQ,eAAeC,mBAAmB;AAAA,IACtC1D,SAASD,SAASC;AAAAA,IAClBiD;AAAAA,EAAAA,CACD;AAED,SAAOK,iBAAiB;AAAA,IACtB,GAAGvD;AAAAA,IACHC,SAAS;AAAA,MACP,GAAGD,SAASC;AAAAA,MACZC,WAAW;AAAA,QACTG,QAAQqD;AAAAA,QACRN,OAAOK;AAAAA,MAAAA;AAAAA,IACT;AAAA,EACF,CACD;AACH,GCvCaG,WACX5D,CAAAA,aAEOA,SAASC,QAAQU;"}