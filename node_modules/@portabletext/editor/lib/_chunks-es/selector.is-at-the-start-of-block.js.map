{"version":3,"file":"selector.is-at-the-start-of-block.js","sources":["../../src/selectors/selector.get-focus-block.ts","../../src/selectors/selector.get-focus-text-block.ts","../../src/selectors/selector.get-focus-child.ts","../../src/selectors/selector.get-focus-span.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-selection-start-point.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts","../../src/selectors/selector.is-selection-collapsed.ts","../../src/selectors/selector.get-focus-inline-object.ts","../../src/selectors/selector.get-selected-blocks.ts","../../src/selectors/selector.get-selection-end-block.ts","../../src/selectors/selector.get-selection-start-block.ts","../../src/selectors/selector.is-selection-expanded.ts","../../src/selectors/selector.is-selecting-entire-blocks.ts","../../src/selectors/selector.get-selected-value.ts","../../src/types/paths.ts","../../src/utils/util.is-selection-expanded.ts","../../src/selectors/selector.get-next-span.ts","../../src/selectors/selector.get-previous-span.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selector.get-mark-state.ts","../../src/selectors/selector.get-active-annotation-marks.ts","../../src/selectors/selector.get-active-decorators.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-previous-inline-object.ts","../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.get-focus-block-object.ts","../../src/selectors/selector.get-focus-list-block.ts","../../src/selectors/selector.get-last-block.ts","../../src/selectors/selector.get-next-block.ts","../../src/selectors/selector.get-previous-block.ts","../../src/selectors/selector.get-selected-text-blocks.ts","../../src/selectors/selector.get-selection-end-child.ts","../../src/selectors/selector.get-selection-start-child.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts"],"sourcesContent":["import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const key = getBlockKeyFromSelectionPoint(snapshot.context.selection.focus)\n  const index = key ? snapshot.blockIndexMap.get(key) : undefined\n\n  const node =\n    index !== undefined ? snapshot.context.value.at(index) : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const focusBlock = getFocusTextBlock(snapshot)\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = getChildKeyFromSelectionPoint(snapshot.context.selection.focus)\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n","import {isSpan, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  {node: PortableTextSpan; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  return snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const endPoint = getSelectionEndPoint(snapshot.context.selection)\n    const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n    const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey)\n    const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n    if (pointBlockIndex === undefined || endBlockIndex === undefined) {\n      return false\n    }\n\n    if (pointBlockIndex > endBlockIndex) {\n      // The point block is after the end block.\n      return true\n    }\n\n    if (pointBlockIndex < endBlockIndex) {\n      // The point block is before the end block.\n      return false\n    }\n\n    // The point block is the same as the end block.\n    const pointBlock = snapshot.context.value.at(pointBlockIndex)\n\n    if (!pointBlock) {\n      // The point block is not in the value.\n      return false\n    }\n\n    if (!isTextBlock(snapshot.context, pointBlock)) {\n      // The point block is not a text block.\n      // Since the point block is the same as the end block, the point is not\n      // after the selection.\n      return false\n    }\n\n    let pointChildIndex: number | undefined\n    let endChildIndex: number | undefined\n\n    let childIndex = -1\n\n    // The point block is the same as the end block, so we need to find the\n    // child indices and compare them.\n    for (const child of pointBlock.children) {\n      childIndex++\n\n      if (child._key === pointChildKey && child._key === endChildKey) {\n        return point.offset > endPoint.offset\n      }\n\n      if (child._key === pointChildKey) {\n        pointChildIndex = childIndex\n      }\n\n      if (child._key === endChildKey) {\n        endChildIndex = childIndex\n      }\n\n      if (pointChildIndex !== undefined && endChildIndex !== undefined) {\n        break\n      }\n    }\n\n    if (pointChildIndex === undefined || endChildIndex === undefined) {\n      return false\n    }\n\n    return pointChildIndex > endChildIndex\n  }\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const startPoint = getSelectionStartPoint(snapshot.context.selection)\n    const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n    const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n\n    const pointBlockKey = getBlockKeyFromSelectionPoint(point)\n    const pointChildKey = getChildKeyFromSelectionPoint(point)\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n    const pointBlockIndex = snapshot.blockIndexMap.get(pointBlockKey)\n\n    if (startBlockIndex === undefined || pointBlockIndex === undefined) {\n      return false\n    }\n\n    if (pointBlockIndex < startBlockIndex) {\n      // The point block is before the start block.\n      return true\n    }\n\n    if (pointBlockIndex > startBlockIndex) {\n      // The point block is after the start block.\n      return false\n    }\n\n    // The point block is the same as the start block.\n    const pointBlock = snapshot.context.value.at(pointBlockIndex)\n\n    if (!pointBlock) {\n      // The point block is not in the value.\n      return false\n    }\n\n    if (!isTextBlock(snapshot.context, pointBlock)) {\n      // The point block is not a text block.\n      // Since the point block is the same as the start block, the point is not\n      // before the selection.\n      return false\n    }\n\n    let pointChildIndex: number | undefined\n    let startChildIndex: number | undefined\n\n    let childIndex = -1\n\n    // The point block is the same as the start block, so we need to find the\n    // child indices and compare them.\n    for (const child of pointBlock.children) {\n      childIndex++\n\n      if (child._key === pointChildKey && child._key === startChildKey) {\n        return point.offset < startPoint.offset\n      }\n\n      if (child._key === pointChildKey) {\n        pointChildIndex = childIndex\n      }\n\n      if (child._key === startChildKey) {\n        startChildIndex = childIndex\n      }\n\n      if (pointChildIndex !== undefined && startChildIndex !== undefined) {\n        break\n      }\n    }\n\n    if (pointChildIndex === undefined || startChildIndex === undefined) {\n      return false\n    }\n\n    return pointChildIndex < startChildIndex\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!selection || !snapshot.context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    const originalSelectionStartPoint = getSelectionStartPoint(snapshot)\n    const originalSelectionEndPoint = getSelectionEndPoint(snapshot)\n\n    if (\n      !selectionStartPoint ||\n      !selectionEndPoint ||\n      !originalSelectionStartPoint ||\n      !originalSelectionEndPoint\n    ) {\n      return false\n    }\n\n    const startPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionStartPoint,\n    )\n    const endPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionEndPoint,\n    )\n\n    if (\n      startPointEqualToOriginalStartPoint &&\n      endPointEqualToOriginalEndPoint\n    ) {\n      return true\n    }\n\n    const startPointBeforeSelection =\n      isPointBeforeSelection(selectionStartPoint)(snapshot)\n    const startPointAfterSelection =\n      isPointAfterSelection(selectionStartPoint)(snapshot)\n    const endPointBeforeSelection =\n      isPointBeforeSelection(selectionEndPoint)(snapshot)\n    const endPointAfterSelection =\n      isPointAfterSelection(selectionEndPoint)(snapshot)\n\n    const originalStartPointBeforeStartPoint = isPointBeforeSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n    const originalStartPointAfterStartPoint = isPointAfterSelection(\n      originalSelectionStartPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionStartPoint,\n          focus: selectionStartPoint,\n        },\n      },\n    })\n\n    const originalEndPointBeforeEndPoint = isPointBeforeSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n    const originalEndPointAfterEndPoint = isPointAfterSelection(\n      originalSelectionEndPoint,\n    )({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection: {\n          anchor: selectionEndPoint,\n          focus: selectionEndPoint,\n        },\n      },\n    })\n\n    const startPointEqualToOriginalEndPoint = isEqualSelectionPoints(\n      selectionStartPoint,\n      originalSelectionEndPoint,\n    )\n    const endPointEqualToOriginalStartPoint = isEqualSelectionPoints(\n      selectionEndPoint,\n      originalSelectionStartPoint,\n    )\n\n    // If all checks fail then we can deduce that the selection does not exist\n    // and there doesn't overlap with the snapshot selection\n    if (\n      !endPointEqualToOriginalStartPoint &&\n      !startPointEqualToOriginalEndPoint &&\n      !originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return false\n    }\n\n    if (endPointBeforeSelection && !endPointEqualToOriginalStartPoint) {\n      return false\n    }\n\n    if (startPointAfterSelection && !startPointEqualToOriginalEndPoint) {\n      return false\n    }\n\n    if (\n      !originalStartPointBeforeStartPoint &&\n      originalStartPointAfterStartPoint &&\n      !originalEndPointBeforeEndPoint &&\n      originalEndPointAfterEndPoint\n    ) {\n      return !endPointEqualToOriginalStartPoint\n    }\n\n    if (\n      originalStartPointBeforeStartPoint &&\n      !originalStartPointAfterStartPoint &&\n      originalEndPointBeforeEndPoint &&\n      !originalEndPointAfterEndPoint\n    ) {\n      return !startPointEqualToOriginalEndPoint\n    }\n\n    if (\n      !startPointAfterSelection ||\n      !startPointBeforeSelection ||\n      !endPointAfterSelection ||\n      !endPointBeforeSelection\n    ) {\n      return true\n    }\n\n    return false\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(snapshot.context.selection.anchor.path) ===\n      JSON.stringify(snapshot.context.selection.focus.path) &&\n    snapshot.context.selection?.anchor.offset ===\n      snapshot.context.selection?.focus.offset\n  )\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getFocusInlineObject: EditorSelector<\n  {node: PortableTextObject; path: ChildPath} | undefined\n> = (snapshot) => {\n  const focusChild = getFocusChild(snapshot)\n\n  return focusChild && !isSpan(snapshot.context, focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: BlockPath}> = []\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: BlockPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusBlock({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = (snapshot) => {\n  return snapshot.context.selection !== null && !isSelectionCollapsed(snapshot)\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const isSelectingEntireBlocks: EditorSelector<boolean> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return false\n  }\n\n  const startPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.focus\n    : snapshot.context.selection.anchor\n  const endPoint = snapshot.context.selection.backward\n    ? snapshot.context.selection.anchor\n    : snapshot.context.selection.focus\n\n  const startBlock = getSelectionStartBlock(snapshot)\n  const endBlock = getSelectionEndBlock(snapshot)\n\n  if (!startBlock || !endBlock) {\n    return false\n  }\n\n  const startBlockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: startBlock,\n  })\n  const endBlockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: endBlock,\n  })\n\n  return (\n    isEqualSelectionPoints(startBlockStartPoint, startPoint) &&\n    isEqualSelectionPoints(endBlockEndPoint, endPoint)\n  )\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {sliceBlocks} from '../utils/util.slice-blocks'\n\n/**\n * @public\n */\nexport const getSelectedValue: EditorSelector<Array<PortableTextBlock>> = (\n  snapshot,\n) => {\n  const selection = snapshot.context.selection\n\n  if (!selection) {\n    return []\n  }\n\n  const startPoint = getSelectionStartPoint(selection)\n  const endPoint = getSelectionEndPoint(selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return []\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return []\n  }\n\n  const startBlock = snapshot.context.value.at(startBlockIndex)\n  const slicedStartBlock = startBlock\n    ? sliceBlocks({\n        context: snapshot.context,\n        blocks: [startBlock],\n      }).at(0)\n    : undefined\n\n  if (startBlockIndex === endBlockIndex) {\n    return slicedStartBlock ? [slicedStartBlock] : []\n  }\n\n  const endBlock = snapshot.context.value.at(endBlockIndex)\n  const slicedEndBlock = endBlock\n    ? sliceBlocks({\n        context: snapshot.context,\n        blocks: [endBlock],\n      }).at(0)\n    : undefined\n\n  const middleBlocks = snapshot.context.value.slice(\n    startBlockIndex + 1,\n    endBlockIndex,\n  )\n\n  return [\n    ...(slicedStartBlock ? [slicedStartBlock] : []),\n    ...middleBlocks,\n    ...(slicedEndBlock ? [slicedEndBlock] : []),\n  ]\n}\n","/**\n * A segment in a path that identifies an element by its `_key` property.\n * @public\n */\nexport interface KeyedSegment {\n  _key: string\n}\n\n/**\n * A tuple representing a range selection, e.g., `[0, 5]` or `['', 3]`.\n * @public\n */\nexport type IndexTuple = [number | '', number | '']\n\n/**\n * A single segment in a path. Can be:\n * - A string (property name)\n * - A number (array index)\n * - A KeyedSegment (object with `_key`)\n * - An IndexTuple (range selection)\n * @public\n */\nexport type PathSegment = string | number | KeyedSegment | IndexTuple\n\n/**\n * A path is an array of path segments that describes a location in a document.\n * @public\n */\nexport type Path = PathSegment[]\n\n/**\n * @public\n */\nexport type BlockPath = [{_key: string}]\n\n/**\n * @public\n */\nexport function isBlockPath(path: Path): path is BlockPath {\n  const firstSegment = path.at(0)\n\n  return (\n    path.length === 1 &&\n    firstSegment !== undefined &&\n    isRecord(firstSegment) &&\n    '_key' in firstSegment &&\n    typeof firstSegment._key === 'string'\n  )\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type AnnotationPath = [{_key: string}, 'markDefs', {_key: string}]\n\n/**\n * @public\n */\nexport type ChildPath = [{_key: string}, 'children', {_key: string}]\n","import type {EditorSelection} from '../types/editor'\nimport {isSelectionCollapsed} from './util.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isSelectionExpanded(selection: EditorSelection) {\n  if (!selection) {\n    return false\n  }\n\n  return !isSelectionCollapsed(selection)\n}\n","import {isSpan, isTextBlock, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {KeyedSegment} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n\n  if (!selectionEndBlock || !selectionEndPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionEndBlock.node)) {\n    return undefined\n  }\n\n  const selectionEndPointChildKey =\n    getChildKeyFromSelectionPoint(selectionEndPoint)\n\n  let endPointChildFound = false\n  let nextSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionEndBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (isSpan(snapshot.context, child) && endPointChildFound) {\n      nextSpan = {\n        node: child,\n        path: [...selectionEndBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return nextSpan\n}\n","import {isSpan, isTextBlock, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {KeyedSegment} from '../types/paths'\nimport {getChildKeyFromSelectionPoint} from '../utils/util.selection-point'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousSpan: EditorSelector<\n  | {\n      node: PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n\n  if (!selectionStartBlock || !selectionStartPoint) {\n    return undefined\n  }\n\n  if (!isTextBlock(snapshot.context, selectionStartBlock.node)) {\n    return undefined\n  }\n\n  const selectionStartPointChildKey =\n    getChildKeyFromSelectionPoint(selectionStartPoint)\n\n  let previousSpan:\n    | {\n        node: PortableTextSpan\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of selectionStartBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (isSpan(snapshot.context, child)) {\n      previousSpan = {\n        node: child,\n        path: [...selectionStartBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return previousSpan\n}\n","import {isSpan, isTextBlock, type PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from '../utils/util.selection-point'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: ChildPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot)\n  const endPoint = getSelectionEndPoint(snapshot)\n\n  if (!startPoint || !endPoint) {\n    return selectedSpans\n  }\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n  const startSpanKey = getChildKeyFromSelectionPoint(startPoint)\n  const endSpanKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedSpans\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  let startBlockFound = false\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      startBlockFound = true\n    }\n\n    if (!isTextBlock(snapshot.context, block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (startBlockFound) {\n      for (const child of block.children) {\n        if (!isSpan(snapshot.context, child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isBlockPath} from '../types/paths'\nimport {blockOffsetToSpanSelectionPoint} from '../utils/util.block-offset'\nimport {isSelectionExpanded} from '../utils/util.is-selection-expanded'\nimport {getFocusSpan} from './selector.get-focus-span'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextSpan} from './selector.get-next-span'\nimport {getPreviousSpan} from './selector.get-previous-span'\nimport {getSelectedSpans} from './selector.get-selected-spans'\n\n/**\n * @beta\n */\nexport type MarkState =\n  | {\n      state: 'unchanged'\n      marks: Array<string>\n    }\n  | {\n      state: 'changed'\n      marks: Array<string>\n      previousMarks: Array<string>\n    }\n\n/**\n * Given that text is inserted at the current position, what marks should\n * be applied?\n * @beta\n */\nexport const getMarkState: EditorSelector<MarkState | undefined> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  let selection = snapshot.context.selection\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  if (!focusTextBlock) {\n    return undefined\n  }\n\n  if (isBlockPath(selection.anchor.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.anchor.path,\n        offset: selection.anchor.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          anchor: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  if (isBlockPath(selection.focus.path)) {\n    const spanSelectionPoint = blockOffsetToSpanSelectionPoint({\n      context: snapshot.context,\n      blockOffset: {\n        path: selection.focus.path,\n        offset: selection.focus.offset,\n      },\n      direction: selection.backward ? 'backward' : 'forward',\n    })\n\n    selection = spanSelectionPoint\n      ? {\n          ...selection,\n          focus: spanSelectionPoint,\n        }\n      : selection\n  }\n\n  const focusSpan = getFocusSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n\n  if (!focusSpan) {\n    return undefined\n  }\n\n  if (isSelectionExpanded(selection)) {\n    const selectedSpans = getSelectedSpans({\n      ...snapshot,\n      context: {\n        ...snapshot.context,\n        selection,\n      },\n    })\n\n    let index = 0\n    let marks: Array<string> = []\n\n    for (const span of selectedSpans) {\n      if (index === 0) {\n        marks = span.node.marks ?? []\n      } else {\n        if (span.node.marks?.length === 0) {\n          marks = []\n          continue\n        }\n\n        marks = marks.filter((mark) =>\n          (span.node.marks ?? []).some((spanMark) => spanMark === mark),\n        )\n      }\n\n      index++\n    }\n\n    return {\n      state: 'unchanged',\n      marks,\n    }\n  }\n\n  const decorators = snapshot.context.schema.decorators.map(\n    (decorator) => decorator.name,\n  )\n  const marks = focusSpan.node.marks ?? []\n  const marksWithoutAnnotations = marks.filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  const spanHasAnnotations = marks.length > marksWithoutAnnotations.length\n\n  const spanIsEmpty = focusSpan.node.text.length === 0\n\n  const atTheBeginningOfSpan = snapshot.context.selection.anchor.offset === 0\n  const atTheEndOfSpan =\n    snapshot.context.selection.anchor.offset === focusSpan.node.text.length\n\n  const previousSpan = getPreviousSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpan = getNextSpan({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection,\n    },\n  })\n  const nextSpanAnnotations =\n    nextSpan?.node?.marks?.filter((mark) => !decorators.includes(mark)) ?? []\n  const spanAnnotations = marks.filter((mark) => !decorators.includes(mark))\n\n  const previousSpanHasAnnotations = previousSpan\n    ? previousSpan.node.marks?.some((mark) => !decorators.includes(mark))\n    : false\n  const previousSpanHasSameAnnotations = previousSpan\n    ? previousSpan.node.marks\n        ?.filter((mark) => !decorators.includes(mark))\n        .every((mark) => marks.includes(mark))\n    : false\n  const previousSpanHasSameAnnotation = previousSpan\n    ? previousSpan.node.marks?.some(\n        (mark) => !decorators.includes(mark) && marks.includes(mark),\n      )\n    : false\n\n  const previousSpanHasSameMarks = previousSpan\n    ? previousSpan.node.marks?.every((mark) => marks.includes(mark))\n    : false\n  const nextSpanSharesSomeAnnotations = spanAnnotations.some((mark) =>\n    nextSpanAnnotations?.includes(mark),\n  )\n\n  if (spanHasAnnotations && !spanIsEmpty) {\n    if (atTheBeginningOfSpan) {\n      if (previousSpanHasSameMarks) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotations) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: previousSpan?.node.marks ?? [],\n        }\n      } else if (previousSpanHasSameAnnotation) {\n        return {\n          state: 'unchanged',\n          marks: focusSpan.node.marks ?? [],\n        }\n      } else if (!previousSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n    }\n\n    if (atTheEndOfSpan) {\n      if (!nextSpan) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n\n      if (nextSpanAnnotations.length > 0 && !nextSpanSharesSomeAnnotations) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: [],\n        }\n      }\n\n      if (\n        (nextSpanSharesSomeAnnotations &&\n          nextSpanAnnotations.length < spanAnnotations.length) ||\n        !nextSpanSharesSomeAnnotations\n      ) {\n        return {\n          state: 'changed',\n          previousMarks: marks,\n          marks: nextSpan?.node.marks ?? [],\n        }\n      }\n    }\n  }\n\n  if (atTheBeginningOfSpan && !spanIsEmpty && !!previousSpan) {\n    if (previousSpanHasAnnotations) {\n      return {\n        state: 'changed',\n        marks,\n        previousMarks: previousSpan?.node.marks ?? [],\n      }\n    } else {\n      return {\n        state: 'changed',\n        previousMarks: marks,\n        marks: (previousSpan?.node.marks ?? []).filter((mark) =>\n          decorators.includes(mark),\n        ),\n      }\n    }\n  }\n\n  return {\n    state: 'unchanged',\n    marks,\n  }\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveAnnotationsMarks(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const markState = getMarkState(snapshot)\n\n  return (markState?.marks ?? []).filter(\n    (mark) =>\n      !schema.decorators.map((decorator) => decorator.name).includes(mark),\n  )\n}\n","import type {EditorSnapshot} from '../editor/editor-snapshot'\nimport {getMarkState} from './selector.get-mark-state'\n\nexport function getActiveDecorators(snapshot: EditorSnapshot) {\n  const schema = snapshot.context.schema\n  const decoratorState = snapshot.decoratorState\n  const markState = getMarkState(snapshot)\n  const decorators = schema.decorators.map((decorator) => decorator.name)\n\n  const markStateDecorators = (markState?.marks ?? []).filter((mark) =>\n    decorators.includes(mark),\n  )\n\n  let activeDecorators: Array<string> = markStateDecorators\n\n  for (const decorator in decoratorState) {\n    if (decoratorState[decorator] === false) {\n      activeDecorators = activeDecorators.filter(\n        (activeDecorator) => activeDecorator !== decorator,\n      )\n    } else if (decoratorState[decorator] === true) {\n      if (!activeDecorators.includes(decorator)) {\n        activeDecorators.push(decorator)\n      }\n    }\n  }\n\n  return activeDecorators\n}\n","import {isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveAnnotationsMarks} from './selector.get-active-annotation-marks'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * Check whether an annotation is active in the given `snapshot`.\n *\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n  options?: {\n    /**\n     * Choose whether the annotation has to take up the entire selection in the\n     * `snapshot` or if the annotation can be partially selected.\n     *\n     * Defaults to 'full'\n     */\n    mode?: 'partial' | 'full'\n  },\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    const mode = options?.mode ?? 'full'\n\n    if (mode === 'partial') {\n      const selectedValue = getSelectedValue(snapshot)\n\n      const selectionMarkDefs = selectedValue.flatMap((block) =>\n        isTextBlock(snapshot.context, block) ? (block.markDefs ?? []) : [],\n      )\n\n      return selectionMarkDefs.some((markDef) => markDef._type === annotation)\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isTextBlock(snapshot.context, block.node)\n        ? (block.node.markDefs ?? [])\n        : [],\n    )\n    const activeAnnotations = getActiveAnnotationsMarks(snapshot)\n    const activeMarkDefs = selectionMarkDefs.filter(\n      (markDef) =>\n        markDef._type === annotation &&\n        activeAnnotations.includes(markDef._key),\n    )\n\n    return activeMarkDefs.length > 0\n  }\n}\n","import {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getMarkState} from './selector.get-mark-state'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const markState = getMarkState(snapshot)\n\n  const activeAnnotations = (markState?.marks ?? []).filter(\n    (mark) =>\n      !snapshot.context.schema.decorators\n        .map((decorator) => decorator.name)\n        .includes(mark),\n  )\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isTextBlock(snapshot.context, block.node)\n      ? (block.node.markDefs ?? [])\n      : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    activeAnnotations.includes(markDef._key),\n  )\n}\n","import {isTextBlock, type PortableTextListBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selector.get-selected-blocks'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return undefined\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter((block) =>\n    isTextBlock(snapshot.context, block),\n  )\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionEndPoint = getSelectionEndPoint(snapshot)\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeyedSegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(snapshot.context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import {isSpan, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeyedSegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: ChildPath\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(snapshot.context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import {isSpan, isTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedValue} from './selector.get-selected-value'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = (snapshot) => {\n  const selectedValue = getSelectedValue(snapshot)\n\n  return selectedValue.reduce((text, block) => {\n    if (!isTextBlock(snapshot.context, block)) {\n      return text\n    }\n\n    return (\n      text +\n      block.children.reduce((text, child) => {\n        if (isSpan(snapshot.context, child)) {\n          return text + child.text\n        }\n\n        return text\n      }, '')\n    )\n  }, '')\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockOffset} from '../types/block-offset'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  spanSelectionPointToBlockOffset,\n} from '../utils/util.block-offset'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed(snapshot)) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock(snapshot)\n  const selectionStartPoint = getSelectionStartPoint(snapshot)\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        context: snapshot.context,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject(snapshot)\n  const blockStartPoint = getBlockStartPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textBefore = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject(snapshot)\n  const blockEndPoint = getBlockEndPoint({\n    context: snapshot.context,\n    block: focusTextBlock,\n  })\n  const textAfter = getSelectionText({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    context: snapshot.context,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import {isTextBlock, type PortableTextObject} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getFocusBlock} from './selector.get-focus-block'\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusBlock = getFocusBlock(snapshot)\n\n  return focusBlock && !isTextBlock(snapshot.context, focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n","import type {PortableTextListBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {isListBlock} from '../utils/parse-blocks'\nimport {getFocusTextBlock} from './selector.get-focus-text-block'\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const focusTextBlock = getFocusTextBlock(snapshot)\n\n  return focusTextBlock && isListBlock(snapshot.context, focusTextBlock.node)\n    ? {node: focusTextBlock.node, path: focusTextBlock.path}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const node = snapshot.context.value[snapshot.context.value.length - 1]\n    ? snapshot.context.value[snapshot.context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndBlock} from './selector.get-selection-end-block'\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionEndBlock = getSelectionEndBlock(snapshot)\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionEndBlock.node._key)\n\n  if (index === undefined || index === snapshot.context.value.length - 1) {\n    return undefined\n  }\n\n  const nextBlock = snapshot.context.value.at(index + 1)\n\n  return nextBlock\n    ? {node: nextBlock, path: [{_key: nextBlock._key}]}\n    : undefined\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionStartBlock} from './selector.get-selection-start-block'\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: BlockPath} | undefined\n> = (snapshot) => {\n  const selectionStartBlock = getSelectionStartBlock(snapshot)\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  const index = snapshot.blockIndexMap.get(selectionStartBlock.node._key)\n\n  if (index === undefined || index === 0) {\n    return undefined\n  }\n\n  const previousBlock = snapshot.context.value.at(index - 1)\n\n  return previousBlock\n    ? {node: previousBlock, path: [{_key: previousBlock._key}]}\n    : undefined\n}\n","import {isTextBlock, type PortableTextTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getBlockKeyFromSelectionPoint} from '../utils/util.selection-point'\n\n/**\n * @public\n */\nexport const getSelectedTextBlocks: EditorSelector<\n  Array<{node: PortableTextTextBlock; path: BlockPath}>\n> = (snapshot) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedTextBlocks: Array<{\n    node: PortableTextTextBlock\n    path: BlockPath\n  }> = []\n\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedTextBlocks\n  }\n\n  const startBlockIndex = snapshot.blockIndexMap.get(startBlockKey)\n  const endBlockIndex = snapshot.blockIndexMap.get(endBlockKey)\n\n  if (startBlockIndex === undefined || endBlockIndex === undefined) {\n    return selectedTextBlocks\n  }\n\n  const slicedValue = snapshot.context.value.slice(\n    startBlockIndex,\n    endBlockIndex + 1,\n  )\n\n  for (const block of slicedValue) {\n    if (block._key === startBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n\n      break\n    }\n\n    if (selectedTextBlocks.length > 0) {\n      if (isTextBlock(snapshot.context, block)) {\n        selectedTextBlocks.push({node: block, path: [{_key: block._key}]})\n      }\n    }\n  }\n\n  return selectedTextBlocks\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionEndPoint} from '../utils/util.get-selection-end-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionEndChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const endPoint = getSelectionEndPoint(snapshot.context.selection)\n\n  if (!endPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: endPoint,\n        focus: endPoint,\n      },\n    },\n  })\n}\n","import type {PortableTextObject, PortableTextSpan} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {ChildPath} from '../types/paths'\nimport {getSelectionStartPoint} from '../utils/util.get-selection-start-point'\nimport {getFocusChild} from './selector.get-focus-child'\n\n/**\n * @public\n */\nexport const getSelectionStartChild: EditorSelector<\n  | {\n      node: PortableTextSpan | PortableTextObject\n      path: ChildPath\n    }\n  | undefined\n> = (snapshot) => {\n  const startPoint = getSelectionStartPoint(snapshot.context.selection)\n\n  if (!startPoint) {\n    return undefined\n  }\n\n  return getFocusChild({\n    ...snapshot,\n    context: {\n      ...snapshot.context,\n      selection: {\n        anchor: startPoint,\n        focus: startPoint,\n      },\n    },\n  })\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveDecorators} from './selector.get-active-decorators'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    const activeDecorators = getActiveDecorators(snapshot)\n\n    return activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockEndPoint} from '../utils/util.get-block-end-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockEndPoint = getBlockEndPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockEndPoint,\n    )\n  }\n}\n","import type {PortableTextBlock} from '@portabletext/schema'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {BlockPath} from '../types/paths'\nimport {getBlockStartPoint} from '../utils/util.get-block-start-point'\nimport {isEqualSelectionPoints} from '../utils/util.is-equal-selection-points'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: BlockPath\n}): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection || !isSelectionCollapsed(snapshot)) {\n      return false\n    }\n\n    const blockStartPoint = getBlockStartPoint({\n      context: snapshot.context,\n      block,\n    })\n\n    return isEqualSelectionPoints(\n      snapshot.context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n"],"names":["getFocusBlock","snapshot","context","selection","key","getBlockKeyFromSelectionPoint","focus","index","blockIndexMap","get","undefined","node","value","at","path","_key","getFocusTextBlock","focusBlock","isTextBlock","getFocusChild","getChildKeyFromSelectionPoint","children","find","span","getFocusSpan","focusChild","isSpan","getSelectionEndPoint","backward","anchor","getSelectionStartPoint","isPointAfterSelection","point","endPoint","endBlockKey","endChildKey","pointBlockKey","pointChildKey","pointBlockIndex","endBlockIndex","pointBlock","pointChildIndex","endChildIndex","childIndex","child","offset","isPointBeforeSelection","startPoint","startBlockKey","startChildKey","startBlockIndex","startChildIndex","isOverlappingSelection","selectionStartPoint","selectionEndPoint","originalSelectionStartPoint","originalSelectionEndPoint","startPointEqualToOriginalStartPoint","isEqualSelectionPoints","endPointEqualToOriginalEndPoint","startPointBeforeSelection","startPointAfterSelection","endPointBeforeSelection","endPointAfterSelection","originalStartPointBeforeStartPoint","originalStartPointAfterStartPoint","originalEndPointBeforeEndPoint","originalEndPointAfterEndPoint","startPointEqualToOriginalEndPoint","endPointEqualToOriginalStartPoint","isSelectionCollapsed","JSON","stringify","getFocusInlineObject","getSelectedBlocks","selectedBlocks","startKey","endKey","slicedValue","slice","block","push","length","getSelectionEndBlock","getSelectionStartBlock","isSelectionExpanded","isSelectingEntireBlocks","startBlock","endBlock","startBlockStartPoint","getBlockStartPoint","endBlockEndPoint","getBlockEndPoint","getSelectedValue","slicedStartBlock","sliceBlocks","blocks","slicedEndBlock","middleBlocks","isBlockPath","firstSegment","isRecord","getNextSpan","selectionEndBlock","selectionEndPointChildKey","endPointChildFound","nextSpan","getPreviousSpan","selectionStartBlock","selectionStartPointChildKey","previousSpan","getSelectedSpans","selectedSpans","startSpanKey","endSpanKey","startBlockFound","text","getMarkState","spanSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","focusSpan","marks","filter","mark","some","spanMark","state","decorators","schema","map","decorator","name","marksWithoutAnnotations","includes","spanHasAnnotations","spanIsEmpty","atTheBeginningOfSpan","atTheEndOfSpan","nextSpanAnnotations","spanAnnotations","previousSpanHasAnnotations","previousSpanHasSameAnnotations","every","previousSpanHasSameAnnotation","previousSpanHasSameMarks","nextSpanSharesSomeAnnotations","previousMarks","getActiveAnnotationsMarks","getActiveDecorators","decoratorState","markState","activeDecorators","activeDecorator","isActiveAnnotation","annotation","options","mode","flatMap","markDefs","markDef","_type","selectionMarkDefs","activeAnnotations","getActiveAnnotations","getActiveListItem","selectedTextBlocks","firstTextBlock","firstListItem","listItem","getActiveStyle","firstStyle","style","getNextInlineObject","focusTextBlock","isKeyedSegment","inlineObject","getPreviousInlineObject","getSelectionText","reduce","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","blockStartPoint","textDirectlyBefore","split","nextInlineObject","blockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","caretWordEndSelectionPoint","caretWordSelection","getFocusBlockObject","getFocusListBlock","isListBlock","getLastBlock","getNextBlock","nextBlock","getPreviousBlock","previousBlock","getSelectedTextBlocks","getSelectionEndChild","getSelectionStartChild","isActiveDecorator","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","isAtTheStartOfBlock"],"mappings":"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"}