{"version":3,"file":"util.slice-text-block.js","sources":["../../src/utils/util.get-text-block-text.ts","../../src/utils/util.is-empty-text-block.ts","../../src/utils/util.slice-text-block.ts"],"sourcesContent":["import type {PortableTextTextBlock} from '@portabletext/schema'\n\n/**\n * @public\n */\nexport function getTextBlockText(block: PortableTextTextBlock) {\n  return block.children.map((child) => child.text ?? '').join('')\n}\n","import {isSpan, isTextBlock, type PortableTextBlock} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {getTextBlockText} from './util.get-text-block-text'\n\n/**\n * @public\n */\nexport function isEmptyTextBlock(\n  context: Pick<EditorContext, 'schema'>,\n  block: PortableTextBlock | unknown,\n) {\n  if (!isTextBlock(context, block)) {\n    return false\n  }\n\n  const onlyText = block.children.every((child) => isSpan(context, child))\n  const blockText = getTextBlockText(block)\n\n  return onlyText && blockText === ''\n}\n","import {\n  isSpan,\n  type PortableTextChild,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport type {EditorContext} from '../editor/editor-snapshot'\nimport {getSelectionEndPoint} from './util.get-selection-end-point'\nimport {getSelectionStartPoint} from './util.get-selection-start-point'\nimport {\n  getBlockKeyFromSelectionPoint,\n  getChildKeyFromSelectionPoint,\n} from './util.selection-point'\n\nexport function sliceTextBlock({\n  context,\n  block,\n}: {\n  context: Pick<EditorContext, 'schema' | 'selection'>\n  block: PortableTextTextBlock\n}): PortableTextTextBlock {\n  const startPoint = getSelectionStartPoint(context.selection)\n  const endPoint = getSelectionEndPoint(context.selection)\n\n  if (!startPoint || !endPoint) {\n    return block\n  }\n\n  const startBlockKey = getBlockKeyFromSelectionPoint(startPoint)\n  const endBlockKey = getBlockKeyFromSelectionPoint(endPoint)\n\n  if (startBlockKey !== endBlockKey || startBlockKey !== block._key) {\n    return block\n  }\n\n  const startChildKey = getChildKeyFromSelectionPoint(startPoint)\n  const endChildKey = getChildKeyFromSelectionPoint(endPoint)\n\n  if (!startChildKey || !endChildKey) {\n    return block\n  }\n\n  let startChildFound = false\n  const children: Array<PortableTextChild> = []\n\n  for (const child of block.children) {\n    if (child._key === startChildKey) {\n      startChildFound = true\n\n      if (isSpan(context, child)) {\n        const text =\n          child._key === endChildKey\n            ? child.text.slice(startPoint.offset, endPoint.offset)\n            : child.text.slice(startPoint.offset)\n\n        children.push({\n          ...child,\n          text,\n        })\n      } else {\n        children.push(child)\n      }\n\n      if (startChildKey === endChildKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (child._key === endChildKey) {\n      if (isSpan(context, child)) {\n        children.push({\n          ...child,\n          text: child.text.slice(0, endPoint.offset),\n        })\n      } else {\n        children.push(child)\n      }\n\n      break\n    }\n\n    if (startChildFound) {\n      children.push(child)\n    }\n  }\n\n  return {\n    ...block,\n    children,\n  }\n}\n"],"names":["getTextBlockText","block","children","map","child","text","join","isEmptyTextBlock","context","isTextBlock","onlyText","every","isSpan","blockText","sliceTextBlock","startPoint","getSelectionStartPoint","selection","endPoint","getSelectionEndPoint","startBlockKey","getBlockKeyFromSelectionPoint","endBlockKey","_key","startChildKey","getChildKeyFromSelectionPoint","endChildKey","startChildFound","slice","offset","push"],"mappings":";;AAKO,SAASA,iBAAiBC,OAA8B;AAC7D,SAAOA,MAAMC,SAASC,IAAKC,CAAAA,UAAUA,MAAMC,QAAQ,EAAE,EAAEC,KAAK,EAAE;AAChE;ACAO,SAASC,iBACdC,SACAP,OACA;AACA,MAAI,CAACQ,YAAYD,SAASP,KAAK;AAC7B,WAAO;AAGT,QAAMS,WAAWT,MAAMC,SAASS,MAAOP,CAAAA,UAAUQ,OAAOJ,SAASJ,KAAK,CAAC,GACjES,YAAYb,iBAAiBC,KAAK;AAExC,SAAOS,YAAYG,cAAc;AACnC;ACNO,SAASC,eAAe;AAAA,EAC7BN;AAAAA,EACAP;AAIF,GAA0B;AACxB,QAAMc,aAAaC,uBAAuBR,QAAQS,SAAS,GACrDC,WAAWC,qBAAqBX,QAAQS,SAAS;AAEvD,MAAI,CAACF,cAAc,CAACG;AAClB,WAAOjB;AAGT,QAAMmB,gBAAgBC,8BAA8BN,UAAU,GACxDO,cAAcD,8BAA8BH,QAAQ;AAE1D,MAAIE,kBAAkBE,eAAeF,kBAAkBnB,MAAMsB;AAC3D,WAAOtB;AAGT,QAAMuB,gBAAgBC,8BAA8BV,UAAU,GACxDW,cAAcD,8BAA8BP,QAAQ;AAE1D,MAAI,CAACM,iBAAiB,CAACE;AACrB,WAAOzB;AAGT,MAAI0B,kBAAkB;AACtB,QAAMzB,WAAqC,CAAA;AAE3C,aAAWE,SAASH,MAAMC,UAAU;AAClC,QAAIE,MAAMmB,SAASC,eAAe;AAGhC,UAFAG,kBAAkB,IAEdf,OAAOJ,SAASJ,KAAK,GAAG;AAC1B,cAAMC,OACJD,MAAMmB,SAASG,cACXtB,MAAMC,KAAKuB,MAAMb,WAAWc,QAAQX,SAASW,MAAM,IACnDzB,MAAMC,KAAKuB,MAAMb,WAAWc,MAAM;AAExC3B,iBAAS4B,KAAK;AAAA,UACZ,GAAG1B;AAAAA,UACHC;AAAAA,QAAAA,CACD;AAAA,MACH;AACEH,iBAAS4B,KAAK1B,KAAK;AAGrB,UAAIoB,kBAAkBE;AACpB;AAGF;AAAA,IACF;AAEA,QAAItB,MAAMmB,SAASG,aAAa;AAC1Bd,aAAOJ,SAASJ,KAAK,IACvBF,SAAS4B,KAAK;AAAA,QACZ,GAAG1B;AAAAA,QACHC,MAAMD,MAAMC,KAAKuB,MAAM,GAAGV,SAASW,MAAM;AAAA,MAAA,CAC1C,IAED3B,SAAS4B,KAAK1B,KAAK;AAGrB;AAAA,IACF;AAEIuB,uBACFzB,SAAS4B,KAAK1B,KAAK;AAAA,EAEvB;AAEA,SAAO;AAAA,IACL,GAAGH;AAAAA,IACHC;AAAAA,EAAAA;AAEJ;"}