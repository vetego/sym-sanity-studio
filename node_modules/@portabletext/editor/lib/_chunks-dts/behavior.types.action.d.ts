import * as _portabletext_schema6 from "@portabletext/schema";
import { AnnotationDefinition, AnnotationSchemaType, BaseDefinition, BlockObjectDefinition, BlockObjectSchemaType, DecoratorDefinition, DecoratorSchemaType, FieldDefinition, InlineObjectDefinition, InlineObjectSchemaType, ListDefinition, ListSchemaType, PortableTextBlock, PortableTextBlock as PortableTextBlock$1, PortableTextChild, PortableTextChild as PortableTextChild$1, PortableTextListBlock, PortableTextObject, PortableTextObject as PortableTextObject$1, PortableTextSpan, PortableTextSpan as PortableTextSpan$1, PortableTextTextBlock, PortableTextTextBlock as PortableTextTextBlock$1, Schema, SchemaDefinition, SchemaDefinition as SchemaDefinition$1, StyleDefinition, StyleSchemaType, TypedObject, defineSchema } from "@portabletext/schema";
import { BaseRange, Descendant, Operation, Range } from "slate";
import * as xstate71 from "xstate";
import { ActorRef, ActorRefFrom, EventObject, Snapshot } from "xstate";
import * as react10 from "react";
import React$1, { BaseSyntheticEvent, ClipboardEvent, Component, FocusEvent, JSX, KeyboardEvent as KeyboardEvent$1, MutableRefObject, PropsWithChildren, ReactElement, RefObject, TextareaHTMLAttributes } from "react";
import { Patch, Patch as Patch$1 } from "@portabletext/patches";
import { Observable, Subject } from "rxjs";
import { ArrayDefinition, ArraySchemaType, BlockDecoratorDefinition, BlockListDefinition, BlockStyleDefinition, ObjectSchemaType } from "@sanity/types";
import { ReactEditor } from "slate-react";
type MIMEType = `${string}/${string}`;
/**
 * @internal
 */
type PickFromUnion<TUnion, TTagKey extends keyof TUnion, TPickedTags extends TUnion[TTagKey]> = TUnion extends Record<TTagKey, TPickedTags> ? TUnion : never;
type NamespaceEvent<TEvent, TNamespace$1 extends string> = TEvent extends {
  type: infer TEventType;
} ? { [K in keyof TEvent]: K extends 'type' ? `${TNamespace$1}.${TEventType & string}` : TEvent[K] } : never;
type StrictExtract<T, U extends T> = U;
type Converter<TMIMEType extends MIMEType = MIMEType> = {
  mimeType: TMIMEType;
  serialize: Serializer<TMIMEType>;
  deserialize: Deserializer<TMIMEType>;
};
type ConverterEvent<TMIMEType extends MIMEType = MIMEType> = {
  type: 'serialize';
  originEvent: 'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart';
} | {
  type: 'serialization.failure';
  mimeType: TMIMEType;
  originEvent: 'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart';
  reason: string;
} | {
  type: 'serialization.success';
  data: string;
  mimeType: TMIMEType;
  originEvent: 'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart';
} | {
  type: 'deserialize';
  data: string;
} | {
  type: 'deserialization.failure';
  mimeType: TMIMEType;
  reason: string;
} | {
  type: 'deserialization.success';
  data: Array<PortableTextBlock>;
  mimeType: TMIMEType;
};
type Serializer<TMIMEType extends MIMEType> = ({
  snapshot,
  event
}: {
  snapshot: EditorSnapshot;
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'serialize'>;
}) => PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'serialization.success' | 'serialization.failure'>;
type Deserializer<TMIMEType extends MIMEType> = ({
  snapshot,
  event
}: {
  snapshot: EditorSnapshot;
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'deserialize'>;
}) => PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'deserialization.success' | 'deserialization.failure'>;
/**
 * A segment in a path that identifies an element by its `_key` property.
 * @public
 */
interface KeyedSegment {
  _key: string;
}
/**
 * A tuple representing a range selection, e.g., `[0, 5]` or `['', 3]`.
 * @public
 */
type IndexTuple = [number | '', number | ''];
/**
 * A single segment in a path. Can be:
 * - A string (property name)
 * - A number (array index)
 * - A KeyedSegment (object with `_key`)
 * - An IndexTuple (range selection)
 * @public
 */
type PathSegment = string | number | KeyedSegment | IndexTuple;
/**
 * A path is an array of path segments that describes a location in a document.
 * @public
 */
type Path = PathSegment[];
/**
 * @public
 */
type BlockPath = [{
  _key: string;
}];
/**
 * @public
 */
type AnnotationPath = [{
  _key: string;
}, 'markDefs', {
  _key: string;
}];
/**
 * @public
 */
type ChildPath = [{
  _key: string;
}, 'children', {
  _key: string;
}];
/**
 * @public
 */
type EditorSchema = Schema;
type DecoratedRange = BaseRange & {
  rangeDecoration: RangeDecoration;
};
type HistoryItem = {
  operations: Operation[];
  timestamp: Date;
};
interface History {
  redos: HistoryItem[];
  undos: HistoryItem[];
}
type RemotePatch = {
  patch: Patch;
  time: Date;
  snapshot: PortableTextBlock[] | undefined;
  previousSnapshot: PortableTextBlock[] | undefined;
};
interface PortableTextSlateEditor extends ReactEditor {
  _key: 'editor';
  _type: 'editor';
  createPlaceholderBlock: () => Descendant;
  isTextBlock: (value: unknown) => value is PortableTextTextBlock;
  isTextSpan: (value: unknown) => value is PortableTextSpan;
  isListBlock: (value: unknown) => value is PortableTextListBlock;
  decoratedRanges: Array<DecoratedRange>;
  decoratorState: Record<string, boolean | undefined>;
  blockIndexMap: Map<string, number>;
  history: History;
  lastSelection: EditorSelection;
  lastSlateSelection: Range | null;
  listIndexMap: Map<string, number>;
  remotePatches: Array<RemotePatch>;
  undoStepId: string | undefined;
  value: Array<PortableTextBlock>;
  isDeferringMutations: boolean;
  isNormalizingNode: boolean;
  isPatching: boolean;
  isPerformingBehaviorOperation: boolean;
  isProcessingRemoteChanges: boolean;
  isRedoing: boolean;
  isUndoing: boolean;
  withHistory: boolean;
  /**
   * Use hotkeys
   */
  pteWithHotKeys: (event: KeyboardEvent$1<HTMLDivElement>) => void;
  /**
   * Undo
   */
  undo: () => void;
  /**
   * Redo
   */
  redo: () => void;
}
/**
 * @public
 */
type EditorEmittedEvent = {
  type: 'blurred';
  event: FocusEvent<HTMLDivElement, Element>;
} | {
  /**
   * @deprecated Will be removed in the next major version
   */
  type: 'done loading';
} | {
  type: 'editable';
} | ErrorEvent | {
  type: 'focused';
  event: FocusEvent<HTMLDivElement, Element>;
} | {
  type: 'invalid value';
  resolution: InvalidValueResolution | null;
  value: Array<PortableTextBlock> | undefined;
} | {
  /**
   * @deprecated Will be removed in the next major version
   */
  type: 'loading';
} | MutationEvent | PatchEvent | {
  type: 'read only';
} | {
  type: 'ready';
} | {
  type: 'selection';
  selection: EditorSelection;
} | {
  type: 'value changed';
  value: Array<PortableTextBlock> | undefined;
};
/**
 * @deprecated The event is no longer emitted
 */
type ErrorEvent = {
  type: 'error';
  name: string;
  description: string;
  data: unknown;
};
/**
 * @public
 */
type MutationEvent = {
  type: 'mutation';
  patches: Array<Patch>;
  value: Array<PortableTextBlock> | undefined;
};
type PatchEvent = {
  type: 'patch';
  patch: Patch;
};
type SlateEditor = {
  instance: PortableTextSlateEditor;
  initialValue: Array<Descendant>;
};
type InternalEditor = Editor & {
  _internal: {
    editable: EditableAPI;
    editorActor: EditorActor;
    slateEditor: SlateEditor;
  };
};
/**
 * Props for the PortableTextEditor component
 *
 * @public
 * @deprecated Use `EditorProvider` instead
 */
type PortableTextEditorProps<TEditor extends InternalEditor | undefined = undefined> = PropsWithChildren<TEditor extends InternalEditor ? {
  /**
   * @internal
   */
  editor: TEditor;
} : {
  editor?: undefined;
  /**
   * Function that gets called when the editor changes the value
   */
  onChange: (change: EditorChange) => void;
  /**
   * Schema type for the portable text field
   */
  schemaType: ArraySchemaType<PortableTextBlock> | ArrayDefinition;
  /**
   * Function used to generate keys for array items (`_key`)
   */
  keyGenerator?: () => string;
  /**
   * Observable of local and remote patches for the edited value.
   */
  patches$?: PatchObservable;
  /**
   * Backward compatibility (renamed to patches$).
   */
  incomingPatches$?: PatchObservable;
  /**
   * Whether or not the editor should be in read-only mode
   */
  readOnly?: boolean;
  /**
   * The current value of the portable text field
   */
  value?: PortableTextBlock[];
  /**
   * A ref to the editor instance
   */
  editorRef?: MutableRefObject<PortableTextEditor | null>;
}>;
/**
 * The main Portable Text Editor component.
 * @public
 * @deprecated Use `EditorProvider` instead
 */
declare class PortableTextEditor extends Component<PortableTextEditorProps<InternalEditor | undefined>> {
  static displayName: string;
  /**
   * An observable of all the editor changes.
   */
  change$: EditorChanges;
  /**
   * A lookup table for all the relevant schema types for this portable text type.
   */
  schemaTypes: PortableTextMemberSchemaTypes;
  /**
   * The editor instance
   */
  private editor;
  private editable;
  private actors?;
  private subscriptions;
  private unsubscribers;
  constructor(props: PortableTextEditorProps);
  componentDidMount(): void;
  componentDidUpdate(prevProps: PortableTextEditorProps): void;
  componentWillUnmount(): void;
  setEditable: (editable: EditableAPI) => void;
  render(): react10.JSX.Element;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)
   * ```
   */
  static activeAnnotations: (editor: PortableTextEditor) => PortableTextObject[];
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))
   * ```
   */
  static isAnnotationActive: (editor: PortableTextEditor, annotationType: PortableTextObject["_type"]) => boolean;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.add',
   *  annotation: {
   *    name: '...',
   *    value: {...},
   *  }
   * })
   * ```
   */
  static addAnnotation: <TSchemaType extends {
    name: string;
  }>(editor: PortableTextEditor, type: TSchemaType, value?: {
    [prop: string]: unknown;
  }) => AddedAnnotationPaths | undefined;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'blur',
   * })
   * ```
   */
  static blur: (editor: PortableTextEditor) => void;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'delete',
   *  at: {...},
   *  direction: '...',
   *  unit: '...',
   * })
   * ```
   */
  static delete: (editor: PortableTextEditor, selection: EditorSelection, options?: EditableAPIDeleteOptions) => void;
  static findDOMNode: (editor: PortableTextEditor, element: PortableTextBlock | PortableTextChild) => Node | undefined;
  static findByPath: (editor: PortableTextEditor, path: Path) => [_portabletext_schema6.PortableTextTextBlock<PortableTextObject | _portabletext_schema6.PortableTextSpan> | PortableTextObject | _portabletext_schema6.PortableTextSpan | undefined, Path | undefined];
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'focus',
   * })
   * ```
   */
  static focus: (editor: PortableTextEditor) => void;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)
   * ```
   */
  static focusBlock: (editor: PortableTextEditor) => PortableTextBlock | undefined;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)
   * ```
   */
  static focusChild: (editor: PortableTextEditor) => PortableTextChild | undefined;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selection = useEditorSelector(editor, selectors.getSelection)
   * ```
   */
  static getSelection: (editor: PortableTextEditor) => EditorSelection;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const value = useEditorSelector(editor, selectors.getValue)
   * ```
   */
  static getValue: (editor: PortableTextEditor) => PortableTextBlock[] | undefined;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))
   * ```
   */
  static hasBlockStyle: (editor: PortableTextEditor, blockStyle: string) => boolean;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))
   * ```
   */
  static hasListStyle: (editor: PortableTextEditor, listStyle: string) => boolean;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)
   * ```
   */
  static isCollapsedSelection: (editor: PortableTextEditor) => boolean;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)
   * ```
   */
  static isExpandedSelection: (editor: PortableTextEditor) => boolean;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))
   * ```
   */
  static isMarkActive: (editor: PortableTextEditor, mark: string) => boolean;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.span',
   *  text: '...',
   *  annotations: [{name: '...', value: {...}}],
   *  decorators: ['...'],
   * })
   * editor.send({
   *  type: 'insert.inline object',
   *  inlineObject: {
   *    name: '...',
   *    value: {...},
   *  },
   * })
   * ```
   */
  static insertChild: <TSchemaType extends {
    name: string;
  }>(editor: PortableTextEditor, type: TSchemaType, value?: {
    [prop: string]: unknown;
  }) => Path | undefined;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.block object',
   *  blockObject: {
   *    name: '...',
   *    value: {...},
   *  },
   *  placement: 'auto' | 'after' | 'before',
   * })
   * ```
   */
  static insertBlock: <TSchemaType extends {
    name: string;
  }>(editor: PortableTextEditor, type: TSchemaType, value?: {
    [prop: string]: unknown;
  }) => Path | undefined;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.break',
   * })
   * ```
   */
  static insertBreak: (editor: PortableTextEditor) => void;
  static isVoid: (editor: PortableTextEditor, element: PortableTextBlock | PortableTextChild) => boolean;
  static isObjectPath: (_editor: PortableTextEditor, path: Path) => boolean;
  static marks: (editor: PortableTextEditor) => string[];
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'select',
   *  selection: {...},
   * })
   * ```
   */
  static select: (editor: PortableTextEditor, selection: EditorSelection | null) => void;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.remove',
   *  annotation: {
   *    name: '...',
   *  },
   * })
   * ```
   */
  static removeAnnotation: <TSchemaType extends {
    name: string;
  }>(editor: PortableTextEditor, type: TSchemaType) => void;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'style.toggle',
   *  style: '...',
   * })
   * ```
   */
  static toggleBlockStyle: (editor: PortableTextEditor, blockStyle: string) => void;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'list item.toggle',
   *  listItem: '...',
   * })
   * ```
   */
  static toggleList: (editor: PortableTextEditor, listStyle: string) => void;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'decorator.toggle',
   *  decorator: '...',
   * })
   * ```
   */
  static toggleMark: (editor: PortableTextEditor, mark: string) => void;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selectedValue = useEditorSelector(editor, selectors.getSelectedValue)
   * ```
   */
  static getFragment: (editor: PortableTextEditor) => PortableTextBlock[] | undefined;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.undo',
   * })
   * ```
   */
  static undo: (editor: PortableTextEditor) => void;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.redo',
   * })
   * ```
   */
  static redo: (editor: PortableTextEditor) => void;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))
   * ```
   */
  static isSelectionsOverlapping: (editor: PortableTextEditor, selectionA: EditorSelection, selectionB: EditorSelection) => boolean;
}
/**
 * @beta
 */
type HotkeyOptions = {
  marks?: Record<string, string>;
  custom?: Record<string, (event: BaseSyntheticEvent, editor: PortableTextEditor) => void>;
};
/**
 * @public
 */
type PortableTextEditableProps = Omit<TextareaHTMLAttributes<HTMLDivElement>, 'onPaste' | 'onCopy' | 'onBeforeInput'> & {
  ref?: React.Ref<HTMLDivElement>;
  hotkeys?: HotkeyOptions;
  onBeforeInput?: (event: InputEvent) => void;
  onPaste?: OnPasteFn;
  onCopy?: OnCopyFn;
  rangeDecorations?: RangeDecoration[];
  renderAnnotation?: RenderAnnotationFunction;
  renderBlock?: RenderBlockFunction;
  renderChild?: RenderChildFunction;
  renderDecorator?: RenderDecoratorFunction;
  renderListItem?: RenderListItemFunction;
  renderPlaceholder?: RenderPlaceholderFunction;
  renderStyle?: RenderStyleFunction;
  scrollSelectionIntoView?: ScrollSelectionIntoViewFunction;
  selection?: EditorSelection;
  spellCheck?: boolean;
};
/**
 * @public
 *
 *
 * The core component that renders the editor. Must be placed within the {@link EditorProvider} component.
 *
 * @example
 * ```tsx
 * import { PortableTextEditable, EditorProvider } from '@portabletext/editor'
 *
 * function MyComponent() {
 *  return (
 *   <EditorProvider>
 *    <PortableTextEditable />
 *  </EditorProvider>
 *  )
 * }
 * ```
 * @group Components
 */
declare const PortableTextEditable: react10.ForwardRefExoticComponent<Omit<PortableTextEditableProps, "ref"> & react10.RefAttributes<Omit<HTMLDivElement, "as" | "onPaste" | "onBeforeInput">>>;
/** @beta */
interface EditableAPIDeleteOptions {
  mode?: 'blocks' | 'children' | 'selected';
}
/**
 * @public
 */
type AddedAnnotationPaths = {
  /**
   * @deprecated An annotation may be applied to multiple blocks, resulting
   * in multiple `markDef`'s being created. Use `markDefPaths` instead.
   */
  markDefPath: Path;
  markDefPaths: Array<Path>;
  /**
   * @deprecated Does not return anything meaningful since an annotation
   * can span multiple blocks and spans. If references the span closest
   * to the focus point of the selection.
   */
  spanPath: Path;
};
/** @beta */
interface EditableAPI {
  activeAnnotations: () => PortableTextObject[];
  isAnnotationActive: (annotationType: PortableTextObject['_type']) => boolean;
  addAnnotation: <TSchemaType extends {
    name: string;
  }>(type: TSchemaType, value?: {
    [prop: string]: unknown;
  }) => AddedAnnotationPaths | undefined;
  blur: () => void;
  delete: (selection: EditorSelection, options?: EditableAPIDeleteOptions) => void;
  findByPath: (path: Path) => [PortableTextBlock | PortableTextChild | undefined, Path | undefined];
  findDOMNode: (element: PortableTextBlock | PortableTextChild) => Node | undefined;
  focus: () => void;
  focusBlock: () => PortableTextBlock | undefined;
  focusChild: () => PortableTextChild | undefined;
  getSelection: () => EditorSelection;
  getFragment: () => PortableTextBlock[] | undefined;
  getValue: () => PortableTextBlock[] | undefined;
  hasBlockStyle: (style: string) => boolean;
  hasListStyle: (listStyle: string) => boolean;
  insertBlock: <TSchemaType extends {
    name: string;
  }>(type: TSchemaType, value?: {
    [prop: string]: unknown;
  }) => Path;
  insertChild: <TSchemaType extends {
    name: string;
  }>(type: TSchemaType, value?: {
    [prop: string]: unknown;
  }) => Path;
  insertBreak: () => void;
  isCollapsedSelection: () => boolean;
  isExpandedSelection: () => boolean;
  isMarkActive: (mark: string) => boolean;
  isSelectionsOverlapping: (selectionA: EditorSelection, selectionB: EditorSelection) => boolean;
  isVoid: (element: PortableTextBlock | PortableTextChild) => boolean;
  marks: () => string[];
  redo: () => void;
  removeAnnotation: <TSchemaType extends {
    name: string;
  }>(type: TSchemaType) => void;
  select: (selection: EditorSelection) => void;
  toggleBlockStyle: (blockStyle: string) => void;
  toggleList: (listStyle: string) => void;
  toggleMark: (mark: string) => void;
  undo: () => void;
}
/** @public */
type EditorSelectionPoint = {
  path: Path;
  offset: number;
};
/** @public */
type EditorSelection = {
  anchor: EditorSelectionPoint;
  focus: EditorSelectionPoint;
  backward?: boolean;
} | null;
/**
 * The editor has mutated it's content.
 * @beta */
type MutationChange = {
  type: 'mutation';
  patches: Patch[];
  snapshot: PortableTextBlock[] | undefined;
};
/**
 * The editor has produced a patch
 * @beta */
type PatchChange = {
  type: 'patch';
  patch: Patch;
};
/**
 * The editor has received a new (props) value
 * @beta */
type ValueChange = {
  type: 'value';
  value: PortableTextBlock[] | undefined;
};
/**
 * The editor has a new selection
 * @beta */
type SelectionChange = {
  type: 'selection';
  selection: EditorSelection;
};
/**
 * The editor received focus
 * @beta */
type FocusChange = {
  type: 'focus';
  event: FocusEvent<HTMLDivElement, Element>;
};
/**
 * @beta
 * @deprecated Use `'patch'` changes instead
 */
type UnsetChange = {
  type: 'unset';
  previousValue: PortableTextBlock[];
};
/**
 * The editor blurred
 * @beta */
type BlurChange = {
  type: 'blur';
  event: FocusEvent<HTMLDivElement, Element>;
};
/**
 * The editor is currently loading something
 * Could be used to show a spinner etc.
 * @beta
 * @deprecated Will be removed in the next major version
 */
type LoadingChange = {
  type: 'loading';
  isLoading: boolean;
};
/**
 * The editor content is ready to be edited by the user
 * @beta */
type ReadyChange = {
  type: 'ready';
};
/**
 * The editor produced an error
 * @beta
 * @deprecated The change is no longer emitted
 * */
type ErrorChange = {
  type: 'error';
  name: string;
  level: 'warning' | 'error';
  description: string;
  data?: unknown;
};
/**
 * The editor has invalid data in the value that can be resolved by the user
 * @beta */
type InvalidValueResolution = {
  autoResolve?: boolean;
  patches: Patch[];
  description: string;
  action: string;
  item: PortableTextBlock[] | PortableTextBlock | PortableTextChild | undefined;
  /**
   * i18n keys for the description and action
   *
   * These are in addition to the description and action properties, to decouple the editor from
   * the i18n system, and allow usage without it. The i18n keys take precedence over the
   * description and action properties, if i18n framework is available.
   */
  i18n: {
    description: `inputs.portable-text.invalid-value.${Lowercase<string>}.description`;
    action: `inputs.portable-text.invalid-value.${Lowercase<string>}.action`;
    values?: Record<string, string | number | string[]>;
  };
};
/**
 * The editor has an invalid value
 * @beta */
type InvalidValue = {
  type: 'invalidValue';
  resolution: InvalidValueResolution | null;
  value: PortableTextBlock[] | undefined;
};
/**
 * The editor performed a undo history step
 * @beta
 * @deprecated The change is no longer emitted
 *  */
type UndoChange = {
  type: 'undo';
  patches: Patch[];
  timestamp: Date;
};
/**
 * The editor performed redo history step
 * @beta
 * @deprecated The change is no longer emitted
 *  */
type RedoChange = {
  type: 'redo';
  patches: Patch[];
  timestamp: Date;
};
/**
 * The editor was either connected or disconnected to the network
 * To show out of sync warnings etc when in collaborative mode.
 * @beta
 * @deprecated The change is no longer emitted
 *  */
type ConnectionChange = {
  type: 'connection';
  value: 'online' | 'offline';
};
/**
 * When the editor changes, it will emit a change item describing the change
 * @beta */
type EditorChange = BlurChange | ConnectionChange | ErrorChange | FocusChange | InvalidValue | LoadingChange | MutationChange | PatchChange | ReadyChange | RedoChange | SelectionChange | UndoChange | UnsetChange | ValueChange;
/**
 * @beta
 */
type EditorChanges = Subject<EditorChange>;
/** @beta */
type OnPasteResult = {
  insert?: TypedObject[];
  path?: Path;
} | undefined;
/**
 * @beta
 */
type OnPasteResultOrPromise = OnPasteResult | Promise<OnPasteResult>;
/** @beta */
interface PasteData {
  event: ClipboardEvent;
  path: Path;
  schemaTypes: PortableTextMemberSchemaTypes;
  value: PortableTextBlock[] | undefined;
}
/**
 * @beta
 * It is encouraged not to return `Promise<undefined>` from the `OnPasteFn` as
 * a mechanism to fall back to the native paste behaviour. This doesn't work in
 * all cases. Always return plain `undefined` if possible.
 **/
type OnPasteFn = (data: PasteData) => OnPasteResultOrPromise;
/** @beta */
type OnBeforeInputFn = (event: InputEvent) => void;
/** @beta */
type OnCopyFn = (event: ClipboardEvent<HTMLDivElement | HTMLSpanElement>) => undefined | unknown;
/** @beta */
type PatchObservable = Observable<{
  patches: Patch[];
  snapshot: PortableTextBlock[] | undefined;
}>;
/** @beta */
interface BlockRenderProps {
  children: ReactElement<any>;
  editorElementRef: RefObject<HTMLElement | null>;
  focused: boolean;
  level?: number;
  listItem?: string;
  path: BlockPath;
  selected: boolean;
  style?: string;
  schemaType: ObjectSchemaType;
  /** @deprecated Use `schemaType` instead */
  type: ObjectSchemaType;
  value: PortableTextBlock;
}
/** @beta */
interface BlockChildRenderProps {
  annotations: PortableTextObject[];
  children: ReactElement<any>;
  editorElementRef: RefObject<HTMLElement | null>;
  focused: boolean;
  path: Path;
  selected: boolean;
  schemaType: ObjectSchemaType;
  /** @deprecated Use `schemaType` instead */
  type: ObjectSchemaType;
  value: PortableTextChild;
}
/** @beta */
interface BlockAnnotationRenderProps {
  block: PortableTextBlock;
  children: ReactElement<any>;
  editorElementRef: RefObject<HTMLElement | null>;
  focused: boolean;
  path: Path;
  schemaType: ObjectSchemaType;
  selected: boolean;
  /** @deprecated Use `schemaType` instead */
  type: ObjectSchemaType;
  value: PortableTextObject;
}
/** @beta */
interface BlockDecoratorRenderProps {
  children: ReactElement<any>;
  editorElementRef: RefObject<HTMLElement | null>;
  focused: boolean;
  path: Path;
  schemaType: BlockDecoratorDefinition;
  selected: boolean;
  /** @deprecated Use `schemaType` instead */
  type: BlockDecoratorDefinition;
  value: string;
}
/** @beta */
interface BlockListItemRenderProps {
  block: PortableTextTextBlock;
  children: ReactElement<any>;
  editorElementRef: RefObject<HTMLElement | null>;
  focused: boolean;
  level: number;
  path: Path;
  schemaType: BlockListDefinition;
  selected: boolean;
  value: string;
}
/** @beta */
type RenderBlockFunction = (props: BlockRenderProps) => JSX.Element;
/** @beta */
type RenderChildFunction = (props: BlockChildRenderProps) => JSX.Element;
/** @beta */
type RenderEditableFunction = (props: PortableTextEditableProps) => JSX.Element;
/** @beta */
type RenderAnnotationFunction = (props: BlockAnnotationRenderProps) => JSX.Element;
/** @beta */
type RenderPlaceholderFunction = () => React.ReactNode;
/** @beta */
type RenderStyleFunction = (props: BlockStyleRenderProps) => JSX.Element;
/** @beta */
interface BlockStyleRenderProps {
  block: PortableTextTextBlock;
  children: ReactElement<any>;
  editorElementRef: RefObject<HTMLElement | null>;
  focused: boolean;
  path: Path;
  selected: boolean;
  schemaType: BlockStyleDefinition;
  value: string;
}
/** @beta */
type RenderListItemFunction = (props: BlockListItemRenderProps) => JSX.Element;
/** @beta */
type RenderDecoratorFunction = (props: BlockDecoratorRenderProps) => JSX.Element;
/** @beta */
type ScrollSelectionIntoViewFunction = (editor: PortableTextEditor, domRange: globalThis.Range) => void;
/**
 * Parameters for the callback that will be called for a RangeDecoration's onMoved.
 * @alpha */
interface RangeDecorationOnMovedDetails {
  rangeDecoration: RangeDecoration;
  newSelection: EditorSelection;
  origin: 'remote' | 'local';
}
/**
 * A range decoration is a UI affordance that wraps a given selection range in the editor
 * with a custom component. This can be used to highlight search results,
 * mark validation errors on specific words, draw user presence and similar.
 * @alpha */
interface RangeDecoration {
  /**
   * A component for rendering the range decoration.
   * The component will receive the children (text) of the range decoration as its children.
   *
   * @example
   * ```ts
   * (rangeComponentProps: PropsWithChildren) => (
   *    <SearchResultHighlight>
   *      {rangeComponentProps.children}
   *    </SearchResultHighlight>
   *  )
   * ```
   */
  component: (props: PropsWithChildren) => ReactElement<any>;
  /**
   * The editor content selection range
   */
  selection: EditorSelection;
  /**
   * A optional callback that will be called when the range decoration potentially moves according to user edits.
   */
  onMoved?: (details: RangeDecorationOnMovedDetails) => void;
  /**
   * A custom payload that can be set on the range decoration
   */
  payload?: Record<string, unknown>;
}
/** @beta */
type PortableTextMemberSchemaTypes = {
  annotations: (ObjectSchemaType & {
    i18nTitleKey?: string;
  })[];
  block: ObjectSchemaType;
  blockObjects: ObjectSchemaType[];
  decorators: BlockDecoratorDefinition[];
  inlineObjects: ObjectSchemaType[];
  portableText: ArraySchemaType<PortableTextBlock>;
  span: ObjectSchemaType;
  styles: BlockStyleDefinition[];
  lists: BlockListDefinition[];
};
/**
 * @public
 */
type EditorContext = {
  converters: Array<Converter>;
  keyGenerator: () => string;
  readOnly: boolean;
  schema: EditorSchema;
  selection: EditorSelection;
  value: Array<PortableTextBlock>;
};
/**
 * @public
 */
type EditorSnapshot = {
  context: EditorContext;
  blockIndexMap: Map<string, number>;
  /**
   * @beta
   * Subject to change
   */
  decoratorState: Record<string, boolean | undefined>;
};
/**
 * @beta
 */
type BehaviorGuard<TBehaviorEvent, TGuardResponse> = (payload: {
  snapshot: EditorSnapshot;
  event: TBehaviorEvent;
  dom: EditorDom;
}) => TGuardResponse | false;
/**
 * @beta
 */
type Behavior<TBehaviorEventType extends '*' | `${BehaviorEventTypeNamespace}.*` | BehaviorEvent['type'] = '*' | `${BehaviorEventTypeNamespace}.*` | BehaviorEvent['type'], TGuardResponse = true, TBehaviorEvent extends ResolveBehaviorEvent<TBehaviorEventType> = ResolveBehaviorEvent<TBehaviorEventType>> = {
  /**
   * Editor Event that triggers this Behavior.
   */
  on: TBehaviorEventType;
  /**
   * Predicate function that determines if the Behavior should be executed.
   * Returning a non-nullable value from the guard will pass the value to the
   * actions and execute them.
   */
  guard?: BehaviorGuard<TBehaviorEvent, TGuardResponse>;
  /**
   * Array of Behavior Action sets.
   * Each set represents a step in the history stack.
   */
  actions: Array<BehaviorActionSet<TBehaviorEvent, TGuardResponse>>;
};
/**
 * @beta
 *
 * @example
 *
 * ```tsx
 * const noLowerCaseA = defineBehavior({
 *   on: 'insert.text',
 *   guard: ({event, snapshot}) => event.text === 'a',
 *   actions: [({event, snapshot}) => [{type: 'insert.text', text: 'A'}]],
 * })
 * ```
 *
 */
declare function defineBehavior<TPayload extends Record<string, unknown>, TBehaviorEventType extends '*' | `${BehaviorEventTypeNamespace}.*` | BehaviorEvent['type'] = CustomBehaviorEvent['type'], TGuardResponse = true>(behavior: Behavior<TBehaviorEventType, TGuardResponse, ResolveBehaviorEvent<TBehaviorEventType, TPayload>>): Behavior;
/**
 * @public
 */
type EditorConfig = {
  /**
   * @beta
   */
  keyGenerator?: () => string;
  readOnly?: boolean;
  initialValue?: Array<PortableTextBlock>;
} & ({
  schemaDefinition: SchemaDefinition;
  schema?: undefined;
} | {
  schemaDefinition?: undefined;
  schema: ArraySchemaType<PortableTextBlock> | ArrayDefinition;
});
/**
 * @public
 */
type EditorEvent = ExternalEditorEvent | ExternalBehaviorEvent | {
  type: 'update value';
  value: Array<PortableTextBlock> | undefined;
};
/**
 * @public
 */
type Editor = {
  dom: EditorDom;
  getSnapshot: () => EditorSnapshot;
  /**
   * @beta
   */
  registerBehavior: (config: {
    behavior: Behavior;
  }) => () => void;
  send: (event: EditorEvent) => void;
  on: ActorRef<Snapshot<unknown>, EventObject, EditorEmittedEvent>['on'];
};
/**
 * @public
 */
type EditorProviderProps = {
  initialConfig: EditorConfig;
  children?: React$1.ReactNode;
};
/**
 * @public
 * The EditorProvider component is used to set up the editor context and configure the Portable Text Editor.
 * @example
 * ```tsx
 * import {EditorProvider} from '@portabletext/editor'
 *
 * function App() {
 *  return (
 *    <EditorProvider initialConfig={{ ... }} >
 *      ...
 *    </EditorProvider>
 *  )
 * }
 *
 * ```
 * @group Components
 */
declare function EditorProvider(props: EditorProviderProps): React$1.JSX.Element;
/**
 * @public
 */
type EditorSelector<TSelected> = (snapshot: EditorSnapshot) => TSelected;
/**
 * @public
 * Hook to select a value from the editor state.
 * @example
 * Pass a selector as the second argument
 * ```tsx
 * import { useEditorSelector } from '@portabletext/editor'
 *
 * function MyComponent(editor) {
 *  const value = useEditorSelector(editor, selector)
 * }
 * ```
 * @example
 * Pass an inline selector as the second argument.
 * In this case, use the editor context to obtain the schema.
 * ```tsx
 * import { useEditorSelector } from '@portabletext/editor'
 *
 * function MyComponent(editor) {
 *  const schema = useEditorSelector(editor, (snapshot) => snapshot.context.schema)
 * }
 * ```
 * @group Hooks
 */
declare function useEditorSelector<TSelected>(editor: Editor, selector: EditorSelector<TSelected>, compare?: (a: TSelected, b: TSelected) => boolean): TSelected;
/**
 * @deprecated Use `useEditor` to get the current editor instance.
 * @public
 * Get the current editor object from the React context.
 */
declare const usePortableTextEditor: () => PortableTextEditor;
/**
 * @deprecated Use `useEditorSelector` to get the current editor selection.
 * @public
 * Get the current editor selection from the React context.
 */
declare const usePortableTextEditorSelection: () => EditorSelection;
/**
 * @public
 */
declare const defaultKeyGenerator: () => string;
/**
 * @public
 * Get the current editor context from the `EditorProvider`.
 * Must be used inside the `EditorProvider` component.
 * @returns The current editor object.
 * @example
 * ```tsx
 * import { useEditor } from '@portabletext/editor'
 *
 * function MyComponent() {
 *  const editor = useEditor()
 * }
 * ```
 * @group Hooks
 */
declare function useEditor(): Editor;
/**
 * @beta
 */
type BlockOffset = {
  path: BlockPath;
  offset: number;
};
type EditorPriority = {
  id: string;
  name?: string;
  reference?: {
    priority: EditorPriority;
    importance: 'higher' | 'lower';
  };
};
type BehaviorConfig = {
  behavior: Behavior;
  priority: EditorPriority;
};
/**
 * @public
 */
type PatchesEvent = {
  type: 'patches';
  patches: Array<Patch>;
  snapshot: Array<PortableTextBlock> | undefined;
};
/**
 * @public
 */
type ExternalEditorEvent = {
  type: 'update readOnly';
  readOnly: boolean;
} | PatchesEvent;
type InternalPatchEvent = NamespaceEvent<PatchEvent, 'internal'> & {
  operationId?: string;
  value: Array<PortableTextBlock>;
};
/**
 * @internal
 */
type EditorActor = ActorRefFrom<typeof editorMachine>;
/**
 * @internal
 */
declare const editorMachine: xstate71.StateMachine<{
  behaviors: Set<BehaviorConfig>;
  behaviorsSorted: boolean;
  converters: Set<Converter>;
  getLegacySchema: () => PortableTextMemberSchemaTypes;
  keyGenerator: () => string;
  pendingEvents: Array<InternalPatchEvent | MutationEvent>;
  pendingIncomingPatchesEvents: Array<PatchesEvent>;
  schema: EditorSchema;
  initialReadOnly: boolean;
  selection: EditorSelection;
  initialValue: Array<PortableTextBlock> | undefined;
  internalDrag?: {
    origin: Pick<EventPosition, "selection">;
  };
  dragGhost?: HTMLElement;
  slateEditor?: PortableTextSlateEditor;
}, InternalPatchEvent | MutationEvent | PatchesEvent | {
  type: "update readOnly";
  readOnly: boolean;
} | {
  type: "add behavior";
  behaviorConfig: BehaviorConfig;
} | {
  type: "remove behavior";
  behaviorConfig: BehaviorConfig;
} | {
  type: "blur";
  editor: PortableTextSlateEditor;
} | {
  type: "focus";
  editor: PortableTextSlateEditor;
} | {
  type: "update selection";
  selection: EditorSelection;
} | {
  type: "done syncing value";
} | {
  type: "syncing value";
} | {
  type: "behavior event";
  behaviorEvent: BehaviorEvent;
  editor: PortableTextSlateEditor;
  nativeEvent?: {
    preventDefault: () => void;
  };
} | {
  type: "set drag ghost";
  ghost: HTMLElement;
} | {
  type: "dragstart";
  ghost?: HTMLElement;
  origin: Pick<EventPosition, "selection">;
} | {
  type: "dragend";
} | {
  type: "drop";
} | {
  type: "add slate editor";
  editor: PortableTextSlateEditor;
}, {}, never, {
  type: "add behavior to context";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "remove behavior from context";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "add slate editor to context";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "emit patch event";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "emit mutation event";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "emit read only";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "emit editable";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "defer event";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "emit pending events";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "emit ready";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "clear pending events";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "defer incoming patches";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "emit pending incoming patches";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "clear pending incoming patches";
  params: xstate71.NonReducibleUnknown;
} | {
  type: "handle blur";
  params: unknown;
} | {
  type: "handle focus";
  params: unknown;
} | {
  type: "handle behavior event";
  params: unknown;
} | {
  type: "sort behaviors";
  params: xstate71.NonReducibleUnknown;
}, {
  type: "slate is busy";
  params: unknown;
} | {
  type: "slate is normalizing node";
  params: unknown;
}, never, {
  "edit mode": {
    editable: "dragging internally" | "idle" | {
      focusing: "checking if busy" | "busy";
    };
  } | {
    "read only": "read only" | "determine initial edit mode";
  };
  setup: "setting up" | {
    "set up": {
      "value sync": "syncing value" | "idle";
      writing: "dirty" | {
        pristine: "idle";
      };
    };
  };
}, "dragging internally", {
  converters?: Array<Converter>;
  getLegacySchema: () => PortableTextMemberSchemaTypes;
  keyGenerator: () => string;
  readOnly?: boolean;
  schema: EditorSchema;
  initialValue?: Array<PortableTextBlock>;
}, xstate71.NonReducibleUnknown, InternalPatchEvent | MutationEvent | PatchesEvent | {
  type: "blurred";
  event: react10.FocusEvent<HTMLDivElement, Element>;
} | {
  type: "done loading";
} | {
  type: "editable";
} | {
  type: "error";
  name: string;
  description: string;
  data: unknown;
} | {
  type: "focused";
  event: react10.FocusEvent<HTMLDivElement, Element>;
} | {
  type: "invalid value";
  resolution: InvalidValueResolution | null;
  value: Array<PortableTextBlock> | undefined;
} | {
  type: "loading";
} | {
  type: "read only";
} | {
  type: "ready";
} | {
  type: "selection";
  selection: EditorSelection;
} | {
  type: "value changed";
  value: Array<PortableTextBlock> | undefined;
}, xstate71.MetaObject, {
  id: "editor";
  states: {
    readonly 'edit mode': {
      states: {
        readonly 'read only': {
          states: {
            readonly 'determine initial edit mode': {};
            readonly 'read only': {};
          };
        };
        readonly editable: {
          states: {
            readonly idle: {};
            readonly focusing: {
              states: {
                readonly 'checking if busy': {};
                readonly busy: {};
              };
            };
            readonly 'dragging internally': {};
          };
        };
      };
    };
    readonly setup: {
      states: {
        readonly 'setting up': {};
        readonly 'set up': {
          states: {
            readonly 'value sync': {
              states: {
                readonly idle: {};
                readonly 'syncing value': {};
              };
            };
            readonly writing: {
              states: {
                readonly pristine: {
                  states: {
                    readonly idle: {};
                  };
                };
                readonly dirty: {};
              };
            };
          };
        };
      };
    };
  };
}>;
type EventPosition = {
  block: 'start' | 'end';
  /**
   * Did the event origin from the editor DOM node itself or from a child node?
   */
  isEditor: boolean;
  selection: NonNullable<EditorSelection>;
};
type TextBlockWithOptionalKey = Omit<PortableTextTextBlock, '_key'> & {
  _key?: PortableTextTextBlock['_key'];
};
type ObjectBlockWithOptionalKey = Omit<PortableTextObject, '_key'> & {
  _key?: PortableTextObject['_key'];
};
type BlockWithOptionalKey = TextBlockWithOptionalKey | ObjectBlockWithOptionalKey;
type SpanWithOptionalKey = Omit<PortableTextSpan, '_key'> & {
  _key?: PortableTextSpan['_key'];
};
type ChildWithOptionalKey = SpanWithOptionalKey | ObjectBlockWithOptionalKey;
/**
 * @beta
 */
type BehaviorEvent = SyntheticBehaviorEvent | NativeBehaviorEvent | CustomBehaviorEvent;
type BehaviorEventTypeNamespace = SyntheticBehaviorEventNamespace | NativeBehaviorEventNamespace | CustomBehaviorEventNamespace;
type NamespacedBehaviorEventType<TNamespace$1 extends BehaviorEventTypeNamespace | ''> = TNamespace$1 extends '' ? BehaviorEvent['type'] : Extract<BehaviorEvent['type'], TNamespace$1 | `${TNamespace$1}.${string}`>;
/**************************************
 * External events
 **************************************/
type ExternalBehaviorEventNamespace = 'blur' | 'focus' | 'insert';
type ExternalBehaviorEventType<TNamespace$1 extends ExternalBehaviorEventNamespace, TType$1 extends string = ''> = TType$1 extends '' ? `${TNamespace$1}` : `${TNamespace$1}.${TType$1}`;
type ExternalBehaviorEvent = {
  type: ExternalBehaviorEventType<'blur'>;
} | {
  type: ExternalBehaviorEventType<'focus'>;
} | {
  type: ExternalBehaviorEventType<'insert', 'block object'>;
  placement: InsertPlacement;
  blockObject: {
    name: string;
    value?: {
      [prop: string]: unknown;
    };
  };
} | BehaviorEvent;
/**************************************
 * Synthetic events
 **************************************/
declare const syntheticBehaviorEventTypes: readonly ["annotation.add", "annotation.remove", "block.set", "block.unset", "child.set", "child.unset", "decorator.add", "decorator.remove", "delete", "history.redo", "history.undo", "insert.block", "insert.child", "insert.text", "move.backward", "move.block", "move.forward", "select"];
type SyntheticBehaviorEventType = (typeof syntheticBehaviorEventTypes)[number] | (typeof abstractBehaviorEventTypes)[number];
type SyntheticBehaviorEventNamespace = ExtractNamespace<SyntheticBehaviorEventType>;
/**
 * @beta
 */
type SyntheticBehaviorEvent = {
  type: StrictExtract<SyntheticBehaviorEventType, 'annotation.add'>;
  annotation: {
    name: string;
    _key?: string;
    value: {
      [prop: string]: unknown;
    };
  };
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'annotation.remove'>;
  annotation: {
    name: string;
  };
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'block.set'>;
  at: BlockPath;
  props: Record<string, unknown>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'block.unset'>;
  at: BlockPath;
  props: Array<string>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'child.set'>;
  at: ChildPath;
  props: {
    [prop: string]: unknown;
  };
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'child.unset'>;
  at: ChildPath;
  props: Array<string>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'decorator.add'>;
  decorator: string;
  at?: NonNullable<EditorSelection>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'decorator.remove'>;
  decorator: string;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'delete'>;
  at?: NonNullable<EditorSelection>;
  /**
   * Defaults to forward deletion.
   */
  direction?: 'backward' | 'forward';
  /**
   * Defaults to character deletion.
   */
  unit?: 'character' | 'word' | 'line' | 'block' | 'child';
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'history.redo'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'history.undo'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.block'>;
  block: BlockWithOptionalKey;
  placement: InsertPlacement;
  select?: 'start' | 'end' | 'none';
  at?: NonNullable<EditorSelection>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.child'>;
  child: ChildWithOptionalKey;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.text'>;
  text: string;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'move.backward'>;
  distance: number;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'move.block'>;
  at: BlockPath;
  to: BlockPath;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'move.forward'>;
  distance: number;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'select'>;
  at: EditorSelection;
} | AbstractBehaviorEvent;
/**
 * @beta
 */
type InsertPlacement = 'auto' | 'after' | 'before';
/**************************************
 * Abstract events
 **************************************/
declare const abstractBehaviorEventTypes: readonly ["annotation.set", "annotation.toggle", "decorator.toggle", "delete.backward", "delete.block", "delete.child", "delete.forward", "delete.text", "deserialize", "deserialize.data", "deserialization.success", "deserialization.failure", "insert.blocks", "insert.break", "insert.inline object", "insert.soft break", "insert.span", "list item.add", "list item.remove", "list item.toggle", "move.block down", "move.block up", "select.block", "select.previous block", "select.next block", "serialize", "serialize.data", "serialization.success", "serialization.failure", "split", "style.add", "style.remove", "style.toggle"];
type AbstractBehaviorEvent = {
  type: StrictExtract<SyntheticBehaviorEventType, 'annotation.set'>;
  at: AnnotationPath;
  props: Record<string, unknown>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'annotation.toggle'>;
  annotation: {
    name: string;
    value: {
      [prop: string]: unknown;
    };
  };
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'decorator.toggle'>;
  decorator: string;
  at?: NonNullable<EditorSelection>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'delete.backward'>;
  unit: 'character' | 'word' | 'line' | 'block';
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'delete.block'>;
  at: BlockPath;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'delete.child'>;
  at: ChildPath;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'delete.forward'>;
  unit: 'character' | 'word' | 'line' | 'block';
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'delete.text'>;
  at: NonNullable<EditorSelection>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'deserialize'>;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'drag.drop' | 'clipboard.paste'> | InputBehaviorEvent;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'deserialize.data'>;
  mimeType: MIMEType;
  data: string;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'drag.drop' | 'clipboard.paste'> | InputBehaviorEvent;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'serialize'>;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'serialize.data'>;
  mimeType: MIMEType;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'deserialization.success'>;
  mimeType: MIMEType;
  data: Array<PortableTextBlock>;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'drag.drop' | 'clipboard.paste'> | InputBehaviorEvent;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'deserialization.failure'>;
  mimeType: MIMEType;
  reason: string;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'drag.drop' | 'clipboard.paste'> | InputBehaviorEvent;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'serialization.success'>;
  mimeType: MIMEType;
  data: string;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'serialization.failure'>;
  mimeType: MIMEType;
  reason: string;
  originEvent: PickFromUnion<NativeBehaviorEvent, 'type', 'clipboard.copy' | 'clipboard.cut' | 'drag.dragstart'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.blocks'>;
  blocks: Array<BlockWithOptionalKey>;
  placement: InsertPlacement;
  select?: 'start' | 'end' | 'none';
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.break'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.inline object'>;
  inlineObject: {
    name: string;
    value?: {
      [prop: string]: unknown;
    };
  };
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.soft break'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'insert.span'>;
  text: string;
  annotations?: Array<{
    name: string;
    value: {
      [prop: string]: unknown;
    };
  }>;
  decorators?: Array<string>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'list item.add'>;
  listItem: string;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'list item.remove'>;
  listItem: string;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'list item.toggle'>;
  listItem: string;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'move.block down'>;
  at: BlockPath;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'move.block up'>;
  at: BlockPath;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'select.block'>;
  at: BlockPath;
  select?: 'start' | 'end';
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'select.previous block'>;
  select?: 'start' | 'end';
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'select.next block'>;
  select?: 'start' | 'end';
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'split'>;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'style.add'>;
  style: string;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'style.remove'>;
  style: string;
} | {
  type: StrictExtract<SyntheticBehaviorEventType, 'style.toggle'>;
  style: string;
};
/**************************************
 * Native events
 **************************************/
declare const nativeBehaviorEventTypes: readonly ["clipboard.copy", "clipboard.cut", "clipboard.paste", "drag.dragstart", "drag.drag", "drag.dragend", "drag.dragenter", "drag.dragover", "drag.dragleave", "drag.drop", "input.*", "keyboard.keydown", "keyboard.keyup", "mouse.click"];
type NativeBehaviorEventType = (typeof nativeBehaviorEventTypes)[number];
type NativeBehaviorEventNamespace = ExtractNamespace<NativeBehaviorEventType>;
/**
 * @beta
 */
type NativeBehaviorEvent = ClipboardBehaviorEvent | DragBehaviorEvent | InputBehaviorEvent | KeyboardBehaviorEvent | MouseBehaviorEvent;
type ClipboardBehaviorEvent = {
  type: StrictExtract<NativeBehaviorEventType, 'clipboard.copy'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
  position: Pick<EventPosition, 'selection'>;
} | {
  type: StrictExtract<NativeBehaviorEventType, 'clipboard.cut'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
  position: Pick<EventPosition, 'selection'>;
} | {
  type: StrictExtract<NativeBehaviorEventType, 'clipboard.paste'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
  position: Pick<EventPosition, 'selection'>;
};
type DragBehaviorEvent = {
  type: StrictExtract<NativeBehaviorEventType, 'drag.dragstart'>;
  originEvent: {
    clientX: number;
    clientY: number;
    dataTransfer: DataTransfer;
  };
  position: Pick<EventPosition, 'selection'>;
} | {
  type: StrictExtract<NativeBehaviorEventType, 'drag.drag'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
} | {
  type: StrictExtract<NativeBehaviorEventType, 'drag.dragend'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
} | {
  type: StrictExtract<NativeBehaviorEventType, 'drag.dragenter'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
  position: EventPosition;
} | {
  type: StrictExtract<NativeBehaviorEventType, 'drag.dragover'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
  dragOrigin?: Pick<EventPosition, 'selection'>;
  position: EventPosition;
} | {
  type: StrictExtract<NativeBehaviorEventType, 'drag.drop'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
  dragOrigin?: Pick<EventPosition, 'selection'>;
  position: EventPosition;
} | {
  type: StrictExtract<NativeBehaviorEventType, 'drag.dragleave'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
};
/**
 * Used to represent native InputEvents that hold a DataTransfer object.
 *
 * These can either be one of:
 *
 * - insertFromPaste
 * - insertFromPasteAsQuotation
 * - insertFromDrop
 * - insertReplacementText
 * - insertFromYank
 */
type InputBehaviorEvent = {
  type: StrictExtract<NativeBehaviorEventType, 'input.*'>;
  originEvent: {
    dataTransfer: DataTransfer;
  };
};
type KeyboardBehaviorEvent = {
  type: StrictExtract<NativeBehaviorEventType, 'keyboard.keydown'>;
  originEvent: Pick<KeyboardEvent, 'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'>;
} | {
  type: StrictExtract<NativeBehaviorEventType, 'keyboard.keyup'>;
  originEvent: Pick<KeyboardEvent, 'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'>;
};
type MouseBehaviorEvent = {
  type: StrictExtract<NativeBehaviorEventType, 'mouse.click'>;
  position: EventPosition;
};
/**************************************
 * Custom events
 **************************************/
type CustomBehaviorEventNamespace = 'custom';
type CustomBehaviorEventType<TNamespace$1 extends CustomBehaviorEventNamespace, TType$1 extends string = ''> = TType$1 extends '' ? `${TNamespace$1}` : `${TNamespace$1}.${TType$1}`;
/**
 * @beta
 */
type CustomBehaviorEvent<TPayload extends Record<string, unknown> = Record<string, unknown>, TType$1 extends string = string, TInternalType extends CustomBehaviorEventType<'custom', TType$1> = CustomBehaviorEventType<'custom', TType$1>> = {
  type: TInternalType;
} & TPayload;
/**************************************
 * Resolve behavior event
 **************************************/
type ResolveBehaviorEvent<TBehaviorEventType extends '*' | `${BehaviorEventTypeNamespace}.*` | BehaviorEvent['type'], TPayload extends Record<string, unknown> = Record<string, unknown>> = TBehaviorEventType extends '*' ? BehaviorEvent : TBehaviorEventType extends `${infer TNamespace}.*` ? TNamespace extends BehaviorEventTypeNamespace ? PickFromUnion<BehaviorEvent, 'type', NamespacedBehaviorEventType<TNamespace>> : never : TBehaviorEventType extends `custom.${infer TType}` ? CustomBehaviorEvent<TPayload, TType> : TBehaviorEventType extends BehaviorEvent['type'] ? PickFromUnion<BehaviorEvent, 'type', TBehaviorEventType> : never;
type ExtractNamespace<TType$1 extends string> = TType$1 extends `${infer Namespace}.${string}` ? Namespace : TType$1;
type EditorDom = {
  getBlockNodes: (snapshot: EditorSnapshot) => Array<Node>;
  getChildNodes: (snapshot: EditorSnapshot) => Array<Node>;
  getEditorElement: () => Element | undefined;
  getSelectionRect: (snapshot: EditorSnapshot) => DOMRect | null;
  getStartBlockElement: (snapshot: EditorSnapshot) => Element | null;
  getEndBlockElement: (snapshot: EditorSnapshot) => Element | null;
  /**
   * Let the Editor set the drag ghost. This is to be sure that it will get
   * properly removed again when the drag ends.
   */
  setDragGhost: ({
    event,
    ghost
  }: {
    event: PickFromUnion<BehaviorEvent, 'type', 'drag.dragstart'>;
    ghost: {
      element: HTMLElement;
      x: number;
      y: number;
    };
  }) => void;
};
/**
 * @beta
 */
type BehaviorAction = {
  type: 'execute';
  event: SyntheticBehaviorEvent;
} | {
  type: 'forward';
  event: NativeBehaviorEvent | SyntheticBehaviorEvent | CustomBehaviorEvent;
} | {
  type: 'raise';
  event: SyntheticBehaviorEvent | CustomBehaviorEvent;
} | {
  type: 'effect';
  effect: (payload: {
    /**
     * Send a Behavior Event back into the Editor.
     *
     * @example
     * ```ts
     * defineBehavior({
     *   on: '...',
     *   actions: [
     *     () => [
     *       effect(({send}) => {
     *         doSomethingAsync()
     *           .then(() => {
     *             send({
     *               type: '...',
     *             })
     *           })
     *       })
     *     ],
     *   ],
     * })
     * ```
     */
    send: (event: ExternalBehaviorEvent) => void;
  }) => void;
};
/**
 * @beta
 */
declare function execute(event: SyntheticBehaviorEvent): PickFromUnion<BehaviorAction, 'type', 'execute'>;
/**
 * @beta
 */
declare function forward(event: NativeBehaviorEvent | SyntheticBehaviorEvent | CustomBehaviorEvent): PickFromUnion<BehaviorAction, 'type', 'forward'>;
/**
 * @beta
 */
declare function raise(event: SyntheticBehaviorEvent | CustomBehaviorEvent): PickFromUnion<BehaviorAction, 'type', 'raise'>;
/**
 * @beta
 */
declare function effect(effect: PickFromUnion<BehaviorAction, 'type', 'effect'>['effect']): PickFromUnion<BehaviorAction, 'type', 'effect'>;
/**
 * @beta
 */
type BehaviorActionSet<TBehaviorEvent, TGuardResponse> = (payload: {
  snapshot: EditorSnapshot;
  event: TBehaviorEvent;
  dom: EditorDom;
}, guardResponse: TGuardResponse) => Array<BehaviorAction>;
export { BlockAnnotationRenderProps as $, AnnotationPath as $t, PortableTextTextBlock$1 as A, ReadyChange as At, EditorSelector as B, ScrollSelectionIntoViewFunction as Bt, ListDefinition as C, OnPasteResultOrPromise as Ct, PortableTextChild$1 as D, PortableTextMemberSchemaTypes as Dt, PortableTextBlock$1 as E, PatchObservable as Et, BlockOffset as F, RenderDecoratorFunction as Ft, EditorConfig as G, PortableTextEditable as Gt, EditorProvider as H, UndoChange as Ht, useEditor as I, RenderEditableFunction as It, defineBehavior as J, PortableTextEditor as Jt, EditorEvent as K, PortableTextEditableProps as Kt, defaultKeyGenerator as L, RenderListItemFunction as Lt, StyleDefinition as M, RenderAnnotationFunction as Mt, StyleSchemaType as N, RenderBlockFunction as Nt, PortableTextObject$1 as O, RangeDecoration as Ot, defineSchema as P, RenderChildFunction as Pt, AddedAnnotationPaths as Q, EditorSchema as Qt, usePortableTextEditorSelection as R, RenderPlaceholderFunction as Rt, InlineObjectSchemaType as S, OnPasteResult as St, Patch$1 as T, PatchChange as Tt, EditorProviderProps as U, UnsetChange as Ut, useEditorSelector as V, SelectionChange as Vt, Editor as W, ValueChange as Wt, EditorContext as X, EditorEmittedEvent as Xt, BehaviorGuard as Y, PortableTextEditorProps as Yt, EditorSnapshot as Z, MutationEvent as Zt, BlockObjectSchemaType as _, LoadingChange as _t, forward as a, BlurChange as at, FieldDefinition as b, OnCopyFn as bt, CustomBehaviorEvent as c, EditableAPIDeleteOptions as ct, SyntheticBehaviorEvent as d, EditorSelection as dt, BlockPath as en, BlockChildRenderProps as et, PatchesEvent as f, EditorSelectionPoint as ft, BlockObjectDefinition as g, InvalidValueResolution as gt, BaseDefinition as h, InvalidValue as ht, execute as i, BlockStyleRenderProps as it, SchemaDefinition$1 as j, RedoChange as jt, PortableTextSpan$1 as k, RangeDecorationOnMovedDetails as kt, InsertPlacement as l, EditorChange as lt, AnnotationSchemaType as m, FocusChange as mt, BehaviorActionSet as n, KeyedSegment as nn, BlockListItemRenderProps as nt, raise as o, ConnectionChange as ot, AnnotationDefinition as p, ErrorChange as pt, Behavior as q, HotkeyOptions as qt, effect as r, BlockRenderProps as rt, BehaviorEvent as s, EditableAPI as st, BehaviorAction as t, ChildPath as tn, BlockDecoratorRenderProps as tt, NativeBehaviorEvent as u, EditorChanges as ut, DecoratorDefinition as v, MutationChange as vt, ListSchemaType as w, PasteData as wt, InlineObjectDefinition as x, OnPasteFn as xt, DecoratorSchemaType as y, OnBeforeInputFn as yt, usePortableTextEditor as z, RenderStyleFunction as zt };