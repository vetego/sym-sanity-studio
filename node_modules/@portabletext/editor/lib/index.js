import { jsxs, jsx, Fragment } from "react/jsx-runtime";
import { c } from "react/compiler-runtime";
import { useSelector, useActorRef } from "@xstate/react";
import { createContext, useRef, useContext, useState, useEffect, forwardRef, Component, startTransition } from "react";
import { Element as Element$1, Text, Range, Editor, Node, Point, Path, Transforms, createEditor, deleteText, Operation } from "slate";
import { useSelected, useSlateSelector, useSlateStatic, ReactEditor, useSlate, Editable, withReact, Slate } from "slate-react";
import debug$e from "debug";
import { DOMEditor, isDOMNode, EDITOR_TO_PENDING_SELECTION, IS_FOCUSED, IS_READ_ONLY } from "slate-dom";
import { getBlockEndPoint, getBlockStartPoint, getBlockKeyFromSelectionPoint, isSelectionCollapsed, isKeyedSegment, isEqualSelectionPoints, getChildKeyFromSelectionPoint, blockOffsetToSpanSelectionPoint, defaultKeyGenerator, parseBlocks, parseBlock, isListBlock, isTypedObject, getSelectionStartPoint as getSelectionStartPoint$1, getSelectionEndPoint as getSelectionEndPoint$1, parseAnnotation, parseMarkDefs, parseSpan, parseInlineObject } from "./_chunks-es/util.slice-blocks.js";
import { isTextBlock, isSpan, compileSchema } from "@portabletext/schema";
import { defineSchema } from "@portabletext/schema";
import { isEmptyTextBlock, sliceTextBlock, getTextBlockText } from "./_chunks-es/util.slice-text-block.js";
import { setup, fromCallback, assign, and, enqueueActions, emit, assertEvent, raise as raise$1, not, createActor } from "xstate";
import { isSelectionCollapsed as isSelectionCollapsed$1, getFocusSpan as getFocusSpan$1, isOverlappingSelection, getFocusInlineObject, getFocusTextBlock, getSelectedBlocks, isSelectionExpanded, getSelectionStartBlock, getSelectionEndBlock, getFocusBlock as getFocusBlock$1, isSelectingEntireBlocks, getSelectedValue, isActiveAnnotation, getActiveAnnotationsMarks, getActiveDecorators, getSelectionStartChild, getSelectionEndChild, getSelectionStartPoint, getSelectionEndPoint, getPreviousSpan, getNextSpan, getCaretWordSelection, getFocusBlockObject, getPreviousBlock, getNextBlock, getMarkState, isAtTheEndOfBlock, isAtTheStartOfBlock, getFocusListBlock, isActiveDecorator, getFocusChild as getFocusChild$1, getActiveAnnotations, getLastBlock as getLastBlock$1, getSelectedTextBlocks, isActiveListItem, isActiveStyle } from "./_chunks-es/selector.is-at-the-start-of-block.js";
import { defineBehavior, forward, raise, effect } from "./behaviors/index.js";
import { compileSchemaDefinitionToPortableTextMemberSchemaTypes, createPortableTextMemberSchemaTypes, portableTextMemberSchemaTypesToSchema } from "@portabletext/sanity-bridge";
import { htmlToBlocks } from "@portabletext/block-tools";
import { toHTML } from "@portabletext/to-html";
import { markdownToPortableText, portableTextToMarkdown } from "@portabletext/markdown";
import { Schema } from "@sanity/schema";
import { applyAll, unset, insert, set, setIfMissing, diffMatchPatch as diffMatchPatch$1 } from "@portabletext/patches";
import { createKeyboardShortcut, code, underline, italic, bold, undo, redo } from "@portabletext/keyboard-shortcuts";
import { EditorContext } from "./_chunks-es/use-editor.js";
import { useEditor } from "./_chunks-es/use-editor.js";
import { Subject } from "rxjs";
const rootName = "sanity-pte:";
debug$e(rootName);
function debugWithName(name) {
  const namespace = `${rootName}${name}`;
  return debug$e && debug$e.enabled(namespace) ? debug$e(namespace) : debug$e(rootName);
}
function isEqualValues(context, a, b) {
  if (!a || !b)
    return a === b;
  if (a.length !== b.length)
    return !1;
  for (let index = 0; index < a.length; index++) {
    const blockA = a.at(index), blockB = b.at(index);
    if (!blockA || !blockB || !isEqualBlocks(context, blockA, blockB))
      return !1;
  }
  return !0;
}
function isEqualBlocks(context, a, b) {
  return a._type !== b._type ? !1 : a._type === context.schema.block.name && b._type === context.schema.block.name ? isEqualTextBlocks(context, a, b) : isEqualPortableTextObjects(a, b);
}
function isEqualTextBlocks(context, a, b) {
  return !isTextBlock(context, a) || !isTextBlock(context, b) || a._key !== b._key || a.style !== b.style || a.listItem !== b.listItem || a.level !== b.level || "markDefs" in a && "markDefs" in b && (!Array.isArray(a.markDefs) || !Array.isArray(b.markDefs) || !isEqualMarkDefs(a.markDefs, b.markDefs)) || !isEqualChildren(a.children, b.children) ? !1 : isEqualProps(a, b, ["_key", "_type", "style", "listItem", "level", "markDefs", "children"]);
}
function isEqualProps(a, b, excludeKeys) {
  const keysA = Object.keys(a).filter((key) => !excludeKeys.includes(key)), keysB = Object.keys(b).filter((key) => !excludeKeys.includes(key));
  if (keysA.length !== keysB.length)
    return !1;
  for (const key of keysA) {
    if (!(key in a) || !(key in b))
      return !1;
    const valueA = a[key], valueB = b[key];
    if (valueA !== valueB && !isDeepEqual(valueA, valueB))
      return !1;
  }
  return !0;
}
function isEqualInlineObjects(a, b) {
  return a._key !== b._key || a._type !== b._type ? !1 : isEqualProps(a, b, ["_key", "_type"]);
}
function isEqualMarks(a, b) {
  if (!a || !b)
    return a === b;
  if (a.length !== b.length)
    return !1;
  for (let index = 0; index < a.length; index++)
    if (a.at(index) !== b.at(index))
      return !1;
  return !0;
}
function isEqualSpans(a, b) {
  return a._key !== b._key || a._type !== b._type || a.text !== b.text || !isEqualMarks(a.marks, b.marks) ? !1 : isEqualProps(a, b, ["_key", "_type", "text", "marks"]);
}
function isEqualMarkDefs(a, b) {
  if (a.length !== b.length)
    return !1;
  for (let index = 0; index < a.length; index++) {
    const markDefA = a.at(index), markDefB = b.at(index);
    if (!markDefA || !markDefB || !isDeepEqual(markDefA, markDefB))
      return !1;
  }
  return !0;
}
function isEqualChildren(a, b) {
  if (a.length !== b.length)
    return !1;
  for (let index = 0; index < a.length; index++) {
    const childA = a.at(index), childB = b.at(index);
    if (!childA || !childB || !isEqualChild(childA, childB))
      return !1;
  }
  return !0;
}
function isEqualChild(a, b) {
  return a._type === "span" && b._type === "span" ? isEqualSpans(a, b) : isEqualInlineObjects(a, b);
}
function isEqualPortableTextObjects(a, b) {
  return a._key !== b._key || a._type !== b._type ? !1 : isEqualProps(a, b, ["_key", "_type"]);
}
function isDeepEqual(data, other) {
  return isDeepEqualImplementation(data, other);
}
function isDeepEqualImplementation(data, other) {
  if (data === other || Object.is(data, other))
    return !0;
  if (typeof data != "object" || typeof other != "object" || data === null || other === null || Object.getPrototypeOf(data) !== Object.getPrototypeOf(other))
    return !1;
  if (Array.isArray(data))
    return isDeepEqualArrays(data, other);
  if (data instanceof Map)
    return isDeepEqualMaps(data, other);
  if (data instanceof Set)
    return isDeepEqualSets(data, other);
  if (data instanceof Date)
    return data.getTime() === other.getTime();
  if (data instanceof RegExp)
    return data.toString() === other.toString();
  if (Object.keys(data).length !== Object.keys(other).length)
    return !1;
  for (const [key, value] of Object.entries(data))
    if (!(key in other) || !isDeepEqualImplementation(
      value,
      // @ts-expect-error [ts7053] - We already checked that `other` has `key`
      other[key]
    ))
      return !1;
  return !0;
}
function isDeepEqualArrays(data, other) {
  if (data.length !== other.length)
    return !1;
  for (const [index, item] of data.entries())
    if (!isDeepEqualImplementation(item, other[index]))
      return !1;
  return !0;
}
function isDeepEqualMaps(data, other) {
  if (data.size !== other.size)
    return !1;
  for (const [key, value] of data.entries())
    if (!other.has(key) || !isDeepEqualImplementation(value, other.get(key)))
      return !1;
  return !0;
}
function isDeepEqualSets(data, other) {
  if (data.size !== other.size)
    return !1;
  const otherCopy = [...other];
  for (const dataItem of data) {
    let isFound = !1;
    for (const [index, otherItem] of otherCopy.entries())
      if (isDeepEqualImplementation(dataItem, otherItem)) {
        isFound = !0, otherCopy.splice(index, 1);
        break;
      }
    if (!isFound)
      return !1;
  }
  return !0;
}
const VOID_CHILD_KEY = "void-child";
function toSlateBlock(block, {
  schemaTypes
}) {
  const {
    _type,
    _key,
    ...rest
  } = block;
  if (block && block._type === schemaTypes.block.name) {
    const textBlock = block;
    let hasInlines = !1;
    const hasMissingMarkDefs = typeof textBlock.markDefs > "u", hasMissingChildren = typeof textBlock.children > "u", children = (textBlock.children || []).map((child) => {
      const {
        _type: childType,
        _key: childKey,
        ...childProps
      } = child, propKeys = Object.keys(childProps);
      return childType === void 0 && propKeys.length === 1 && propKeys.at(0) === "text" ? {
        _key: childKey,
        _type: schemaTypes.span.name,
        text: childProps.text
      } : childType !== schemaTypes.span.name ? (hasInlines = !0, {
        _type: childType,
        _key: childKey,
        children: [{
          _key: VOID_CHILD_KEY,
          _type: schemaTypes.span.name,
          text: "",
          marks: []
        }],
        value: childProps,
        __inline: !0
      }) : child;
    });
    return !hasMissingMarkDefs && !hasMissingChildren && !hasInlines && Element$1.isElement(block) ? block : {
      _type,
      _key,
      ...rest,
      children
    };
  }
  return {
    _type,
    _key,
    children: [{
      _key: VOID_CHILD_KEY,
      _type: "span",
      text: "",
      marks: []
    }],
    value: rest
  };
}
function fromSlateBlock(block, textBlockType) {
  const {
    _key,
    _type
  } = block;
  if (!_key || !_type)
    throw new Error("Not a valid block");
  if (_type === textBlockType && "children" in block && Array.isArray(block.children) && _key) {
    let hasInlines = !1;
    const children = block.children.map((child) => {
      const {
        _type: _cType
      } = child;
      if ("value" in child && _cType !== "span") {
        hasInlines = !0;
        const {
          value: v,
          _key: k,
          _type: t,
          __inline: _i,
          children: _c,
          ...rest
        } = child;
        return {
          ...rest,
          ...v,
          _key: k,
          _type: t
        };
      }
      return child;
    });
    return hasInlines ? {
      ...block,
      children,
      _key,
      _type
    } : block;
  }
  const blockValue = "value" in block && block.value;
  return {
    _key,
    _type,
    ...typeof blockValue == "object" ? blockValue : {}
  };
}
function isEqualToEmptyEditor(initialValue, blocks, schemaTypes) {
  if (!blocks || blocks.length !== 1)
    return !1;
  const firstBlock = blocks.at(0);
  if (!firstBlock)
    return !0;
  if (!Element$1.isElement(firstBlock) || firstBlock._type !== schemaTypes.block.name || "listItem" in firstBlock || !("style" in firstBlock) || firstBlock.style !== schemaTypes.styles.at(0)?.name || !Array.isArray(firstBlock.children) || firstBlock.children.length !== 1)
    return !1;
  const firstChild = firstBlock.children.at(0);
  return !(!firstChild || !Text.isText(firstChild) || !("_type" in firstChild) || firstChild._type !== schemaTypes.span.name || firstChild.text !== "" || firstChild.marks?.join("") || Object.keys(firstBlock).some((key) => key !== "_type" && key !== "_key" && key !== "children" && key !== "markDefs" && key !== "style") || isEqualValues({
    schema: schemaTypes
  }, initialValue, [firstBlock]));
}
function getFocusBlock({
  editor
}) {
  if (!editor.selection)
    return [void 0, void 0];
  try {
    return Editor.node(editor, editor.selection.focus.path.slice(0, 1)) ?? [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getFocusSpan({
  editor
}) {
  if (!editor.selection)
    return [void 0, void 0];
  try {
    const [focusBlock] = getFocusBlock({
      editor
    });
    if (!focusBlock)
      return [void 0, void 0];
    if (!editor.isTextBlock(focusBlock))
      return [void 0, void 0];
    const [node, path] = Editor.node(editor, editor.selection.focus.path.slice(0, 2));
    if (editor.isTextSpan(node))
      return [node, path];
  } catch {
    return [void 0, void 0];
  }
  return [void 0, void 0];
}
function getPointBlock({
  editor,
  point
}) {
  try {
    const [block] = Editor.node(editor, point.path.slice(0, 1)) ?? [void 0, void 0];
    return block ? [block, point.path.slice(0, 1)] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getFocusChild({
  editor
}) {
  const [focusBlock, focusBlockPath] = getFocusBlock({
    editor
  }), childIndex = editor.selection?.focus.path.at(1);
  if (!focusBlock || !focusBlockPath || childIndex === void 0)
    return [void 0, void 0];
  try {
    const focusChild = Node.child(focusBlock, childIndex);
    return focusChild ? [focusChild, [...focusBlockPath, childIndex]] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getPointChild({
  editor,
  point
}) {
  const [block, blockPath] = getPointBlock({
    editor,
    point
  }), childIndex = point.path.at(1);
  if (!block || !blockPath || childIndex === void 0)
    return [void 0, void 0];
  try {
    const pointChild = Node.child(block, childIndex);
    return pointChild ? [pointChild, [...blockPath, childIndex]] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getFirstBlock({
  editor
}) {
  if (editor.children.length === 0)
    return [void 0, void 0];
  const firstBlockPath = Editor.start(editor, []).path.at(0);
  try {
    return firstBlockPath !== void 0 ? Editor.node(editor, [firstBlockPath]) ?? [void 0, void 0] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getLastBlock({
  editor
}) {
  if (editor.children.length === 0)
    return [void 0, void 0];
  const lastBlockPath = Editor.end(editor, []).path.at(0);
  try {
    return lastBlockPath !== void 0 ? Editor.node(editor, [lastBlockPath]) ?? [void 0, void 0] : [void 0, void 0];
  } catch {
    return [void 0, void 0];
  }
}
function getNodeBlock({
  editor,
  schema,
  node
}) {
  if (Editor.isEditor(node))
    return;
  if (isBlockElement({
    editor,
    schema
  }, node))
    return elementToBlock({
      schema,
      element: node
    });
  const parent = Array.from(Editor.nodes(editor, {
    mode: "highest",
    at: [],
    match: (n) => isBlockElement({
      editor,
      schema
    }, n) && n.children.some((child) => child._key === node._key)
  })).at(0)?.at(0);
  return Element$1.isElement(parent) ? elementToBlock({
    schema,
    element: parent
  }) : void 0;
}
function elementToBlock({
  schema,
  element
}) {
  return fromSlateBlock(element, schema.block.name);
}
function isBlockElement({
  editor,
  schema
}, node) {
  return Element$1.isElement(node) && !editor.isInline(node) && (schema.block.name === node._type || schema.blockObjects.some((blockObject) => blockObject.name === node._type));
}
function isListItemActive({
  editor,
  listItem
}) {
  if (!editor.selection)
    return !1;
  const selectedBlocks = [...Editor.nodes(editor, {
    at: editor.selection,
    match: (node) => editor.isTextBlock(node)
  })];
  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => editor.isListBlock(node) && node.listItem === listItem) : !1;
}
function isStyleActive({
  editor,
  style
}) {
  if (!editor.selection)
    return !1;
  const selectedBlocks = [...Editor.nodes(editor, {
    at: editor.selection,
    match: (node) => editor.isTextBlock(node)
  })];
  return selectedBlocks.length > 0 ? selectedBlocks.every(([node]) => node.style === style) : !1;
}
function slateRangeToSelection({
  schema,
  editor,
  range
}) {
  const [anchorBlock] = getPointBlock({
    editor,
    point: range.anchor
  }), [focusBlock] = getPointBlock({
    editor,
    point: range.focus
  });
  if (!anchorBlock || !focusBlock)
    return null;
  const [anchorChild] = anchorBlock._type === schema.block.name ? getPointChild({
    editor,
    point: range.anchor
  }) : [void 0, void 0], [focusChild] = focusBlock._type === schema.block.name ? getPointChild({
    editor,
    point: range.focus
  }) : [void 0, void 0], selection = {
    anchor: {
      path: [{
        _key: anchorBlock._key
      }],
      offset: range.anchor.offset
    },
    focus: {
      path: [{
        _key: focusBlock._key
      }],
      offset: range.focus.offset
    },
    backward: Range.isBackward(range)
  };
  return anchorChild && (selection.anchor.path.push("children"), selection.anchor.path.push({
    _key: anchorChild._key
  })), focusChild && (selection.focus.path.push("children"), selection.focus.path.push({
    _key: focusChild._key
  })), selection;
}
function slatePointToSelectionPoint({
  schema,
  editor,
  point
}) {
  const [block] = getPointBlock({
    editor,
    point
  });
  if (!block)
    return;
  const [child] = block._type === schema.block.name ? getPointChild({
    editor,
    point
  }) : [void 0, void 0];
  return child ? {
    path: [{
      _key: block._key
    }, "children", {
      _key: child._key
    }],
    offset: point.offset
  } : {
    path: [{
      _key: block._key
    }],
    offset: point.offset
  };
}
function getEventPosition({
  editorActor,
  slateEditor,
  event
}) {
  if (editorActor.getSnapshot().matches({
    setup: "setting up"
  }))
    return;
  const eventNode = getEventNode({
    slateEditor,
    event
  });
  if (!eventNode)
    return;
  const eventBlock = getNodeBlock({
    editor: slateEditor,
    schema: editorActor.getSnapshot().context.schema,
    node: eventNode
  }), eventPositionBlock = getEventPositionBlock({
    node: eventNode,
    slateEditor,
    event
  }), eventSelection = getEventSelection({
    schema: editorActor.getSnapshot().context.schema,
    slateEditor,
    event
  });
  if (eventBlock && eventPositionBlock && !eventSelection && !Editor.isEditor(eventNode))
    return {
      block: eventPositionBlock,
      isEditor: !1,
      selection: {
        anchor: getBlockStartPoint({
          context: editorActor.getSnapshot().context,
          block: {
            node: eventBlock,
            path: [{
              _key: eventBlock._key
            }]
          }
        }),
        focus: getBlockEndPoint({
          context: editorActor.getSnapshot().context,
          block: {
            node: eventBlock,
            path: [{
              _key: eventBlock._key
            }]
          }
        })
      }
    };
  if (!eventPositionBlock || !eventSelection)
    return;
  const eventSelectionFocusBlockKey = getBlockKeyFromSelectionPoint(eventSelection.focus);
  if (eventSelectionFocusBlockKey !== void 0)
    return isSelectionCollapsed(eventSelection) && eventBlock && eventSelectionFocusBlockKey !== eventBlock._key ? {
      block: eventPositionBlock,
      isEditor: !1,
      selection: {
        anchor: getBlockStartPoint({
          context: editorActor.getSnapshot().context,
          block: {
            node: eventBlock,
            path: [{
              _key: eventBlock._key
            }]
          }
        }),
        focus: getBlockEndPoint({
          context: editorActor.getSnapshot().context,
          block: {
            node: eventBlock,
            path: [{
              _key: eventBlock._key
            }]
          }
        })
      }
    } : {
      block: eventPositionBlock,
      isEditor: Editor.isEditor(eventNode),
      selection: eventSelection
    };
}
function getEventNode({
  slateEditor,
  event
}) {
  if (!DOMEditor.hasTarget(slateEditor, event.target))
    return;
  let node;
  try {
    node = DOMEditor.toSlateNode(slateEditor, event.target);
  } catch (error) {
    console.error(error);
  }
  return node;
}
function getEventPositionBlock({
  node,
  slateEditor,
  event
}) {
  const [firstBlock] = getFirstBlock({
    editor: slateEditor
  });
  if (!firstBlock)
    return;
  let firstBlockElement;
  try {
    firstBlockElement = DOMEditor.toDOMNode(slateEditor, firstBlock);
  } catch (error) {
    console.error(error);
  }
  if (!firstBlockElement)
    return;
  const firstBlockRect = firstBlockElement.getBoundingClientRect();
  if (event.pageY < firstBlockRect.top)
    return "start";
  const [lastBlock] = getLastBlock({
    editor: slateEditor
  });
  if (!lastBlock)
    return;
  let lastBlockElement;
  try {
    lastBlockElement = DOMEditor.toDOMNode(slateEditor, lastBlock);
  } catch (error) {
    console.error(error);
  }
  if (!lastBlockElement)
    return;
  const lastBlockRef = lastBlockElement.getBoundingClientRect();
  if (event.pageY > lastBlockRef.bottom)
    return "end";
  let element;
  try {
    element = DOMEditor.toDOMNode(slateEditor, node);
  } catch (error) {
    console.error(error);
  }
  if (!element)
    return;
  const elementRect = element.getBoundingClientRect(), top = elementRect.top, height = elementRect.height;
  return Math.abs(top - event.pageY) < height / 2 ? "start" : "end";
}
function getEventSelection({
  schema,
  slateEditor,
  event
}) {
  const range = getSlateRangeFromEvent(slateEditor, event);
  return range ? slateRangeToSelection({
    schema,
    editor: slateEditor,
    range
  }) : null;
}
function getSlateRangeFromEvent(editor, event) {
  if (!event.target || !isDOMNode(event.target))
    return;
  const window2 = DOMEditor.getWindow(editor);
  let domRange;
  if (window2.document.caretPositionFromPoint !== void 0) {
    const position = window2.document.caretPositionFromPoint(event.clientX, event.clientY);
    if (position)
      try {
        domRange = window2.document.createRange(), domRange.setStart(position.offsetNode, position.offset), domRange.setEnd(position.offsetNode, position.offset);
      } catch {
      }
  } else if (window2.document.caretRangeFromPoint !== void 0)
    domRange = window2.document.caretRangeFromPoint(event.clientX, event.clientY) ?? void 0;
  else {
    console.warn("Neither caretPositionFromPoint nor caretRangeFromPoint is supported");
    return;
  }
  if (!domRange)
    return;
  let range;
  try {
    range = DOMEditor.toSlateRange(editor, domRange, {
      exactMatch: !1,
      // It can still throw even with this option set to true
      suppressThrow: !1
    });
  } catch {
  }
  return range;
}
function normalizePoint(point, value) {
  if (!point || !value)
    return null;
  const newPath = [];
  let newOffset = point.offset || 0;
  const blockKey = typeof point.path[0] == "object" && "_key" in point.path[0] && point.path[0]._key, childKey = typeof point.path[2] == "object" && "_key" in point.path[2] && point.path[2]._key, block = value.find((blk) => blk._key === blockKey);
  if (block)
    newPath.push({
      _key: block._key
    });
  else
    return null;
  if (block && point.path[1] === "children") {
    if (!block.children || Array.isArray(block.children) && block.children.length === 0)
      return null;
    const child = Array.isArray(block.children) && block.children.find((cld) => cld._key === childKey);
    if (child)
      newPath.push("children"), newPath.push({
        _key: child._key
      }), newOffset = child.text && child.text.length >= point.offset ? point.offset : child.text && child.text.length || 0;
    else
      return null;
  }
  return {
    path: newPath,
    offset: newOffset
  };
}
function normalizeSelection(selection, value) {
  if (!selection || !value || value.length === 0)
    return null;
  let newAnchor = null, newFocus = null;
  const {
    anchor,
    focus
  } = selection;
  return anchor && value.find((blk) => isKeyedSegment(anchor.path[0]) && blk._key === anchor.path[0]._key) && (newAnchor = normalizePoint(anchor, value)), focus && value.find((blk) => isKeyedSegment(focus.path[0]) && blk._key === focus.path[0]._key) && (newFocus = normalizePoint(focus, value)), newAnchor && newFocus ? {
    anchor: newAnchor,
    focus: newFocus,
    backward: selection.backward
  } : null;
}
function toSlateRange(snapshot) {
  if (!snapshot.context.selection)
    return null;
  if (isEqualSelectionPoints(snapshot.context.selection.anchor, snapshot.context.selection.focus)) {
    const anchorPoint2 = toSlateSelectionPoint(snapshot, snapshot.context.selection.anchor, snapshot.context.selection.backward ? "backward" : "forward");
    return anchorPoint2 ? {
      anchor: anchorPoint2,
      focus: anchorPoint2
    } : null;
  }
  const anchorPoint = toSlateSelectionPoint(snapshot, snapshot.context.selection.anchor, snapshot.context.selection.backward ? "forward" : "backward"), focusPoint = toSlateSelectionPoint(snapshot, snapshot.context.selection.focus, snapshot.context.selection.backward ? "backward" : "forward");
  return !anchorPoint || !focusPoint ? null : {
    anchor: anchorPoint,
    focus: focusPoint
  };
}
function toSlateSelectionPoint(snapshot, selectionPoint, direction) {
  const blockKey = getBlockKeyFromSelectionPoint(selectionPoint);
  if (!blockKey)
    return;
  const blockIndex = snapshot.blockIndexMap.get(blockKey);
  if (blockIndex === void 0)
    return;
  const block = snapshot.context.value.at(blockIndex);
  if (!block)
    return;
  if (!isTextBlock(snapshot.context, block))
    return {
      path: [blockIndex, 0],
      offset: 0
    };
  let childKey = getChildKeyFromSelectionPoint({
    path: selectionPoint.path
  });
  const spanSelectionPoint = childKey ? void 0 : blockOffsetToSpanSelectionPoint({
    context: {
      schema: snapshot.context.schema,
      value: [block]
    },
    blockOffset: {
      path: [{
        _key: blockKey
      }],
      offset: selectionPoint.offset
    },
    direction
  });
  if (childKey = spanSelectionPoint ? getChildKeyFromSelectionPoint(spanSelectionPoint) : childKey, !childKey)
    return {
      path: [blockIndex, 0],
      offset: 0
    };
  let offset = spanSelectionPoint?.offset ?? selectionPoint.offset, childPath = [], childIndex = -1, pathChild;
  for (const child of block.children)
    if (childIndex++, child._key === childKey) {
      pathChild = child, isSpan(snapshot.context, child) ? childPath = [childIndex] : (childPath = [childIndex, 0], offset = 0);
      break;
    }
  return childPath.length === 0 ? {
    path: [blockIndex, 0],
    offset: 0
  } : {
    path: [blockIndex].concat(childPath),
    offset: isSpan(snapshot.context, pathChild) ? Math.min(pathChild.text.length, offset) : offset
  };
}
const EditorActorContext = createContext({});
function moveRangeByOperation(range, operation) {
  const anchor = Point.transform(range.anchor, operation), focus = Point.transform(range.focus, operation);
  return anchor === null || focus === null ? null : Point.equals(anchor, range.anchor) && Point.equals(focus, range.focus) ? range : {
    anchor,
    focus
  };
}
const slateOperationCallback = ({
  input,
  sendBack
}) => {
  const originalApply = input.slateEditor.apply;
  return input.slateEditor.apply = (op) => {
    op.type !== "set_selection" && sendBack({
      type: "slate operation",
      operation: op
    }), originalApply(op);
  }, () => {
    input.slateEditor.apply = originalApply;
  };
}, rangeDecorationsMachine = setup({
  types: {
    context: {},
    input: {},
    events: {}
  },
  actions: {
    "update pending range decorations": assign({
      pendingRangeDecorations: ({
        context,
        event
      }) => event.type !== "range decorations updated" ? context.pendingRangeDecorations : event.rangeDecorations
    }),
    "set up initial range decorations": ({
      context
    }) => {
      const rangeDecorationState = [];
      for (const rangeDecoration of context.pendingRangeDecorations) {
        const slateRange = toSlateRange({
          context: {
            schema: context.schema,
            value: context.slateEditor.value,
            selection: rangeDecoration.selection
          },
          blockIndexMap: context.slateEditor.blockIndexMap
        });
        if (!Range.isRange(slateRange)) {
          rangeDecoration.onMoved?.({
            newSelection: null,
            rangeDecoration,
            origin: "local"
          });
          continue;
        }
        rangeDecorationState.push({
          rangeDecoration,
          ...slateRange
        });
      }
      context.slateEditor.decoratedRanges = rangeDecorationState;
    },
    "update range decorations": ({
      context,
      event
    }) => {
      if (event.type !== "range decorations updated")
        return;
      const rangeDecorationState = [];
      for (const rangeDecoration of event.rangeDecorations) {
        const slateRange = toSlateRange({
          context: {
            schema: context.schema,
            value: context.slateEditor.value,
            selection: rangeDecoration.selection
          },
          blockIndexMap: context.slateEditor.blockIndexMap
        });
        if (!Range.isRange(slateRange)) {
          rangeDecoration.onMoved?.({
            newSelection: null,
            rangeDecoration,
            origin: "local"
          });
          continue;
        }
        rangeDecorationState.push({
          rangeDecoration,
          ...slateRange
        });
      }
      context.slateEditor.decoratedRanges = rangeDecorationState;
    },
    "move range decorations": ({
      context,
      event
    }) => {
      if (event.type !== "slate operation")
        return;
      const rangeDecorationState = [];
      for (const decoratedRange of context.slateEditor.decoratedRanges) {
        const slateRange = toSlateRange({
          context: {
            schema: context.schema,
            value: context.slateEditor.value,
            selection: decoratedRange.rangeDecoration.selection
          },
          blockIndexMap: context.slateEditor.blockIndexMap
        });
        if (!Range.isRange(slateRange)) {
          decoratedRange.rangeDecoration.onMoved?.({
            newSelection: null,
            rangeDecoration: decoratedRange.rangeDecoration,
            origin: "local"
          });
          continue;
        }
        let newRange;
        if (newRange = moveRangeByOperation(slateRange, event.operation), newRange && newRange !== slateRange || newRange === null && slateRange) {
          const newRangeSelection = newRange ? slateRangeToSelection({
            schema: context.schema,
            editor: context.slateEditor,
            range: newRange
          }) : null;
          decoratedRange.rangeDecoration.onMoved?.({
            newSelection: newRangeSelection,
            rangeDecoration: decoratedRange.rangeDecoration,
            origin: "local"
          });
        }
        newRange !== null && rangeDecorationState.push({
          ...newRange || slateRange,
          rangeDecoration: {
            ...decoratedRange.rangeDecoration,
            selection: slateRangeToSelection({
              schema: context.schema,
              editor: context.slateEditor,
              range: newRange
            })
          }
        });
      }
      context.slateEditor.decoratedRanges = rangeDecorationState;
    },
    "assign readOnly": assign({
      readOnly: ({
        context,
        event
      }) => event.type !== "update read only" ? context.readOnly : event.readOnly
    }),
    "update decorate": assign({
      decorate: ({
        context
      }) => ({
        fn: createDecorate(context.schema, context.slateEditor)
      })
    })
  },
  actors: {
    "slate operation listener": fromCallback(slateOperationCallback)
  },
  guards: {
    "has pending range decorations": ({
      context
    }) => context.pendingRangeDecorations.length > 0,
    "has range decorations": ({
      context
    }) => context.slateEditor.decoratedRanges.length > 0,
    "has different decorations": ({
      context,
      event
    }) => {
      if (event.type !== "range decorations updated")
        return !1;
      const existingRangeDecorations = context.slateEditor.decoratedRanges.map((decoratedRange) => ({
        anchor: decoratedRange.rangeDecoration.selection?.anchor,
        focus: decoratedRange.rangeDecoration.selection?.focus,
        payload: decoratedRange.rangeDecoration.payload
      })), newRangeDecorations = event.rangeDecorations.map((rangeDecoration) => ({
        anchor: rangeDecoration.selection?.anchor,
        focus: rangeDecoration.selection?.focus,
        payload: rangeDecoration.payload
      }));
      return !isDeepEqual(existingRangeDecorations, newRangeDecorations);
    },
    "not read only": ({
      context
    }) => !context.readOnly,
    "should skip setup": ({
      context
    }) => context.skipSetup
  }
}).createMachine({
  id: "range decorations",
  context: ({
    input
  }) => ({
    readOnly: input.readOnly,
    pendingRangeDecorations: input.rangeDecorations,
    decoratedRanges: [],
    skipSetup: input.skipSetup,
    schema: input.schema,
    slateEditor: input.slateEditor,
    decorate: {
      fn: createDecorate(input.schema, input.slateEditor)
    }
  }),
  invoke: {
    src: "slate operation listener",
    input: ({
      context
    }) => ({
      slateEditor: context.slateEditor
    })
  },
  on: {
    "update read only": {
      actions: ["assign readOnly"]
    }
  },
  initial: "setting up",
  states: {
    "setting up": {
      always: [{
        guard: and(["should skip setup", "has pending range decorations"]),
        target: "ready",
        actions: ["set up initial range decorations", "update decorate"]
      }, {
        guard: "should skip setup",
        target: "ready"
      }],
      on: {
        "range decorations updated": {
          actions: ["update pending range decorations"]
        },
        ready: [{
          target: "ready",
          guard: "has pending range decorations",
          actions: ["set up initial range decorations", "update decorate"]
        }, {
          target: "ready"
        }]
      }
    },
    ready: {
      initial: "idle",
      on: {
        "range decorations updated": {
          target: ".idle",
          guard: "has different decorations",
          actions: ["update range decorations", "update decorate"]
        }
      },
      states: {
        idle: {
          on: {
            "slate operation": {
              target: "moving range decorations",
              guard: and(["has range decorations", "not read only"])
            }
          }
        },
        "moving range decorations": {
          entry: ["move range decorations"],
          always: {
            target: "idle"
          }
        }
      }
    }
  }
});
function createDecorate(schema, slateEditor) {
  return function([node, path]) {
    const defaultStyle = schema.styles.at(0)?.name;
    if (slateEditor.value.length === 1 && isEmptyTextBlock({
      schema
    }, slateEditor.value[0]) && (!slateEditor.value[0].style || slateEditor.value[0].style === defaultStyle) && !slateEditor.value[0].listItem)
      return [{
        anchor: {
          path: [0, 0],
          offset: 0
        },
        focus: {
          path: [0, 0],
          offset: 0
        },
        placeholder: !0
      }];
    if (path.length === 0)
      return [];
    if (!Element$1.isElement(node) || node.children.length === 0)
      return [];
    const blockIndex = path.at(0);
    return blockIndex === void 0 ? [] : slateEditor.decoratedRanges.filter((decoratedRange) => Range.isCollapsed(decoratedRange) ? node.children.some((_, childIndex) => Path.equals(decoratedRange.anchor.path, [blockIndex, childIndex]) && Path.equals(decoratedRange.focus.path, [blockIndex, childIndex])) : Range.intersection(decoratedRange, {
      anchor: {
        path,
        offset: 0
      },
      focus: {
        path,
        offset: 0
      }
    }) || Range.includes(decoratedRange, path));
  };
}
const RelayActorContext = createContext({});
function RenderDefaultBlockObject(props) {
  const $ = c(4);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    userSelect: "none"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] !== props.blockObject._key || $[2] !== props.blockObject._type ? (t1 = /* @__PURE__ */ jsxs("div", { style: t0, children: [
    "[",
    props.blockObject._type,
    ": ",
    props.blockObject._key,
    "]"
  ] }), $[1] = props.blockObject._key, $[2] = props.blockObject._type, $[3] = t1) : t1 = $[3], t1;
}
function RenderDefaultInlineObject(props) {
  const $ = c(4);
  let t0;
  $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    userSelect: "none"
  }, $[0] = t0) : t0 = $[0];
  let t1;
  return $[1] !== props.inlineObject._key || $[2] !== props.inlineObject._type ? (t1 = /* @__PURE__ */ jsxs("span", { style: t0, children: [
    "[",
    props.inlineObject._type,
    ": ",
    props.inlineObject._key,
    "]"
  ] }), $[1] = props.inlineObject._key, $[2] = props.inlineObject._type, $[3] = t1) : t1 = $[3], t1;
}
function DropIndicator() {
  const $ = c(1);
  let t0;
  return $[0] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx("div", { contentEditable: !1, className: "pt-drop-indicator", style: {
    position: "absolute",
    width: "100%",
    height: 1,
    borderBottom: "1px solid currentColor",
    zIndex: 5
  }, children: /* @__PURE__ */ jsx("span", {}) }), $[0] = t0) : t0 = $[0], t0;
}
function RenderBlockObject(props) {
  const $ = c(33), blockObjectRef = useRef(null), selected = useSelected();
  let t0;
  $[0] !== selected ? (t0 = (editor) => selected && editor.selection !== null && Range.isCollapsed(editor.selection), $[0] = selected, $[1] = t0) : t0 = $[1];
  const focused = useSlateSelector(t0);
  let t1;
  if ($[2] !== props.element._type || $[3] !== props.legacySchema.blockObjects) {
    let t22;
    $[5] !== props.element._type ? (t22 = (schemaType) => schemaType.name === props.element._type, $[5] = props.element._type, $[6] = t22) : t22 = $[6], t1 = props.legacySchema.blockObjects.find(t22), $[2] = props.element._type, $[3] = props.legacySchema.blockObjects, $[4] = t1;
  } else
    t1 = $[4];
  const legacySchemaType = t1;
  legacySchemaType || console.error(`Unable to find Block Object "${props.element._type}" in Schema`);
  let t2;
  $[7] !== props.blockObject || $[8] !== props.element._key || $[9] !== props.element._type ? (t2 = props.blockObject ?? {
    _key: props.element._key,
    _type: props.element._type
  }, $[7] = props.blockObject, $[8] = props.element._key, $[9] = props.element._type, $[10] = t2) : t2 = $[10];
  const blockObject = t2;
  let t3;
  $[11] !== props.dropPosition ? (t3 = props.dropPosition === "start" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null, $[11] = props.dropPosition, $[12] = t3) : t3 = $[12];
  const t4 = !props.readOnly;
  let t5;
  $[13] !== blockObject || $[14] !== focused || $[15] !== legacySchemaType || $[16] !== props.element._key || $[17] !== props.renderBlock || $[18] !== selected ? (t5 = props.renderBlock && legacySchemaType ? /* @__PURE__ */ jsx(RenderBlock$1, { renderBlock: props.renderBlock, editorElementRef: blockObjectRef, focused, path: [{
    _key: props.element._key
  }], schemaType: legacySchemaType, selected, type: legacySchemaType, value: blockObject, children: /* @__PURE__ */ jsx(RenderDefaultBlockObject, { blockObject }) }) : /* @__PURE__ */ jsx(RenderDefaultBlockObject, { blockObject }), $[13] = blockObject, $[14] = focused, $[15] = legacySchemaType, $[16] = props.element._key, $[17] = props.renderBlock, $[18] = selected, $[19] = t5) : t5 = $[19];
  let t6;
  $[20] !== t4 || $[21] !== t5 ? (t6 = /* @__PURE__ */ jsx("div", { ref: blockObjectRef, contentEditable: !1, draggable: t4, children: t5 }), $[20] = t4, $[21] = t5, $[22] = t6) : t6 = $[22];
  let t7;
  $[23] !== props.dropPosition ? (t7 = props.dropPosition === "end" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null, $[23] = props.dropPosition, $[24] = t7) : t7 = $[24];
  let t8;
  return $[25] !== props.attributes || $[26] !== props.children || $[27] !== props.element._key || $[28] !== props.element._type || $[29] !== t3 || $[30] !== t6 || $[31] !== t7 ? (t8 = /* @__PURE__ */ jsxs("div", { ...props.attributes, className: "pt-block pt-object-block", "data-block-key": props.element._key, "data-block-name": props.element._type, "data-block-type": "object", children: [
    t3,
    props.children,
    t6,
    t7
  ] }), $[25] = props.attributes, $[26] = props.children, $[27] = props.element._key, $[28] = props.element._type, $[29] = t3, $[30] = t6, $[31] = t7, $[32] = t8) : t8 = $[32], t8;
}
function RenderBlock$1({
  renderBlock,
  children,
  editorElementRef,
  focused,
  path,
  schemaType,
  selected,
  type,
  value
}) {
  return renderBlock({
    children,
    editorElementRef,
    focused,
    path,
    schemaType,
    selected,
    type,
    value
  });
}
function RenderInlineObject(props) {
  const $ = c(32), inlineObjectRef = useRef(null), slateEditor = useSlateStatic(), selected = useSelected();
  let t0;
  $[0] !== selected ? (t0 = (editor) => selected && editor.selection !== null && Range.isCollapsed(editor.selection), $[0] = selected, $[1] = t0) : t0 = $[1];
  const focused = useSlateSelector(t0);
  let t1;
  if ($[2] !== props.element._type || $[3] !== props.legacySchema.inlineObjects) {
    let t22;
    $[5] !== props.element._type ? (t22 = (inlineObject) => inlineObject.name === props.element._type, $[5] = props.element._type, $[6] = t22) : t22 = $[6], t1 = props.legacySchema.inlineObjects.find(t22), $[2] = props.element._type, $[3] = props.legacySchema.inlineObjects, $[4] = t1;
  } else
    t1 = $[4];
  const legacySchemaType = t1;
  legacySchemaType || console.error(`Unable to find Inline Object "${props.element._type}" in Schema`);
  let t2;
  if ($[7] !== props.element || $[8] !== slateEditor) {
    const path = DOMEditor.findPath(slateEditor, props.element);
    t2 = getPointBlock({
      editor: slateEditor,
      point: {
        path,
        offset: 0
      }
    }), $[7] = props.element, $[8] = slateEditor, $[9] = t2;
  } else
    t2 = $[9];
  const [block] = t2;
  block || console.error(`Unable to find parent block of inline object ${props.element._key}`);
  let t3;
  $[10] !== props.element ? (t3 = "value" in props.element && typeof props.element.value == "object" ? props.element.value : {}, $[10] = props.element, $[11] = t3) : t3 = $[11];
  let t4;
  $[12] !== props.element._key || $[13] !== props.element._type || $[14] !== t3 ? (t4 = {
    _key: props.element._key,
    _type: props.element._type,
    ...t3
  }, $[12] = props.element._key, $[13] = props.element._type, $[14] = t3, $[15] = t4) : t4 = $[15];
  const inlineObject_0 = t4, t5 = !props.readOnly;
  let t6;
  $[16] === /* @__PURE__ */ Symbol.for("react.memo_cache_sentinel") ? (t6 = {
    display: "inline-block"
  }, $[16] = t6) : t6 = $[16];
  let t7;
  $[17] !== block || $[18] !== focused || $[19] !== inlineObject_0 || $[20] !== legacySchemaType || $[21] !== props.element._key || $[22] !== props.renderChild || $[23] !== selected ? (t7 = /* @__PURE__ */ jsx("span", { ref: inlineObjectRef, style: t6, children: props.renderChild && block && legacySchemaType ? /* @__PURE__ */ jsx(RenderChild$1, { renderChild: props.renderChild, annotations: [], editorElementRef: inlineObjectRef, selected, focused, path: [{
    _key: block._key
  }, "children", {
    _key: props.element._key
  }], schemaType: legacySchemaType, value: inlineObject_0, type: legacySchemaType, children: /* @__PURE__ */ jsx(RenderDefaultInlineObject, { inlineObject: inlineObject_0 }) }) : /* @__PURE__ */ jsx(RenderDefaultInlineObject, { inlineObject: inlineObject_0 }) }), $[17] = block, $[18] = focused, $[19] = inlineObject_0, $[20] = legacySchemaType, $[21] = props.element._key, $[22] = props.renderChild, $[23] = selected, $[24] = t7) : t7 = $[24];
  let t8;
  return $[25] !== inlineObject_0._key || $[26] !== inlineObject_0._type || $[27] !== props.attributes || $[28] !== props.children || $[29] !== t5 || $[30] !== t7 ? (t8 = /* @__PURE__ */ jsxs("span", { ...props.attributes, draggable: t5, className: "pt-inline-object", "data-child-key": inlineObject_0._key, "data-child-name": inlineObject_0._type, "data-child-type": "object", children: [
    props.children,
    t7
  ] }), $[25] = inlineObject_0._key, $[26] = inlineObject_0._type, $[27] = props.attributes, $[28] = props.children, $[29] = t5, $[30] = t7, $[31] = t8) : t8 = $[31], t8;
}
function RenderChild$1({
  renderChild,
  annotations,
  children,
  editorElementRef,
  focused,
  path,
  schemaType,
  selected,
  value,
  type
}) {
  return renderChild({
    annotations,
    children,
    editorElementRef,
    focused,
    path,
    schemaType,
    selected,
    value,
    type
  });
}
function RenderTextBlock(props) {
  const $ = c(75), blockRef = useRef(null), selected = useSelected();
  let t0;
  $[0] !== selected ? (t0 = (editor) => selected && editor.selection !== null && Range.isCollapsed(editor.selection), $[0] = selected, $[1] = t0) : t0 = $[1];
  const focused = useSlateSelector(t0);
  let t1;
  $[2] !== props.textBlock._key ? (t1 = (editor_0) => editor_0.listIndexMap.get(props.textBlock._key), $[2] = props.textBlock._key, $[3] = t1) : t1 = $[3];
  const listIndex = useSlateSelector(t1);
  let children = props.children;
  if (props.renderStyle && props.textBlock.style) {
    let t22;
    $[4] !== props.legacySchema || $[5] !== props.textBlock.style ? (t22 = props.textBlock.style !== void 0 ? props.legacySchema.styles.find((style) => style.value === props.textBlock.style) : void 0, $[4] = props.legacySchema, $[5] = props.textBlock.style, $[6] = t22) : t22 = $[6];
    const legacyStyleSchemaType = t22;
    if (legacyStyleSchemaType) {
      let t32;
      $[7] !== props.textBlock._key ? (t32 = [{
        _key: props.textBlock._key
      }], $[7] = props.textBlock._key, $[8] = t32) : t32 = $[8];
      let t42;
      $[9] !== children || $[10] !== focused || $[11] !== legacyStyleSchemaType || $[12] !== props.renderStyle || $[13] !== props.textBlock || $[14] !== selected || $[15] !== t32 ? (t42 = /* @__PURE__ */ jsx(RenderStyle, { renderStyle: props.renderStyle, block: props.textBlock, editorElementRef: blockRef, focused, path: t32, schemaType: legacyStyleSchemaType, selected, value: props.textBlock.style, children }), $[9] = children, $[10] = focused, $[11] = legacyStyleSchemaType, $[12] = props.renderStyle, $[13] = props.textBlock, $[14] = selected, $[15] = t32, $[16] = t42) : t42 = $[16], children = t42;
    } else
      console.error(`Unable to find Schema type for text block style ${props.textBlock.style}`);
  }
  if (props.renderListItem && props.textBlock.listItem) {
    let t22;
    if ($[17] !== props.legacySchema.lists || $[18] !== props.textBlock.listItem) {
      let t32;
      $[20] !== props.textBlock.listItem ? (t32 = (list) => list.value === props.textBlock.listItem, $[20] = props.textBlock.listItem, $[21] = t32) : t32 = $[21], t22 = props.legacySchema.lists.find(t32), $[17] = props.legacySchema.lists, $[18] = props.textBlock.listItem, $[19] = t22;
    } else
      t22 = $[19];
    const legacyListItemSchemaType = t22;
    if (legacyListItemSchemaType) {
      const t32 = props.textBlock.level ?? 1;
      let t42;
      $[22] !== props.textBlock._key ? (t42 = [{
        _key: props.textBlock._key
      }], $[22] = props.textBlock._key, $[23] = t42) : t42 = $[23];
      let t52;
      $[24] !== children || $[25] !== focused || $[26] !== legacyListItemSchemaType || $[27] !== props.renderListItem || $[28] !== props.textBlock || $[29] !== selected || $[30] !== t32 || $[31] !== t42 ? (t52 = /* @__PURE__ */ jsx(RenderListItem, { renderListItem: props.renderListItem, block: props.textBlock, editorElementRef: blockRef, focused, level: t32, path: t42, selected, value: props.textBlock.listItem, schemaType: legacyListItemSchemaType, children }), $[24] = children, $[25] = focused, $[26] = legacyListItemSchemaType, $[27] = props.renderListItem, $[28] = props.textBlock, $[29] = selected, $[30] = t32, $[31] = t42, $[32] = t52) : t52 = $[32], children = t52;
    } else
      console.error(`Unable to find Schema type for text block list item ${props.textBlock.listItem}`);
  }
  const t2 = props.attributes;
  let t3;
  $[33] !== props.textBlock.style ? (t3 = props.textBlock.style ? [`pt-text-block-style-${props.textBlock.style}`] : [], $[33] = props.textBlock.style, $[34] = t3) : t3 = $[34];
  let t4;
  $[35] !== props.textBlock.level || $[36] !== props.textBlock.listItem ? (t4 = props.textBlock.listItem ? ["pt-list-item", `pt-list-item-${props.textBlock.listItem}`, `pt-list-item-level-${props.textBlock.level ?? 1}`] : [], $[35] = props.textBlock.level, $[36] = props.textBlock.listItem, $[37] = t4) : t4 = $[37];
  let t5;
  $[38] !== t3 || $[39] !== t4 ? (t5 = ["pt-block", "pt-text-block", ...t3, ...t4], $[38] = t3, $[39] = t4, $[40] = t5) : t5 = $[40];
  const t6 = t5.join(" ");
  let t7;
  $[41] !== props.textBlock.listItem ? (t7 = props.textBlock.listItem !== void 0 ? {
    "data-list-item": props.textBlock.listItem
  } : {}, $[41] = props.textBlock.listItem, $[42] = t7) : t7 = $[42];
  let t8;
  $[43] !== props.textBlock.level ? (t8 = props.textBlock.level !== void 0 ? {
    "data-level": props.textBlock.level
  } : {}, $[43] = props.textBlock.level, $[44] = t8) : t8 = $[44];
  let t9;
  $[45] !== props.textBlock.style ? (t9 = props.textBlock.style !== void 0 ? {
    "data-style": props.textBlock.style
  } : {}, $[45] = props.textBlock.style, $[46] = t9) : t9 = $[46];
  let t10;
  $[47] !== listIndex ? (t10 = listIndex !== void 0 ? {
    "data-list-index": listIndex
  } : {}, $[47] = listIndex, $[48] = t10) : t10 = $[48];
  let t11;
  $[49] !== props.dropPosition ? (t11 = props.dropPosition === "start" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null, $[49] = props.dropPosition, $[50] = t11) : t11 = $[50];
  let t12;
  $[51] !== children || $[52] !== focused || $[53] !== props.legacySchema || $[54] !== props.renderBlock || $[55] !== props.textBlock || $[56] !== selected ? (t12 = props.renderBlock ? /* @__PURE__ */ jsx(RenderBlock, { renderBlock: props.renderBlock, editorElementRef: blockRef, focused, level: props.textBlock.level, listItem: props.textBlock.listItem, path: [{
    _key: props.textBlock._key
  }], selected, schemaType: props.legacySchema.block, style: props.textBlock.style, type: props.legacySchema.block, value: props.textBlock, children }) : children, $[51] = children, $[52] = focused, $[53] = props.legacySchema, $[54] = props.renderBlock, $[55] = props.textBlock, $[56] = selected, $[57] = t12) : t12 = $[57];
  let t13;
  $[58] !== t12 ? (t13 = /* @__PURE__ */ jsx("div", { ref: blockRef, children: t12 }), $[58] = t12, $[59] = t13) : t13 = $[59];
  let t14;
  $[60] !== props.dropPosition ? (t14 = props.dropPosition === "end" ? /* @__PURE__ */ jsx(DropIndicator, {}) : null, $[60] = props.dropPosition, $[61] = t14) : t14 = $[61];
  let t15;
  return $[62] !== props.attributes || $[63] !== props.spellCheck || $[64] !== props.textBlock._key || $[65] !== props.textBlock._type || $[66] !== t10 || $[67] !== t11 || $[68] !== t13 || $[69] !== t14 || $[70] !== t6 || $[71] !== t7 || $[72] !== t8 || $[73] !== t9 ? (t15 = /* @__PURE__ */ jsxs("div", { ...t2, className: t6, spellCheck: props.spellCheck, "data-block-key": props.textBlock._key, "data-block-name": props.textBlock._type, "data-block-type": "text", ...t7, ...t8, ...t9, ...t10, children: [
    t11,
    t13,
    t14
  ] }), $[62] = props.attributes, $[63] = props.spellCheck, $[64] = props.textBlock._key, $[65] = props.textBlock._type, $[66] = t10, $[67] = t11, $[68] = t13, $[69] = t14, $[70] = t6, $[71] = t7, $[72] = t8, $[73] = t9, $[74] = t15) : t15 = $[74], t15;
}
function RenderBlock({
  renderBlock,
  children,
  editorElementRef,
  focused,
  level,
  listItem,
  path,
  selected,
  style,
  schemaType,
  type,
  value
}) {
  return renderBlock({
    children,
    editorElementRef,
    focused,
    level,
    listItem,
    path,
    selected,
    style,
    schemaType,
    type,
    value
  });
}
function RenderListItem({
  renderListItem,
  block,
  children,
  editorElementRef,
  focused,
  level,
  path,
  schemaType,
  selected,
  value
}) {
  return renderListItem({
    block,
    children,
    editorElementRef,
    focused,
    level,
    path,
    schemaType,
    selected,
    value
  });
}
function RenderStyle({
  renderStyle,
  block,
  children,
  editorElementRef,
  focused,
  path,
  schemaType,
  selected,
  value
}) {
  return renderStyle({
    block,
    children,
    editorElementRef,
    focused,
    path,
    schemaType,
    selected,
    value
  });
}
function RenderElement(props) {
  const $ = c(36), editorActor = useContext(EditorActorContext), schema = useSelector(editorActor, _temp$3), legacySchema = useSelector(editorActor, _temp2$2), slateStatic = useSlateStatic();
  if ("__inline" in props.element && props.element.__inline === !0) {
    let t02;
    return $[0] !== legacySchema || $[1] !== props.attributes || $[2] !== props.children || $[3] !== props.element || $[4] !== props.readOnly || $[5] !== props.renderChild || $[6] !== schema ? (t02 = /* @__PURE__ */ jsx(RenderInlineObject, { attributes: props.attributes, element: props.element, legacySchema, readOnly: props.readOnly, renderChild: props.renderChild, schema, children: props.children }), $[0] = legacySchema, $[1] = props.attributes, $[2] = props.children, $[3] = props.element, $[4] = props.readOnly, $[5] = props.renderChild, $[6] = schema, $[7] = t02) : t02 = $[7], t02;
  }
  let block, t0;
  if ($[8] !== props.element._key || $[9] !== schema || $[10] !== slateStatic.blockIndexMap || $[11] !== slateStatic.value) {
    const blockIndex = slateStatic.blockIndexMap.get(props.element._key);
    block = blockIndex !== void 0 ? slateStatic.value.at(blockIndex) : void 0, t0 = isTextBlock({
      schema
    }, block), $[8] = props.element._key, $[9] = schema, $[10] = slateStatic.blockIndexMap, $[11] = slateStatic.value, $[12] = block, $[13] = t0;
  } else
    block = $[12], t0 = $[13];
  if (t0) {
    const t12 = props.dropPosition?.blockKey === props.element._key ? props.dropPosition.positionBlock : void 0;
    let t22;
    return $[14] !== block || $[15] !== legacySchema || $[16] !== props.attributes || $[17] !== props.children || $[18] !== props.element || $[19] !== props.readOnly || $[20] !== props.renderBlock || $[21] !== props.renderListItem || $[22] !== props.renderStyle || $[23] !== props.spellCheck || $[24] !== t12 ? (t22 = /* @__PURE__ */ jsx(RenderTextBlock, { attributes: props.attributes, dropPosition: t12, element: props.element, legacySchema, readOnly: props.readOnly, renderBlock: props.renderBlock, renderListItem: props.renderListItem, renderStyle: props.renderStyle, spellCheck: props.spellCheck, textBlock: block, children: props.children }), $[14] = block, $[15] = legacySchema, $[16] = props.attributes, $[17] = props.children, $[18] = props.element, $[19] = props.readOnly, $[20] = props.renderBlock, $[21] = props.renderListItem, $[22] = props.renderStyle, $[23] = props.spellCheck, $[24] = t12, $[25] = t22) : t22 = $[25], t22;
  }
  const t1 = props.dropPosition?.blockKey === props.element._key ? props.dropPosition.positionBlock : void 0;
  let t2;
  return $[26] !== block || $[27] !== legacySchema || $[28] !== props.attributes || $[29] !== props.children || $[30] !== props.element || $[31] !== props.readOnly || $[32] !== props.renderBlock || $[33] !== schema || $[34] !== t1 ? (t2 = /* @__PURE__ */ jsx(RenderBlockObject, { attributes: props.attributes, blockObject: block, dropPosition: t1, element: props.element, legacySchema, readOnly: props.readOnly, renderBlock: props.renderBlock, schema, children: props.children }), $[26] = block, $[27] = legacySchema, $[28] = props.attributes, $[29] = props.children, $[30] = props.element, $[31] = props.readOnly, $[32] = props.renderBlock, $[33] = schema, $[34] = t1, $[35] = t2) : t2 = $[35], t2;
}
function _temp2$2(s_0) {
  return s_0.context.getLegacySchema();
}
function _temp$3(s) {
  return s.context.schema;
}
function defaultCompare(a, b) {
  return a === b;
}
function useEditorSelector(editor, selector, t0) {
  const $ = c(3), compare = t0 === void 0 ? defaultCompare : t0;
  let t1;
  return $[0] !== editor || $[1] !== selector ? (t1 = (editorActorSnapshot) => {
    const snapshot = getEditorSnapshot({
      editorActorSnapshot,
      slateEditorInstance: editor._internal.slateEditor.instance
    });
    return selector(snapshot);
  }, $[0] = editor, $[1] = selector, $[2] = t1) : t1 = $[2], useSelector(editor._internal.editorActor, t1, compare);
}
function getEditorSnapshot({
  editorActorSnapshot,
  slateEditorInstance
}) {
  const selection = slateEditorInstance.selection ? slateRangeToSelection({
    schema: editorActorSnapshot.context.schema,
    editor: slateEditorInstance,
    range: slateEditorInstance.selection
  }) : null;
  return {
    blockIndexMap: slateEditorInstance.blockIndexMap,
    context: {
      converters: [...editorActorSnapshot.context.converters],
      keyGenerator: editorActorSnapshot.context.keyGenerator,
      readOnly: editorActorSnapshot.matches({
        "edit mode": "read only"
      }),
      schema: editorActorSnapshot.context.schema,
      selection,
      value: slateEditorInstance.value
    },
    decoratorState: slateEditorInstance.decoratorState
  };
}
function RenderSpan(props) {
  const $ = c(40), slateEditor = useSlateStatic(), editorActor = useContext(EditorActorContext), legacySchema = useSelector(editorActor, _temp$2), spanRef = useRef(null);
  let t0;
  $[0] !== props.leaf._key || $[1] !== slateEditor ? (t0 = (editorActorSnapshot) => {
    const snapshot = getEditorSnapshot({
      editorActorSnapshot,
      slateEditorInstance: slateEditor
    });
    if (!snapshot.context.selection || !isSelectionCollapsed$1(snapshot))
      return !1;
    const focusedSpan = getFocusSpan$1(snapshot);
    return focusedSpan ? focusedSpan.node._key === props.leaf._key : !1;
  }, $[0] = props.leaf._key, $[1] = slateEditor, $[2] = t0) : t0 = $[2];
  const focused = useSelector(editorActor, t0);
  let t1;
  $[3] !== props.children.props.parent || $[4] !== props.leaf._key || $[5] !== props.leaf.text || $[6] !== slateEditor ? (t1 = (editorActorSnapshot_0) => {
    const snapshot_0 = getEditorSnapshot({
      editorActorSnapshot: editorActorSnapshot_0,
      slateEditorInstance: slateEditor
    });
    if (!snapshot_0.context.selection)
      return !1;
    const parent = props.children.props.parent, block = parent && isTextBlock(snapshot_0.context, parent) ? parent : void 0, spanSelection = block ? {
      anchor: {
        path: [{
          _key: block._key
        }, "children", {
          _key: props.leaf._key
        }],
        offset: 0
      },
      focus: {
        path: [{
          _key: block._key
        }, "children", {
          _key: props.leaf._key
        }],
        offset: props.leaf.text.length
      }
    } : null;
    return isOverlappingSelection(spanSelection)(snapshot_0);
  }, $[3] = props.children.props.parent, $[4] = props.leaf._key, $[5] = props.leaf.text, $[6] = slateEditor, $[7] = t1) : t1 = $[7];
  const selected = useSelector(editorActor, t1), parent_0 = props.children.props.parent, block_0 = parent_0 && slateEditor.isTextBlock(parent_0) ? parent_0 : void 0;
  let t2;
  $[8] !== block_0 || $[9] !== props.leaf._key ? (t2 = block_0 ? [{
    _key: block_0._key
  }, "children", {
    _key: props.leaf._key
  }] : void 0, $[8] = block_0, $[9] = props.leaf._key, $[10] = t2) : t2 = $[10];
  const path = t2;
  let annotationMarkDefs, children;
  if ($[11] !== block_0 || $[12] !== editorActor || $[13] !== focused || $[14] !== legacySchema || $[15] !== path || $[16] !== props.children || $[17] !== props.leaf.marks || $[18] !== props.renderAnnotation || $[19] !== props.renderDecorator || $[20] !== selected) {
    const decoratorSchemaTypes = editorActor.getSnapshot().context.schema.decorators.map(_temp2$1), decorators = [...new Set((props.leaf.marks ?? []).filter((mark) => decoratorSchemaTypes.includes(mark)))];
    annotationMarkDefs = (props.leaf.marks ?? []).flatMap((mark_0) => {
      if (decoratorSchemaTypes.includes(mark_0))
        return [];
      const markDef_0 = block_0?.markDefs?.find((markDef) => markDef._key === mark_0);
      return markDef_0 ? [markDef_0] : [];
    }), children = props.children;
    for (const mark_1 of decorators) {
      const legacyDecoratorSchemaType = legacySchema.decorators.find((dec) => dec.value === mark_1);
      path && legacyDecoratorSchemaType && props.renderDecorator && (children = /* @__PURE__ */ jsx(RenderDecorator, { renderDecorator: props.renderDecorator, editorElementRef: spanRef, focused, path, selected, schemaType: legacyDecoratorSchemaType, value: mark_1, type: legacyDecoratorSchemaType, children }));
    }
    for (const annotationMarkDef of annotationMarkDefs) {
      const legacyAnnotationSchemaType = legacySchema.annotations.find((t) => t.name === annotationMarkDef._type);
      legacyAnnotationSchemaType && (block_0 && path && props.renderAnnotation ? children = /* @__PURE__ */ jsx("span", { ref: spanRef, children: /* @__PURE__ */ jsx(RenderAnnotation, { renderAnnotation: props.renderAnnotation, block: block_0, editorElementRef: spanRef, focused, path, selected, schemaType: legacyAnnotationSchemaType, value: annotationMarkDef, type: legacyAnnotationSchemaType, children }) }) : children = /* @__PURE__ */ jsx("span", { ref: spanRef, children }));
    }
    $[11] = block_0, $[12] = editorActor, $[13] = focused, $[14] = legacySchema, $[15] = path, $[16] = props.children, $[17] = props.leaf.marks, $[18] = props.renderAnnotation, $[19] = props.renderDecorator, $[20] = selected, $[21] = annotationMarkDefs, $[22] = children;
  } else
    annotationMarkDefs = $[21], children = $[22];
  if (block_0 && path && props.renderChild) {
    let t32;
    if ($[23] !== block_0.children || $[24] !== props.leaf) {
      let t4;
      $[26] !== props.leaf ? (t4 = (_child) => _child._key === props.leaf._key, $[26] = props.leaf, $[27] = t4) : t4 = $[27], t32 = block_0.children.find(t4), $[23] = block_0.children, $[24] = props.leaf, $[25] = t32;
    } else
      t32 = $[25];
    const child = t32;
    if (child) {
      let t4;
      $[28] !== annotationMarkDefs || $[29] !== child || $[30] !== children || $[31] !== focused || $[32] !== legacySchema.span || $[33] !== path || $[34] !== props.renderChild || $[35] !== selected ? (t4 = /* @__PURE__ */ jsx(RenderChild, { renderChild: props.renderChild, annotations: annotationMarkDefs, editorElementRef: spanRef, focused, path, schemaType: legacySchema.span, selected, value: child, type: legacySchema.span, children }), $[28] = annotationMarkDefs, $[29] = child, $[30] = children, $[31] = focused, $[32] = legacySchema.span, $[33] = path, $[34] = props.renderChild, $[35] = selected, $[36] = t4) : t4 = $[36], children = t4;
    }
  }
  let t3;
  return $[37] !== children || $[38] !== props.attributes ? (t3 = /* @__PURE__ */ jsx("span", { ...props.attributes, ref: spanRef, children }), $[37] = children, $[38] = props.attributes, $[39] = t3) : t3 = $[39], t3;
}
function _temp2$1(decorator) {
  return decorator.name;
}
function _temp$2(s) {
  return s.context.getLegacySchema();
}
function RenderAnnotation({
  renderAnnotation,
  block,
  children,
  editorElementRef,
  focused,
  path,
  schemaType,
  selected,
  value,
  type
}) {
  return renderAnnotation({
    block,
    children,
    editorElementRef,
    focused,
    path,
    schemaType,
    selected,
    value,
    type
  });
}
function RenderDecorator({
  renderDecorator,
  children,
  editorElementRef,
  focused,
  path,
  schemaType,
  selected,
  value,
  type
}) {
  return renderDecorator({
    children,
    editorElementRef,
    focused,
    path,
    schemaType,
    selected,
    value,
    type
  });
}
function RenderChild({
  renderChild,
  annotations,
  children,
  editorElementRef,
  focused,
  path,
  schemaType,
  selected,
  value,
  type
}) {
  return renderChild({
    annotations,
    children,
    editorElementRef,
    focused,
    path,
    schemaType,
    selected,
    value,
    type
  });
}
const PLACEHOLDER_STYLE = {
  position: "absolute",
  userSelect: "none",
  pointerEvents: "none",
  left: 0,
  right: 0
};
function RenderLeaf(props) {
  const $ = c(12), editorActor = useContext(EditorActorContext), schema = useSelector(editorActor, _temp$1);
  if (props.leaf._type !== schema.span.name)
    return props.children;
  let t0;
  $[0] !== props ? (t0 = /* @__PURE__ */ jsx(RenderSpan, { ...props }), $[0] = props, $[1] = t0) : t0 = $[1];
  let renderedSpan = t0;
  if (props.renderPlaceholder && props.leaf.placeholder && props.text.text === "") {
    let t1;
    $[2] !== props.renderPlaceholder ? (t1 = props.renderPlaceholder(), $[2] = props.renderPlaceholder, $[3] = t1) : t1 = $[3];
    let t2;
    $[4] !== t1 ? (t2 = /* @__PURE__ */ jsx("span", { style: PLACEHOLDER_STYLE, contentEditable: !1, children: t1 }), $[4] = t1, $[5] = t2) : t2 = $[5];
    let t3;
    return $[6] !== renderedSpan || $[7] !== t2 ? (t3 = /* @__PURE__ */ jsxs(Fragment, { children: [
      t2,
      renderedSpan
    ] }), $[6] = renderedSpan, $[7] = t2, $[8] = t3) : t3 = $[8], t3;
  }
  const rangeDecoration = props.leaf.rangeDecoration;
  if (rangeDecoration) {
    let t1;
    $[9] !== rangeDecoration || $[10] !== renderedSpan ? (t1 = rangeDecoration.component({
      children: renderedSpan
    }), $[9] = rangeDecoration, $[10] = renderedSpan, $[11] = t1) : t1 = $[11], renderedSpan = t1;
  }
  return renderedSpan;
}
function _temp$1(s) {
  return s.context.schema;
}
function RenderText(props) {
  const $ = c(5);
  let t0;
  return $[0] !== props.attributes || $[1] !== props.children || $[2] !== props.text._key || $[3] !== props.text._type ? (t0 = /* @__PURE__ */ jsx("span", { ...props.attributes, "data-child-key": props.text._key, "data-child-name": props.text._type, "data-child-type": "span", children: props.children }), $[0] = props.attributes, $[1] = props.children, $[2] = props.text._key, $[3] = props.text._type, $[4] = t0) : t0 = $[4], t0;
}
const IS_MAC = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent), modifiers = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, aliases = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: IS_MAC ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, keyCodes = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222,
  f1: 112,
  f2: 113,
  f3: 114,
  f4: 115,
  f5: 116,
  f6: 117,
  f7: 118,
  f8: 119,
  f9: 120,
  f10: 121,
  f11: 122,
  f12: 123,
  f13: 124,
  f14: 125,
  f15: 126,
  f16: 127,
  f17: 128,
  f18: 129,
  f19: 130,
  f20: 131
};
function isHotkey(hotkey, event) {
  return compareHotkey(parseHotkey(hotkey), event);
}
function parseHotkey(hotkey) {
  const parsedHotkey = {
    altKey: !1,
    ctrlKey: !1,
    metaKey: !1,
    shiftKey: !1
  }, hotkeySegments = hotkey.replace("++", "+add").split("+");
  for (const rawHotkeySegment of hotkeySegments) {
    const optional = rawHotkeySegment.endsWith("?") && rawHotkeySegment.length > 1, hotkeySegment = optional ? rawHotkeySegment.slice(0, -1) : rawHotkeySegment, keyName = toKeyName(hotkeySegment), modifier = modifiers[keyName], alias = aliases[hotkeySegment], code2 = keyCodes[keyName];
    if (hotkeySegment.length > 1 && modifier === void 0 && alias === void 0 && code2 === void 0)
      throw new TypeError(`Unknown modifier: "${hotkeySegment}"`);
    (hotkeySegments.length === 1 || modifier === void 0) && (parsedHotkey.key = keyName, parsedHotkey.keyCode = toKeyCode(hotkeySegment)), modifier !== void 0 && (parsedHotkey[modifier] = optional ? null : !0);
  }
  return parsedHotkey;
}
function compareHotkey(parsedHotkey, event) {
  return (parsedHotkey.altKey == null || parsedHotkey.altKey === event.altKey) && (parsedHotkey.ctrlKey == null || parsedHotkey.ctrlKey === event.ctrlKey) && (parsedHotkey.metaKey == null || parsedHotkey.metaKey === event.metaKey) && (parsedHotkey.shiftKey == null || parsedHotkey.shiftKey === event.shiftKey) ? parsedHotkey.keyCode !== void 0 && event.keyCode !== void 0 ? parsedHotkey.keyCode === 91 && event.keyCode === 93 ? !0 : parsedHotkey.keyCode === event.keyCode : parsedHotkey.keyCode === event.keyCode || parsedHotkey.key === event.key.toLowerCase() : !1;
}
function toKeyCode(name) {
  const keyName = toKeyName(name);
  return keyCodes[keyName] ?? keyName.toUpperCase().charCodeAt(0);
}
function toKeyName(name) {
  const keyName = name.toLowerCase();
  return aliases[keyName] ?? keyName;
}
const debug$d = debugWithName("plugin:withHotKeys");
function createWithHotkeys(editorActor, portableTextEditor, hotkeysFromOptions) {
  const reservedHotkeys = ["enter", "tab", "shift", "delete", "end"], activeHotkeys = hotkeysFromOptions ?? {};
  return function(editor) {
    return editor.pteWithHotKeys = (event) => {
      Object.keys(activeHotkeys).forEach((cat) => {
        if (cat === "marks")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              event.preventDefault();
              const possibleMark = activeHotkeys[cat];
              if (possibleMark) {
                const mark = possibleMark[hotkey];
                debug$d(`HotKey ${hotkey} to toggle ${mark}`), editorActor.send({
                  type: "behavior event",
                  behaviorEvent: {
                    type: "decorator.toggle",
                    decorator: mark
                  },
                  editor
                });
              }
            }
          }
        if (cat === "custom")
          for (const hotkey in activeHotkeys[cat]) {
            if (reservedHotkeys.includes(hotkey))
              throw new Error(`The hotkey ${hotkey} is reserved!`);
            if (isHotkey(hotkey, event.nativeEvent)) {
              const possibleCommand = activeHotkeys[cat];
              if (possibleCommand) {
                const command = possibleCommand[hotkey];
                command(event, portableTextEditor);
              }
            }
          }
      });
    }, editor;
  };
}
function createEditorPriority(config) {
  return {
    id: defaultKeyGenerator(),
    name: config?.name,
    reference: config?.reference
  };
}
const corePriority = createEditorPriority({
  name: "core"
});
function getDragSelection({
  eventSelection,
  snapshot
}) {
  let dragSelection = eventSelection;
  if (getFocusInlineObject({
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: eventSelection
    }
  }))
    return dragSelection;
  const draggingCollapsedSelection = isSelectionCollapsed$1({
    context: {
      ...snapshot.context,
      selection: eventSelection
    }
  }), draggedTextBlock = getFocusTextBlock({
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: eventSelection
    }
  }), draggedSpan = getFocusSpan$1({
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: eventSelection
    }
  });
  draggingCollapsedSelection && draggedTextBlock && draggedSpan && (dragSelection = {
    anchor: getBlockStartPoint({
      context: snapshot.context,
      block: draggedTextBlock
    }),
    focus: getBlockEndPoint({
      context: snapshot.context,
      block: draggedTextBlock
    })
  });
  const selectedBlocks = getSelectedBlocks(snapshot);
  if (snapshot.context.selection && isSelectionExpanded(snapshot) && selectedBlocks.length > 1) {
    const selectionStartBlock = getSelectionStartBlock(snapshot), selectionEndBlock = getSelectionEndBlock(snapshot);
    if (!selectionStartBlock || !selectionEndBlock)
      return dragSelection;
    const selectionStartPoint = getBlockStartPoint({
      context: snapshot.context,
      block: selectionStartBlock
    }), selectionEndPoint = getBlockEndPoint({
      context: snapshot.context,
      block: selectionEndBlock
    });
    isOverlappingSelection(eventSelection)({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: selectionStartPoint,
          focus: selectionEndPoint
        }
      }
    }) && (dragSelection = {
      anchor: selectionStartPoint,
      focus: selectionEndPoint
    });
  }
  return dragSelection;
}
function createDropPositionBehaviorsConfig({
  setDropPosition
}) {
  return [{
    behavior: defineBehavior({
      on: "drag.dragover",
      guard: ({
        snapshot,
        event
      }) => {
        const dropFocusBlock = getFocusBlock$1({
          ...snapshot,
          context: {
            ...snapshot.context,
            selection: event.position.selection
          }
        });
        if (!dropFocusBlock)
          return !1;
        const dragOrigin = event.dragOrigin;
        if (!dragOrigin)
          return !1;
        const dragSelection = getDragSelection({
          eventSelection: dragOrigin.selection,
          snapshot
        });
        return getSelectedBlocks({
          ...snapshot,
          context: {
            ...snapshot.context,
            selection: dragSelection
          }
        }).some((draggedBlock) => draggedBlock.node._key === dropFocusBlock.node._key) || !isSelectingEntireBlocks({
          ...snapshot,
          context: {
            ...snapshot.context,
            selection: dragSelection
          }
        }) ? !1 : {
          dropFocusBlock
        };
      },
      actions: [({
        event
      }, {
        dropFocusBlock
      }) => [{
        type: "effect",
        effect: () => {
          setDropPosition({
            blockKey: dropFocusBlock.node._key,
            positionBlock: event.position.block
          });
        }
      }]]
    }),
    priority: createEditorPriority({
      reference: {
        priority: corePriority,
        importance: "lower"
      }
    })
  }, {
    behavior: defineBehavior({
      on: "drag.*",
      guard: ({
        event
      }) => event.type !== "drag.dragover",
      actions: [({
        event
      }) => [{
        type: "effect",
        effect: () => {
          setDropPosition(void 0);
        }
      }, forward(event)]]
    }),
    priority: createEditorPriority({
      reference: {
        priority: corePriority,
        importance: "lower"
      }
    })
  }];
}
function useDropPosition() {
  const $ = c(3), editorActor = useContext(EditorActorContext), [dropPosition, setDropPosition] = useState();
  let t0, t1;
  return $[0] !== editorActor ? (t0 = () => {
    const behaviorConfigs = createDropPositionBehaviorsConfig({
      setDropPosition
    });
    for (const behaviorConfig of behaviorConfigs)
      editorActor.send({
        type: "add behavior",
        behaviorConfig
      });
    return () => {
      for (const behaviorConfig_0 of behaviorConfigs)
        editorActor.send({
          type: "remove behavior",
          behaviorConfig: behaviorConfig_0
        });
    };
  }, t1 = [editorActor, setDropPosition], $[0] = editorActor, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1), dropPosition;
}
const PortableTextEditorContext = createContext(null), usePortableTextEditor = () => {
  const editor = useContext(PortableTextEditorContext);
  if (!editor)
    throw new Error("The `usePortableTextEditor` hook must be used inside the <PortableTextEditor> component's context.");
  return editor;
}, debug$c = debugWithName("validate selection machine"), validateSelectionSetup = setup({
  types: {
    context: {},
    input: {},
    events: {}
  },
  guards: {
    "pending operations": ({
      context
    }) => context.slateEditor.operations.length > 0
  }
}), validateSelectionAction = validateSelectionSetup.createAction(({
  context,
  event
}) => {
  validateSelection(context.slateEditor, event.editorElement);
}), validateSelectionMachine = validateSelectionSetup.createMachine({
  id: "validate selection",
  context: ({
    input
  }) => ({
    slateEditor: input.slateEditor
  }),
  initial: "idle",
  states: {
    idle: {
      on: {
        "validate selection": [{
          guard: "pending operations",
          target: "waiting"
        }, {
          actions: [validateSelectionAction],
          target: "idle"
        }]
      }
    },
    waiting: {
      after: {
        0: [{
          guard: "pending operations",
          target: ".",
          reenter: !0
        }, {
          target: "idle",
          actions: [validateSelectionAction]
        }]
      },
      on: {
        "validate selection": {
          target: ".",
          reenter: !0
        }
      }
    }
  }
});
function validateSelection(slateEditor, editorElement) {
  if (!slateEditor.selection)
    return;
  let root;
  try {
    root = ReactEditor.findDocumentOrShadowRoot(slateEditor);
  } catch {
  }
  if (!root || editorElement !== root.activeElement)
    return;
  const domSelection = ReactEditor.getWindow(slateEditor).getSelection();
  if (!domSelection || domSelection.rangeCount === 0)
    return;
  const existingDOMRange = domSelection.getRangeAt(0);
  try {
    const newDOMRange = ReactEditor.toDOMRange(slateEditor, slateEditor.selection);
    (newDOMRange.startOffset !== existingDOMRange.startOffset || newDOMRange.endOffset !== existingDOMRange.endOffset) && (debug$c("DOM range out of sync, validating selection"), domSelection?.removeAllRanges(), domSelection.addRange(newDOMRange));
  } catch {
    debug$c("Could not resolve selection, selecting top document"), Transforms.deselect(slateEditor), slateEditor.children.length > 0 && Transforms.select(slateEditor, Editor.start(slateEditor, [])), slateEditor.onChange();
  }
}
const debug$b = debugWithName("component:Editable"), PortableTextEditable = forwardRef(function(props, forwardedRef) {
  const $ = c(177);
  let hotkeys, onBeforeInput, onBlur, onClick, onCopy, onCut, onDrag, onDragEnd, onDragEnter, onDragLeave, onDragOver, onDragStart, onDrop, onFocus, onPaste, propsSelection, rangeDecorations, renderAnnotation, renderBlock, renderChild, renderDecorator, renderListItem, renderPlaceholder, renderStyle, restProps, scrollSelectionIntoView, spellCheck;
  $[0] !== props ? ({
    hotkeys,
    onBlur,
    onFocus,
    onBeforeInput,
    onPaste,
    onCopy,
    onCut,
    onClick,
    onDragStart,
    onDrag,
    onDragEnd,
    onDragEnter,
    onDragOver,
    onDrop,
    onDragLeave,
    rangeDecorations,
    renderAnnotation,
    renderBlock,
    renderChild,
    renderDecorator,
    renderListItem,
    renderPlaceholder,
    renderStyle,
    selection: propsSelection,
    scrollSelectionIntoView,
    spellCheck,
    ...restProps
  } = props, $[0] = props, $[1] = hotkeys, $[2] = onBeforeInput, $[3] = onBlur, $[4] = onClick, $[5] = onCopy, $[6] = onCut, $[7] = onDrag, $[8] = onDragEnd, $[9] = onDragEnter, $[10] = onDragLeave, $[11] = onDragOver, $[12] = onDragStart, $[13] = onDrop, $[14] = onFocus, $[15] = onPaste, $[16] = propsSelection, $[17] = rangeDecorations, $[18] = renderAnnotation, $[19] = renderBlock, $[20] = renderChild, $[21] = renderDecorator, $[22] = renderListItem, $[23] = renderPlaceholder, $[24] = renderStyle, $[25] = restProps, $[26] = scrollSelectionIntoView, $[27] = spellCheck) : (hotkeys = $[1], onBeforeInput = $[2], onBlur = $[3], onClick = $[4], onCopy = $[5], onCut = $[6], onDrag = $[7], onDragEnd = $[8], onDragEnter = $[9], onDragLeave = $[10], onDragOver = $[11], onDragStart = $[12], onDrop = $[13], onFocus = $[14], onPaste = $[15], propsSelection = $[16], rangeDecorations = $[17], renderAnnotation = $[18], renderBlock = $[19], renderChild = $[20], renderDecorator = $[21], renderListItem = $[22], renderPlaceholder = $[23], renderStyle = $[24], restProps = $[25], scrollSelectionIntoView = $[26], spellCheck = $[27]);
  const portableTextEditor = usePortableTextEditor(), [hasInvalidValue, setHasInvalidValue] = useState(!1), editorActor = useContext(EditorActorContext), relayActor = useContext(RelayActorContext), readOnly = useSelector(editorActor, _temp), slateEditor = useSlate();
  let t0;
  $[28] !== slateEditor ? (t0 = {
    input: {
      slateEditor
    }
  }, $[28] = slateEditor, $[29] = t0) : t0 = $[29];
  const validateSelectionActor = useActorRef(validateSelectionMachine, t0);
  let t1;
  $[30] !== rangeDecorations ? (t1 = rangeDecorations ?? [], $[30] = rangeDecorations, $[31] = t1) : t1 = $[31];
  let t2;
  $[32] !== editorActor ? (t2 = editorActor.getSnapshot(), $[32] = editorActor, $[33] = t2) : t2 = $[33];
  const t3 = t2.context.schema;
  let t4;
  $[34] !== editorActor ? (t4 = editorActor.getSnapshot().matches({
    setup: "setting up"
  }), $[34] = editorActor, $[35] = t4) : t4 = $[35];
  const t5 = !t4;
  let t6;
  $[36] !== readOnly || $[37] !== slateEditor || $[38] !== t1 || $[39] !== t2.context.schema || $[40] !== t5 ? (t6 = {
    input: {
      rangeDecorations: t1,
      readOnly,
      schema: t3,
      slateEditor,
      skipSetup: t5
    }
  }, $[36] = readOnly, $[37] = slateEditor, $[38] = t1, $[39] = t2.context.schema, $[40] = t5, $[41] = t6) : t6 = $[41];
  const rangeDecorationsActor = useActorRef(rangeDecorationsMachine, t6), decorate = useSelector(rangeDecorationsActor, _temp2), dropPosition = useDropPosition();
  let t7, t8;
  $[42] !== rangeDecorationsActor || $[43] !== readOnly ? (t7 = () => {
    rangeDecorationsActor.send({
      type: "update read only",
      readOnly
    });
  }, t8 = [rangeDecorationsActor, readOnly], $[42] = rangeDecorationsActor, $[43] = readOnly, $[44] = t7, $[45] = t8) : (t7 = $[44], t8 = $[45]), useEffect(t7, t8);
  let t10, t9;
  $[46] !== rangeDecorations || $[47] !== rangeDecorationsActor ? (t9 = () => {
    rangeDecorationsActor.send({
      type: "range decorations updated",
      rangeDecorations: rangeDecorations ?? []
    });
  }, t10 = [rangeDecorationsActor, rangeDecorations], $[46] = rangeDecorations, $[47] = rangeDecorationsActor, $[48] = t10, $[49] = t9) : (t10 = $[48], t9 = $[49]), useEffect(t9, t10);
  bb0: {
    if (readOnly)
      break bb0;
    createWithHotkeys(editorActor, portableTextEditor, hotkeys)(slateEditor);
  }
  let t12;
  $[50] !== dropPosition || $[51] !== readOnly || $[52] !== renderBlock || $[53] !== renderChild || $[54] !== renderListItem || $[55] !== renderStyle || $[56] !== spellCheck ? (t12 = (eProps) => /* @__PURE__ */ jsx(RenderElement, { ...eProps, dropPosition, readOnly, renderBlock, renderChild, renderListItem, renderStyle, spellCheck }), $[50] = dropPosition, $[51] = readOnly, $[52] = renderBlock, $[53] = renderChild, $[54] = renderListItem, $[55] = renderStyle, $[56] = spellCheck, $[57] = t12) : t12 = $[57];
  const renderElement = t12;
  let t13;
  $[58] !== readOnly || $[59] !== renderAnnotation || $[60] !== renderChild || $[61] !== renderDecorator || $[62] !== renderPlaceholder ? (t13 = (leafProps) => /* @__PURE__ */ jsx(RenderLeaf, { ...leafProps, readOnly, renderAnnotation, renderChild, renderDecorator, renderPlaceholder }), $[58] = readOnly, $[59] = renderAnnotation, $[60] = renderChild, $[61] = renderDecorator, $[62] = renderPlaceholder, $[63] = t13) : t13 = $[63];
  const renderLeaf = t13, renderText = _temp3;
  let t14;
  $[64] !== editorActor || $[65] !== propsSelection || $[66] !== slateEditor ? (t14 = () => {
    if (propsSelection) {
      debug$b(`Selection from props ${JSON.stringify(propsSelection)}`);
      const normalizedSelection = normalizeSelection(propsSelection, slateEditor.value);
      if (normalizedSelection !== null) {
        debug$b(`Normalized selection from props ${JSON.stringify(normalizedSelection)}`);
        const slateRange = toSlateRange({
          context: {
            schema: editorActor.getSnapshot().context.schema,
            value: slateEditor.value,
            selection: normalizedSelection
          },
          blockIndexMap: slateEditor.blockIndexMap
        });
        slateRange && (Transforms.select(slateEditor, slateRange), slateEditor.operations.some(_temp4) || editorActor.send({
          type: "update selection",
          selection: normalizedSelection
        }), slateEditor.onChange());
      }
    }
  }, $[64] = editorActor, $[65] = propsSelection, $[66] = slateEditor, $[67] = t14) : t14 = $[67];
  const restoreSelectionFromProps = t14;
  let t15, t16;
  $[68] !== editorActor || $[69] !== rangeDecorationsActor || $[70] !== restoreSelectionFromProps ? (t15 = () => {
    const onReady = editorActor.on("ready", () => {
      rangeDecorationsActor.send({
        type: "ready"
      }), restoreSelectionFromProps();
    }), onInvalidValue = editorActor.on("invalid value", () => {
      setHasInvalidValue(!0);
    }), onValueChanged = editorActor.on("value changed", () => {
      setHasInvalidValue(!1);
    });
    return () => {
      onReady.unsubscribe(), onInvalidValue.unsubscribe(), onValueChanged.unsubscribe();
    };
  }, t16 = [rangeDecorationsActor, editorActor, restoreSelectionFromProps], $[68] = editorActor, $[69] = rangeDecorationsActor, $[70] = restoreSelectionFromProps, $[71] = t15, $[72] = t16) : (t15 = $[71], t16 = $[72]), useEffect(t15, t16);
  let t17, t18;
  $[73] !== hasInvalidValue || $[74] !== propsSelection || $[75] !== restoreSelectionFromProps ? (t17 = () => {
    propsSelection && !hasInvalidValue && restoreSelectionFromProps();
  }, t18 = [hasInvalidValue, propsSelection, restoreSelectionFromProps], $[73] = hasInvalidValue, $[74] = propsSelection, $[75] = restoreSelectionFromProps, $[76] = t17, $[77] = t18) : (t17 = $[76], t18 = $[77]), useEffect(t17, t18);
  let t19;
  $[78] !== editorActor || $[79] !== onCopy || $[80] !== slateEditor ? (t19 = (event) => {
    if (onCopy)
      onCopy(event) !== void 0 && event.preventDefault();
    else if (event.nativeEvent.clipboardData) {
      event.stopPropagation(), event.preventDefault();
      const selection = slateEditor.selection ? slateRangeToSelection({
        schema: editorActor.getSnapshot().context.schema,
        editor: slateEditor,
        range: slateEditor.selection
      }) : void 0, position = selection ? {
        selection
      } : void 0;
      if (!position) {
        console.warn("Could not find position for copy event");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "clipboard.copy",
          originEvent: {
            dataTransfer: event.nativeEvent.clipboardData
          },
          position
        },
        editor: slateEditor,
        nativeEvent: event
      });
    }
  }, $[78] = editorActor, $[79] = onCopy, $[80] = slateEditor, $[81] = t19) : t19 = $[81];
  const handleCopy = t19;
  let t20;
  $[82] !== editorActor || $[83] !== onCut || $[84] !== slateEditor ? (t20 = (event_0) => {
    if (onCut)
      onCut(event_0) !== void 0 && event_0.preventDefault();
    else if (event_0.nativeEvent.clipboardData) {
      event_0.stopPropagation(), event_0.preventDefault();
      const selection_0 = editorActor.getSnapshot().context.selection, position_0 = selection_0 ? {
        selection: selection_0
      } : void 0;
      if (!position_0) {
        console.warn("Could not find position for cut event");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "clipboard.cut",
          originEvent: {
            dataTransfer: event_0.nativeEvent.clipboardData
          },
          position: position_0
        },
        editor: slateEditor,
        nativeEvent: event_0
      });
    }
  }, $[82] = editorActor, $[83] = onCut, $[84] = slateEditor, $[85] = t20) : t20 = $[85];
  const handleCut = t20;
  let t21;
  $[86] !== editorActor || $[87] !== onPaste || $[88] !== portableTextEditor || $[89] !== relayActor || $[90] !== slateEditor ? (t21 = (event_1) => {
    const value = slateEditor.value, path = (slateEditor.selection ? slateRangeToSelection({
      schema: editorActor.getSnapshot().context.schema,
      editor: slateEditor,
      range: slateEditor.selection
    }) : null)?.focus.path || [], onPasteResult = onPaste?.({
      event: event_1,
      value,
      path,
      schemaTypes: portableTextEditor.schemaTypes
    });
    if (onPasteResult || !slateEditor.selection)
      event_1.preventDefault(), relayActor.send({
        type: "loading"
      }), Promise.resolve(onPasteResult).then((result_1) => {
        if (debug$b("Custom paste function from client resolved", result_1), !result_1 || !result_1.insert) {
          debug$b("No result from custom paste handler, pasting normally");
          const selection_1 = editorActor.getSnapshot().context.selection, position_1 = selection_1 ? {
            selection: selection_1
          } : void 0;
          if (!position_1) {
            console.warn("Could not find position for paste event");
            return;
          }
          editorActor.send({
            type: "behavior event",
            behaviorEvent: {
              type: "clipboard.paste",
              originEvent: {
                dataTransfer: event_1.clipboardData
              },
              position: position_1
            },
            editor: slateEditor,
            nativeEvent: event_1
          });
        } else
          result_1.insert ? editorActor.send({
            type: "behavior event",
            behaviorEvent: {
              type: "insert.blocks",
              blocks: parseBlocks({
                context: {
                  keyGenerator: editorActor.getSnapshot().context.keyGenerator,
                  schema: editorActor.getSnapshot().context.schema
                },
                blocks: result_1.insert,
                options: {
                  normalize: !1,
                  removeUnusedMarkDefs: !0,
                  validateFields: !1
                }
              }),
              placement: "auto"
            },
            editor: slateEditor
          }) : console.warn("Your onPaste function returned something unexpected:", result_1);
      }).catch(_temp5).finally(() => {
        relayActor.send({
          type: "done loading"
        });
      });
    else if (event_1.nativeEvent.clipboardData) {
      event_1.preventDefault(), event_1.stopPropagation();
      const selection_2 = editorActor.getSnapshot().context.selection, position_2 = selection_2 ? {
        selection: selection_2
      } : void 0;
      if (!position_2) {
        console.warn("Could not find position for paste event");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "clipboard.paste",
          originEvent: {
            dataTransfer: event_1.nativeEvent.clipboardData
          },
          position: position_2
        },
        editor: slateEditor,
        nativeEvent: event_1
      });
    }
    debug$b("No result from custom paste handler, pasting normally");
  }, $[86] = editorActor, $[87] = onPaste, $[88] = portableTextEditor, $[89] = relayActor, $[90] = slateEditor, $[91] = t21) : t21 = $[91];
  const handlePaste = t21;
  let t22;
  $[92] !== editorActor || $[93] !== onFocus || $[94] !== relayActor || $[95] !== slateEditor ? (t22 = (event_2) => {
    onFocus && onFocus(event_2), event_2.isDefaultPrevented() || (relayActor.send({
      type: "focused",
      event: event_2
    }), !slateEditor.selection && slateEditor.children.length === 1 && isEmptyTextBlock(editorActor.getSnapshot().context, slateEditor.value.at(0)) && (Transforms.select(slateEditor, Editor.start(slateEditor, [])), slateEditor.onChange()));
  }, $[92] = editorActor, $[93] = onFocus, $[94] = relayActor, $[95] = slateEditor, $[96] = t22) : t22 = $[96];
  const handleOnFocus = t22;
  let t23;
  $[97] !== editorActor || $[98] !== onClick || $[99] !== slateEditor ? (t23 = (event_3) => {
    if (onClick && onClick(event_3), event_3.isDefaultPrevented() || event_3.isPropagationStopped())
      return;
    const position_3 = getEventPosition({
      editorActor,
      slateEditor,
      event: event_3.nativeEvent
    });
    position_3 && editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "mouse.click",
        position: position_3
      },
      editor: slateEditor,
      nativeEvent: event_3
    });
  }, $[97] = editorActor, $[98] = onClick, $[99] = slateEditor, $[100] = t23) : t23 = $[100];
  const handleClick = t23;
  let t24;
  $[101] !== onBlur || $[102] !== relayActor ? (t24 = (event_4) => {
    onBlur && onBlur(event_4), event_4.isPropagationStopped() || relayActor.send({
      type: "blurred",
      event: event_4
    });
  }, $[101] = onBlur, $[102] = relayActor, $[103] = t24) : t24 = $[103];
  const handleOnBlur = t24;
  let t25;
  $[104] !== onBeforeInput ? (t25 = (event_5) => {
    onBeforeInput && onBeforeInput(event_5);
  }, $[104] = onBeforeInput, $[105] = t25) : t25 = $[105];
  const handleOnBeforeInput = t25;
  let t26;
  $[106] !== editorActor || $[107] !== props || $[108] !== slateEditor ? (t26 = (event_6) => {
    props.onKeyDown && props.onKeyDown(event_6), event_6.isDefaultPrevented() || slateEditor.pteWithHotKeys(event_6), event_6.isDefaultPrevented() || editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "keyboard.keydown",
        originEvent: {
          key: event_6.key,
          code: event_6.code,
          altKey: event_6.altKey,
          ctrlKey: event_6.ctrlKey,
          metaKey: event_6.metaKey,
          shiftKey: event_6.shiftKey
        }
      },
      editor: slateEditor,
      nativeEvent: event_6
    });
  }, $[106] = editorActor, $[107] = props, $[108] = slateEditor, $[109] = t26) : t26 = $[109];
  const handleKeyDown = t26;
  let t27;
  $[110] !== editorActor || $[111] !== props || $[112] !== slateEditor ? (t27 = (event_7) => {
    props.onKeyUp && props.onKeyUp(event_7), event_7.isDefaultPrevented() || editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "keyboard.keyup",
        originEvent: {
          key: event_7.key,
          code: event_7.code,
          altKey: event_7.altKey,
          ctrlKey: event_7.ctrlKey,
          metaKey: event_7.metaKey,
          shiftKey: event_7.shiftKey
        }
      },
      editor: slateEditor,
      nativeEvent: event_7
    });
  }, $[110] = editorActor, $[111] = props, $[112] = slateEditor, $[113] = t27) : t27 = $[113];
  const handleKeyUp = t27;
  let t28;
  bb1: {
    if (scrollSelectionIntoView === void 0) {
      t28 = void 0;
      break bb1;
    }
    if (scrollSelectionIntoView === null) {
      t28 = noop;
      break bb1;
    }
    let t292;
    $[114] !== portableTextEditor || $[115] !== scrollSelectionIntoView ? (t292 = (_editor, domRange) => {
      scrollSelectionIntoView(portableTextEditor, domRange);
    }, $[114] = portableTextEditor, $[115] = scrollSelectionIntoView, $[116] = t292) : t292 = $[116], t28 = t292;
  }
  const scrollSelectionIntoViewToSlate = t28;
  let t29, t30;
  $[117] !== editorActor || $[118] !== slateEditor ? (t29 = () => {
    const window2 = ReactEditor.getWindow(slateEditor), onDragEnd_0 = () => {
      editorActor.send({
        type: "dragend"
      });
    }, onDrop_0 = () => {
      editorActor.send({
        type: "drop"
      });
    };
    return window2.document.addEventListener("dragend", onDragEnd_0), window2.document.addEventListener("drop", onDrop_0), () => {
      window2.document.removeEventListener("dragend", onDragEnd_0), window2.document.removeEventListener("drop", onDrop_0);
    };
  }, t30 = [slateEditor, editorActor], $[117] = editorActor, $[118] = slateEditor, $[119] = t29, $[120] = t30) : (t29 = $[119], t30 = $[120]), useEffect(t29, t30);
  let t31;
  $[121] !== editorActor || $[122] !== onDragStart || $[123] !== slateEditor ? (t31 = (event_8) => {
    if (onDragStart?.(event_8), event_8.isDefaultPrevented() || event_8.isPropagationStopped())
      return;
    const position_4 = getEventPosition({
      editorActor,
      slateEditor,
      event: event_8.nativeEvent
    });
    if (!position_4) {
      console.warn("Could not find position for dragstart event");
      return;
    }
    return editorActor.send({
      type: "dragstart",
      origin: position_4
    }), editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "drag.dragstart",
        originEvent: {
          clientX: event_8.clientX,
          clientY: event_8.clientY,
          dataTransfer: event_8.dataTransfer
        },
        position: position_4
      },
      editor: slateEditor
    }), !0;
  }, $[121] = editorActor, $[122] = onDragStart, $[123] = slateEditor, $[124] = t31) : t31 = $[124];
  const handleDragStart = t31;
  let t32;
  $[125] !== editorActor || $[126] !== onDrag || $[127] !== slateEditor ? (t32 = (event_9) => {
    if (onDrag?.(event_9), !(event_9.isDefaultPrevented() || event_9.isPropagationStopped() || !getEventPosition({
      editorActor,
      slateEditor,
      event: event_9.nativeEvent
    })))
      return editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.drag",
          originEvent: {
            dataTransfer: event_9.dataTransfer
          }
        },
        editor: slateEditor
      }), !0;
  }, $[125] = editorActor, $[126] = onDrag, $[127] = slateEditor, $[128] = t32) : t32 = $[128];
  const handleDrag = t32;
  let t33;
  $[129] !== editorActor || $[130] !== onDragEnd || $[131] !== slateEditor ? (t33 = (event_10) => {
    if (onDragEnd?.(event_10), !(event_10.isDefaultPrevented() || event_10.isPropagationStopped()))
      return editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.dragend",
          originEvent: {
            dataTransfer: event_10.dataTransfer
          }
        },
        editor: slateEditor
      }), !0;
  }, $[129] = editorActor, $[130] = onDragEnd, $[131] = slateEditor, $[132] = t33) : t33 = $[132];
  const handleDragEnd = t33;
  let t34;
  $[133] !== editorActor || $[134] !== onDragEnter || $[135] !== slateEditor ? (t34 = (event_11) => {
    if (onDragEnter?.(event_11), event_11.isDefaultPrevented() || event_11.isPropagationStopped())
      return;
    const position_6 = getEventPosition({
      editorActor,
      slateEditor,
      event: event_11.nativeEvent
    });
    if (position_6)
      return editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.dragenter",
          originEvent: {
            dataTransfer: event_11.dataTransfer
          },
          position: position_6
        },
        editor: slateEditor
      }), !0;
  }, $[133] = editorActor, $[134] = onDragEnter, $[135] = slateEditor, $[136] = t34) : t34 = $[136];
  const handleDragEnter = t34;
  let t35;
  $[137] !== editorActor || $[138] !== onDragOver || $[139] !== slateEditor ? (t35 = (event_12) => {
    if (onDragOver?.(event_12), event_12.isDefaultPrevented() || event_12.isPropagationStopped())
      return;
    const position_7 = getEventPosition({
      editorActor,
      slateEditor,
      event: event_12.nativeEvent
    });
    if (position_7)
      return editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.dragover",
          originEvent: {
            dataTransfer: event_12.dataTransfer
          },
          dragOrigin: editorActor.getSnapshot().context.internalDrag?.origin,
          position: position_7
        },
        editor: slateEditor,
        nativeEvent: event_12
      }), !0;
  }, $[137] = editorActor, $[138] = onDragOver, $[139] = slateEditor, $[140] = t35) : t35 = $[140];
  const handleDragOver = t35;
  let t36;
  $[141] !== editorActor || $[142] !== onDrop || $[143] !== slateEditor ? (t36 = (event_13) => {
    if (onDrop?.(event_13), event_13.isDefaultPrevented() || event_13.isPropagationStopped())
      return;
    const position_8 = getEventPosition({
      editorActor,
      slateEditor,
      event: event_13.nativeEvent
    });
    if (!position_8) {
      console.warn("Could not find position for drop event");
      return;
    }
    return editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "drag.drop",
        originEvent: {
          dataTransfer: event_13.dataTransfer
        },
        dragOrigin: editorActor.getSnapshot().context.internalDrag?.origin,
        position: position_8
      },
      editor: slateEditor,
      nativeEvent: event_13
    }), !0;
  }, $[141] = editorActor, $[142] = onDrop, $[143] = slateEditor, $[144] = t36) : t36 = $[144];
  const handleDrop = t36;
  let t37;
  $[145] !== editorActor || $[146] !== onDragLeave || $[147] !== slateEditor ? (t37 = (event_14) => {
    if (onDragLeave?.(event_14), !(event_14.isDefaultPrevented() || event_14.isPropagationStopped() || !getEventPosition({
      editorActor,
      slateEditor,
      event: event_14.nativeEvent
    })))
      return editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "drag.dragleave",
          originEvent: {
            dataTransfer: event_14.dataTransfer
          }
        },
        editor: slateEditor
      }), !0;
  }, $[145] = editorActor, $[146] = onDragLeave, $[147] = slateEditor, $[148] = t37) : t37 = $[148];
  const handleDragLeave = t37;
  let t38;
  $[149] !== forwardedRef || $[150] !== validateSelectionActor ? (t38 = (editorElement) => {
    if (typeof forwardedRef == "function" ? forwardedRef(editorElement) : forwardedRef && (forwardedRef.current = editorElement), editorElement) {
      const mutationObserver = new MutationObserver(() => {
        validateSelectionActor.send({
          type: "validate selection",
          editorElement
        });
      });
      return mutationObserver.observe(editorElement, {
        attributeOldValue: !1,
        attributes: !1,
        characterData: !1,
        childList: !0,
        subtree: !0
      }), () => {
        mutationObserver.disconnect();
      };
    }
  }, $[149] = forwardedRef, $[150] = validateSelectionActor, $[151] = t38) : t38 = $[151];
  const callbackRef = t38;
  if (!portableTextEditor)
    return null;
  let t39;
  return $[152] !== callbackRef || $[153] !== decorate || $[154] !== handleClick || $[155] !== handleCopy || $[156] !== handleCut || $[157] !== handleDrag || $[158] !== handleDragEnd || $[159] !== handleDragEnter || $[160] !== handleDragLeave || $[161] !== handleDragOver || $[162] !== handleDragStart || $[163] !== handleDrop || $[164] !== handleKeyDown || $[165] !== handleKeyUp || $[166] !== handleOnBeforeInput || $[167] !== handleOnBlur || $[168] !== handleOnFocus || $[169] !== handlePaste || $[170] !== hasInvalidValue || $[171] !== readOnly || $[172] !== renderElement || $[173] !== renderLeaf || $[174] !== restProps || $[175] !== scrollSelectionIntoViewToSlate ? (t39 = hasInvalidValue ? null : /* @__PURE__ */ jsx(Editable, { ...restProps, ref: callbackRef, "data-read-only": readOnly, autoFocus: !1, className: restProps.className || "pt-editable", decorate, onBlur: handleOnBlur, onCopy: handleCopy, onCut: handleCut, onClick: handleClick, onDOMBeforeInput: handleOnBeforeInput, onDragStart: handleDragStart, onDrag: handleDrag, onDragEnd: handleDragEnd, onDragEnter: handleDragEnter, onDragOver: handleDragOver, onDrop: handleDrop, onDragLeave: handleDragLeave, onFocus: handleOnFocus, onKeyDown: handleKeyDown, onKeyUp: handleKeyUp, onPaste: handlePaste, readOnly, renderPlaceholder: void 0, renderElement, renderLeaf, renderText, scrollSelectionIntoView: scrollSelectionIntoViewToSlate }), $[152] = callbackRef, $[153] = decorate, $[154] = handleClick, $[155] = handleCopy, $[156] = handleCut, $[157] = handleDrag, $[158] = handleDragEnd, $[159] = handleDragEnter, $[160] = handleDragLeave, $[161] = handleDragOver, $[162] = handleDragStart, $[163] = handleDrop, $[164] = handleKeyDown, $[165] = handleKeyUp, $[166] = handleOnBeforeInput, $[167] = handleOnBlur, $[168] = handleOnFocus, $[169] = handlePaste, $[170] = hasInvalidValue, $[171] = readOnly, $[172] = renderElement, $[173] = renderLeaf, $[174] = restProps, $[175] = scrollSelectionIntoViewToSlate, $[176] = t39) : t39 = $[176], t39;
});
PortableTextEditable.displayName = "ForwardRef(PortableTextEditable)";
function noop() {
}
function _temp(s) {
  return s.matches({
    "edit mode": "read only"
  });
}
function _temp2(s_0) {
  return s_0.context.decorate?.fn;
}
function _temp3(props_0) {
  return /* @__PURE__ */ jsx(RenderText, { ...props_0 });
}
function _temp4(o) {
  return o.type === "set_selection";
}
function _temp5(error) {
  return console.warn(error), error;
}
const forEachActor = (actorRef, callback) => {
  callback(actorRef);
  const children = actorRef.getSnapshot().children;
  children && Object.values(children).forEach((child) => {
    forEachActor(child, callback);
  });
};
function stopActor(actorRef) {
  const persistedSnapshots = [];
  forEachActor(actorRef, (ref) => {
    persistedSnapshots.push([ref, ref.getSnapshot()]), ref.observers = /* @__PURE__ */ new Set();
  });
  const systemSnapshot = actorRef.system.getSnapshot?.();
  actorRef.stop(), actorRef.system._snapshot = systemSnapshot, persistedSnapshots.forEach(([ref, snapshot]) => {
    ref._processingStatus = 0, ref._snapshot = snapshot;
  });
}
const converterJson = {
  mimeType: "application/json",
  serialize: ({
    snapshot,
    event
  }) => {
    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === "application/x-portable-text");
    return portableTextConverter ? {
      ...portableTextConverter.serialize({
        snapshot,
        event
      }),
      mimeType: "application/json",
      originEvent: event.originEvent
    } : {
      type: "serialization.failure",
      mimeType: "application/json",
      originEvent: event.originEvent,
      reason: "No application/x-portable-text Converter found"
    };
  },
  deserialize: ({
    snapshot,
    event
  }) => {
    const portableTextConverter = snapshot.context.converters.find((converter) => converter.mimeType === "application/x-portable-text");
    return portableTextConverter ? {
      ...portableTextConverter.deserialize({
        snapshot,
        event
      }),
      mimeType: "application/json"
    } : {
      type: "deserialization.failure",
      mimeType: "application/json",
      reason: "No application/x-portable-text Converter found"
    };
  }
}, converterPortableText = {
  mimeType: "application/x-portable-text",
  serialize: ({
    snapshot,
    event
  }) => {
    if (!snapshot.context.selection)
      return {
        type: "serialization.failure",
        mimeType: "application/x-portable-text",
        originEvent: event.originEvent,
        reason: "No selection"
      };
    const blocks = getSelectedValue(snapshot);
    return blocks.length === 0 ? {
      type: "serialization.failure",
      mimeType: "application/x-portable-text",
      reason: "No blocks serialized",
      originEvent: event.originEvent
    } : {
      type: "serialization.success",
      data: JSON.stringify(blocks),
      mimeType: "application/x-portable-text",
      originEvent: event.originEvent
    };
  },
  deserialize: ({
    snapshot,
    event
  }) => {
    const blocks = JSON.parse(event.data);
    if (!Array.isArray(blocks))
      return {
        type: "deserialization.failure",
        mimeType: "application/x-portable-text",
        reason: "Data is not an array"
      };
    const parsedBlocks = blocks.flatMap((block) => {
      const parsedBlock = parseBlock({
        context: snapshot.context,
        block,
        options: {
          normalize: !1,
          removeUnusedMarkDefs: !0,
          validateFields: !1
        }
      });
      return parsedBlock ? [parsedBlock] : [];
    });
    return parsedBlocks.length === 0 && blocks.length > 0 ? {
      type: "deserialization.failure",
      mimeType: "application/x-portable-text",
      reason: "No blocks were parsed"
    } : {
      type: "deserialization.success",
      data: parsedBlocks,
      mimeType: "application/x-portable-text"
    };
  }
};
function createConverterTextHtml(legacySchema) {
  return {
    mimeType: "text/html",
    serialize: ({
      snapshot,
      event
    }) => {
      if (!snapshot.context.selection)
        return {
          type: "serialization.failure",
          mimeType: "text/html",
          originEvent: event.originEvent,
          reason: "No selection"
        };
      const blocks = getSelectedValue(snapshot), html = toHTML(blocks, {
        onMissingComponent: !1,
        components: {
          unknownType: ({
            children
          }) => children !== void 0 ? `${children}` : ""
        }
      });
      return html === "" ? {
        type: "serialization.failure",
        mimeType: "text/html",
        originEvent: event.originEvent,
        reason: "Serialized HTML is empty"
      } : {
        type: "serialization.success",
        data: html,
        mimeType: "text/html",
        originEvent: event.originEvent
      };
    },
    deserialize: ({
      snapshot,
      event
    }) => {
      const parsedBlocks = htmlToBlocks(event.data, legacySchema.portableText, {
        keyGenerator: snapshot.context.keyGenerator,
        unstable_whitespaceOnPasteMode: legacySchema.block.options.unstable_whitespaceOnPasteMode
      }).flatMap((block) => {
        const parsedBlock = parseBlock({
          context: snapshot.context,
          block,
          options: {
            normalize: !1,
            removeUnusedMarkDefs: !0,
            validateFields: !1
          }
        });
        return parsedBlock ? [parsedBlock] : [];
      });
      return parsedBlocks.length === 0 ? {
        type: "deserialization.failure",
        mimeType: "text/html",
        reason: "No blocks deserialized"
      } : {
        type: "deserialization.success",
        data: parsedBlocks,
        mimeType: "text/html"
      };
    }
  };
}
const converterTextMarkdown = {
  mimeType: "text/markdown",
  serialize: ({
    snapshot,
    event
  }) => {
    if (!snapshot.context.selection)
      return {
        type: "serialization.failure",
        mimeType: "text/markdown",
        reason: "No selection",
        originEvent: event.originEvent
      };
    const blocks = getSelectedValue(snapshot);
    return {
      type: "serialization.success",
      data: portableTextToMarkdown(blocks),
      mimeType: "text/markdown",
      originEvent: event.originEvent
    };
  },
  deserialize: ({
    snapshot,
    event
  }) => {
    const parsedBlocks = markdownToPortableText(event.data, {
      keyGenerator: snapshot.context.keyGenerator,
      schema: snapshot.context.schema
    }).flatMap((block) => {
      const parsedBlock = parseBlock({
        context: snapshot.context,
        block,
        options: {
          normalize: !1,
          removeUnusedMarkDefs: !0,
          validateFields: !1
        }
      });
      return parsedBlock ? [parsedBlock] : [];
    });
    return parsedBlocks.length === 0 ? {
      type: "deserialization.failure",
      mimeType: "text/markdown",
      reason: "No blocks deserialized"
    } : {
      type: "deserialization.success",
      data: parsedBlocks,
      mimeType: "text/markdown"
    };
  }
};
function createConverterTextPlain(legacySchema) {
  return {
    mimeType: "text/plain",
    serialize: ({
      snapshot,
      event
    }) => snapshot.context.selection ? {
      type: "serialization.success",
      data: getSelectedValue(snapshot).map((block) => isTextBlock(snapshot.context, block) ? block.children.map((child) => child._type === snapshot.context.schema.span.name ? child.text : event.originEvent === "drag.dragstart" ? `[${snapshot.context.schema.inlineObjects.find((inlineObjectType) => inlineObjectType.name === child._type)?.title ?? "Object"}]` : "").join("") : event.originEvent === "drag.dragstart" ? `[${snapshot.context.schema.blockObjects.find((blockObjectType) => blockObjectType.name === block._type)?.title ?? "Object"}]` : "").filter((block) => block !== "").join(`

`),
      mimeType: "text/plain",
      originEvent: event.originEvent
    } : {
      type: "serialization.failure",
      mimeType: "text/plain",
      originEvent: event.originEvent,
      reason: "No selection"
    },
    deserialize: ({
      snapshot,
      event
    }) => {
      const textToHtml = `<html><body>${escapeHtml(event.data).split(/\n{2,}/).map((line) => line ? `<p>${line.replace(/(?:\r\n|\r|\n)/g, "<br/>")}</p>` : "<p></p>").join("")}</body></html>`, parsedBlocks = htmlToBlocks(textToHtml, legacySchema.portableText, {
        keyGenerator: snapshot.context.keyGenerator
      }).flatMap((block) => {
        const parsedBlock = parseBlock({
          context: snapshot.context,
          block,
          options: {
            normalize: !1,
            removeUnusedMarkDefs: !0,
            validateFields: !1
          }
        });
        return parsedBlock ? [parsedBlock] : [];
      });
      return parsedBlocks.length === 0 ? {
        type: "deserialization.failure",
        mimeType: "text/plain",
        reason: "No blocks deserialized"
      } : {
        type: "deserialization.success",
        data: parsedBlocks,
        mimeType: "text/plain"
      };
    }
  };
}
const entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;",
  "`": "&#x60;",
  "=": "&#x3D;"
};
function escapeHtml(str) {
  return String(str).replace(/[&<>"'`=/]/g, (s) => entityMap[s]);
}
function createCoreConverters(legacySchema) {
  return [converterJson, converterPortableText, converterTextMarkdown, createConverterTextHtml(legacySchema), createConverterTextPlain(legacySchema)];
}
function compileType(rawType) {
  return Schema.compile({
    name: "blockTypeSchema",
    types: [rawType]
  }).get(rawType.name);
}
function createEditableAPI(editor, editorActor) {
  const types = editorActor.getSnapshot().context.schema;
  return {
    focus: () => {
      editorActor.send({
        type: "focus",
        editor
      });
    },
    blur: () => {
      editorActor.send({
        type: "blur",
        editor
      });
    },
    toggleMark: (mark) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "decorator.toggle",
          decorator: mark
        },
        editor
      });
    },
    toggleList: (listItem) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "list item.toggle",
          listItem
        },
        editor
      });
    },
    toggleBlockStyle: (style) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "style.toggle",
          style
        },
        editor
      });
    },
    isMarkActive: (mark) => {
      const snapshot = getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: editor
      });
      return getActiveDecorators(snapshot).includes(mark);
    },
    marks: () => {
      const snapshot = getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: editor
      }), activeAnnotations = getActiveAnnotationsMarks(snapshot), activeDecorators = getActiveDecorators(snapshot);
      return [...activeAnnotations, ...activeDecorators];
    },
    undo: () => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.undo"
        },
        editor
      });
    },
    redo: () => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.redo"
        },
        editor
      });
    },
    select: (selection) => {
      const slateSelection = toSlateRange({
        context: {
          schema: editorActor.getSnapshot().context.schema,
          value: editor.value,
          selection
        },
        blockIndexMap: editor.blockIndexMap
      });
      slateSelection ? Transforms.select(editor, slateSelection) : Transforms.deselect(editor), editor.onChange();
    },
    focusBlock: () => {
      if (!editor.selection)
        return;
      const focusBlockIndex = editor.selection.focus.path.at(0);
      if (focusBlockIndex !== void 0)
        return editor.value.at(focusBlockIndex);
    },
    focusChild: () => {
      if (!editor.selection)
        return;
      const focusBlockIndex = editor.selection.focus.path.at(0), focusChildIndex = editor.selection.focus.path.at(1), block = focusBlockIndex !== void 0 ? editor.value.at(focusBlockIndex) : void 0;
      if (block && isTextBlock(editorActor.getSnapshot().context, block))
        return focusChildIndex === void 0 ? void 0 : block.children.at(focusChildIndex);
    },
    insertChild: (type, value) => (editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "insert.child",
        child: {
          _type: type.name,
          ...value || {}
        }
      },
      editor
    }), editor.selection ? slateRangeToSelection({
      schema: editorActor.getSnapshot().context.schema,
      editor,
      range: editor.selection
    })?.focus.path ?? [] : []),
    insertBlock: (type, value) => (editorActor.send({
      type: "behavior event",
      behaviorEvent: {
        type: "insert.block",
        block: {
          _type: type.name,
          ...value || {}
        },
        placement: "auto"
      },
      editor
    }), editor.selection ? slateRangeToSelection({
      schema: editorActor.getSnapshot().context.schema,
      editor,
      range: editor.selection
    })?.focus.path ?? [] : []),
    hasBlockStyle: (style) => {
      try {
        return isStyleActive({
          editor,
          style
        });
      } catch {
        return !1;
      }
    },
    hasListStyle: (listItem) => {
      try {
        return isListItemActive({
          editor,
          listItem
        });
      } catch {
        return !1;
      }
    },
    isVoid: (element) => ![types.block.name, types.span.name].includes(element._type),
    findByPath: (path) => {
      const blockKey = getBlockKeyFromSelectionPoint({
        path
      });
      if (!blockKey)
        return [void 0, void 0];
      const blockIndex = editor.blockIndexMap.get(blockKey);
      if (blockIndex === void 0)
        return [void 0, void 0];
      const block = editor.value.at(blockIndex);
      if (!block)
        return [void 0, void 0];
      const childKey = getChildKeyFromSelectionPoint({
        path
      });
      if (path.length === 1 && !childKey)
        return [block, [{
          _key: block._key
        }]];
      if (isTextBlock(editorActor.getSnapshot().context, block) && childKey) {
        const child = block.children.find((child2) => child2._key === childKey);
        if (child)
          return [child, [{
            _key: block._key
          }, "children", {
            _key: child._key
          }]];
      }
      return [void 0, void 0];
    },
    findDOMNode: (element) => {
      let node;
      try {
        const [item] = Array.from(Editor.nodes(editor, {
          at: [],
          match: (n) => n._key === element._key
        }) || [])[0] || [void 0];
        node = ReactEditor.toDOMNode(editor, item);
      } catch {
      }
      return node;
    },
    activeAnnotations: () => {
      if (!editor.selection || editor.selection.focus.path.length < 2)
        return [];
      try {
        const activeAnnotations = [], spans = Editor.nodes(editor, {
          at: editor.selection,
          match: (node) => Text.isText(node) && node.marks !== void 0 && Array.isArray(node.marks) && node.marks.length > 0
        });
        for (const [span, path] of spans) {
          const [block] = Editor.node(editor, path, {
            depth: 1
          });
          editor.isTextBlock(block) && block.markDefs?.forEach((def) => {
            Text.isText(span) && span.marks && Array.isArray(span.marks) && span.marks.includes(def._key) && activeAnnotations.push(def);
          });
        }
        return activeAnnotations;
      } catch {
        return [];
      }
    },
    isAnnotationActive: (annotationType) => {
      const snapshot = getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: editor
      });
      return isActiveAnnotation(annotationType)(snapshot);
    },
    addAnnotation: (type, value) => {
      const snapshotBefore = getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: editor
      }), selectedValueBefore = getSelectedValue(snapshotBefore), focusSpanBefore = getFocusSpan$1(snapshotBefore), markDefsBefore = selectedValueBefore.flatMap((block) => isTextBlock(snapshotBefore.context, block) ? block.markDefs ?? [] : []);
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "annotation.add",
          annotation: {
            name: type.name,
            value: value ?? {}
          }
        },
        editor
      });
      const snapshotAfter = getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: editor
      }), selectedValueAfter = getSelectedValue(snapshotAfter), focusBlockAfter = getFocusBlock$1(snapshotAfter), focusSpanAfter = getFocusSpan$1(snapshotAfter), newMarkDefKeysOnFocusSpan = focusSpanAfter?.node.marks?.filter((mark) => !focusSpanBefore?.node.marks?.includes(mark) && !snapshotAfter.context.schema.decorators.map((decorator) => decorator.name).includes(mark)), markDefs = selectedValueAfter.flatMap((block) => isTextBlock(snapshotAfter.context, block) ? block.markDefs?.map((markDef2) => ({
        markDef: markDef2,
        path: [{
          _key: block._key
        }, "markDefs", {
          _key: markDef2._key
        }]
      })) ?? [] : []).filter((markDef2) => !markDefsBefore.some((markDefBefore) => markDefBefore._key === markDef2.markDef._key)), spanPath = focusSpanAfter?.path, markDef = markDefs.find((markDef2) => newMarkDefKeysOnFocusSpan?.some((mark) => mark === markDef2.markDef._key));
      if (focusBlockAfter && spanPath && markDef)
        return {
          markDefPath: markDef.path,
          markDefPaths: markDefs.map((markDef2) => markDef2.path),
          spanPath
        };
    },
    delete: (selection, options) => {
      selection && editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "delete",
          at: selection,
          unit: options?.mode === "blocks" ? "block" : options?.mode === "children" ? "child" : void 0
        },
        editor
      });
    },
    removeAnnotation: (type) => {
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "annotation.remove",
          annotation: {
            name: type.name
          }
        },
        editor
      });
    },
    getSelection: () => {
      if (!editor.selection)
        return null;
      if (editor.selection === editor.lastSlateSelection)
        return editor.lastSelection;
      const selection = slateRangeToSelection({
        schema: editorActor.getSnapshot().context.schema,
        editor,
        range: editor.selection
      });
      return editor.lastSlateSelection = editor.selection, editor.lastSelection = selection, selection;
    },
    getValue: () => editor.value,
    isCollapsedSelection: () => !!editor.selection && Range.isCollapsed(editor.selection),
    isExpandedSelection: () => !!editor.selection && Range.isExpanded(editor.selection),
    insertBreak: () => {
      editor.insertBreak(), editor.onChange();
    },
    getFragment: () => {
      const snapshot = getEditorSnapshot({
        editorActorSnapshot: editorActor.getSnapshot(),
        slateEditorInstance: editor
      });
      return getSelectedValue(snapshot);
    },
    isSelectionsOverlapping: (selectionA, selectionB) => {
      const rangeA = toSlateRange({
        context: {
          schema: editorActor.getSnapshot().context.schema,
          value: editor.value,
          selection: selectionA
        },
        blockIndexMap: editor.blockIndexMap
      }), rangeB = toSlateRange({
        context: {
          schema: editorActor.getSnapshot().context.schema,
          value: editor.value,
          selection: selectionB
        },
        blockIndexMap: editor.blockIndexMap
      });
      return Range.isRange(rangeA) && Range.isRange(rangeB) && Range.includes(rangeA, rangeB);
    }
  };
}
const levelIndexMaps = /* @__PURE__ */ new Map();
function buildIndexMaps(context, {
  blockIndexMap,
  listIndexMap
}) {
  blockIndexMap.clear(), listIndexMap.clear(), levelIndexMaps.clear();
  let previousListItem;
  for (let blockIndex = 0; blockIndex < context.value.length; blockIndex++) {
    const block = context.value.at(blockIndex);
    if (block === void 0)
      continue;
    if (blockIndexMap.set(block._key, blockIndex), !isTextBlock(context, block)) {
      levelIndexMaps.clear(), previousListItem = void 0;
      continue;
    }
    if (block.listItem === void 0 || block.level === void 0) {
      levelIndexMaps.clear(), previousListItem = void 0;
      continue;
    }
    if (!previousListItem) {
      const levelIndexMap2 = levelIndexMaps.get(block.listItem) ?? /* @__PURE__ */ new Map();
      levelIndexMap2.set(block.level, 1), levelIndexMaps.set(block.listItem, levelIndexMap2), listIndexMap.set(block._key, 1), previousListItem = {
        listItem: block.listItem,
        level: block.level
      };
      continue;
    }
    if (previousListItem.listItem === block.listItem && previousListItem.level < block.level) {
      const levelIndexMap2 = levelIndexMaps.get(block.listItem) ?? /* @__PURE__ */ new Map();
      levelIndexMap2.set(block.level, 1), levelIndexMaps.set(block.listItem, levelIndexMap2), listIndexMap.set(block._key, 1), previousListItem = {
        listItem: block.listItem,
        level: block.level
      };
      continue;
    }
    levelIndexMaps.forEach((levelIndexMap2, listItem) => {
      if (listItem === block.listItem)
        return;
      const levelsToDelete = [];
      levelIndexMap2.forEach((_, level) => {
        level >= block.level && levelsToDelete.push(level);
      }), levelsToDelete.forEach((level) => {
        levelIndexMap2.delete(level);
      });
    });
    const levelIndexMap = levelIndexMaps.get(block.listItem) ?? /* @__PURE__ */ new Map(), levelCounter = levelIndexMap.get(block.level) ?? 0;
    levelIndexMap.set(block.level, levelCounter + 1), levelIndexMaps.set(block.listItem, levelIndexMap), listIndexMap.set(block._key, levelCounter + 1), previousListItem = {
      listItem: block.listItem,
      level: block.level
    };
  }
}
function createPlaceholderBlock(context) {
  return {
    _type: context.schema.block.name,
    _key: context.keyGenerator(),
    style: context.schema.styles[0].name ?? "normal",
    markDefs: [],
    children: [{
      _type: context.schema.span.name,
      _key: context.keyGenerator(),
      text: "",
      marks: []
    }]
  };
}
function createWithEventListeners(editorActor) {
  return function(editor) {
    const {
      delete: editorDelete,
      insertNodes,
      select,
      setSelection
    } = editor;
    return editor.delete = (options) => {
      if (editor.isPerformingBehaviorOperation) {
        editorDelete(options);
        return;
      }
      const range = options?.at ? Editor.range(editor, options.at) : void 0, selection = range ? slateRangeToSelection({
        schema: editorActor.getSnapshot().context.schema,
        editor,
        range
      }) : void 0;
      selection ? editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "delete",
          at: selection,
          direction: options?.reverse ? "backward" : "forward",
          unit: options?.unit
        },
        editor
      }) : editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "delete",
          direction: options?.reverse ? "backward" : "forward",
          unit: options?.unit
        },
        editor
      });
    }, editor.deleteBackward = (unit) => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .deleteBackward(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "delete.backward",
          unit
        },
        editor
      });
    }, editor.deleteForward = (unit) => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .deleteForward(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "delete.forward",
          unit
        },
        editor
      });
    }, editor.insertBreak = () => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .insertBreak(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "insert.break"
        },
        editor
      });
    }, editor.insertData = (dataTransfer) => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .insertData(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "input.*",
          originEvent: {
            dataTransfer
          }
        },
        editor
      });
    }, editor.insertNodes = (nodes, options) => {
      if (editor.isNormalizingNode) {
        const normalizedNodes = (Node.isNode(nodes) ? [nodes] : nodes).map((node) => Text.isText(node) && typeof node._type != "string" ? {
          ...node,
          _type: editorActor.getSnapshot().context.schema.span.name
        } : node);
        insertNodes(normalizedNodes, options);
        return;
      }
      insertNodes(nodes, options);
    }, editor.insertSoftBreak = () => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .insertSoftBreak(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "insert.soft break"
        },
        editor
      });
    }, editor.insertText = (text) => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .insertText(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "insert.text",
          text
        },
        editor
      });
    }, editor.redo = () => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .redo(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.redo"
        },
        editor
      });
    }, editor.select = (location) => {
      if (editor.isPerformingBehaviorOperation) {
        select(location);
        return;
      }
      if (editor.selection) {
        select(location);
        return;
      }
      const range = Editor.range(editor, location);
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "select",
          at: slateRangeToSelection({
            schema: editorActor.getSnapshot().context.schema,
            editor,
            range
          })
        },
        editor
      });
    }, editor.setSelection = (partialRange) => {
      if (editor.isPerformingBehaviorOperation) {
        setSelection(partialRange);
        return;
      }
      const anchor = partialRange.anchor ? slatePointToSelectionPoint({
        schema: editorActor.getSnapshot().context.schema,
        editor,
        point: partialRange.anchor
      }) : void 0, focus = partialRange.focus ? slatePointToSelectionPoint({
        schema: editorActor.getSnapshot().context.schema,
        editor,
        point: partialRange.focus
      }) : void 0, backward = editor.selection ? Range.isBackward({
        anchor: partialRange.anchor ?? editor.selection.anchor,
        focus: partialRange.focus ?? editor.selection.focus
      }) : partialRange.anchor && partialRange.focus ? Range.isBackward({
        anchor: partialRange.anchor,
        focus: partialRange.focus
      }) : void 0;
      if (editor.selection) {
        const newAnchor = partialRange.anchor ?? editor.selection.anchor, newFocus = partialRange.focus ?? editor.selection.focus;
        if (Point.equals(newAnchor, editor.selection.anchor) && Point.equals(newFocus, editor.selection.focus)) {
          setSelection(partialRange);
          return;
        }
      }
      if (!anchor || !focus) {
        setSelection(partialRange);
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "select",
          at: {
            anchor,
            focus,
            backward
          }
        },
        editor
      });
    }, editor.setFragmentData = () => {
      console.error("Unexpected call to .setFragmentData(...)");
    }, editor.undo = () => {
      if (editor.isPerformingBehaviorOperation) {
        console.error("Unexpected call to .undo(...)");
        return;
      }
      editorActor.send({
        type: "behavior event",
        behaviorEvent: {
          type: "history.undo"
        },
        editor
      });
    }, editor;
  };
}
function createUndoSteps({
  steps,
  op,
  editor,
  currentUndoStepId,
  previousUndoStepId
}) {
  const lastStep = steps.at(-1);
  if (!lastStep)
    return createNewStep(steps, op, editor);
  if (editor.operations.length > 0)
    return currentUndoStepId === previousUndoStepId || editor.isNormalizingNode ? mergeIntoLastStep(steps, lastStep, op) : createNewStep(steps, op, editor);
  if (op.type === "set_selection" && currentUndoStepId === void 0 && previousUndoStepId !== void 0 || op.type === "set_selection" && currentUndoStepId !== void 0 && previousUndoStepId !== void 0 && previousUndoStepId !== currentUndoStepId)
    return mergeIntoLastStep(steps, lastStep, op);
  if (currentUndoStepId === void 0 && previousUndoStepId === void 0) {
    if (op.type === "set_selection")
      return mergeIntoLastStep(steps, lastStep, op);
    const lastOp = lastStep.operations.at(-1);
    return lastOp && op.type === "insert_text" && lastOp.type === "insert_text" && op.offset === lastOp.offset + lastOp.text.length && Path.equals(op.path, lastOp.path) && op.text !== " " || lastOp && op.type === "remove_text" && lastOp.type === "remove_text" && op.offset + op.text.length === lastOp.offset && Path.equals(op.path, lastOp.path) ? mergeIntoLastStep(steps, lastStep, op) : createNewStep(steps, op, editor);
  }
  return createNewStep(steps, op, editor);
}
function createNewStep(steps, op, editor) {
  const operations = editor.selection === null ? [op] : [{
    type: "set_selection",
    properties: {
      ...editor.selection
    },
    newProperties: {
      ...editor.selection
    }
  }, op];
  return [...steps, {
    operations,
    timestamp: /* @__PURE__ */ new Date()
  }];
}
function mergeIntoLastStep(steps, lastStep, op) {
  return [...steps.slice(0, -1), {
    timestamp: lastStep.timestamp,
    operations: [...lastStep.operations, op]
  }];
}
const debug$a = debugWithName("plugin:history"), UNDO_STEP_LIMIT = 1e3;
function pluginHistory({
  editorActor,
  subscriptions
}) {
  return (editor) => {
    let previousSnapshot = editor.value, previousUndoStepId = editor.undoStepId;
    subscriptions.push(() => {
      const subscription = editorActor.on("patches", ({
        patches,
        snapshot
      }) => {
        let reset = !1;
        for (const patch of patches)
          if (!reset && patch.origin !== "local") {
            if (patch.type === "unset" && patch.path.length === 0) {
              debug$a("Someone else cleared the content, resetting undo/redo history"), editor.history = {
                undos: [],
                redos: []
              }, editor.remotePatches.splice(0, editor.remotePatches.length), editor.withHistory = !0, reset = !0;
              return;
            }
            editor.remotePatches.push({
              patch,
              time: /* @__PURE__ */ new Date(),
              snapshot,
              previousSnapshot
            });
          }
        previousSnapshot = snapshot;
      });
      return () => {
        subscription.unsubscribe();
      };
    });
    const {
      apply: apply2
    } = editor;
    return editor.apply = (op) => {
      if (editorActor.getSnapshot().matches({
        "edit mode": "read only"
      })) {
        apply2(op);
        return;
      }
      if (editor.isProcessingRemoteChanges) {
        apply2(op);
        return;
      }
      if (editor.isUndoing || editor.isRedoing) {
        apply2(op);
        return;
      }
      const withHistory = editor.withHistory, currentUndoStepId = editor.undoStepId;
      if (!withHistory) {
        previousUndoStepId = currentUndoStepId, apply2(op);
        return;
      }
      for (op.type !== "set_selection" && (editor.history.redos = []), editor.history.undos = createUndoSteps({
        steps: editor.history.undos,
        op,
        editor,
        currentUndoStepId,
        previousUndoStepId
      }); editor.history.undos.length > UNDO_STEP_LIMIT; )
        editor.history.undos.shift();
      previousUndoStepId = currentUndoStepId, apply2(op);
    }, editor;
  };
}
function withNormalizeNode(editor, fn) {
  const prev = editor.isNormalizingNode;
  editor.isNormalizingNode = !0, fn(), editor.isNormalizingNode = prev;
}
function withoutPatching(editor, fn) {
  const prev = editor.isPatching;
  editor.isPatching = !1, fn(), editor.isPatching = prev;
}
const debug$9 = debugWithName("plugin:withPortableTextMarkModel");
function createWithNormalize(editorActor) {
  return function(editor) {
    const {
      apply: apply2,
      normalizeNode
    } = editor, defaultStyle = editorActor.getSnapshot().context.schema.styles.at(0)?.name;
    return editor.normalizeNode = (nodeEntry) => {
      const [node, path] = nodeEntry;
      if (Editor.isEditor(node) && node.children.length === 0 && withoutPatching(editor, () => {
        withNormalizeNode(editor, () => {
          Transforms.insertNodes(editor, createPlaceholderBlock(editorActor.getSnapshot().context), {
            at: [0],
            select: !0
          });
        });
      }), editor.isTextBlock(node)) {
        const children = Node.children(editor, path);
        for (const [child, childPath] of children) {
          const nextNode = node.children[childPath[1] + 1];
          if (editor.isTextSpan(child) && editor.isTextSpan(nextNode) && child.marks?.every((mark) => nextNode.marks?.includes(mark)) && nextNode.marks?.every((mark) => child.marks?.includes(mark))) {
            debug$9("Merging spans", JSON.stringify(child, null, 2), JSON.stringify(nextNode, null, 2)), withNormalizeNode(editor, () => {
              Transforms.mergeNodes(editor, {
                at: [childPath[0], childPath[1] + 1],
                voids: !0
              });
            });
            return;
          }
        }
      }
      if (editor.isTextBlock(node) && !Array.isArray(node.markDefs)) {
        debug$9("Adding .markDefs to block node"), withNormalizeNode(editor, () => {
          Transforms.setNodes(editor, {
            markDefs: []
          }, {
            at: path
          });
        });
        return;
      }
      if (defaultStyle && editor.isTextBlock(node) && typeof node.style > "u") {
        debug$9("Adding .style to block node"), withNormalizeNode(editor, () => {
          Transforms.setNodes(editor, {
            style: defaultStyle
          }, {
            at: path
          });
        });
        return;
      }
      if (editor.isTextSpan(node) && !Array.isArray(node.marks)) {
        debug$9("Adding .marks to span node"), withNormalizeNode(editor, () => {
          Transforms.setNodes(editor, {
            marks: []
          }, {
            at: path
          });
        });
        return;
      }
      if (editor.isTextSpan(node)) {
        const blockPath = Path.parent(path), [block] = Editor.node(editor, blockPath), decorators = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), annotations = node.marks?.filter((mark) => !decorators.includes(mark));
        if (editor.isTextBlock(block) && node.text === "" && annotations && annotations.length > 0) {
          debug$9("Removing annotations from empty span node"), withNormalizeNode(editor, () => {
            Transforms.setNodes(editor, {
              marks: node.marks?.filter((mark) => decorators.includes(mark))
            }, {
              at: path
            });
          });
          return;
        }
      }
      if (editor.isTextBlock(node)) {
        const decorators = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name);
        for (const [child, childPath] of Node.children(editor, path))
          if (editor.isTextSpan(child)) {
            const marks = child.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators.includes(mark) && !node.markDefs?.find((def) => def._key === mark));
            if (orphanedAnnotations.length > 0) {
              debug$9("Removing orphaned annotations from span node"), withNormalizeNode(editor, () => {
                Transforms.setNodes(editor, {
                  marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))
                }, {
                  at: childPath
                });
              });
              return;
            }
          }
      }
      if (editor.isTextSpan(node)) {
        const blockPath = Path.parent(path), [block] = Editor.node(editor, blockPath);
        if (editor.isTextBlock(block)) {
          const decorators = editorActor.getSnapshot().context.schema.decorators.map((decorator) => decorator.name), marks = node.marks ?? [], orphanedAnnotations = marks.filter((mark) => !decorators.includes(mark) && !block.markDefs?.find((def) => def._key === mark));
          if (orphanedAnnotations.length > 0) {
            debug$9("Removing orphaned annotations from span node"), withNormalizeNode(editor, () => {
              Transforms.setNodes(editor, {
                marks: marks.filter((mark) => !orphanedAnnotations.includes(mark))
              }, {
                at: path
              });
            });
            return;
          }
        }
      }
      if (editor.isTextBlock(node)) {
        const markDefs = node.markDefs ?? [], markDefKeys = /* @__PURE__ */ new Set(), newMarkDefs = [];
        for (const markDef of markDefs)
          markDefKeys.has(markDef._key) || (markDefKeys.add(markDef._key), newMarkDefs.push(markDef));
        if (markDefs.length !== newMarkDefs.length) {
          debug$9("Removing duplicate markDefs"), withNormalizeNode(editor, () => {
            Transforms.setNodes(editor, {
              markDefs: newMarkDefs
            }, {
              at: path
            });
          });
          return;
        }
      }
      if (editor.isTextBlock(node) && !editor.operations.some((op) => op.type === "merge_node" && "markDefs" in op.properties && op.path.length === 1)) {
        const newMarkDefs = (node.markDefs || []).filter((def) => node.children.find((child) => Text.isText(child) && Array.isArray(child.marks) && child.marks.includes(def._key)));
        if (node.markDefs && !isEqualMarkDefs(newMarkDefs, node.markDefs)) {
          debug$9("Removing markDef not in use"), withNormalizeNode(editor, () => {
            Transforms.setNodes(editor, {
              markDefs: newMarkDefs
            }, {
              at: path
            });
          });
          return;
        }
      }
      withNormalizeNode(editor, () => {
        normalizeNode(nodeEntry);
      });
    }, editor.apply = (op) => {
      if (editor.isProcessingRemoteChanges) {
        apply2(op);
        return;
      }
      if (editor.isUndoing || editor.isRedoing) {
        apply2(op);
        return;
      }
      if (op.type === "set_selection")
        if (op.properties && op.newProperties && op.properties.anchor && op.properties.focus && op.newProperties.anchor && op.newProperties.focus) {
          const previousSelectionIsCollapsed = Range.isCollapsed({
            anchor: op.properties.anchor,
            focus: op.properties.focus
          }), newSelectionIsCollapsed = Range.isCollapsed({
            anchor: op.newProperties.anchor,
            focus: op.newProperties.focus
          });
          if (previousSelectionIsCollapsed && newSelectionIsCollapsed) {
            const focusSpan = Array.from(Editor.nodes(editor, {
              mode: "lowest",
              at: op.properties.focus,
              match: (n) => editor.isTextSpan(n),
              voids: !1
            }))[0]?.[0], newFocusSpan = Array.from(Editor.nodes(editor, {
              mode: "lowest",
              at: op.newProperties.focus,
              match: (n) => editor.isTextSpan(n),
              voids: !1
            }))[0]?.[0], movedToNextSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] + 1 && focusSpan.text.length === op.properties.focus.offset && op.newProperties.focus.offset === 0, movedToPreviousSpan = focusSpan && newFocusSpan && op.newProperties.focus.path[0] === op.properties.focus.path[0] && op.newProperties.focus.path[1] === op.properties.focus.path[1] - 1 && op.properties.focus.offset === 0 && newFocusSpan.text.length === op.newProperties.focus.offset;
            !movedToNextSpan && !movedToPreviousSpan && (editor.decoratorState = {});
          }
        } else
          editor.decoratorState = {};
      if (op.type === "merge_node" && op.path.length === 1 && "markDefs" in op.properties && op.properties._type === editorActor.getSnapshot().context.schema.block.name && Array.isArray(op.properties.markDefs) && op.properties.markDefs.length > 0 && op.path[0] - 1 >= 0) {
        const [targetBlock, targetPath] = Editor.node(editor, [op.path[0] - 1]);
        if (editor.isTextBlock(targetBlock)) {
          const oldDefs = Array.isArray(targetBlock.markDefs) && targetBlock.markDefs || [], newMarkDefs = [...new Map([...oldDefs, ...op.properties.markDefs].map((def) => [def._key, def])).values()];
          debug$9("Copying markDefs over to merged block", op), Transforms.setNodes(editor, {
            markDefs: newMarkDefs
          }, {
            at: targetPath,
            voids: !1
          }), apply2(op);
          return;
        }
      }
      apply2(op);
    }, editor;
  };
}
function createWithObjectKeys(editorActor) {
  return function(editor) {
    const {
      apply: apply2,
      normalizeNode
    } = editor;
    return editor.apply = (operation) => {
      if (editor.isProcessingRemoteChanges) {
        apply2(operation);
        return;
      }
      if (editor.isUndoing || editor.isRedoing) {
        apply2(operation);
        return;
      }
      if (operation.type === "split_node") {
        const existingKeys = [...Node.descendants(editor)].map(([node]) => node._key);
        apply2({
          ...operation,
          properties: {
            ...operation.properties,
            _key: operation.properties._key === void 0 || existingKeys.includes(operation.properties._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.properties._key
          }
        });
        return;
      }
      if (operation.type === "insert_node" && !Editor.isEditor(operation.node)) {
        const existingKeys = [...Node.descendants(editor)].map(([node]) => node._key);
        apply2({
          ...operation,
          node: {
            ...operation.node,
            _key: operation.node._key === void 0 || existingKeys.includes(operation.node._key) ? editorActor.getSnapshot().context.keyGenerator() : operation.node._key
          }
        });
        return;
      }
      if (operation.type === "merge_node") {
        const index = operation.path[operation.path.length - 1], prevPath = Path.previous(operation.path), prevIndex = prevPath[prevPath.length - 1];
        if (operation.path.length !== 1 || prevPath.length !== 1) {
          apply2(operation);
          return;
        }
        const block = editor.value.at(index), previousBlock = editor.value.at(prevIndex);
        if (!block || !previousBlock) {
          apply2(operation);
          return;
        }
        if (!isTextBlock(editorActor.getSnapshot().context, block) || !isTextBlock(editorActor.getSnapshot().context, previousBlock)) {
          apply2(operation);
          return;
        }
        const previousBlockChildKeys = previousBlock.children.map((child) => child._key), previousBlockMarkDefKeys = previousBlock.markDefs?.map((markDef) => markDef._key) ?? [], markDefKeyMap = /* @__PURE__ */ new Map(), adjustedMarkDefs = block.markDefs?.map((markDef) => {
          if (previousBlockMarkDefKeys.includes(markDef._key)) {
            const newKey = editorActor.getSnapshot().context.keyGenerator();
            return markDefKeyMap.set(markDef._key, newKey), {
              ...markDef,
              _key: newKey
            };
          }
          return markDef;
        });
        let childIndex = 0;
        for (const child of block.children) {
          if (isSpan(editorActor.getSnapshot().context, child)) {
            const marks = child.marks?.map((mark) => markDefKeyMap.get(mark) || mark) ?? [];
            isEqualMarks(child.marks, marks) || Transforms.setNodes(editor, {
              marks
            }, {
              at: [index, childIndex]
            });
          }
          previousBlockChildKeys.includes(child._key) && Transforms.setNodes(editor, {
            _key: editorActor.getSnapshot().context.keyGenerator()
          }, {
            at: [index, childIndex]
          }), childIndex++;
        }
        apply2({
          ...operation,
          properties: {
            ...operation.properties,
            // Make sure the adjusted markDefs are carried along for the merge
            // operation
            markDefs: adjustedMarkDefs
          }
        });
        return;
      }
      apply2(operation);
    }, editor.normalizeNode = (entry) => {
      const [node, path] = entry;
      if (Element$1.isElement(node)) {
        const [parent] = Editor.parent(editor, path);
        if (parent && Editor.isEditor(parent)) {
          const blockKeys = /* @__PURE__ */ new Set();
          for (const sibling of parent.children) {
            if (sibling._key && blockKeys.has(sibling._key)) {
              const _key = editorActor.getSnapshot().context.keyGenerator();
              blockKeys.add(_key), withNormalizeNode(editor, () => {
                Transforms.setNodes(editor, {
                  _key
                }, {
                  at: path
                });
              });
              return;
            }
            if (!sibling._key) {
              const _key = editorActor.getSnapshot().context.keyGenerator();
              blockKeys.add(_key), withNormalizeNode(editor, () => {
                Transforms.setNodes(editor, {
                  _key
                }, {
                  at: path
                });
              });
              return;
            }
            blockKeys.add(sibling._key);
          }
        }
      }
      if (Element$1.isElement(node) && node._type === editorActor.getSnapshot().context.schema.block.name) {
        if (!node._key) {
          withNormalizeNode(editor, () => {
            Transforms.setNodes(editor, {
              _key: editorActor.getSnapshot().context.keyGenerator()
            }, {
              at: path
            });
          });
          return;
        }
        const childKeys = /* @__PURE__ */ new Set();
        for (const [child, childPath] of Node.children(editor, path)) {
          if (child._key && childKeys.has(child._key)) {
            const _key = editorActor.getSnapshot().context.keyGenerator();
            childKeys.add(_key), withNormalizeNode(editor, () => {
              Transforms.setNodes(editor, {
                _key
              }, {
                at: childPath
              });
            });
            return;
          }
          if (!child._key) {
            const _key = editorActor.getSnapshot().context.keyGenerator();
            childKeys.add(_key), withNormalizeNode(editor, () => {
              Transforms.setNodes(editor, {
                _key
              }, {
                at: childPath
              });
            });
            return;
          }
          childKeys.add(child._key);
        }
      }
      withNormalizeNode(editor, () => {
        normalizeNode(entry);
      });
    }, editor;
  };
}
function cloneDiff(diff2) {
  const [type, patch] = diff2;
  return [type, patch];
}
function getCommonOverlap(textA, textB) {
  let text1 = textA, text2 = textB;
  const text1Length = text1.length, text2Length = text2.length;
  if (text1Length === 0 || text2Length === 0) return 0;
  text1Length > text2Length ? text1 = text1.substring(text1Length - text2Length) : text1Length < text2Length && (text2 = text2.substring(0, text1Length));
  const textLength = Math.min(text1Length, text2Length);
  if (text1 === text2) return textLength;
  let best = 0, length = 1;
  for (let found = 0; found !== -1; ) {
    const pattern = text1.substring(textLength - length);
    if (found = text2.indexOf(pattern), found === -1) return best;
    length += found, (found === 0 || text1.substring(textLength - length) === text2.substring(0, length)) && (best = length, length++);
  }
  return best;
}
function getCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1[0] !== text2[0]) return 0;
  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerStart = 0;
  for (; pointerMin < pointerMid; ) text1.substring(pointerStart, pointerMid) === text2.substring(pointerStart, pointerMid) ? (pointerMin = pointerMid, pointerStart = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  return pointerMid;
}
function getCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1[text1.length - 1] !== text2[text2.length - 1]) return 0;
  let pointerMin = 0, pointerMax = Math.min(text1.length, text2.length), pointerMid = pointerMax, pointerEnd = 0;
  for (; pointerMin < pointerMid; ) text1.substring(text1.length - pointerMid, text1.length - pointerEnd) === text2.substring(text2.length - pointerMid, text2.length - pointerEnd) ? (pointerMin = pointerMid, pointerEnd = pointerMin) : pointerMax = pointerMid, pointerMid = Math.floor((pointerMax - pointerMin) / 2 + pointerMin);
  return pointerMid;
}
function isHighSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 55296 && charCode <= 56319;
}
function isLowSurrogate(char) {
  const charCode = char.charCodeAt(0);
  return charCode >= 56320 && charCode <= 57343;
}
function bisect(text1, text2, deadline) {
  const text1Length = text1.length, text2Length = text2.length, maxD = Math.ceil((text1Length + text2Length) / 2), vOffset = maxD, vLength = 2 * maxD, v1 = new Array(vLength), v2 = new Array(vLength);
  for (let x = 0; x < vLength; x++) v1[x] = -1, v2[x] = -1;
  v1[vOffset + 1] = 0, v2[vOffset + 1] = 0;
  const delta = text1Length - text2Length, front = delta % 2 !== 0;
  let k1start = 0, k1end = 0, k2start = 0, k2end = 0;
  for (let d = 0; d < maxD && !(Date.now() > deadline); d++) {
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1Offset = vOffset + k1;
      let x1;
      k1 === -d || k1 !== d && v1[k1Offset - 1] < v1[k1Offset + 1] ? x1 = v1[k1Offset + 1] : x1 = v1[k1Offset - 1] + 1;
      let y1 = x1 - k1;
      for (; x1 < text1Length && y1 < text2Length && text1.charAt(x1) === text2.charAt(y1); ) x1++, y1++;
      if (v1[k1Offset] = x1, x1 > text1Length) k1end += 2;
      else if (y1 > text2Length) k1start += 2;
      else if (front) {
        const k2Offset = vOffset + delta - k1;
        if (k2Offset >= 0 && k2Offset < vLength && v2[k2Offset] !== -1) {
          const x2 = text1Length - v2[k2Offset];
          if (x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2Offset = vOffset + k2;
      let x2;
      k2 === -d || k2 !== d && v2[k2Offset - 1] < v2[k2Offset + 1] ? x2 = v2[k2Offset + 1] : x2 = v2[k2Offset - 1] + 1;
      let y2 = x2 - k2;
      for (; x2 < text1Length && y2 < text2Length && text1.charAt(text1Length - x2 - 1) === text2.charAt(text2Length - y2 - 1); ) x2++, y2++;
      if (v2[k2Offset] = x2, x2 > text1Length) k2end += 2;
      else if (y2 > text2Length) k2start += 2;
      else if (!front) {
        const k1Offset = vOffset + delta - k2;
        if (k1Offset >= 0 && k1Offset < vLength && v1[k1Offset] !== -1) {
          const x1 = v1[k1Offset], y1 = vOffset + x1 - k1Offset;
          if (x2 = text1Length - x2, x1 >= x2) return bisectSplit(text1, text2, x1, y1, deadline);
        }
      }
    }
  }
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
}
function bisectSplit(text1, text2, x, y, deadline) {
  const text1a = text1.substring(0, x), text2a = text2.substring(0, y), text1b = text1.substring(x), text2b = text2.substring(y), diffs = doDiff(text1a, text2a, {
    checkLines: !1,
    deadline
  }), diffsb = doDiff(text1b, text2b, {
    checkLines: !1,
    deadline
  });
  return diffs.concat(diffsb);
}
function findHalfMatch(text1, text2, timeout = 1) {
  if (timeout <= 0) return null;
  const longText = text1.length > text2.length ? text1 : text2, shortText = text1.length > text2.length ? text2 : text1;
  if (longText.length < 4 || shortText.length * 2 < longText.length) return null;
  const halfMatch1 = halfMatchI(longText, shortText, Math.ceil(longText.length / 4)), halfMatch2 = halfMatchI(longText, shortText, Math.ceil(longText.length / 2));
  let halfMatch;
  if (halfMatch1 && halfMatch2) halfMatch = halfMatch1[4].length > halfMatch2[4].length ? halfMatch1 : halfMatch2;
  else {
    if (!halfMatch1 && !halfMatch2) return null;
    halfMatch2 ? halfMatch1 || (halfMatch = halfMatch2) : halfMatch = halfMatch1;
  }
  if (!halfMatch) throw new Error("Unable to find a half match.");
  let text1A, text1B, text2A, text2B;
  text1.length > text2.length ? (text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3]) : (text2A = halfMatch[0], text2B = halfMatch[1], text1A = halfMatch[2], text1B = halfMatch[3]);
  const midCommon = halfMatch[4];
  return [text1A, text1B, text2A, text2B, midCommon];
}
function halfMatchI(longText, shortText, i) {
  const seed = longText.slice(i, i + Math.floor(longText.length / 4));
  let j = -1, bestCommon = "", bestLongTextA, bestLongTextB, bestShortTextA, bestShortTextB;
  for (; (j = shortText.indexOf(seed, j + 1)) !== -1; ) {
    const prefixLength = getCommonPrefix(longText.slice(i), shortText.slice(j)), suffixLength = getCommonSuffix(longText.slice(0, i), shortText.slice(0, j));
    bestCommon.length < suffixLength + prefixLength && (bestCommon = shortText.slice(j - suffixLength, j) + shortText.slice(j, j + prefixLength), bestLongTextA = longText.slice(0, i - suffixLength), bestLongTextB = longText.slice(i + prefixLength), bestShortTextA = shortText.slice(0, j - suffixLength), bestShortTextB = shortText.slice(j + prefixLength));
  }
  return bestCommon.length * 2 >= longText.length ? [bestLongTextA || "", bestLongTextB || "", bestShortTextA || "", bestShortTextB || "", bestCommon || ""] : null;
}
function charsToLines(diffs, lineArray) {
  for (let x = 0; x < diffs.length; x++) {
    const chars = diffs[x][1], text = [];
    for (let y = 0; y < chars.length; y++) text[y] = lineArray[chars.charCodeAt(y)];
    diffs[x][1] = text.join("");
  }
}
function linesToChars(textA, textB) {
  const lineArray = [], lineHash = {};
  lineArray[0] = "";
  function diffLinesToMunge(text) {
    let chars = "", lineStart = 0, lineEnd = -1, lineArrayLength = lineArray.length;
    for (; lineEnd < text.length - 1; ) {
      lineEnd = text.indexOf(`
`, lineStart), lineEnd === -1 && (lineEnd = text.length - 1);
      let line = text.slice(lineStart, lineEnd + 1);
      (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) ? chars += String.fromCharCode(lineHash[line]) : (lineArrayLength === maxLines && (line = text.slice(lineStart), lineEnd = text.length), chars += String.fromCharCode(lineArrayLength), lineHash[line] = lineArrayLength, lineArray[lineArrayLength++] = line), lineStart = lineEnd + 1;
    }
    return chars;
  }
  let maxLines = 4e4;
  const chars1 = diffLinesToMunge(textA);
  maxLines = 65535;
  const chars2 = diffLinesToMunge(textB);
  return {
    chars1,
    chars2,
    lineArray
  };
}
function doLineModeDiff(textA, textB, opts) {
  let text1 = textA, text2 = textB;
  const a = linesToChars(text1, text2);
  text1 = a.chars1, text2 = a.chars2;
  const linearray = a.lineArray;
  let diffs = doDiff(text1, text2, {
    checkLines: !1,
    deadline: opts.deadline
  });
  charsToLines(diffs, linearray), diffs = cleanupSemantic(diffs), diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "";
  for (; pointer < diffs.length; ) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        countInsert++, textInsert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        countDelete++, textDelete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (countDelete >= 1 && countInsert >= 1) {
          diffs.splice(pointer - countDelete - countInsert, countDelete + countInsert), pointer = pointer - countDelete - countInsert;
          const aa = doDiff(textDelete, textInsert, {
            checkLines: !1,
            deadline: opts.deadline
          });
          for (let j = aa.length - 1; j >= 0; j--) diffs.splice(pointer, 0, aa[j]);
          pointer += aa.length;
        }
        countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
    pointer++;
  }
  return diffs.pop(), diffs;
}
function computeDiff(text1, text2, opts) {
  let diffs;
  if (!text1) return [[DIFF_INSERT, text2]];
  if (!text2) return [[DIFF_DELETE, text1]];
  const longtext = text1.length > text2.length ? text1 : text2, shorttext = text1.length > text2.length ? text2 : text1, i = longtext.indexOf(shorttext);
  if (i !== -1) return diffs = [[DIFF_INSERT, longtext.substring(0, i)], [DIFF_EQUAL, shorttext], [DIFF_INSERT, longtext.substring(i + shorttext.length)]], text1.length > text2.length && (diffs[0][0] = DIFF_DELETE, diffs[2][0] = DIFF_DELETE), diffs;
  if (shorttext.length === 1) return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  const halfMatch = findHalfMatch(text1, text2);
  if (halfMatch) {
    const text1A = halfMatch[0], text1B = halfMatch[1], text2A = halfMatch[2], text2B = halfMatch[3], midCommon = halfMatch[4], diffsA = doDiff(text1A, text2A, opts), diffsB = doDiff(text1B, text2B, opts);
    return diffsA.concat([[DIFF_EQUAL, midCommon]], diffsB);
  }
  return opts.checkLines && text1.length > 100 && text2.length > 100 ? doLineModeDiff(text1, text2, opts) : bisect(text1, text2, opts.deadline);
}
var __defProp$2 = Object.defineProperty, __getOwnPropSymbols$2 = Object.getOwnPropertySymbols, __hasOwnProp$2 = Object.prototype.hasOwnProperty, __propIsEnum$2 = Object.prototype.propertyIsEnumerable, __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value
}) : obj[key] = value, __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {})) __hasOwnProp$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2) for (var prop of __getOwnPropSymbols$2(b)) __propIsEnum$2.call(b, prop) && __defNormalProp$2(a, prop, b[prop]);
  return a;
};
const DIFF_DELETE = -1, DIFF_INSERT = 1, DIFF_EQUAL = 0;
function diff(textA, textB, opts) {
  if (textA === null || textB === null) throw new Error("Null input. (diff)");
  const diffs = doDiff(textA, textB, createInternalOpts(opts || {}));
  return adjustDiffForSurrogatePairs(diffs), diffs;
}
function doDiff(textA, textB, options) {
  let text1 = textA, text2 = textB;
  if (text1 === text2) return text1 ? [[DIFF_EQUAL, text1]] : [];
  let commonlength = getCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength), text2 = text2.substring(commonlength), commonlength = getCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength), text2 = text2.substring(0, text2.length - commonlength);
  let diffs = computeDiff(text1, text2, options);
  return commonprefix && diffs.unshift([DIFF_EQUAL, commonprefix]), commonsuffix && diffs.push([DIFF_EQUAL, commonsuffix]), diffs = cleanupMerge(diffs), diffs;
}
function createDeadLine(timeout) {
  let t = 1;
  return typeof timeout < "u" && (t = timeout <= 0 ? Number.MAX_VALUE : timeout), Date.now() + t * 1e3;
}
function createInternalOpts(opts) {
  return __spreadValues$2({
    checkLines: !0,
    deadline: createDeadLine(opts.timeout || 1)
  }, opts);
}
function combineChar(data, char, dir) {
  return dir === 1 ? data + char : char + data;
}
function splitChar(data, dir) {
  return dir === 1 ? [data.substring(0, data.length - 1), data[data.length - 1]] : [data.substring(1), data[0]];
}
function hasSharedChar(diffs, i, j, dir) {
  return dir === 1 ? diffs[i][1][diffs[i][1].length - 1] === diffs[j][1][diffs[j][1].length - 1] : diffs[i][1][0] === diffs[j][1][0];
}
function deisolateChar(diffs, i, dir) {
  const inv = dir === 1 ? -1 : 1;
  let insertIdx = null, deleteIdx = null, j = i + dir;
  for (; j >= 0 && j < diffs.length && (insertIdx === null || deleteIdx === null); j += dir) {
    const [op, text2] = diffs[j];
    if (text2.length !== 0) {
      if (op === DIFF_INSERT) {
        insertIdx === null && (insertIdx = j);
        continue;
      } else if (op === DIFF_DELETE) {
        deleteIdx === null && (deleteIdx = j);
        continue;
      } else if (op === DIFF_EQUAL) {
        if (insertIdx === null && deleteIdx === null) {
          const [rest, char2] = splitChar(diffs[i][1], dir);
          diffs[i][1] = rest, diffs[j][1] = combineChar(diffs[j][1], char2, inv);
          return;
        }
        break;
      }
    }
  }
  if (insertIdx !== null && deleteIdx !== null && hasSharedChar(diffs, insertIdx, deleteIdx, dir)) {
    const [insertText, insertChar] = splitChar(diffs[insertIdx][1], inv), [deleteText2] = splitChar(diffs[deleteIdx][1], inv);
    diffs[insertIdx][1] = insertText, diffs[deleteIdx][1] = deleteText2, diffs[i][1] = combineChar(diffs[i][1], insertChar, dir);
    return;
  }
  const [text, char] = splitChar(diffs[i][1], dir);
  diffs[i][1] = text, insertIdx === null ? (diffs.splice(j, 0, [DIFF_INSERT, char]), deleteIdx !== null && deleteIdx >= j && deleteIdx++) : diffs[insertIdx][1] = combineChar(diffs[insertIdx][1], char, inv), deleteIdx === null ? diffs.splice(j, 0, [DIFF_DELETE, char]) : diffs[deleteIdx][1] = combineChar(diffs[deleteIdx][1], char, inv);
}
function adjustDiffForSurrogatePairs(diffs) {
  for (let i = 0; i < diffs.length; i++) {
    const [diffType, diffText] = diffs[i];
    if (diffText.length === 0) continue;
    const firstChar = diffText[0], lastChar = diffText[diffText.length - 1];
    isHighSurrogate(lastChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, 1), isLowSurrogate(firstChar) && diffType === DIFF_EQUAL && deisolateChar(diffs, i, -1);
  }
  for (let i = 0; i < diffs.length; i++) diffs[i][1].length === 0 && diffs.splice(i, 1);
}
function cleanupSemantic(rawDiffs) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;
  const equalities = [];
  let equalitiesLength = 0, lastEquality = null, pointer = 0, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0;
  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (equalities[equalitiesLength++] = pointer, lengthInsertions1 = lengthInsertions2, lengthDeletions1 = lengthDeletions2, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = diffs[pointer][1]) : (diffs[pointer][0] === DIFF_INSERT ? lengthInsertions2 += diffs[pointer][1].length : lengthDeletions2 += diffs[pointer][1].length, lastEquality && lastEquality.length <= Math.max(lengthInsertions1, lengthDeletions1) && lastEquality.length <= Math.max(lengthInsertions2, lengthDeletions2) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, lengthInsertions1 = 0, lengthDeletions1 = 0, lengthInsertions2 = 0, lengthDeletions2 = 0, lastEquality = null, hasChanges = !0)), pointer++;
  for (hasChanges && (diffs = cleanupMerge(diffs)), diffs = cleanupSemanticLossless(diffs), pointer = 1; pointer < diffs.length; ) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1], insertion = diffs[pointer][1], overlapLength1 = getCommonOverlap(deletion, insertion), overlapLength2 = getCommonOverlap(insertion, deletion);
      overlapLength1 >= overlapLength2 ? (overlapLength1 >= deletion.length / 2 || overlapLength1 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, insertion.substring(0, overlapLength1)]), diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlapLength1), diffs[pointer + 1][1] = insertion.substring(overlapLength1), pointer++) : (overlapLength2 >= deletion.length / 2 || overlapLength2 >= insertion.length / 2) && (diffs.splice(pointer, 0, [DIFF_EQUAL, deletion.substring(0, overlapLength2)]), diffs[pointer - 1][0] = DIFF_INSERT, diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlapLength2), diffs[pointer + 1][0] = DIFF_DELETE, diffs[pointer + 1][1] = deletion.substring(overlapLength2), pointer++), pointer++;
    }
    pointer++;
  }
  return diffs;
}
const nonAlphaNumericRegex = /[^a-zA-Z0-9]/, whitespaceRegex = /\s/, linebreakRegex = /[\r\n]/, blanklineEndRegex = /\n\r?\n$/, blanklineStartRegex = /^\r?\n\r?\n/;
function cleanupSemanticLossless(rawDiffs) {
  const diffs = rawDiffs.map((diff2) => cloneDiff(diff2));
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) return 6;
    const char1 = one.charAt(one.length - 1), char2 = two.charAt(0), nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex), nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex), whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex), whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex), lineBreak1 = whitespace1 && char1.match(linebreakRegex), lineBreak2 = whitespace2 && char2.match(linebreakRegex), blankLine1 = lineBreak1 && one.match(blanklineEndRegex), blankLine2 = lineBreak2 && two.match(blanklineStartRegex);
    return blankLine1 || blankLine2 ? 5 : lineBreak1 || lineBreak2 ? 4 : nonAlphaNumeric1 && !whitespace1 && whitespace2 ? 3 : whitespace1 || whitespace2 ? 2 : nonAlphaNumeric1 || nonAlphaNumeric2 ? 1 : 0;
  }
  let pointer = 1;
  for (; pointer < diffs.length - 1; ) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1], edit = diffs[pointer][1], equality2 = diffs[pointer + 1][1];
      const commonOffset = getCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset), edit = commonString + edit.substring(0, edit.length - commonOffset), equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2, bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      for (; edit.charAt(0) === equality2.charAt(0); ) {
        equality1 += edit.charAt(0), edit = edit.substring(1) + equality2.charAt(0), equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        score >= bestScore && (bestScore = score, bestEquality1 = equality1, bestEdit = edit, bestEquality2 = equality2);
      }
      diffs[pointer - 1][1] !== bestEquality1 && (bestEquality1 ? diffs[pointer - 1][1] = bestEquality1 : (diffs.splice(pointer - 1, 1), pointer--), diffs[pointer][1] = bestEdit, bestEquality2 ? diffs[pointer + 1][1] = bestEquality2 : (diffs.splice(pointer + 1, 1), pointer--));
    }
    pointer++;
  }
  return diffs;
}
function cleanupMerge(rawDiffs) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2));
  diffs.push([DIFF_EQUAL, ""]);
  let pointer = 0, countDelete = 0, countInsert = 0, textDelete = "", textInsert = "", commonlength;
  for (; pointer < diffs.length; ) switch (diffs[pointer][0]) {
    case DIFF_INSERT:
      countInsert++, textInsert += diffs[pointer][1], pointer++;
      break;
    case DIFF_DELETE:
      countDelete++, textDelete += diffs[pointer][1], pointer++;
      break;
    case DIFF_EQUAL:
      countDelete + countInsert > 1 ? (countDelete !== 0 && countInsert !== 0 && (commonlength = getCommonPrefix(textInsert, textDelete), commonlength !== 0 && (pointer - countDelete - countInsert > 0 && diffs[pointer - countDelete - countInsert - 1][0] === DIFF_EQUAL ? diffs[pointer - countDelete - countInsert - 1][1] += textInsert.substring(0, commonlength) : (diffs.splice(0, 0, [DIFF_EQUAL, textInsert.substring(0, commonlength)]), pointer++), textInsert = textInsert.substring(commonlength), textDelete = textDelete.substring(commonlength)), commonlength = getCommonSuffix(textInsert, textDelete), commonlength !== 0 && (diffs[pointer][1] = textInsert.substring(textInsert.length - commonlength) + diffs[pointer][1], textInsert = textInsert.substring(0, textInsert.length - commonlength), textDelete = textDelete.substring(0, textDelete.length - commonlength))), pointer -= countDelete + countInsert, diffs.splice(pointer, countDelete + countInsert), textDelete.length && (diffs.splice(pointer, 0, [DIFF_DELETE, textDelete]), pointer++), textInsert.length && (diffs.splice(pointer, 0, [DIFF_INSERT, textInsert]), pointer++), pointer++) : pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL ? (diffs[pointer - 1][1] += diffs[pointer][1], diffs.splice(pointer, 1)) : pointer++, countInsert = 0, countDelete = 0, textDelete = "", textInsert = "";
      break;
    default:
      throw new Error("Unknown diff operation");
  }
  diffs[diffs.length - 1][1] === "" && diffs.pop();
  let hasChanges = !1;
  for (pointer = 1; pointer < diffs.length - 1; ) diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL && (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1] ? (diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length), diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1], diffs.splice(pointer - 1, 1), hasChanges = !0) : diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1] && (diffs[pointer - 1][1] += diffs[pointer + 1][1], diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1], diffs.splice(pointer + 1, 1), hasChanges = !0)), pointer++;
  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
function trueCount(...args) {
  return args.reduce((n, bool) => n + (bool ? 1 : 0), 0);
}
function cleanupEfficiency(rawDiffs, editCost = 4) {
  let diffs = rawDiffs.map((diff2) => cloneDiff(diff2)), hasChanges = !1;
  const equalities = [];
  let equalitiesLength = 0, lastEquality = null, pointer = 0, preIns = !1, preDel = !1, postIns = !1, postDel = !1;
  for (; pointer < diffs.length; ) diffs[pointer][0] === DIFF_EQUAL ? (diffs[pointer][1].length < editCost && (postIns || postDel) ? (equalities[equalitiesLength++] = pointer, preIns = postIns, preDel = postDel, lastEquality = diffs[pointer][1]) : (equalitiesLength = 0, lastEquality = null), postIns = !1, postDel = !1) : (diffs[pointer][0] === DIFF_DELETE ? postDel = !0 : postIns = !0, lastEquality && (preIns && preDel && postIns && postDel || lastEquality.length < editCost / 2 && trueCount(preIns, preDel, postIns, postDel) === 3) && (diffs.splice(equalities[equalitiesLength - 1], 0, [DIFF_DELETE, lastEquality]), diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT, equalitiesLength--, lastEquality = null, preIns && preDel ? (postIns = !0, postDel = !0, equalitiesLength = 0) : (equalitiesLength--, pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1, postIns = !1, postDel = !1), hasChanges = !0)), pointer++;
  return hasChanges && (diffs = cleanupMerge(diffs)), diffs;
}
var __defProp$1 = Object.defineProperty, __getOwnPropSymbols$1 = Object.getOwnPropertySymbols, __hasOwnProp$1 = Object.prototype.hasOwnProperty, __propIsEnum$1 = Object.prototype.propertyIsEnumerable, __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value
}) : obj[key] = value, __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {})) __hasOwnProp$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1) for (var prop of __getOwnPropSymbols$1(b)) __propIsEnum$1.call(b, prop) && __defNormalProp$1(a, prop, b[prop]);
  return a;
};
const DEFAULT_OPTIONS = {
  /**
   * At what point is no match declared (0.0 = perfection, 1.0 = very loose).
   */
  threshold: 0.5,
  /**
   * How far to search for a match (0 = exact location, 1000+ = broad match).
   * A match this many characters away from the expected location will add
   * 1.0 to the score (0.0 is a perfect match).
   */
  distance: 1e3
};
function applyDefaults(options) {
  return __spreadValues$1(__spreadValues$1({}, DEFAULT_OPTIONS), options);
}
const MAX_BITS$1 = 32;
function bitap(text, pattern, loc, opts = {}) {
  if (pattern.length > MAX_BITS$1) throw new Error("Pattern too long for this browser.");
  const options = applyDefaults(opts), s = getAlphabetFromPattern(pattern);
  function getBitapScore(e, x) {
    const accuracy = e / pattern.length, proximity = Math.abs(loc - x);
    return options.distance ? accuracy + proximity / options.distance : proximity ? 1 : accuracy;
  }
  let scoreThreshold = options.threshold, bestLoc = text.indexOf(pattern, loc);
  bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold), bestLoc = text.lastIndexOf(pattern, loc + pattern.length), bestLoc !== -1 && (scoreThreshold = Math.min(getBitapScore(0, bestLoc), scoreThreshold)));
  const matchmask = 1 << pattern.length - 1;
  bestLoc = -1;
  let binMin, binMid, binMax = pattern.length + text.length, lastRd = [];
  for (let d = 0; d < pattern.length; d++) {
    for (binMin = 0, binMid = binMax; binMin < binMid; ) getBitapScore(d, loc + binMid) <= scoreThreshold ? binMin = binMid : binMax = binMid, binMid = Math.floor((binMax - binMin) / 2 + binMin);
    binMax = binMid;
    let start = Math.max(1, loc - binMid + 1);
    const finish = Math.min(loc + binMid, text.length) + pattern.length, rd = new Array(finish + 2);
    rd[finish + 1] = (1 << d) - 1;
    for (let j = finish; j >= start; j--) {
      const charMatch = s[text.charAt(j - 1)];
      if (d === 0 ? rd[j] = (rd[j + 1] << 1 | 1) & charMatch : rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((lastRd[j + 1] | lastRd[j]) << 1 | 1) | lastRd[j + 1], rd[j] & matchmask) {
        const score = getBitapScore(d, j - 1);
        if (score <= scoreThreshold) if (scoreThreshold = score, bestLoc = j - 1, bestLoc > loc) start = Math.max(1, 2 * loc - bestLoc);
        else break;
      }
    }
    if (getBitapScore(d + 1, loc) > scoreThreshold) break;
    lastRd = rd;
  }
  return bestLoc;
}
function getAlphabetFromPattern(pattern) {
  const s = {};
  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] = 0;
  for (let i = 0; i < pattern.length; i++) s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
  return s;
}
function match(text, pattern, searchLocation, options = {}) {
  if (text === null || pattern === null || searchLocation === null) throw new Error("Null input. (match())");
  const loc = Math.max(0, Math.min(searchLocation, text.length));
  if (text === pattern) return 0;
  if (text.length) {
    if (text.substring(loc, loc + pattern.length) === pattern) return loc;
  } else return -1;
  return bitap(text, pattern, loc, options);
}
function diffText1(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_INSERT && (text[x] = diffs[x][1]);
  return text.join("");
}
function diffText2(diffs) {
  const text = [];
  for (let x = 0; x < diffs.length; x++) diffs[x][0] !== DIFF_DELETE && (text[x] = diffs[x][1]);
  return text.join("");
}
function levenshtein(diffs) {
  let leven = 0, insertions = 0, deletions = 0;
  for (let x = 0; x < diffs.length; x++) {
    const op = diffs[x][0], data = diffs[x][1];
    switch (op) {
      case DIFF_INSERT:
        insertions += data.length;
        break;
      case DIFF_DELETE:
        deletions += data.length;
        break;
      case DIFF_EQUAL:
        leven += Math.max(insertions, deletions), insertions = 0, deletions = 0;
        break;
      default:
        throw new Error("Unknown diff operation.");
    }
  }
  return leven += Math.max(insertions, deletions), leven;
}
function xIndex(diffs, location) {
  let chars1 = 0, chars2 = 0, lastChars1 = 0, lastChars2 = 0, x;
  for (x = 0; x < diffs.length && (diffs[x][0] !== DIFF_INSERT && (chars1 += diffs[x][1].length), diffs[x][0] !== DIFF_DELETE && (chars2 += diffs[x][1].length), !(chars1 > location)); x++) lastChars1 = chars1, lastChars2 = chars2;
  return diffs.length !== x && diffs[x][0] === DIFF_DELETE ? lastChars2 : lastChars2 + (location - lastChars1);
}
function countUtf8Bytes(str) {
  let bytes = 0;
  for (let i = 0; i < str.length; i++) {
    const codePoint = str.codePointAt(i);
    if (typeof codePoint > "u") throw new Error("Failed to get codepoint");
    bytes += utf8len(codePoint);
  }
  return bytes;
}
function adjustIndiciesToUcs2(patches, base, options = {}) {
  let byteOffset = 0, idx = 0;
  function advanceTo(target) {
    for (; byteOffset < target; ) {
      const codePoint = base.codePointAt(idx);
      if (typeof codePoint > "u") return idx;
      byteOffset += utf8len(codePoint), codePoint > 65535 ? idx += 2 : idx += 1;
    }
    if (!options.allowExceedingIndices && byteOffset !== target) throw new Error("Failed to determine byte offset");
    return idx;
  }
  const adjusted = [];
  for (const patch of patches) adjusted.push({
    diffs: patch.diffs.map((diff2) => cloneDiff(diff2)),
    start1: advanceTo(patch.start1),
    start2: advanceTo(patch.start2),
    utf8Start1: patch.utf8Start1,
    utf8Start2: patch.utf8Start2,
    length1: patch.length1,
    length2: patch.length2,
    utf8Length1: patch.utf8Length1,
    utf8Length2: patch.utf8Length2
  });
  return adjusted;
}
function utf8len(codePoint) {
  return codePoint <= 127 ? 1 : codePoint <= 2047 ? 2 : codePoint <= 65535 ? 3 : 4;
}
const MAX_BITS = 32, DEFAULT_MARGIN = 4;
function addPadding(patches, margin = DEFAULT_MARGIN) {
  const paddingLength = margin;
  let nullPadding = "";
  for (let x = 1; x <= paddingLength; x++) nullPadding += String.fromCharCode(x);
  for (const p of patches) p.start1 += paddingLength, p.start2 += paddingLength, p.utf8Start1 += paddingLength, p.utf8Start2 += paddingLength;
  let patch = patches[0], diffs = patch.diffs;
  if (diffs.length === 0 || diffs[0][0] !== DIFF_EQUAL) diffs.unshift([DIFF_EQUAL, nullPadding]), patch.start1 -= paddingLength, patch.start2 -= paddingLength, patch.utf8Start1 -= paddingLength, patch.utf8Start2 -= paddingLength, patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
  else if (paddingLength > diffs[0][1].length) {
    const firstDiffLength = diffs[0][1].length, extraLength = paddingLength - firstDiffLength;
    diffs[0][1] = nullPadding.substring(firstDiffLength) + diffs[0][1], patch.start1 -= extraLength, patch.start2 -= extraLength, patch.utf8Start1 -= extraLength, patch.utf8Start2 -= extraLength, patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
  }
  if (patch = patches[patches.length - 1], diffs = patch.diffs, diffs.length === 0 || diffs[diffs.length - 1][0] !== DIFF_EQUAL) diffs.push([DIFF_EQUAL, nullPadding]), patch.length1 += paddingLength, patch.length2 += paddingLength, patch.utf8Length1 += paddingLength, patch.utf8Length2 += paddingLength;
  else if (paddingLength > diffs[diffs.length - 1][1].length) {
    const extraLength = paddingLength - diffs[diffs.length - 1][1].length;
    diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength), patch.length1 += extraLength, patch.length2 += extraLength, patch.utf8Length1 += extraLength, patch.utf8Length2 += extraLength;
  }
  return nullPadding;
}
function createPatchObject(start1, start2) {
  return {
    diffs: [],
    start1,
    start2,
    utf8Start1: start1,
    utf8Start2: start2,
    length1: 0,
    length2: 0,
    utf8Length1: 0,
    utf8Length2: 0
  };
}
function splitMax(patches, margin = DEFAULT_MARGIN) {
  const patchSize = MAX_BITS;
  for (let x = 0; x < patches.length; x++) {
    if (patches[x].length1 <= patchSize) continue;
    const bigpatch = patches[x];
    patches.splice(x--, 1);
    let start1 = bigpatch.start1, start2 = bigpatch.start2, preContext = "";
    for (; bigpatch.diffs.length !== 0; ) {
      const patch = createPatchObject(start1 - preContext.length, start2 - preContext.length);
      let empty = !0;
      if (preContext !== "") {
        const precontextByteCount = countUtf8Bytes(preContext);
        patch.length1 = preContext.length, patch.utf8Length1 = precontextByteCount, patch.length2 = preContext.length, patch.utf8Length2 = precontextByteCount, patch.diffs.push([DIFF_EQUAL, preContext]);
      }
      for (; bigpatch.diffs.length !== 0 && patch.length1 < patchSize - margin; ) {
        const diffType = bigpatch.diffs[0][0];
        let diffText = bigpatch.diffs[0][1], diffTextByteCount = countUtf8Bytes(diffText);
        if (diffType === DIFF_INSERT) {
          patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length;
          const diff2 = bigpatch.diffs.shift();
          diff2 && patch.diffs.push(diff2), empty = !1;
        } else diffType === DIFF_DELETE && patch.diffs.length === 1 && patch.diffs[0][0] === DIFF_EQUAL && diffText.length > 2 * patchSize ? (patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, empty = !1, patch.diffs.push([diffType, diffText]), bigpatch.diffs.shift()) : (diffText = diffText.substring(0, patchSize - patch.length1 - margin), diffTextByteCount = countUtf8Bytes(diffText), patch.length1 += diffText.length, patch.utf8Length1 += diffTextByteCount, start1 += diffText.length, diffType === DIFF_EQUAL ? (patch.length2 += diffText.length, patch.utf8Length2 += diffTextByteCount, start2 += diffText.length) : empty = !1, patch.diffs.push([diffType, diffText]), diffText === bigpatch.diffs[0][1] ? bigpatch.diffs.shift() : bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diffText.length));
      }
      preContext = diffText2(patch.diffs), preContext = preContext.substring(preContext.length - margin);
      const postContext = diffText1(bigpatch.diffs).substring(0, margin), postContextByteCount = countUtf8Bytes(postContext);
      postContext !== "" && (patch.length1 += postContext.length, patch.length2 += postContext.length, patch.utf8Length1 += postContextByteCount, patch.utf8Length2 += postContextByteCount, patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL ? patch.diffs[patch.diffs.length - 1][1] += postContext : patch.diffs.push([DIFF_EQUAL, postContext])), empty || patches.splice(++x, 0, patch);
    }
  }
}
function apply(patches, originalText, opts = {}) {
  if (typeof patches == "string") throw new Error("Patches must be an array - pass the patch to `parsePatch()` first");
  let text = originalText;
  if (patches.length === 0) return [text, []];
  const parsed = adjustIndiciesToUcs2(patches, text, {
    allowExceedingIndices: opts.allowExceedingIndices
  }), margin = opts.margin || DEFAULT_MARGIN, deleteThreshold = opts.deleteThreshold || 0.4, nullPadding = addPadding(parsed, margin);
  text = nullPadding + text + nullPadding, splitMax(parsed, margin);
  let delta = 0;
  const results = [];
  for (let x = 0; x < parsed.length; x++) {
    const expectedLoc = parsed[x].start2 + delta, text1 = diffText1(parsed[x].diffs);
    let startLoc, endLoc = -1;
    if (text1.length > MAX_BITS ? (startLoc = match(text, text1.substring(0, MAX_BITS), expectedLoc), startLoc !== -1 && (endLoc = match(text, text1.substring(text1.length - MAX_BITS), expectedLoc + text1.length - MAX_BITS), (endLoc === -1 || startLoc >= endLoc) && (startLoc = -1))) : startLoc = match(text, text1, expectedLoc), startLoc === -1) results[x] = !1, delta -= parsed[x].length2 - parsed[x].length1;
    else {
      results[x] = !0, delta = startLoc - expectedLoc;
      let text2;
      if (endLoc === -1 ? text2 = text.substring(startLoc, startLoc + text1.length) : text2 = text.substring(startLoc, endLoc + MAX_BITS), text1 === text2) text = text.substring(0, startLoc) + diffText2(parsed[x].diffs) + text.substring(startLoc + text1.length);
      else {
        let diffs = diff(text1, text2, {
          checkLines: !1
        });
        if (text1.length > MAX_BITS && levenshtein(diffs) / text1.length > deleteThreshold) results[x] = !1;
        else {
          diffs = cleanupSemanticLossless(diffs);
          let index1 = 0, index2 = 0;
          for (let y = 0; y < parsed[x].diffs.length; y++) {
            const mod = parsed[x].diffs[y];
            mod[0] !== DIFF_EQUAL && (index2 = xIndex(diffs, index1)), mod[0] === DIFF_INSERT ? text = text.substring(0, startLoc + index2) + mod[1] + text.substring(startLoc + index2) : mod[0] === DIFF_DELETE && (text = text.substring(0, startLoc + index2) + text.substring(startLoc + xIndex(diffs, index1 + mod[1].length))), mod[0] !== DIFF_DELETE && (index1 += mod[1].length);
          }
        }
      }
    }
  }
  return text = text.substring(nullPadding.length, text.length - nullPadding.length), [text, results];
}
const patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
function parse(textline) {
  if (!textline) return [];
  const patches = [], lines = textline.split(`
`);
  let textPointer = 0;
  for (; textPointer < lines.length; ) {
    const m = lines[textPointer].match(patchHeader);
    if (!m) throw new Error(`Invalid patch string: ${lines[textPointer]}`);
    const patch = createPatchObject(toInt(m[1]), toInt(m[3]));
    for (patches.push(patch), m[2] === "" ? (patch.start1--, patch.utf8Start1--, patch.length1 = 1, patch.utf8Length1 = 1) : m[2] === "0" ? (patch.length1 = 0, patch.utf8Length1 = 0) : (patch.start1--, patch.utf8Start1--, patch.utf8Length1 = toInt(m[2]), patch.length1 = patch.utf8Length1), m[4] === "" ? (patch.start2--, patch.utf8Start2--, patch.length2 = 1, patch.utf8Length2 = 1) : m[4] === "0" ? (patch.length2 = 0, patch.utf8Length2 = 0) : (patch.start2--, patch.utf8Start2--, patch.utf8Length2 = toInt(m[4]), patch.length2 = patch.utf8Length2), textPointer++; textPointer < lines.length; ) {
      const currentLine = lines[textPointer], sign = currentLine.charAt(0);
      if (sign === "@") break;
      if (sign === "") {
        textPointer++;
        continue;
      }
      let line;
      try {
        line = decodeURI(currentLine.slice(1));
      } catch {
        throw new Error(`Illegal escape in parse: ${currentLine}`);
      }
      const utf8Diff = countUtf8Bytes(line) - line.length;
      if (sign === "-") patch.diffs.push([DIFF_DELETE, line]), patch.length1 -= utf8Diff;
      else if (sign === "+") patch.diffs.push([DIFF_INSERT, line]), patch.length2 -= utf8Diff;
      else if (sign === " ") patch.diffs.push([DIFF_EQUAL, line]), patch.length1 -= utf8Diff, patch.length2 -= utf8Diff;
      else throw new Error(`Invalid patch mode "${sign}" in: ${line}`);
      textPointer++;
    }
  }
  return patches;
}
function toInt(num) {
  return parseInt(num, 10);
}
function createApplyPatch(context) {
  return (editor, patch) => {
    let changed = !1;
    try {
      switch (patch.type) {
        case "insert":
          changed = insertPatch(context, editor, patch);
          break;
        case "unset":
          changed = unsetPatch(editor, patch);
          break;
        case "set":
          changed = setPatch(editor, patch);
          break;
        case "setIfMissing":
          changed = setPatch(editor, patch);
          break;
        case "diffMatchPatch":
          changed = diffMatchPatch(editor, patch);
          break;
      }
    } catch (err) {
      console.error(err);
    }
    return changed;
  };
}
function diffMatchPatch(editor, patch) {
  const block = findBlock(editor.children, patch.path);
  if (!block)
    return !1;
  const child = findBlockChild(block, patch.path);
  if (!child || !(block && editor.isTextBlock(block.node) && patch.path.length === 4 && patch.path[1] === "children" && patch.path[3] === "text") || !Text.isText(child.node))
    return !1;
  const patches = parse(patch.value), [newValue] = apply(patches, child.node.text, {
    allowExceedingIndices: !0
  }), diff$1 = cleanupEfficiency(diff(child.node.text, newValue), 5);
  let offset = 0;
  for (const [op, text] of diff$1)
    op === DIFF_INSERT ? (editor.apply({
      type: "insert_text",
      path: [block.index, child.index],
      offset,
      text
    }), offset += text.length) : op === DIFF_DELETE ? editor.apply({
      type: "remove_text",
      path: [block.index, child.index],
      offset,
      text
    }) : op === DIFF_EQUAL && (offset += text.length);
  return !0;
}
function insertPatch(context, editor, patch) {
  const block = findBlock(editor.children, patch.path);
  if (!block) {
    if (patch.path.length === 1 && patch.path[0] === 0) {
      const blocksToInsert = patch.items.map((item) => toSlateBlock(item, {
        schemaTypes: context.schema
      }));
      return Transforms.insertNodes(editor, blocksToInsert, {
        at: [0]
      }), !0;
    }
    return !1;
  }
  if (patch.path.length > 1 && patch.path[1] !== "children")
    return !1;
  if (patch.path.length === 1) {
    const {
      items: items2,
      position: position2
    } = patch, blocksToInsert = items2.map((item) => toSlateBlock(item, {
      schemaTypes: context.schema
    })), targetBlockIndex = block.index, normalizedIdx2 = position2 === "after" ? targetBlockIndex + 1 : targetBlockIndex, editorWasEmptyBefore = isEqualToEmptyEditor(context.initialValue, editor.value, context.schema);
    return Transforms.insertNodes(editor, blocksToInsert, {
      at: [normalizedIdx2]
    }), editorWasEmptyBefore && typeof patch.path[0] == "number" && patch.path[0] === 0 && Transforms.removeNodes(editor, {
      at: [position2 === "before" ? targetBlockIndex + blocksToInsert.length : targetBlockIndex]
    }), !0;
  }
  const {
    items,
    position
  } = patch, targetChild = findBlockChild(block, patch.path);
  if (!targetChild)
    return !1;
  const childrenToInsert = toSlateBlock({
    ...block.node,
    children: items
  }, {
    schemaTypes: context.schema
  }), normalizedIdx = position === "after" ? targetChild.index + 1 : targetChild.index, childInsertPath = [block.index, normalizedIdx];
  return childrenToInsert && Element$1.isElement(childrenToInsert) && Transforms.insertNodes(editor, childrenToInsert.children, {
    at: childInsertPath
  }), !0;
}
function setPatch(editor, patch) {
  let value = patch.value;
  typeof patch.path[3] == "string" && (value = {}, value[patch.path[3]] = patch.value);
  const block = findBlock(editor.children, patch.path);
  if (!block)
    return !1;
  const isTextBlock2 = editor.isTextBlock(block.node);
  if (patch.path.length === 1) {
    const updatedBlock = applyAll(block.node, [{
      ...patch,
      path: patch.path.slice(1)
    }]);
    if (editor.isTextBlock(block.node) && Element$1.isElement(updatedBlock)) {
      Transforms.setNodes(editor, updatedBlock, {
        at: [block.index]
      });
      const previousSelection = editor.selection;
      for (const [_, childPath] of Editor.nodes(editor, {
        at: [block.index],
        reverse: !0,
        mode: "lowest"
      }))
        Transforms.removeNodes(editor, {
          at: childPath
        });
      return Transforms.insertNodes(editor, updatedBlock.children, {
        at: [block.index, 0]
      }), previousSelection && (Transforms.setSelection(editor, previousSelection), Transforms.select(editor, previousSelection)), !0;
    } else
      return Transforms.setNodes(editor, updatedBlock, {
        at: [block.index]
      }), !0;
  }
  if (isTextBlock2 && patch.path[1] !== "children") {
    const updatedBlock = applyAll(block.node, [{
      ...patch,
      path: patch.path.slice(1)
    }]);
    return Transforms.setNodes(editor, updatedBlock, {
      at: [block.index]
    }), !0;
  }
  const child = findBlockChild(block, patch.path);
  if (isTextBlock2 && child) {
    if (Text.isText(child.node))
      if (Text.isText(value)) {
        if (patch.type === "setIfMissing")
          return !1;
        const oldText = child.node.text, newText = value.text;
        oldText !== newText && (editor.apply({
          type: "remove_text",
          path: [block.index, child.index],
          offset: 0,
          text: oldText
        }), editor.apply({
          type: "insert_text",
          path: [block.index, child.index],
          offset: 0,
          text: newText
        }), editor.onChange());
      } else {
        const propPath = patch.path.slice(3), propEntry = propPath.at(0);
        if (propEntry === void 0 || typeof propEntry == "string" && ["_key", "_type", "text"].includes(propEntry))
          return !1;
        const newNode = applyAll(child.node, [{
          ...patch,
          path: propPath
        }]);
        Transforms.setNodes(editor, newNode, {
          at: [block.index, child.index]
        });
      }
    else {
      const propPath = patch.path.slice(3), reservedProps = ["_key", "_type", "children", "__inline"], propEntry = propPath.at(0);
      if (propEntry === void 0 || typeof propEntry == "string" && reservedProps.includes(propEntry))
        return !1;
      const value2 = "value" in child.node && typeof child.node.value == "object" ? child.node.value : {}, newValue = applyAll(value2, [{
        ...patch,
        path: patch.path.slice(3)
      }]);
      Transforms.setNodes(editor, {
        ...child.node,
        value: newValue
      }, {
        at: [block.index, child.index]
      });
    }
    return !0;
  } else if (block && "value" in block.node)
    if (patch.path.length > 1 && patch.path[1] !== "children") {
      const newVal = applyAll(block.node.value, [{
        ...patch,
        path: patch.path.slice(1)
      }]);
      Transforms.setNodes(editor, {
        ...block.node,
        value: newVal
      }, {
        at: [block.index]
      });
    } else
      return !1;
  return !0;
}
function unsetPatch(editor, patch) {
  if (patch.path.length === 0) {
    Transforms.deselect(editor);
    const children = Node.children(editor, [], {
      reverse: !0
    });
    for (const [_, path] of children)
      Transforms.removeNodes(editor, {
        at: path
      });
    return !0;
  }
  const block = findBlock(editor.children, patch.path);
  if (!block)
    return !1;
  if (patch.path.length === 1)
    return Transforms.removeNodes(editor, {
      at: [block.index]
    }), !0;
  const child = findBlockChild(block, patch.path);
  if (editor.isTextBlock(block.node) && child && patch.path[1] === "children" && patch.path.length === 3)
    return Transforms.removeNodes(editor, {
      at: [block.index, child.index]
    }), !0;
  if (child && !Text.isText(child.node)) {
    const propEntry = patch.path.slice(3).at(0);
    if (propEntry === void 0 || typeof propEntry == "string" && ["_key", "_type", "children", "__inline"].includes(propEntry))
      return !1;
    const value = "value" in child.node && typeof child.node.value == "object" ? child.node.value : {}, newValue = applyAll(value, [{
      ...patch,
      path: patch.path.slice(3)
    }]);
    return Transforms.setNodes(editor, {
      ...child.node,
      value: newValue
    }, {
      at: [block.index, child.index]
    }), !0;
  }
  if (child && Text.isText(child.node)) {
    const propPath = patch.path.slice(3), propEntry = propPath.at(0);
    if (propEntry === void 0 || typeof propEntry == "string" && ["_key", "_type"].includes(propEntry))
      return !1;
    if (typeof propEntry == "string" && propEntry === "text")
      return editor.apply({
        type: "remove_text",
        path: [block.index, child.index],
        offset: 0,
        text: child.node.text
      }), !0;
    const newNode = applyAll(child.node, [{
      ...patch,
      path: propPath
    }]), newKeys = Object.keys(newNode), removedProperties = Object.keys(child.node).filter((property) => !newKeys.includes(property));
    return Transforms.unsetNodes(editor, removedProperties, {
      at: [block.index, child.index]
    }), !0;
  }
  if (!child) {
    if ("value" in block.node) {
      const newVal = applyAll(block.node.value, [{
        ...patch,
        path: patch.path.slice(1)
      }]);
      return Transforms.setNodes(editor, {
        ...block.node,
        value: newVal
      }, {
        at: [block.index]
      }), !0;
    }
    return !1;
  }
  return !1;
}
function findBlock(children, path) {
  let blockIndex = -1;
  const block = children.find((node, index) => {
    const isMatch = isKeyedSegment(path[0]) ? node._key === path[0]._key : index === path[0];
    return isMatch && (blockIndex = index), isMatch;
  });
  if (block)
    return {
      node: block,
      index: blockIndex
    };
}
function findBlockChild(block, path) {
  const blockNode = block.node;
  if (!Element$1.isElement(blockNode) || path[1] !== "children")
    return;
  let childIndex = -1;
  const child = blockNode.children.find((node, index) => {
    const isMatch = isKeyedSegment(path[2]) ? node._key === path[2]._key : index === path[2];
    return isMatch && (childIndex = index), isMatch;
  });
  if (child)
    return {
      node: child,
      index: childIndex
    };
}
function insertTextPatch(schema, children, operation, beforeValue) {
  const block = isTextBlock({
    schema
  }, children[operation.path[0]]) && children[operation.path[0]];
  if (!block)
    throw new Error("Could not find block");
  const textChild = isTextBlock({
    schema
  }, block) && isSpan({
    schema
  }, block.children[operation.path[1]]) && block.children[operation.path[1]];
  if (!textChild)
    throw new Error("Could not find child");
  const path = [{
    _key: block._key
  }, "children", {
    _key: textChild._key
  }, "text"], prevBlock = beforeValue[operation.path[0]], prevChild = isTextBlock({
    schema
  }, prevBlock) && prevBlock.children[operation.path[1]], prevText = isSpan({
    schema
  }, prevChild) ? prevChild.text : "", patch = diffMatchPatch$1(prevText, textChild.text, path);
  return patch.value.length ? [patch] : [];
}
function removeTextPatch(schema, children, operation, beforeValue) {
  const block = children[operation.path[0]];
  if (!block)
    throw new Error("Could not find block");
  const child = isTextBlock({
    schema
  }, block) && block.children[operation.path[1]] || void 0, textChild = isSpan({
    schema
  }, child) ? child : void 0;
  if (child && !textChild)
    throw new Error("Expected span");
  if (!textChild)
    throw new Error("Could not find child");
  const path = [{
    _key: block._key
  }, "children", {
    _key: textChild._key
  }, "text"], beforeBlock = beforeValue[operation.path[0]], prevTextChild = isTextBlock({
    schema
  }, beforeBlock) && beforeBlock.children[operation.path[1]], prevText = isSpan({
    schema
  }, prevTextChild) && prevTextChild.text, patch = diffMatchPatch$1(prevText || "", textChild.text, path);
  return patch.value ? [patch] : [];
}
function setNodePatch(schema, children, operation) {
  const blockIndex = operation.path.at(0);
  if (blockIndex !== void 0 && operation.path.length === 1) {
    const block = children.at(blockIndex);
    if (!block)
      return console.error("Could not find block at index", blockIndex), [];
    if (isTextBlock({
      schema
    }, block)) {
      const patches = [];
      for (const key of Object.keys(operation.newProperties)) {
        const value = operation.newProperties[key];
        key === "_key" ? patches.push(set(value, [blockIndex, "_key"])) : patches.push(set(value, [{
          _key: block._key
        }, key]));
      }
      for (const key of Object.keys(operation.properties))
        key in operation.newProperties || patches.push(unset([{
          _key: block._key
        }, key]));
      return patches;
    } else {
      const patches = [], _key = operation.newProperties._key;
      _key !== void 0 && patches.push(set(_key, [blockIndex, "_key"]));
      const newValue = "value" in operation.newProperties && typeof operation.newProperties.value == "object" ? operation.newProperties.value : {}, keys = Object.keys(newValue);
      for (const key of keys) {
        const value2 = newValue[key];
        patches.push(set(value2, [{
          _key: block._key
        }, key]));
      }
      const value = "value" in operation.properties && typeof operation.properties.value == "object" ? operation.properties.value : {};
      for (const key of Object.keys(value))
        key in newValue || patches.push(unset([{
          _key: block._key
        }, key]));
      return patches;
    }
  } else if (operation.path.length === 2) {
    const block = children[operation.path[0]];
    if (isTextBlock({
      schema
    }, block)) {
      const child = block.children[operation.path[1]];
      if (child) {
        const blockKey = block._key, childKey = child._key, patches = [];
        if (Element$1.isElement(child)) {
          const _key = operation.newProperties._key;
          _key !== void 0 && patches.push(set(_key, [{
            _key: blockKey
          }, "children", block.children.indexOf(child), "_key"]));
          const properties = "value" in operation.newProperties && typeof operation.newProperties.value == "object" ? operation.newProperties.value : {}, keys = Object.keys(properties);
          for (const key of keys) {
            const value = properties[key];
            patches.push(set(value, [{
              _key: blockKey
            }, "children", {
              _key: childKey
            }, key]));
          }
          return patches;
        }
        const newPropNames = Object.keys(operation.newProperties);
        for (const keyName of newPropNames) {
          const value = operation.newProperties[keyName];
          if (keyName === "_key") {
            patches.push(set(value, [{
              _key: blockKey
            }, "children", block.children.indexOf(child), keyName]));
            continue;
          }
          patches.push(set(value, [{
            _key: blockKey
          }, "children", {
            _key: childKey
          }, keyName]));
        }
        const propNames = Object.keys(operation.properties);
        for (const keyName of propNames)
          keyName in operation.newProperties || patches.push(unset([{
            _key: blockKey
          }, "children", {
            _key: childKey
          }, keyName]));
        return patches;
      }
      throw new Error("Could not find a valid child");
    }
    throw new Error("Could not find a valid block");
  } else
    throw new Error(`Unexpected path encountered: ${JSON.stringify(operation.path)}`);
}
function insertNodePatch(schema, children, operation, beforeValue) {
  const block = beforeValue[operation.path[0]];
  if (operation.path.length === 1) {
    const position = operation.path[0] === 0 ? "before" : "after", beforeBlock = beforeValue[operation.path[0] - 1], targetKey = operation.path[0] === 0 ? block?._key : beforeBlock?._key;
    return targetKey ? [insert([fromSlateBlock(operation.node, schema.block.name)], position, [{
      _key: targetKey
    }])] : [setIfMissing(beforeValue, []), insert([fromSlateBlock(operation.node, schema.block.name)], "before", [operation.path[0]])];
  } else if (isTextBlock({
    schema
  }, block) && operation.path.length === 2 && children[operation.path[0]]) {
    const position = block.children.length === 0 || !block.children[operation.path[1] - 1] ? "before" : "after", path = block.children.length <= 1 || !block.children[operation.path[1] - 1] ? [{
      _key: block._key
    }, "children", 0] : [{
      _key: block._key
    }, "children", {
      _key: block.children[operation.path[1] - 1]._key
    }];
    if (Text.isText(operation.node))
      return [insert([operation.node], position, path)];
    const _type = operation.node._type, _key = operation.node._key, value = "value" in operation.node && typeof operation.node.value == "object" ? operation.node.value : {};
    return [insert([{
      _type,
      _key,
      ...value
    }], position, path)];
  }
  return [];
}
function splitNodePatch(schema, children, operation, beforeValue) {
  const patches = [], splitBlock = children[operation.path[0]];
  if (!isTextBlock({
    schema
  }, splitBlock))
    throw new Error(`Block with path ${JSON.stringify(operation.path[0])} is not a text block and can't be split`);
  if (operation.path.length === 1) {
    const oldBlock = beforeValue[operation.path[0]];
    if (isTextBlock({
      schema
    }, oldBlock)) {
      const targetValue = fromSlateBlock(children[operation.path[0] + 1], schema.block.name);
      targetValue && (patches.push(insert([targetValue], "after", [{
        _key: splitBlock._key
      }])), oldBlock.children.slice(operation.position).forEach((span) => {
        const path = [{
          _key: oldBlock._key
        }, "children", {
          _key: span._key
        }];
        patches.push(unset(path));
      }));
    }
    return patches;
  }
  if (operation.path.length === 2) {
    const splitSpan = splitBlock.children[operation.path[1]];
    if (isSpan({
      schema
    }, splitSpan)) {
      const targetSpans = fromSlateBlock({
        ...splitBlock,
        children: splitBlock.children.slice(operation.path[1] + 1, operation.path[1] + 2)
      }, schema.block.name).children;
      patches.push(insert(targetSpans, "after", [{
        _key: splitBlock._key
      }, "children", {
        _key: splitSpan._key
      }])), patches.push(set(splitSpan.text, [{
        _key: splitBlock._key
      }, "children", {
        _key: splitSpan._key
      }, "text"]));
    }
    return patches;
  }
  return patches;
}
function removeNodePatch(schema, beforeValue, operation) {
  const block = beforeValue[operation.path[0]];
  if (operation.path.length === 1) {
    if (block && block._key)
      return [unset([{
        _key: block._key
      }])];
    throw new Error("Block not found");
  } else if (isTextBlock({
    schema
  }, block) && operation.path.length === 2) {
    const spanToRemove = block.children[operation.path[1]];
    return spanToRemove ? block.children.filter((span) => span._key === operation.node._key).length > 1 ? (console.warn(`Multiple spans have \`_key\` ${operation.node._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)), []) : [unset([{
      _key: block._key
    }, "children", {
      _key: spanToRemove._key
    }])] : [];
  } else
    return [];
}
function mergeNodePatch(schema, children, operation, beforeValue) {
  const patches = [], block = beforeValue[operation.path[0]], updatedBlock = children[operation.path[0]];
  if (operation.path.length === 1)
    if (block?._key) {
      const newBlock = fromSlateBlock(children[operation.path[0] - 1], schema.block.name);
      patches.push(set(newBlock, [{
        _key: newBlock._key
      }])), patches.push(unset([{
        _key: block._key
      }]));
    } else
      throw new Error("Target key not found!");
  else if (isTextBlock({
    schema
  }, block) && isTextBlock({
    schema
  }, updatedBlock) && operation.path.length === 2) {
    const updatedSpan = updatedBlock.children[operation.path[1] - 1] && isSpan({
      schema
    }, updatedBlock.children[operation.path[1] - 1]) ? updatedBlock.children[operation.path[1] - 1] : void 0, removedSpan = block.children[operation.path[1]] && isSpan({
      schema
    }, block.children[operation.path[1]]) ? block.children[operation.path[1]] : void 0;
    updatedSpan && (block.children.filter((span) => span._key === updatedSpan._key).length === 1 ? patches.push(set(updatedSpan.text, [{
      _key: block._key
    }, "children", {
      _key: updatedSpan._key
    }, "text"])) : console.warn(`Multiple spans have \`_key\` ${updatedSpan._key}. It's ambiguous which one to update.`, JSON.stringify(block, null, 2))), removedSpan && (block.children.filter((span) => span._key === removedSpan._key).length === 1 ? patches.push(unset([{
      _key: block._key
    }, "children", {
      _key: removedSpan._key
    }])) : console.warn(`Multiple spans have \`_key\` ${removedSpan._key}. It's ambiguous which one to remove.`, JSON.stringify(block, null, 2)));
  }
  return patches;
}
function moveNodePatch(schema, beforeValue, operation) {
  const patches = [], block = beforeValue[operation.path[0]], targetBlock = beforeValue[operation.newPath[0]];
  if (!targetBlock)
    return patches;
  if (operation.path.length === 1) {
    const position = operation.path[0] > operation.newPath[0] ? "before" : "after";
    patches.push(unset([{
      _key: block._key
    }])), patches.push(insert([block], position, [{
      _key: targetBlock._key
    }]));
  } else if (operation.path.length === 2 && isTextBlock({
    schema
  }, block) && isTextBlock({
    schema
  }, targetBlock)) {
    const child = block.children[operation.path[1]], targetChild = targetBlock.children[operation.newPath[1]], position = operation.newPath[1] === targetBlock.children.length ? "after" : "before", childToInsert = block.children[operation.path[1]];
    patches.push(unset([{
      _key: block._key
    }, "children", {
      _key: child._key
    }])), patches.push(insert([childToInsert], position, [{
      _key: targetBlock._key
    }, "children", {
      _key: targetChild._key
    }]));
  }
  return patches;
}
function pluginWithoutHistory(editor, fn) {
  const prev = editor.withHistory;
  editor.withHistory = !1, fn(), editor.withHistory = prev;
}
function withRemoteChanges(editor, fn) {
  const prev = editor.isProcessingRemoteChanges;
  editor.isProcessingRemoteChanges = !0, fn(), editor.isProcessingRemoteChanges = prev;
}
const debug$8 = debugWithName("plugin:withPatches");
function createWithPatches({
  editorActor,
  relayActor,
  subscriptions
}) {
  let previousValue;
  const applyPatch = createApplyPatch(editorActor.getSnapshot().context);
  return function(editor) {
    previousValue = [...editor.value];
    const {
      apply: apply2
    } = editor;
    let bufferedPatches = [];
    const handleBufferedRemotePatches = () => {
      if (bufferedPatches.length === 0)
        return;
      const patches = bufferedPatches;
      bufferedPatches = [];
      let changed = !1;
      withRemoteChanges(editor, () => {
        Editor.withoutNormalizing(editor, () => {
          withoutPatching(editor, () => {
            pluginWithoutHistory(editor, () => {
              for (const patch of patches) {
                debug$8.enabled && debug$8(`Handling remote patch ${JSON.stringify(patch)}`);
                try {
                  changed = applyPatch(editor, patch);
                } catch (error) {
                  console.error(`Applying patch ${JSON.stringify(patch)} failed due to: ${error.message}`);
                }
              }
            });
          });
        }), changed && (editor.normalize(), editor.onChange());
      });
    }, handlePatches = ({
      patches
    }) => {
      const remotePatches = patches.filter((p) => p.origin !== "local");
      remotePatches.length !== 0 && (bufferedPatches = bufferedPatches.concat(remotePatches), handleBufferedRemotePatches());
    };
    return subscriptions.push(() => {
      debug$8("Subscribing to remote patches");
      const sub = editorActor.on("patches", handlePatches);
      return () => {
        debug$8("Unsubscribing to remote patches"), sub.unsubscribe();
      };
    }), editor.apply = (operation) => {
      let patches = [];
      previousValue = editor.value;
      const editorWasEmpty = isEqualToEmptyEditor(editorActor.getSnapshot().context.initialValue, previousValue, editorActor.getSnapshot().context.schema);
      apply2(operation);
      const editorIsEmpty = isEqualToEmptyEditor(editorActor.getSnapshot().context.initialValue, editor.value, editorActor.getSnapshot().context.schema);
      if (!editor.isPatching)
        return editor;
      switch (editorWasEmpty && !editorIsEmpty && operation.type !== "set_selection" && patches.push(insert(previousValue, "before", [0])), operation.type) {
        case "insert_text":
          patches = [...patches, ...insertTextPatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousValue)];
          break;
        case "remove_text":
          patches = [...patches, ...removeTextPatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousValue)];
          break;
        case "remove_node":
          patches = [...patches, ...removeNodePatch(editorActor.getSnapshot().context.schema, previousValue, operation)];
          break;
        case "split_node":
          patches = [...patches, ...splitNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousValue)];
          break;
        case "insert_node":
          patches = [...patches, ...insertNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousValue)];
          break;
        case "set_node":
          patches = [...patches, ...setNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation)];
          break;
        case "merge_node":
          patches = [...patches, ...mergeNodePatch(editorActor.getSnapshot().context.schema, editor.children, operation, previousValue)];
          break;
        case "move_node":
          patches = [...patches, ...moveNodePatch(editorActor.getSnapshot().context.schema, previousValue, operation)];
          break;
      }
      if (!editorWasEmpty && editorIsEmpty && ["merge_node", "set_node", "remove_text", "remove_node"].includes(operation.type) && (patches = [...patches, unset([])], relayActor.send({
        type: "unset",
        previousValue
      })), editorWasEmpty && patches.length > 0 && (patches = [setIfMissing([], []), ...patches]), patches.length > 0)
        for (const patch of patches)
          editorActor.send({
            type: "internal.patch",
            patch: {
              ...patch,
              origin: "local"
            },
            operationId: editor.undoStepId,
            value: editor.value
          });
      return editor;
    }, editor;
  };
}
const debug$7 = debugWithName("plugin:withSchemaTypes");
function createWithSchema({
  editorActor
}) {
  return function(editor) {
    editor.isTextBlock = (value) => Editor.isEditor(value) ? !1 : isTextBlock(editorActor.getSnapshot().context, value), editor.isTextSpan = (value) => Editor.isEditor(value) ? !1 : isSpan(editorActor.getSnapshot().context, value), editor.isListBlock = (value) => Editor.isEditor(value) ? !1 : isListBlock(editorActor.getSnapshot().context, value), editor.isVoid = (element) => Editor.isEditor(element) ? !1 : editorActor.getSnapshot().context.schema.block.name !== element._type && (editorActor.getSnapshot().context.schema.blockObjects.map((obj) => obj.name).includes(element._type) || editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type)), editor.isInline = (element) => Editor.isEditor(element) ? !1 : editorActor.getSnapshot().context.schema.inlineObjects.map((obj) => obj.name).includes(element._type) && "__inline" in element && element.__inline === !0;
    const {
      normalizeNode
    } = editor;
    return editor.normalizeNode = (entry) => {
      const [node, path] = entry;
      if (node._type === void 0 && path.length === 2) {
        debug$7("Setting span type on text node without a type");
        const span = node, key = span._key || editorActor.getSnapshot().context.keyGenerator();
        withNormalizeNode(editor, () => {
          Transforms.setNodes(editor, {
            ...span,
            _type: editorActor.getSnapshot().context.schema.span.name,
            _key: key
          }, {
            at: path
          });
        });
        return;
      }
      if (node._key === void 0 && (path.length === 1 || path.length === 2)) {
        debug$7("Setting missing key on child node without a key");
        const key = editorActor.getSnapshot().context.keyGenerator();
        withNormalizeNode(editor, () => {
          Transforms.setNodes(editor, {
            _key: key
          }, {
            at: path
          });
        });
        return;
      }
      withNormalizeNode(editor, () => {
        normalizeNode(entry);
      });
    }, editor;
  };
}
function pluginUpdateSelection({
  editor,
  editorActor
}) {
  const updateSelection = () => {
    if (editor.selection)
      if (editor.selection === editor.lastSlateSelection)
        editorActor.send({
          type: "update selection",
          selection: editor.lastSelection
        });
      else {
        const selection = slateRangeToSelection({
          schema: editorActor.getSnapshot().context.schema,
          editor,
          range: editor.selection
        });
        editor.lastSlateSelection = editor.selection, editor.lastSelection = selection, editorActor.send({
          type: "update selection",
          selection
        });
      }
    else
      editorActor.send({
        type: "update selection",
        selection: null
      });
  }, {
    onChange
  } = editor;
  return editor.onChange = () => {
    onChange(), editorActor.getSnapshot().matches({
      setup: "setting up"
    }) || updateSelection();
  }, editor;
}
function isEditorNode(node) {
  return typeof node == "object" && node !== null ? !("_type" in node) && "children" in node && Array.isArray(node.children) : !1;
}
function isTextBlockNode(context, node) {
  return isTypedObject(node) && node._type === context.schema.block.name;
}
function isSpanNode(context, node) {
  return typeof node != "object" || node === null || "children" in node ? !1 : "_type" in node ? node._type === context.schema.span.name : "text" in node;
}
function isPartialSpanNode(node) {
  return typeof node == "object" && node !== null && "text" in node && typeof node.text == "string";
}
function isObjectNode(context, node) {
  return !isEditorNode(node) && !isTextBlockNode(context, node) && !isSpanNode(context, node) && !isPartialSpanNode(node);
}
function getBlock(root, path) {
  const index = path.at(0);
  if (!(index === void 0 || path.length !== 1))
    return root.children.at(index);
}
function getNode(context, root, path) {
  if (path.length === 0)
    return root;
  if (path.length === 1)
    return getBlock(root, path);
  if (path.length === 2) {
    const block = getBlock(root, path.slice(0, 1));
    return !block || !isTextBlockNode(context, block) ? void 0 : block.children.at(path[1]) || void 0;
  }
}
function getSpan(context, root, path) {
  const node = getNode(context, root, path);
  if (node && isSpanNode(context, node))
    return node;
}
function getParent(context, root, path) {
  if (path.length === 0)
    return;
  const parentPath = path.slice(0, -1);
  if (parentPath.length === 0)
    return root;
  const blockIndex = parentPath.at(0);
  if (blockIndex === void 0 || parentPath.length !== 1)
    return;
  const block = root.children.at(blockIndex);
  if (block && isTextBlockNode(context, block))
    return block;
}
function applyOperationToPortableText(context, value, operation) {
  const root = {
    children: value
  };
  try {
    return applyOperationToPortableTextImmutable(context, root, operation).children;
  } catch (e) {
    return console.error(e), value;
  }
}
function applyOperationToPortableTextImmutable(context, root, operation) {
  switch (operation.type) {
    case "insert_node": {
      const {
        path,
        node: insertedNode
      } = operation, parent = getParent(context, root, path), index = path[path.length - 1];
      if (!parent || index > parent.children.length)
        return root;
      if (path.length === 1) {
        if (isTextBlockNode(context, insertedNode)) {
          const newBlock = {
            ...insertedNode,
            children: insertedNode.children.map((child) => "__inline" in child ? {
              _key: child._key,
              _type: child._type,
              ..."value" in child && typeof child.value == "object" ? child.value : {}
            } : child)
          };
          return {
            ...root,
            children: insertChildren(root.children, index, newBlock)
          };
        }
        if (Element$1.isElement(insertedNode) && !("__inline" in insertedNode)) {
          const newBlock = {
            _key: insertedNode._key,
            _type: insertedNode._type,
            ..."value" in insertedNode && typeof insertedNode.value == "object" ? insertedNode.value : {}
          };
          return {
            ...root,
            children: insertChildren(root.children, index, newBlock)
          };
        }
      }
      if (path.length === 2) {
        const blockIndex = path[0];
        if (!isTextBlockNode(context, parent))
          return root;
        let newChild;
        if (isPartialSpanNode(insertedNode))
          newChild = insertedNode;
        else if ("__inline" in insertedNode)
          newChild = {
            _key: insertedNode._key,
            _type: insertedNode._type,
            ..."value" in insertedNode && typeof insertedNode.value == "object" ? insertedNode.value : {}
          };
        else
          return root;
        return updateTextBlockAtIndex(context, root, blockIndex, (block) => ({
          ...block,
          children: insertChildren(block.children, index, newChild)
        }));
      }
      return root;
    }
    case "insert_text": {
      const {
        path,
        offset,
        text
      } = operation;
      if (text.length === 0)
        return root;
      const span = getSpan(context, root, path);
      if (!span)
        return root;
      const blockIndex = path[0], childIndex = path[1], before = span.text.slice(0, offset), after = span.text.slice(offset), newSpan = {
        ...span,
        text: before + text + after
      };
      return updateTextBlockAtIndex(context, root, blockIndex, (block) => ({
        ...block,
        children: replaceChild(block.children, childIndex, newSpan)
      }));
    }
    case "merge_node": {
      const {
        path
      } = operation;
      if (path.at(-1) === 0)
        return root;
      const node = getNode(context, root, path), prevPath = Path.previous(path), prev = getNode(context, root, prevPath), parent = getParent(context, root, path);
      if (!node || !prev || !parent)
        return root;
      const index = path[path.length - 1];
      if (isPartialSpanNode(node) && isPartialSpanNode(prev)) {
        const blockIndex = path[0], newPrev = {
          ...prev,
          text: prev.text + node.text
        };
        return updateTextBlockAtIndex(context, root, blockIndex, (block) => {
          const newChildren = replaceChild(block.children, index - 1, newPrev);
          return {
            ...block,
            children: removeChildren(newChildren, index)
          };
        });
      }
      if (isTextBlockNode(context, node) && isTextBlockNode(context, prev)) {
        const newPrev = {
          ...prev,
          children: [...prev.children, ...node.children]
        }, newChildren = replaceChild(root.children, index - 1, newPrev);
        return {
          ...root,
          children: removeChildren(newChildren, index)
        };
      }
      return root;
    }
    case "move_node": {
      const {
        path,
        newPath
      } = operation;
      if (Path.isAncestor(path, newPath))
        return root;
      const node = getNode(context, root, path), parent = getParent(context, root, path), index = path[path.length - 1];
      if (!node || !parent)
        return root;
      let newRoot;
      if (path.length === 1)
        newRoot = {
          ...root,
          children: removeChildren(root.children, index)
        };
      else if (path.length === 2) {
        const blockIndex = path[0];
        newRoot = updateTextBlockAtIndex(context, root, blockIndex, (block) => ({
          ...block,
          children: removeChildren(block.children, index)
        }));
      } else
        return root;
      const truePath = Path.transform(path, operation), newIndex = truePath[truePath.length - 1];
      if (truePath.length === 1)
        return {
          ...newRoot,
          children: insertChildren(newRoot.children, newIndex, node)
        };
      if (truePath.length === 2) {
        const newBlockIndex = truePath[0], newParent = newRoot.children[newBlockIndex];
        return !newParent || !isTextBlockNode(context, newParent) ? root : updateTextBlockAtIndex(context, newRoot, newBlockIndex, (block) => ({
          ...block,
          children: insertChildren(block.children, newIndex, node)
        }));
      }
      return root;
    }
    case "remove_node": {
      const {
        path
      } = operation, index = path[path.length - 1];
      if (!getParent(context, root, path))
        return root;
      if (path.length === 1)
        return {
          ...root,
          children: removeChildren(root.children, index)
        };
      if (path.length === 2) {
        const blockIndex = path[0];
        return updateTextBlockAtIndex(context, root, blockIndex, (block) => ({
          ...block,
          children: removeChildren(block.children, index)
        }));
      }
      return root;
    }
    case "remove_text": {
      const {
        path,
        offset,
        text
      } = operation;
      if (text.length === 0)
        return root;
      const span = getSpan(context, root, path);
      if (!span)
        return root;
      const blockIndex = path[0], childIndex = path[1], before = span.text.slice(0, offset), after = span.text.slice(offset + text.length), newSpan = {
        ...span,
        text: before + after
      };
      return updateTextBlockAtIndex(context, root, blockIndex, (block) => ({
        ...block,
        children: replaceChild(block.children, childIndex, newSpan)
      }));
    }
    case "set_node": {
      const {
        path,
        properties,
        newProperties
      } = operation, node = getNode(context, root, path);
      if (!node || isEditorNode(node))
        return root;
      if (isObjectNode(context, node)) {
        const valueBefore = "value" in properties && typeof properties.value == "object" ? properties.value : {}, valueAfter = "value" in newProperties && typeof newProperties.value == "object" ? newProperties.value : {}, newNode = {
          ...node
        };
        for (const key in newProperties) {
          if (key === "value")
            continue;
          const value = newProperties[key];
          value == null ? delete newNode[key] : newNode[key] = value;
        }
        for (const key in properties)
          key !== "value" && (newProperties.hasOwnProperty(key) || delete newNode[key]);
        for (const key in valueAfter) {
          const value = valueAfter[key];
          value == null ? delete newNode[key] : newNode[key] = value;
        }
        for (const key in valueBefore)
          valueAfter.hasOwnProperty(key) || delete newNode[key];
        return path.length === 1 ? {
          ...root,
          children: replaceChild(root.children, path[0], newNode)
        } : path.length === 2 ? updateTextBlockAtIndex(context, root, path[0], (block) => ({
          ...block,
          children: replaceChild(block.children, path[1], newNode)
        })) : root;
      }
      if (isTextBlockNode(context, node)) {
        const newNode = {
          ...node
        };
        for (const key in newProperties) {
          if (key === "children" || key === "text")
            continue;
          const value = newProperties[key];
          value == null ? delete newNode[key] : newNode[key] = value;
        }
        for (const key in properties)
          newProperties.hasOwnProperty(key) || delete newNode[key];
        return {
          ...root,
          children: replaceChild(root.children, path[0], newNode)
        };
      }
      if (isPartialSpanNode(node)) {
        const newNode = {
          ...node
        };
        for (const key in newProperties) {
          if (key === "text")
            continue;
          const value = newProperties[key];
          value == null ? delete newNode[key] : newNode[key] = value;
        }
        for (const key in properties)
          newProperties.hasOwnProperty(key) || delete newNode[key];
        return updateTextBlockAtIndex(context, root, path[0], (block) => ({
          ...block,
          children: replaceChild(block.children, path[1], newNode)
        }));
      }
      return root;
    }
    case "split_node": {
      const {
        path,
        position,
        properties
      } = operation;
      if (path.length === 0)
        return root;
      const parent = getParent(context, root, path), index = path[path.length - 1];
      if (!parent)
        return root;
      if (isEditorNode(parent)) {
        const block = getBlock(root, path);
        if (!block || !isTextBlockNode(context, block))
          return root;
        const before = block.children.slice(0, position), after = block.children.slice(position), updatedTextBlockNode = {
          ...block,
          children: before
        }, newTextBlockNode = {
          ...properties,
          children: after,
          _type: context.schema.block.name
        };
        return {
          ...root,
          children: insertChildren(replaceChild(root.children, index, updatedTextBlockNode), index + 1, newTextBlockNode)
        };
      }
      if (isTextBlockNode(context, parent)) {
        const node = getNode(context, root, path);
        if (!node || !isSpanNode(context, node))
          return root;
        const blockIndex = path[0], before = node.text.slice(0, position), after = node.text.slice(position), updatedSpanNode = {
          ...node,
          text: before
        }, newSpanNode = {
          ...properties,
          text: after
        };
        return updateTextBlockAtIndex(context, root, blockIndex, (block) => ({
          ...block,
          children: insertChildren(replaceChild(block.children, index, updatedSpanNode), index + 1, newSpanNode)
        }));
      }
      return root;
    }
  }
}
function insertChildren(children, index, ...nodes) {
  return [...children.slice(0, index), ...nodes, ...children.slice(index)];
}
function removeChildren(children, index, count = 1) {
  return [...children.slice(0, index), ...children.slice(index + count)];
}
function replaceChild(children, index, newChild) {
  return [...children.slice(0, index), newChild, ...children.slice(index + 1)];
}
function updateTextBlockAtIndex(context, root, blockIndex, updater) {
  const block = root.children.at(blockIndex);
  if (!block || !isTextBlockNode(context, block))
    return root;
  const newBlock = updater(block);
  return {
    ...root,
    children: replaceChild(root.children, blockIndex, newBlock)
  };
}
function pluginUpdateValue(context, editor) {
  const {
    apply: apply2
  } = editor;
  return editor.apply = (operation) => {
    if (operation.type === "set_selection") {
      apply2(operation);
      return;
    }
    if (editor.value = applyOperationToPortableText(context, editor.value, operation), operation.type === "insert_text" || operation.type === "remove_text") {
      apply2(operation);
      return;
    }
    buildIndexMaps({
      schema: context.schema,
      value: editor.value
    }, {
      blockIndexMap: editor.blockIndexMap,
      listIndexMap: editor.listIndexMap
    }), apply2(operation);
  }, editor;
}
const withPlugins = (editor, options) => {
  const e = editor, {
    editorActor,
    relayActor
  } = options, withObjectKeys = createWithObjectKeys(editorActor), withSchema = createWithSchema({
    editorActor
  }), withPatches = createWithPatches({
    editorActor,
    relayActor,
    subscriptions: options.subscriptions
  }), withUndoRedo = pluginHistory({
    editorActor,
    subscriptions: options.subscriptions
  }), withNormalize = createWithNormalize(editorActor);
  return createWithEventListeners(editorActor)(withSchema(withObjectKeys(withNormalize(withUndoRedo(withPatches(pluginUpdateValue(editorActor.getSnapshot().context, pluginUpdateSelection({
    editorActor,
    editor: e
  }))))))));
}, debug$6 = debugWithName("setup");
function createSlateEditor(config) {
  debug$6("Creating new Slate editor instance");
  const placeholderBlock = createPlaceholderBlock(config.editorActor.getSnapshot().context), editor = createEditor();
  editor.decoratedRanges = [], editor.decoratorState = {}, editor.blockIndexMap = /* @__PURE__ */ new Map(), editor.history = {
    undos: [],
    redos: []
  }, editor.lastSelection = null, editor.lastSlateSelection = null, editor.listIndexMap = /* @__PURE__ */ new Map(), editor.remotePatches = [], editor.undoStepId = void 0, editor.value = [placeholderBlock], editor.isDeferringMutations = !1, editor.isNormalizingNode = !1, editor.isPatching = !0, editor.isPerformingBehaviorOperation = !1, editor.isProcessingRemoteChanges = !1, editor.isRedoing = !1, editor.isUndoing = !1, editor.withHistory = !0;
  const instance = withPlugins(withReact(editor), {
    editorActor: config.editorActor,
    relayActor: config.relayActor,
    subscriptions: config.subscriptions
  });
  return buildIndexMaps({
    schema: config.editorActor.getSnapshot().context.schema,
    value: instance.value
  }, {
    blockIndexMap: instance.blockIndexMap,
    listIndexMap: instance.listIndexMap
  }), {
    instance,
    initialValue: [placeholderBlock]
  };
}
function createEditorDom(sendBack, slateEditor) {
  return {
    getBlockNodes: (snapshot) => getBlockNodes(slateEditor, snapshot),
    getChildNodes: (snapshot) => getChildNodes(slateEditor, snapshot),
    getEditorElement: () => getEditorElement(slateEditor),
    getSelectionRect: (snapshot) => getSelectionRect(snapshot),
    getStartBlockElement: (snapshot) => getStartBlockElement(slateEditor, snapshot),
    getEndBlockElement: (snapshot) => getEndBlockElement(slateEditor, snapshot),
    setDragGhost: ({
      event,
      ghost
    }) => setDragGhost({
      sendBack,
      event,
      ghost
    })
  };
}
function getBlockNodes(slateEditor, snapshot) {
  if (!snapshot.context.selection)
    return [];
  const range = toSlateRange(snapshot);
  if (!range)
    return [];
  try {
    return Array.from(Editor.nodes(slateEditor, {
      at: range,
      mode: "highest",
      match: (n) => !Editor.isEditor(n)
    })).map(([blockNode]) => DOMEditor.toDOMNode(slateEditor, blockNode));
  } catch {
    return [];
  }
}
function getChildNodes(slateEditor, snapshot) {
  if (!snapshot.context.selection)
    return [];
  const range = toSlateRange(snapshot);
  if (!range)
    return [];
  try {
    return Array.from(Editor.nodes(slateEditor, {
      at: range,
      mode: "lowest",
      match: (n) => !Editor.isEditor(n)
    })).map(([childNode]) => DOMEditor.toDOMNode(slateEditor, childNode));
  } catch {
    return [];
  }
}
function getEditorElement(slateEditor) {
  try {
    return DOMEditor.toDOMNode(slateEditor, slateEditor);
  } catch {
    return;
  }
}
function getSelectionRect(snapshot) {
  if (!snapshot.context.selection)
    return null;
  try {
    const selection = window.getSelection();
    return selection ? selection.getRangeAt(0).getBoundingClientRect() : null;
  } catch {
    return null;
  }
}
function getStartBlockElement(slateEditor, snapshot) {
  const startBlock = getSelectionStartBlock(snapshot);
  if (!startBlock)
    return null;
  const startBlockNode = getBlockNodes(slateEditor, {
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: {
        anchor: {
          path: startBlock.path,
          offset: 0
        },
        focus: {
          path: startBlock.path,
          offset: 0
        }
      }
    }
  })?.at(0);
  return startBlockNode && startBlockNode instanceof Element ? startBlockNode : null;
}
function getEndBlockElement(slateEditor, snapshot) {
  const endBlock = getSelectionEndBlock(snapshot);
  if (!endBlock)
    return null;
  const endBlockNode = getBlockNodes(slateEditor, {
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: {
        anchor: {
          path: endBlock.path,
          offset: 0
        },
        focus: {
          path: endBlock.path,
          offset: 0
        }
      }
    }
  })?.at(0);
  return endBlockNode && endBlockNode instanceof Element ? endBlockNode : null;
}
function setDragGhost({
  sendBack,
  event,
  ghost
}) {
  event.originEvent.dataTransfer.setDragImage(ghost.element, ghost.x, ghost.y), sendBack({
    type: "set drag ghost",
    ghost: ghost.element
  });
}
const addAnnotationOnCollapsedSelection = defineBehavior({
  on: "annotation.add",
  guard: ({
    snapshot
  }) => {
    if (!isSelectionCollapsed$1(snapshot))
      return !1;
    const caretWordSelection = getCaretWordSelection(snapshot);
    return !caretWordSelection || !isSelectionExpanded({
      context: {
        ...snapshot.context,
        selection: caretWordSelection
      }
    }) ? !1 : {
      caretWordSelection
    };
  },
  actions: [({
    event
  }, {
    caretWordSelection
  }) => [raise({
    type: "select",
    at: caretWordSelection
  }), raise({
    type: "annotation.add",
    annotation: event.annotation
  })]]
}), preventOverlappingAnnotations = defineBehavior({
  // Given an `annotation.add` event
  on: "annotation.add",
  // When the annotation is active in the selection
  guard: ({
    snapshot,
    event
  }) => isActiveAnnotation(event.annotation.name, {
    mode: "partial"
  })(snapshot),
  // Then the existing annotation is removed
  actions: [({
    event
  }) => [raise({
    type: "annotation.remove",
    annotation: event.annotation
  }), raise(event)]]
}), stripAnnotationsOnFullSpanDeletion = defineBehavior({
  on: "delete",
  guard: ({
    snapshot,
    event
  }) => {
    const effectiveSnapshot = {
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: event.at ?? snapshot.context.selection
      }
    };
    if (!isSelectionExpanded(effectiveSnapshot))
      return !1;
    const startChild = getSelectionStartChild(effectiveSnapshot), startPoint = getSelectionStartPoint(effectiveSnapshot), endChild = getSelectionEndChild(effectiveSnapshot), endPoint = getSelectionEndPoint(effectiveSnapshot);
    if (!startChild || !endChild || !startPoint || !endPoint || startChild.path[2]._key !== endChild.path[2]._key || !isSpan(snapshot.context, startChild.node) || !(startPoint.offset === 0 && endPoint.offset === startChild.node.text.length))
      return !1;
    const decorators = snapshot.context.schema.decorators.map((decorator) => decorator.name), marks = startChild.node.marks ?? [];
    if (!marks.some((mark) => !decorators.includes(mark)))
      return !1;
    const previousSpan = getPreviousSpan(effectiveSnapshot), nextSpan = getNextSpan(effectiveSnapshot), previousSpanHasSameAnnotation = previousSpan ? previousSpan.node.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1, nextSpanHasSameAnnotation = nextSpan ? nextSpan.node.marks?.some((mark) => !decorators.includes(mark) && marks.includes(mark)) : !1;
    if (previousSpanHasSameAnnotation || nextSpanHasSameAnnotation)
      return !1;
    const activeDecorators = getActiveDecorators(effectiveSnapshot);
    return {
      spanPath: startChild.path,
      activeDecorators
    };
  },
  actions: [({
    event
  }, {
    spanPath,
    activeDecorators
  }) => [raise({
    type: "child.set",
    at: spanPath,
    props: {
      marks: activeDecorators
    }
  }), forward(event)]]
}), coreAnnotationBehaviors = [addAnnotationOnCollapsedSelection, preventOverlappingAnnotations, stripAnnotationsOnFullSpanDeletion], defaultKeyboardShortcuts = {
  arrowDown: createKeyboardShortcut({
    default: [{
      key: "ArrowDown",
      alt: !1,
      ctrl: !1,
      meta: !1,
      shift: !1
    }]
  }),
  arrowUp: createKeyboardShortcut({
    default: [{
      key: "ArrowUp",
      alt: !1,
      ctrl: !1,
      meta: !1,
      shift: !1
    }]
  }),
  backspace: createKeyboardShortcut({
    default: [{
      key: "Backspace",
      alt: !1,
      ctrl: !1,
      meta: !1,
      shift: !1
    }]
  }),
  break: createKeyboardShortcut({
    default: [{
      key: "Enter",
      shift: !1
    }]
  }),
  lineBreak: createKeyboardShortcut({
    default: [{
      key: "Enter",
      shift: !0
    }]
  }),
  decorators: {
    strong: bold,
    em: italic,
    underline,
    code
  },
  delete: createKeyboardShortcut({
    default: [{
      key: "Delete",
      alt: !1,
      ctrl: !1,
      meta: !1,
      shift: !1
    }]
  }),
  deleteWord: {
    backward: createKeyboardShortcut({
      default: [{
        key: "Backspace",
        alt: !1,
        ctrl: !0,
        meta: !1
        // shift is optional
      }],
      apple: [{
        key: "Backspace",
        alt: !0,
        ctrl: !1,
        meta: !1
        // shift is optional
      }]
    }),
    forward: createKeyboardShortcut({
      default: [{
        key: "Delete",
        alt: !1,
        ctrl: !0,
        meta: !1
        // shift is optional
      }],
      apple: [{
        key: "Delete",
        alt: !0,
        ctrl: !1,
        meta: !1
        // shift is optional
      }]
    })
  },
  history: {
    undo,
    redo
  },
  tab: createKeyboardShortcut({
    default: [{
      key: "Tab",
      alt: !1,
      ctrl: !1,
      meta: !1,
      shift: !1
    }]
  }),
  shiftTab: createKeyboardShortcut({
    default: [{
      key: "Tab",
      alt: !1,
      ctrl: !1,
      meta: !1,
      shift: !0
    }]
  })
}, arrowDownOnLonelyBlockObject = defineBehavior({
  on: "keyboard.keydown",
  guard: ({
    snapshot,
    event
  }) => {
    if (!defaultKeyboardShortcuts.arrowDown.guard(event.originEvent) || !isSelectionCollapsed$1(snapshot))
      return !1;
    const focusBlockObject = getFocusBlockObject(snapshot), nextBlock = getNextBlock(snapshot);
    return focusBlockObject && !nextBlock;
  },
  actions: [({
    snapshot
  }) => [raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name
    },
    placement: "after"
  })]]
}), arrowUpOnLonelyBlockObject = defineBehavior({
  on: "keyboard.keydown",
  guard: ({
    snapshot,
    event
  }) => {
    if (!defaultKeyboardShortcuts.arrowUp.guard(event.originEvent) || !isSelectionCollapsed$1(snapshot))
      return !1;
    const focusBlockObject = getFocusBlockObject(snapshot), previousBlock = getPreviousBlock(snapshot);
    return focusBlockObject && !previousBlock;
  },
  actions: [({
    snapshot
  }) => [raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name
    },
    placement: "before"
  })]]
}), breakingBlockObject = defineBehavior({
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const focusBlockObject = getFocusBlockObject(snapshot);
    return isSelectionCollapsed$1(snapshot) && focusBlockObject !== void 0;
  },
  actions: [({
    snapshot
  }) => [raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name
    },
    placement: "after"
  })]]
}), clickingAboveLonelyBlockObject = defineBehavior({
  on: "mouse.click",
  guard: ({
    snapshot,
    event
  }) => {
    if (snapshot.context.readOnly || snapshot.context.selection && !isSelectionCollapsed$1(snapshot))
      return !1;
    const focusBlockObject = getFocusBlockObject({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: event.position.selection
      }
    }), previousBlock = getPreviousBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: event.position.selection
      }
    });
    return event.position.isEditor && event.position.block === "start" && focusBlockObject && !previousBlock;
  },
  actions: [({
    snapshot,
    event
  }) => [raise({
    type: "select",
    at: event.position.selection
  }), raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name
    },
    placement: "before",
    select: "start"
  })]]
}), clickingBelowLonelyBlockObject = defineBehavior({
  on: "mouse.click",
  guard: ({
    snapshot,
    event
  }) => {
    if (snapshot.context.readOnly || snapshot.context.selection && !isSelectionCollapsed$1(snapshot))
      return !1;
    const focusBlockObject = getFocusBlockObject({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: event.position.selection
      }
    }), nextBlock = getNextBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: event.position.selection
      }
    });
    return event.position.isEditor && event.position.block === "end" && focusBlockObject && !nextBlock;
  },
  actions: [({
    snapshot,
    event
  }) => [raise({
    type: "select",
    at: event.position.selection
  }), raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name
    },
    placement: "after",
    select: "start"
  })]]
}), deletingEmptyTextBlockAfterBlockObject = defineBehavior({
  on: "delete.backward",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = getFocusTextBlock(snapshot), selectionCollapsed = isSelectionCollapsed$1(snapshot), previousBlock = getPreviousBlock(snapshot);
    return !focusTextBlock || !selectionCollapsed || !previousBlock ? !1 : isEmptyTextBlock(snapshot.context, focusTextBlock.node) && !isTextBlock(snapshot.context, previousBlock.node) ? {
      focusTextBlock,
      previousBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    previousBlock
  }) => [raise({
    type: "delete.block",
    at: focusTextBlock.path
  }), raise({
    type: "select",
    at: {
      anchor: {
        path: previousBlock.path,
        offset: 0
      },
      focus: {
        path: previousBlock.path,
        offset: 0
      }
    }
  })]]
}), deletingEmptyTextBlockBeforeBlockObject = defineBehavior({
  on: "delete.forward",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = getFocusTextBlock(snapshot), selectionCollapsed = isSelectionCollapsed$1(snapshot), nextBlock = getNextBlock(snapshot);
    return !focusTextBlock || !selectionCollapsed || !nextBlock ? !1 : isEmptyTextBlock(snapshot.context, focusTextBlock.node) && !isTextBlock(snapshot.context, nextBlock.node) ? {
      focusTextBlock,
      nextBlock
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    nextBlock
  }) => [raise({
    type: "delete.block",
    at: focusTextBlock.path
  }), raise({
    type: "select",
    at: {
      anchor: {
        path: nextBlock.path,
        offset: 0
      },
      focus: {
        path: nextBlock.path,
        offset: 0
      }
    }
  })]]
}), coreBlockObjectBehaviors = {
  arrowDownOnLonelyBlockObject,
  arrowUpOnLonelyBlockObject,
  breakingBlockObject,
  clickingAboveLonelyBlockObject,
  clickingBelowLonelyBlockObject,
  deletingEmptyTextBlockAfterBlockObject,
  deletingEmptyTextBlockBeforeBlockObject
}, coreDecoratorBehaviors = {
  strongShortcut: defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.decorators.strong.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === "strong"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "strong"
    })]]
  }),
  emShortcut: defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.decorators.em.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === "em"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "em"
    })]]
  }),
  underlineShortcut: defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.decorators.underline.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === "underline"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "underline"
    })]]
  }),
  codeShortcut: defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.decorators.code.guard(event.originEvent) && snapshot.context.schema.decorators.some((decorator) => decorator.name === "code"),
    actions: [() => [raise({
      type: "decorator.toggle",
      decorator: "code"
    })]]
  })
};
function getCompoundClientRect(nodes) {
  if (nodes.length === 0)
    return new DOMRect(0, 0, 0, 0);
  const elements = nodes.filter((node) => node instanceof Element), firstRect = elements.at(0)?.getBoundingClientRect();
  if (!firstRect)
    return new DOMRect(0, 0, 0, 0);
  let left = firstRect.left, top = firstRect.top, right = firstRect.right, bottom = firstRect.bottom;
  for (let i = 1; i < elements.length; i++) {
    const rect = elements[i].getBoundingClientRect();
    left = Math.min(left, rect.left), top = Math.min(top, rect.top), right = Math.max(right, rect.right), bottom = Math.max(bottom, rect.bottom);
  }
  return new DOMRect(left, top, right - left, bottom - top);
}
const coreDndBehaviors = [
  /**
   * Core Behavior that:
   * 1. Calculates and selects a "drag selection"
   * 2. Constructs and sets a drag ghost element
   * 3. Forwards the dragstart event
   */
  defineBehavior({
    on: "drag.dragstart",
    guard: ({
      snapshot,
      dom,
      event
    }) => {
      const dragSelection = getDragSelection({
        snapshot,
        eventSelection: event.position.selection
      }), selectingEntireBlocks = isSelectingEntireBlocks({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragSelection
        }
      }), draggedDomNodes = {
        blockNodes: dom.getBlockNodes({
          ...snapshot,
          context: {
            ...snapshot.context,
            selection: dragSelection
          }
        }),
        childNodes: dom.getChildNodes({
          ...snapshot,
          context: {
            ...snapshot.context,
            selection: dragSelection
          }
        })
      };
      return {
        dragSelection,
        draggedDomNodes,
        selectingEntireBlocks
      };
    },
    actions: [({
      dom,
      event
    }, {
      dragSelection,
      draggedDomNodes,
      selectingEntireBlocks
    }) => {
      const dragGhost = document.createElement("div");
      if (selectingEntireBlocks) {
        const clonedBlockNodes = draggedDomNodes.blockNodes.map((node) => node.cloneNode(!0));
        for (const block of clonedBlockNodes)
          block instanceof HTMLElement && (block.style.position = "relative"), dragGhost.appendChild(block);
        const customGhost = dragGhost.querySelector("[data-pt-drag-ghost-element]");
        if (customGhost && dragGhost.replaceChildren(customGhost), dragGhost.setAttribute("data-dragged", ""), dragGhost.style.position = "absolute", dragGhost.style.left = "-99999px", dragGhost.style.boxSizing = "border-box", document.body.appendChild(dragGhost), customGhost) {
          const customGhostRect = customGhost.getBoundingClientRect(), x = event.originEvent.clientX - customGhostRect.left, y = event.originEvent.clientY - customGhostRect.top;
          return dragGhost.style.width = `${customGhostRect.width}px`, dragGhost.style.height = `${customGhostRect.height}px`, [raise({
            type: "select",
            at: dragSelection
          }), effect(() => {
            dom.setDragGhost({
              event,
              ghost: {
                element: dragGhost,
                x,
                y
              }
            });
          }), forward(event)];
        } else {
          const blocksDomRect = getCompoundClientRect(draggedDomNodes.blockNodes), x = event.originEvent.clientX - blocksDomRect.left, y = event.originEvent.clientY - blocksDomRect.top;
          return dragGhost.style.width = `${blocksDomRect.width}px`, dragGhost.style.height = `${blocksDomRect.height}px`, [raise({
            type: "select",
            at: dragSelection
          }), effect(() => {
            dom.setDragGhost({
              event,
              ghost: {
                element: dragGhost,
                x,
                y
              }
            });
          }), forward(event)];
        }
      } else {
        const clonedChildNodes = draggedDomNodes.childNodes.map((node) => node.cloneNode(!0));
        for (const child of clonedChildNodes)
          dragGhost.appendChild(child);
        dragGhost.style.position = "absolute", dragGhost.style.left = "-99999px", dragGhost.style.boxSizing = "border-box", document.body.appendChild(dragGhost);
        const childrenDomRect = getCompoundClientRect(draggedDomNodes.childNodes), x = event.originEvent.clientX - childrenDomRect.left, y = event.originEvent.clientY - childrenDomRect.top;
        return dragGhost.style.width = `${childrenDomRect.width}px`, dragGhost.style.height = `${childrenDomRect.height}px`, [raise({
          type: "select",
          at: dragSelection
        }), effect(() => {
          dom.setDragGhost({
            event,
            ghost: {
              element: dragGhost,
              x,
              y
            }
          });
        }), forward(event)];
      }
    }]
  }),
  /**
   * When dragging over the drag origin, we don't want to show the caret in the
   * text.
   */
  defineBehavior({
    on: "drag.dragover",
    guard: ({
      snapshot,
      event
    }) => {
      const dragOrigin = event.dragOrigin;
      return dragOrigin ? isOverlappingSelection(event.position.selection)({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragOrigin.selection
        }
      }) : !1;
    },
    actions: []
  }),
  /**
   * If the drop position overlaps the drag origin, then the event should be
   * cancelled.
   */
  defineBehavior({
    on: "drag.drop",
    guard: ({
      snapshot,
      event
    }) => {
      const dragOrigin = event.dragOrigin, dropPosition = event.position.selection;
      return dragOrigin ? isOverlappingSelection(dropPosition)({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragOrigin.selection
        }
      }) : !1;
    },
    actions: []
  }),
  /**
   * If we drop and have access to a drag origin, then we can deserialize
   * without creating a new selection.
   */
  defineBehavior({
    on: "drag.drop",
    guard: ({
      event
    }) => event.dragOrigin !== void 0,
    actions: [({
      event
    }) => [raise({
      type: "deserialize",
      originEvent: event
    })]]
  }),
  /**
   * Otherwise, we should to create a new selection.
   */
  defineBehavior({
    on: "drag.drop",
    actions: [({
      event
    }) => [raise({
      type: "select",
      at: event.position.selection
    }), raise({
      type: "deserialize",
      originEvent: event
    })]]
  }),
  /**
   * Core Behavior that uses the drag origin to mimic a move operation during
   * internal dragging.
   */
  defineBehavior({
    on: "deserialization.success",
    guard: ({
      snapshot,
      event
    }) => {
      if (event.originEvent.type !== "drag.drop" || event.originEvent.dragOrigin === void 0)
        return !1;
      const dragOrigin = event.originEvent.dragOrigin, dragSelection = getDragSelection({
        eventSelection: dragOrigin.selection,
        snapshot
      }), dropPosition = event.originEvent.position.selection, droppingOnDragOrigin = dragOrigin ? isOverlappingSelection(dropPosition)({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragSelection
        }
      }) : !1, draggingEntireBlocks = isSelectingEntireBlocks({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragSelection
        }
      }), draggedBlocks = getSelectedBlocks({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: dragSelection
        }
      });
      return droppingOnDragOrigin ? !1 : {
        dropPosition,
        draggingEntireBlocks,
        draggedBlocks,
        dragOrigin,
        originEvent: event.originEvent
      };
    },
    actions: [({
      event
    }, {
      draggingEntireBlocks,
      draggedBlocks,
      dragOrigin,
      dropPosition,
      originEvent
    }) => [raise({
      type: "select",
      at: dropPosition
    }), ...draggingEntireBlocks ? draggedBlocks.map((block) => raise({
      type: "delete.block",
      at: block.path
    })) : [raise({
      type: "delete",
      at: dragOrigin.selection
    })], raise({
      type: "insert.blocks",
      blocks: event.data,
      placement: draggingEntireBlocks ? originEvent.position.block === "start" ? "before" : originEvent.position.block === "end" ? "after" : "auto" : "auto"
    })]]
  })
], coreInsertBehaviors = [defineBehavior({
  on: "insert.text",
  guard: ({
    snapshot
  }) => {
    if (!getFocusSpan$1(snapshot))
      return !1;
    const markState = getMarkState(snapshot), activeDecorators = getActiveDecorators(snapshot), activeAnnotations = getActiveAnnotationsMarks(snapshot);
    if (markState && markState.state === "unchanged") {
      const markStateDecorators = (markState.marks ?? []).filter((mark) => snapshot.context.schema.decorators.map((decorator) => decorator.name).includes(mark));
      if (markStateDecorators.length === activeDecorators.length && markStateDecorators.every((mark) => activeDecorators.includes(mark)))
        return !1;
    }
    return {
      activeDecorators,
      activeAnnotations
    };
  },
  actions: [({
    snapshot,
    event
  }, {
    activeDecorators,
    activeAnnotations
  }) => [raise({
    type: "insert.child",
    child: {
      _type: snapshot.context.schema.span.name,
      text: event.text,
      marks: [...activeDecorators, ...activeAnnotations]
    }
  })]]
})], breakingAtTheEndOfTextBlock = defineBehavior({
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = getFocusTextBlock(snapshot), selectionCollapsed = isSelectionCollapsed$1(snapshot);
    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)
      return !1;
    const atTheEndOfBlock = isAtTheEndOfBlock(focusTextBlock)(snapshot), focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
    return atTheEndOfBlock ? {
      focusListItem,
      focusLevel
    } : !1;
  },
  actions: [({
    snapshot
  }, {
    focusListItem,
    focusLevel
  }) => [raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name,
      children: [{
        _type: snapshot.context.schema.span.name,
        text: "",
        marks: []
      }],
      markDefs: [],
      listItem: focusListItem,
      level: focusLevel,
      style: snapshot.context.schema.styles[0]?.name
    },
    placement: "after"
  })]]
}), breakingAtTheStartOfTextBlock = defineBehavior({
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = getFocusTextBlock(snapshot), selectionCollapsed = isSelectionCollapsed$1(snapshot);
    if (!snapshot.context.selection || !focusTextBlock || !selectionCollapsed)
      return !1;
    const focusSpan = getFocusSpan$1(snapshot), focusDecorators = focusSpan?.node.marks?.filter((mark) => snapshot.context.schema.decorators.some((decorator) => decorator.name === mark) ?? []), focusAnnotations = focusSpan?.node.marks?.filter((mark) => !snapshot.context.schema.decorators.some((decorator) => decorator.name === mark)) ?? [], focusListItem = focusTextBlock.node.listItem, focusLevel = focusTextBlock.node.level;
    return isAtTheStartOfBlock(focusTextBlock)(snapshot) ? {
      focusAnnotations,
      focusDecorators,
      focusListItem,
      focusLevel
    } : !1;
  },
  actions: [({
    snapshot
  }, {
    focusAnnotations,
    focusDecorators,
    focusListItem,
    focusLevel
  }) => [raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name,
      children: [{
        _type: snapshot.context.schema.span.name,
        marks: focusAnnotations.length === 0 ? focusDecorators : [],
        text: ""
      }],
      listItem: focusListItem,
      level: focusLevel,
      style: snapshot.context.schema.styles[0]?.name
    },
    placement: "before",
    select: "none"
  })]]
}), breakingEntireBlocks = defineBehavior({
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    if (!snapshot.context.selection || !isSelectionExpanded(snapshot))
      return !1;
    const selectedBlocks = getSelectedBlocks(snapshot), selectionStartBlock = getSelectionStartBlock(snapshot), selectionEndBlock = getSelectionEndBlock(snapshot);
    if (!selectionStartBlock || !selectionEndBlock)
      return !1;
    const startBlockStartPoint = getBlockStartPoint({
      context: snapshot.context,
      block: selectionStartBlock
    }), selectionStartPoint = getSelectionStartPoint$1(snapshot.context.selection), endBlockEndPoint = getBlockEndPoint({
      context: snapshot.context,
      block: selectionEndBlock
    }), selectionEndPoint = getSelectionEndPoint$1(snapshot.context.selection);
    return isEqualSelectionPoints(selectionStartPoint, startBlockStartPoint) && isEqualSelectionPoints(selectionEndPoint, endBlockEndPoint) ? {
      selectedBlocks
    } : !1;
  },
  actions: [({
    snapshot
  }, {
    selectedBlocks
  }) => [raise({
    type: "insert.block",
    block: {
      _type: snapshot.context.schema.block.name,
      children: [{
        _type: snapshot.context.schema.span.name,
        text: "",
        marks: []
      }]
    },
    placement: "before",
    select: "start"
  }), ...selectedBlocks.map((block) => raise({
    type: "delete.block",
    at: block.path
  }))]]
}), breakingInlineObject = defineBehavior({
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const selectionCollapsed = isSelectionCollapsed$1(snapshot), focusInlineObject = getFocusInlineObject(snapshot);
    return selectionCollapsed && focusInlineObject;
  },
  actions: [() => [raise({
    type: "move.forward",
    distance: 1
  }), raise({
    type: "split"
  })]]
}), coreInsertBreakBehaviors = {
  breakingAtTheEndOfTextBlock,
  breakingAtTheStartOfTextBlock,
  breakingEntireBlocks,
  breakingInlineObject
};
function isAtTheBeginningOfBlock({
  context,
  block
}) {
  return !isTextBlock(context, block) || !context.selection || !isSelectionCollapsed(context.selection) ? !1 : getChildKeyFromSelectionPoint(context.selection.focus) === block.children[0]._key && context.selection.focus.offset === 0;
}
const MAX_LIST_LEVEL = 10, clearListOnBackspace = defineBehavior({
  on: "delete.backward",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = getFocusTextBlock(snapshot);
    return !focusTextBlock || focusTextBlock.node.level !== 1 || !isAtTheBeginningOfBlock({
      context: snapshot.context,
      block: focusTextBlock.node
    }) ? !1 : {
      focusTextBlock
    };
  },
  actions: [(_, {
    focusTextBlock
  }) => [raise({
    type: "block.unset",
    props: ["listItem", "level"],
    at: focusTextBlock.path
  })]]
}), unindentListOnBackspace = defineBehavior({
  on: "delete.backward",
  guard: ({
    snapshot
  }) => {
    const selectionCollapsed = isSelectionCollapsed$1(snapshot), focusTextBlock = getFocusTextBlock(snapshot), focusSpan = getFocusSpan$1(snapshot);
    return !selectionCollapsed || !focusTextBlock || !focusSpan ? !1 : focusTextBlock.node.children[0]._key === focusSpan.node._key && snapshot.context.selection?.focus.offset === 0 && focusTextBlock.node.level !== void 0 && focusTextBlock.node.level > 1 ? {
      focusTextBlock,
      level: focusTextBlock.node.level - 1
    } : !1;
  },
  actions: [(_, {
    focusTextBlock,
    level
  }) => [raise({
    type: "block.set",
    props: {
      level
    },
    at: focusTextBlock.path
  })]]
}), mergeTextIntoListOnDelete = defineBehavior({
  on: "delete.forward",
  guard: ({
    snapshot
  }) => {
    const focusListBlock = getFocusListBlock(snapshot), nextBlock = getNextBlock(snapshot);
    return !focusListBlock || !nextBlock || !isTextBlock(snapshot.context, nextBlock.node) || !isEmptyTextBlock(snapshot.context, focusListBlock.node) ? !1 : {
      focusListBlock,
      nextBlock
    };
  },
  actions: [(_, {
    nextBlock
  }) => [raise({
    type: "insert.block",
    block: nextBlock.node,
    placement: "auto",
    select: "start"
  }), raise({
    type: "delete.block",
    at: nextBlock.path
  })]]
}), mergeTextIntoListOnBackspace = defineBehavior({
  on: "delete.backward",
  guard: ({
    snapshot
  }) => {
    const focusTextBlock = getFocusTextBlock(snapshot), previousBlock = getPreviousBlock(snapshot);
    if (!focusTextBlock || !previousBlock || !isAtTheBeginningOfBlock({
      context: snapshot.context,
      block: focusTextBlock.node
    }) || !isListBlock(snapshot.context, previousBlock.node) || !isEmptyTextBlock(snapshot.context, previousBlock.node))
      return !1;
    const previousBlockEndPoint = getBlockEndPoint({
      context: snapshot.context,
      block: previousBlock
    });
    return {
      focusTextBlock,
      previousBlockEndPoint
    };
  },
  actions: [(_, {
    focusTextBlock,
    previousBlockEndPoint
  }) => [raise({
    type: "select",
    at: {
      anchor: previousBlockEndPoint,
      focus: previousBlockEndPoint
    }
  }), raise({
    type: "insert.block",
    block: focusTextBlock.node,
    placement: "auto",
    select: "start"
  }), raise({
    type: "delete.block",
    at: focusTextBlock.path
  })]]
}), deletingListFromStart = defineBehavior({
  on: "delete",
  guard: ({
    snapshot,
    event
  }) => {
    const at = event.at ?? snapshot.context.selection;
    if (!at)
      return !1;
    const blocksToDelete = getSelectedBlocks({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: at
      }
    });
    if (blocksToDelete.length < 2)
      return !1;
    const startBlock = blocksToDelete.at(0)?.node, middleBlocks = blocksToDelete.slice(1, -1), endBlock = blocksToDelete.at(-1)?.node;
    if (!isListBlock(snapshot.context, startBlock) || !isListBlock(snapshot.context, endBlock))
      return !1;
    const deleteStartPoint = getSelectionStartPoint({
      context: {
        ...snapshot.context,
        selection: at
      }
    }), deleteEndPoint = getSelectionEndPoint({
      context: {
        ...snapshot.context,
        selection: at
      }
    });
    if (!deleteStartPoint || !deleteEndPoint)
      return !1;
    const startBlockStartPoint = getBlockStartPoint({
      context: snapshot.context,
      block: {
        node: startBlock,
        path: [{
          _key: startBlock._key
        }]
      }
    });
    if (!isEqualSelectionPoints(deleteStartPoint, startBlockStartPoint))
      return !1;
    const startBlockEndPoint = getBlockEndPoint({
      context: snapshot.context,
      block: {
        node: startBlock,
        path: [{
          _key: startBlock._key
        }]
      }
    }), endBlockEndPoint = getBlockEndPoint({
      context: snapshot.context,
      block: {
        node: endBlock,
        path: [{
          _key: endBlock._key
        }]
      }
    }), slicedEndBlock = sliceTextBlock({
      context: {
        schema: snapshot.context.schema,
        selection: {
          anchor: deleteEndPoint,
          focus: endBlockEndPoint
        }
      },
      block: endBlock
    });
    return {
      startBlockStartPoint,
      startBlockEndPoint,
      middleBlocks,
      endBlock,
      slicedEndBlock
    };
  },
  actions: [(_, {
    startBlockStartPoint,
    startBlockEndPoint,
    middleBlocks,
    endBlock,
    slicedEndBlock
  }) => [
    // All block in between can safely be deleted.
    ...middleBlocks.map((block) => raise({
      type: "delete.block",
      at: block.path
    })),
    // The last block is deleted as well.
    raise({
      type: "delete.block",
      at: [{
        _key: endBlock._key
      }]
    }),
    // But in case the delete operation didn't reach all the way to the end
    // of it, we first place the caret at the end of the start block...
    raise({
      type: "select",
      at: {
        anchor: startBlockEndPoint,
        focus: startBlockEndPoint
      }
    }),
    // ...and insert the rest of the end block at the end of it.
    raise({
      type: "insert.block",
      block: slicedEndBlock,
      placement: "auto",
      select: "none"
    }),
    // And finally, we delete the original text of the start block.
    raise({
      type: "delete",
      at: {
        anchor: startBlockStartPoint,
        focus: startBlockEndPoint
      }
    })
  ]]
}), clearListOnEnter = defineBehavior({
  on: "insert.break",
  guard: ({
    snapshot
  }) => {
    const selectionCollapsed = isSelectionCollapsed$1(snapshot), focusListBlock = getFocusListBlock(snapshot);
    return !selectionCollapsed || !focusListBlock || !isEmptyTextBlock(snapshot.context, focusListBlock.node) ? !1 : {
      focusListBlock
    };
  },
  actions: [(_, {
    focusListBlock
  }) => [raise({
    type: "block.unset",
    props: ["listItem", "level"],
    at: focusListBlock.path
  })]]
}), indentListOnTab = defineBehavior({
  on: "keyboard.keydown",
  guard: ({
    snapshot,
    event
  }) => {
    if (!defaultKeyboardShortcuts.tab.guard(event.originEvent))
      return !1;
    const selectedBlocks = getSelectedBlocks(snapshot), selectedListBlocks = selectedBlocks.flatMap((block) => isListBlock(snapshot.context, block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => raise({
    type: "block.set",
    props: {
      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level + 1))
    },
    at: selectedListBlock.path
  }))]
}), unindentListOnShiftTab = defineBehavior({
  on: "keyboard.keydown",
  guard: ({
    snapshot,
    event
  }) => {
    if (!defaultKeyboardShortcuts.shiftTab.guard(event.originEvent))
      return !1;
    const selectedBlocks = getSelectedBlocks(snapshot), selectedListBlocks = selectedBlocks.flatMap((block) => isListBlock(snapshot.context, block.node) ? [{
      node: block.node,
      path: block.path
    }] : []);
    return selectedListBlocks.length === selectedBlocks.length ? {
      selectedListBlocks
    } : !1;
  },
  actions: [(_, {
    selectedListBlocks
  }) => selectedListBlocks.map((selectedListBlock) => raise({
    type: "block.set",
    props: {
      level: Math.min(MAX_LIST_LEVEL, Math.max(1, selectedListBlock.node.level - 1))
    },
    at: selectedListBlock.path
  }))]
}), inheritListLevel = defineBehavior({
  on: "insert.blocks",
  guard: ({
    snapshot,
    event
  }) => {
    const focusListBlock = getFocusListBlock(snapshot);
    if (!focusListBlock)
      return !1;
    const firstInsertedBlock = event.blocks.at(0), secondInsertedBlock = event.blocks.at(1), insertedListBlock = isListBlock(snapshot.context, firstInsertedBlock) ? firstInsertedBlock : isListBlock(snapshot.context, secondInsertedBlock) ? secondInsertedBlock : void 0;
    if (!insertedListBlock)
      return !1;
    const levelDifference = focusListBlock.node.level - insertedListBlock.level;
    return levelDifference === 0 ? !1 : {
      levelDifference,
      insertedListBlock
    };
  },
  actions: [({
    snapshot,
    event
  }, {
    levelDifference,
    insertedListBlock
  }) => {
    let adjustLevel = !0, listStartBlockFound = !1;
    return [raise({
      ...event,
      blocks: event.blocks.map((block) => (block._key === insertedListBlock._key && (listStartBlockFound = !0), adjustLevel ? listStartBlockFound && adjustLevel && isListBlock(snapshot.context, block) ? {
        ...block,
        level: Math.min(MAX_LIST_LEVEL, Math.max(1, block.level + levelDifference))
      } : (listStartBlockFound && (adjustLevel = !1), block) : block))
    })];
  }]
}), inheritListItem = defineBehavior({
  on: "insert.blocks",
  guard: ({
    snapshot,
    event
  }) => {
    const focusListBlock = getFocusListBlock(snapshot);
    if (!focusListBlock || isEmptyTextBlock(snapshot.context, focusListBlock.node))
      return !1;
    const firstInsertedBlock = event.blocks.at(0), secondInsertedBlock = event.blocks.at(1), insertedListBlock = isListBlock(snapshot.context, firstInsertedBlock) ? firstInsertedBlock : isListBlock(snapshot.context, secondInsertedBlock) ? secondInsertedBlock : void 0;
    return !insertedListBlock || focusListBlock.node.level !== insertedListBlock.level || focusListBlock.node.listItem === insertedListBlock.listItem ? !1 : {
      listItem: focusListBlock.node.listItem,
      insertedListBlock
    };
  },
  actions: [({
    snapshot,
    event
  }, {
    listItem,
    insertedListBlock
  }) => {
    let adjustListItem = !0, listStartBlockFound = !1;
    return [raise({
      ...event,
      blocks: event.blocks.map((block) => (block._key === insertedListBlock._key && (listStartBlockFound = !0), adjustListItem ? listStartBlockFound && adjustListItem && isListBlock(snapshot.context, block) ? {
        ...block,
        listItem: block.level === insertedListBlock.level ? listItem : block.listItem
      } : (listStartBlockFound && (adjustListItem = !1), block) : block))
    })];
  }]
}), inheritListProperties = defineBehavior({
  on: "insert.block",
  guard: ({
    snapshot,
    event
  }) => {
    if (event.placement !== "auto" || event.block._type !== snapshot.context.schema.block.name || event.block.listItem !== void 0)
      return !1;
    const focusListBlock = getFocusListBlock(snapshot);
    return !focusListBlock || !isEmptyTextBlock(snapshot.context, focusListBlock.node) ? !1 : {
      level: focusListBlock.node.level,
      listItem: focusListBlock.node.listItem
    };
  },
  actions: [({
    event
  }, {
    level,
    listItem
  }) => [raise({
    ...event,
    block: {
      ...event.block,
      level,
      listItem
    }
  })]]
}), coreListBehaviors = {
  clearListOnBackspace,
  unindentListOnBackspace,
  mergeTextIntoListOnDelete,
  mergeTextIntoListOnBackspace,
  deletingListFromStart,
  clearListOnEnter,
  indentListOnTab,
  unindentListOnShiftTab,
  inheritListLevel,
  inheritListItem,
  inheritListProperties
}, coreBehaviorsConfig = [...coreAnnotationBehaviors, coreDecoratorBehaviors.strongShortcut, coreDecoratorBehaviors.emShortcut, coreDecoratorBehaviors.underlineShortcut, coreDecoratorBehaviors.codeShortcut, ...coreDndBehaviors, coreBlockObjectBehaviors.clickingAboveLonelyBlockObject, coreBlockObjectBehaviors.clickingBelowLonelyBlockObject, coreBlockObjectBehaviors.arrowDownOnLonelyBlockObject, coreBlockObjectBehaviors.arrowUpOnLonelyBlockObject, coreBlockObjectBehaviors.breakingBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockAfterBlockObject, coreBlockObjectBehaviors.deletingEmptyTextBlockBeforeBlockObject, ...coreInsertBehaviors, coreListBehaviors.clearListOnBackspace, coreListBehaviors.unindentListOnBackspace, coreListBehaviors.mergeTextIntoListOnDelete, coreListBehaviors.mergeTextIntoListOnBackspace, coreListBehaviors.deletingListFromStart, coreListBehaviors.clearListOnEnter, coreListBehaviors.indentListOnTab, coreListBehaviors.unindentListOnShiftTab, coreListBehaviors.inheritListLevel, coreListBehaviors.inheritListItem, coreListBehaviors.inheritListProperties, coreInsertBreakBehaviors.breakingAtTheEndOfTextBlock, coreInsertBreakBehaviors.breakingAtTheStartOfTextBlock, coreInsertBreakBehaviors.breakingEntireBlocks, coreInsertBreakBehaviors.breakingInlineObject].map((behavior) => ({
  behavior,
  priority: corePriority
}));
function withPerformingBehaviorOperation(editor, fn) {
  const prev = editor.isPerformingBehaviorOperation;
  editor.isPerformingBehaviorOperation = !0, fn(), editor.isPerformingBehaviorOperation = prev;
}
function withoutNormalizingConditional(editor, predicate, fn) {
  predicate() ? Editor.withoutNormalizing(editor, fn) : fn();
}
const addAnnotationOperationImplementation = ({
  context,
  operation
}) => {
  const parsedAnnotation = parseAnnotation({
    annotation: {
      _type: operation.annotation.name,
      _key: operation.annotation._key,
      ...operation.annotation.value
    },
    context,
    options: {
      validateFields: !0
    }
  });
  if (!parsedAnnotation)
    throw new Error(`Failed to parse annotation ${JSON.stringify(operation.annotation)}`);
  const editor = operation.editor;
  if (!editor.selection || Range.isCollapsed(editor.selection))
    return;
  const selectedBlocks = Editor.nodes(editor, {
    at: editor.selection,
    match: (node) => editor.isTextBlock(node),
    reverse: Range.isBackward(editor.selection)
  });
  let blockIndex = 0;
  for (const [block, blockPath] of selectedBlocks) {
    if (block.children.length === 0 || block.children.length === 1 && block.children[0].text === "")
      continue;
    const annotationKey = blockIndex === 0 ? parsedAnnotation._key : context.keyGenerator(), markDefs = block.markDefs ?? [];
    markDefs.find((markDef) => markDef._type === parsedAnnotation._type && markDef._key === annotationKey) === void 0 && Transforms.setNodes(editor, {
      markDefs: [...markDefs, {
        ...parsedAnnotation,
        _key: annotationKey
      }]
    }, {
      at: blockPath
    }), Transforms.setNodes(editor, {}, {
      match: Text.isText,
      split: !0
    });
    const children = Node.children(editor, blockPath);
    for (const [span, path] of children) {
      if (!editor.isTextSpan(span) || !Range.includes(editor.selection, path))
        continue;
      const marks = span.marks ?? [];
      Transforms.setNodes(editor, {
        marks: [...marks, annotationKey]
      }, {
        at: path
      });
    }
    blockIndex++;
  }
}, removeAnnotationOperationImplementation = ({
  operation
}) => {
  const editor = operation.editor;
  if (editor.selection)
    if (Range.isCollapsed(editor.selection)) {
      const [block, blockPath] = Editor.node(editor, editor.selection, {
        depth: 1
      });
      if (!editor.isTextBlock(block))
        return;
      const potentialAnnotations = (block.markDefs ?? []).filter((markDef) => markDef._type === operation.annotation.name), [selectedChild, selectedChildPath] = Editor.node(editor, editor.selection, {
        depth: 2
      });
      if (!editor.isTextSpan(selectedChild))
        return;
      const annotationToRemove = selectedChild.marks?.find((mark) => potentialAnnotations.some((markDef) => markDef._key === mark));
      if (!annotationToRemove)
        return;
      const previousSpansWithSameAnnotation = [];
      for (const [child, childPath] of Node.children(editor, blockPath, {
        reverse: !0
      }))
        if (editor.isTextSpan(child) && Path.isBefore(childPath, selectedChildPath))
          if (child.marks?.includes(annotationToRemove))
            previousSpansWithSameAnnotation.push([child, childPath]);
          else
            break;
      const nextSpansWithSameAnnotation = [];
      for (const [child, childPath] of Node.children(editor, blockPath))
        if (editor.isTextSpan(child) && Path.isAfter(childPath, selectedChildPath))
          if (child.marks?.includes(annotationToRemove))
            nextSpansWithSameAnnotation.push([child, childPath]);
          else
            break;
      for (const [child, childPath] of [...previousSpansWithSameAnnotation, [selectedChild, selectedChildPath], ...nextSpansWithSameAnnotation])
        Transforms.setNodes(editor, {
          marks: child.marks?.filter((mark) => mark !== annotationToRemove)
        }, {
          at: childPath
        });
    } else {
      Transforms.setNodes(editor, {}, {
        match: (node) => editor.isTextSpan(node),
        split: !0,
        hanging: !0
      });
      const blocks = Editor.nodes(editor, {
        at: editor.selection,
        match: (node) => editor.isTextBlock(node)
      });
      for (const [block, blockPath] of blocks) {
        const children = Node.children(editor, blockPath);
        for (const [child, childPath] of children) {
          if (!editor.isTextSpan(child) || !Range.includes(editor.selection, childPath))
            continue;
          const markDefs = block.markDefs ?? [], marks = child.marks ?? [], marksWithoutAnnotation = marks.filter((mark) => markDefs.find((markDef2) => markDef2._key === mark)?._type !== operation.annotation.name);
          marksWithoutAnnotation.length !== marks.length && Transforms.setNodes(editor, {
            marks: marksWithoutAnnotation
          }, {
            at: childPath
          });
        }
      }
    }
}, blockSetOperationImplementation = ({
  context,
  operation
}) => {
  const blockIndex = operation.editor.blockIndexMap.get(operation.at[0]._key);
  if (blockIndex === void 0)
    throw new Error(`Unable to find block index for block at ${JSON.stringify(operation.at)}`);
  const slateBlock = operation.editor.children.at(blockIndex);
  if (!slateBlock)
    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`);
  if (isTextBlock(context, slateBlock)) {
    const filteredProps = {};
    for (const key of Object.keys(operation.props))
      if (!(key === "_type" || key === "children")) {
        if (key === "style") {
          context.schema.styles.some((style) => style.name === operation.props[key]) && (filteredProps[key] = operation.props[key]);
          continue;
        }
        if (key === "listItem") {
          context.schema.lists.some((list) => list.name === operation.props[key]) && (filteredProps[key] = operation.props[key]);
          continue;
        }
        if (key === "level") {
          filteredProps[key] = operation.props[key];
          continue;
        }
        if (key === "markDefs") {
          const {
            markDefs
          } = parseMarkDefs({
            context,
            markDefs: operation.props[key],
            options: {
              validateFields: !0
            }
          });
          filteredProps[key] = markDefs;
          continue;
        }
        context.schema.block.fields?.some((field) => field.name === key) && (filteredProps[key] = operation.props[key]);
      }
    Transforms.setNodes(operation.editor, filteredProps, {
      at: [blockIndex]
    });
  } else {
    const schemaDefinition = context.schema.blockObjects.find((definition) => definition.name === slateBlock._type), filteredProps = {};
    for (const key of Object.keys(operation.props))
      if (key !== "_type") {
        if (key === "_key") {
          filteredProps[key] = operation.props[key];
          continue;
        }
        schemaDefinition?.fields.some((field) => field.name === key) && (filteredProps[key] = operation.props[key]);
      }
    const patches = Object.entries(filteredProps).map(([key, value]) => key === "_key" ? set(value, ["_key"]) : set(value, ["value", key])), updatedSlateBlock = applyAll(slateBlock, patches);
    Transforms.setNodes(operation.editor, updatedSlateBlock, {
      at: [blockIndex]
    });
  }
}, blockUnsetOperationImplementation = ({
  context,
  operation
}) => {
  const blockKey = operation.at[0]._key, blockIndex = operation.editor.blockIndexMap.get(blockKey);
  if (blockIndex === void 0)
    throw new Error(`Unable to find block index for block key ${blockKey}`);
  const slateBlock = blockIndex !== void 0 ? operation.editor.children.at(blockIndex) : void 0;
  if (!slateBlock)
    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`);
  if (isTextBlock(context, slateBlock)) {
    const propsToRemove = operation.props.filter((prop) => prop !== "_type" && prop !== "_key" && prop !== "children");
    Transforms.unsetNodes(operation.editor, propsToRemove, {
      at: [blockIndex]
    }), operation.props.includes("_key") && Transforms.setNodes(operation.editor, {
      _key: context.keyGenerator()
    }, {
      at: [blockIndex]
    });
    return;
  }
  const patches = operation.props.flatMap((key) => key === "_type" ? [] : key === "_key" ? set(context.keyGenerator(), ["_key"]) : unset(["value", key])), updatedSlateBlock = applyAll(slateBlock, patches);
  Transforms.setNodes(operation.editor, updatedSlateBlock, {
    at: [blockIndex]
  });
}, childSetOperationImplementation = ({
  context,
  operation
}) => {
  const location = toSlateRange({
    context: {
      schema: context.schema,
      value: operation.editor.value,
      selection: {
        anchor: {
          path: operation.at,
          offset: 0
        },
        focus: {
          path: operation.at,
          offset: 0
        }
      }
    },
    blockIndexMap: operation.editor.blockIndexMap
  });
  if (!location)
    throw new Error(`Unable to convert ${JSON.stringify(operation.at)} into a Slate Range`);
  const childEntry = Editor.node(operation.editor, location, {
    depth: 2
  }), child = childEntry?.[0], childPath = childEntry?.[1];
  if (!child || !childPath)
    throw new Error(`Unable to find child at ${JSON.stringify(operation.at)}`);
  if (operation.editor.isTextSpan(child)) {
    const {
      _type,
      text,
      ...rest
    } = operation.props;
    Transforms.setNodes(operation.editor, {
      ...child,
      ...rest
    }, {
      at: childPath
    }), typeof text == "string" && child.text !== text && (operation.editor.apply({
      type: "remove_text",
      path: childPath,
      offset: 0,
      text: child.text
    }), operation.editor.apply({
      type: "insert_text",
      path: childPath,
      offset: 0,
      text
    }));
    return;
  }
  if (Element$1.isElement(child)) {
    const definition = context.schema.inlineObjects.find((definition2) => definition2.name === child._type);
    if (!definition)
      throw new Error(`Unable to find schema definition for Inline Object type ${child._type}`);
    const value = "value" in child && typeof child.value == "object" ? child.value : {}, {
      _type,
      _key,
      ...rest
    } = operation.props;
    for (const prop in rest)
      definition.fields.some((field) => field.name === prop) || delete rest[prop];
    Transforms.setNodes(operation.editor, {
      ...child,
      _key: typeof _key == "string" ? _key : child._key,
      value: {
        ...value,
        ...rest
      }
    }, {
      at: childPath
    });
    return;
  }
  throw new Error(`Unable to determine the type of child at ${JSON.stringify(operation.at)}`);
}, childUnsetOperationImplementation = ({
  context,
  operation
}) => {
  const blockKey = operation.at[0]._key, blockIndex = operation.editor.blockIndexMap.get(blockKey);
  if (blockIndex === void 0)
    throw new Error(`Unable to find block index for block key ${blockKey}`);
  const block = blockIndex !== void 0 ? operation.editor.value.at(blockIndex) : void 0;
  if (!block)
    throw new Error(`Unable to find block at ${JSON.stringify(operation.at)}`);
  if (!isTextBlock(context, block))
    throw new Error(`Block ${JSON.stringify(blockKey)} is not a text block`);
  const childKey = operation.at[2]._key;
  if (!childKey)
    throw new Error(`Unable to find child key at ${JSON.stringify(operation.at)}`);
  const childIndex = block.children.findIndex((child2) => child2._key === childKey);
  if (childIndex === -1)
    throw new Error(`Unable to find child at ${JSON.stringify(operation.at)}`);
  const childEntry = Editor.node(operation.editor, [blockIndex, childIndex], {
    depth: 2
  }), child = childEntry?.[0], childPath = childEntry?.[1];
  if (!child || !childPath)
    throw new Error(`Unable to find child at ${JSON.stringify(operation.at)}`);
  if (operation.editor.isTextSpan(child)) {
    const newNode = {};
    for (const prop of operation.props)
      if (prop !== "text" && prop !== "_type") {
        if (prop === "_key") {
          newNode._key = context.keyGenerator();
          continue;
        }
        newNode[prop] = null;
      }
    Transforms.setNodes(operation.editor, newNode, {
      at: childPath
    }), operation.props.includes("text") && operation.editor.apply({
      type: "remove_text",
      path: childPath,
      offset: 0,
      text: child.text
    });
    return;
  }
  if (Element$1.isElement(child)) {
    const value = "value" in child && typeof child.value == "object" ? child.value : {}, patches = operation.props.map((prop) => ({
      type: "unset",
      path: [prop]
    })), newValue = applyAll(value, patches);
    Transforms.setNodes(operation.editor, {
      ...child,
      _key: operation.props.includes("_key") ? context.keyGenerator() : child._key,
      value: newValue
    }, {
      at: childPath
    });
    return;
  }
  throw new Error(`Unable to determine the type of child at ${JSON.stringify(operation.at)}`);
}, decoratorAddOperationImplementation = ({
  context,
  operation
}) => {
  const editor = operation.editor, mark = operation.decorator;
  let at = operation.at ? toSlateRange({
    context: {
      schema: context.schema,
      value: operation.editor.value,
      selection: operation.at
    },
    blockIndexMap: operation.editor.blockIndexMap
  }) : operation.editor.selection;
  if (!at)
    throw new Error("Unable to add decorator without a selection");
  if (Range.isExpanded(at)) {
    const rangeRef = Editor.rangeRef(editor, at, {
      affinity: "inward"
    }), [start, end] = Range.edges(at), endAtEndOfNode = Editor.isEnd(editor, end, end.path);
    Transforms.splitNodes(editor, {
      at: end,
      match: Text.isText,
      mode: "lowest",
      voids: !1,
      always: !endAtEndOfNode
    });
    const startAtStartOfNode = Editor.isStart(editor, start, start.path);
    if (Transforms.splitNodes(editor, {
      at: start,
      match: Text.isText,
      mode: "lowest",
      voids: !1,
      always: !startAtStartOfNode
    }), at = rangeRef.unref(), !at)
      throw new Error("Unable to add decorator without a selection");
    operation.at || Transforms.select(editor, at);
    const splitTextNodes = Editor.nodes(editor, {
      at,
      match: Text.isText
    });
    for (const [node, path] of splitTextNodes) {
      const marks = [...(Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark), mark];
      Transforms.setNodes(editor, {
        marks
      }, {
        at: path,
        match: Text.isText,
        split: !0,
        hanging: !0
      });
    }
  } else {
    if (!Array.from(Editor.nodes(editor, {
      at,
      match: (node) => editor.isTextSpan(node)
    }))?.at(0))
      return;
    const [block, blockPath] = Editor.node(editor, at, {
      depth: 1
    }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === "" ? block.children[0] : void 0;
    if (lonelyEmptySpan) {
      const existingMarks = lonelyEmptySpan.marks ?? [], existingMarksWithoutDecorator = existingMarks.filter((existingMark) => existingMark !== mark);
      Transforms.setNodes(editor, {
        marks: existingMarks.length === existingMarksWithoutDecorator.length ? [...existingMarks, mark] : existingMarksWithoutDecorator
      }, {
        at: blockPath,
        match: (node) => editor.isTextSpan(node)
      });
    } else
      editor.decoratorState[mark] = !0;
  }
  if (editor.selection) {
    const selection = editor.selection;
    editor.selection = {
      ...selection
    };
  }
}, decoratorRemoveOperationImplementation = ({
  operation
}) => {
  const editor = operation.editor, mark = operation.decorator, {
    selection
  } = editor;
  if (selection) {
    if (Range.isExpanded(selection))
      Transforms.setNodes(editor, {}, {
        match: Text.isText,
        split: !0,
        hanging: !0
      }), editor.selection && [...Editor.nodes(editor, {
        at: editor.selection,
        match: Text.isText
      })].forEach(([node, path]) => {
        const block = editor.children[path[0]];
        Element$1.isElement(block) && block.children.includes(node) && Transforms.setNodes(editor, {
          marks: (Array.isArray(node.marks) ? node.marks : []).filter((eMark) => eMark !== mark),
          _type: "span"
        }, {
          at: path
        });
      });
    else {
      const [block, blockPath] = Editor.node(editor, selection, {
        depth: 1
      }), lonelyEmptySpan = editor.isTextBlock(block) && block.children.length === 1 && editor.isTextSpan(block.children[0]) && block.children[0].text === "" ? block.children[0] : void 0;
      if (lonelyEmptySpan) {
        const existingMarksWithoutDecorator = (lonelyEmptySpan.marks ?? []).filter((existingMark) => existingMark !== mark);
        Transforms.setNodes(editor, {
          marks: existingMarksWithoutDecorator
        }, {
          at: blockPath,
          match: (node) => editor.isTextSpan(node)
        });
      } else
        editor.decoratorState[mark] = !1;
    }
    if (editor.selection) {
      const selection2 = editor.selection;
      editor.selection = {
        ...selection2
      };
    }
  }
}, deleteOperationImplementation = ({
  context,
  operation
}) => {
  const at = operation.at ? toSlateRange({
    context: {
      schema: context.schema,
      value: operation.editor.value,
      selection: operation.at
    },
    blockIndexMap: operation.editor.blockIndexMap
  }) : operation.editor.selection;
  if (!at)
    throw new Error("Unable to delete without a selection");
  const [start, end] = Range.edges(at);
  if (operation.unit === "block") {
    const startBlockIndex = start.path.at(0), endBlockIndex = end.path.at(0);
    if (startBlockIndex === void 0 || endBlockIndex === void 0)
      throw new Error("Failed to get start or end block index");
    Transforms.removeNodes(operation.editor, {
      at: {
        anchor: {
          path: [startBlockIndex],
          offset: 0
        },
        focus: {
          path: [endBlockIndex],
          offset: 0
        }
      },
      mode: "highest"
    });
    return;
  }
  if (operation.unit === "child") {
    Transforms.removeNodes(operation.editor, {
      at,
      match: (node) => isSpan(context, node) && node._key !== VOID_CHILD_KEY || "__inline" in node && node.__inline === !0
    });
    return;
  }
  if (operation.direction === "backward" && operation.unit === "line") {
    const parentBlockEntry = Editor.above(operation.editor, {
      match: (n) => Element$1.isElement(n) && Editor.isBlock(operation.editor, n),
      at
    });
    if (parentBlockEntry) {
      const [, parentBlockPath] = parentBlockEntry, parentElementRange = Editor.range(operation.editor, parentBlockPath, at.anchor), currentLineRange = findCurrentLineRange(operation.editor, parentElementRange);
      if (!Range.isCollapsed(currentLineRange)) {
        Transforms.delete(operation.editor, {
          at: currentLineRange
        });
        return;
      }
    }
  }
  if (operation.unit === "word" && Range.isCollapsed(at)) {
    deleteText(operation.editor, {
      at,
      unit: "word",
      reverse: operation.direction === "backward"
    });
    return;
  }
  const startBlock = Editor.above(operation.editor, {
    match: (n) => Element$1.isElement(n) && Editor.isBlock(operation.editor, n),
    at: start,
    voids: !1
  }), endBlock = Editor.above(operation.editor, {
    match: (n) => Element$1.isElement(n) && Editor.isBlock(operation.editor, n),
    at: end,
    voids: !1
  }), isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]), startNonEditable = Editor.void(operation.editor, {
    at: start,
    mode: "highest"
  }) ?? Editor.elementReadOnly(operation.editor, {
    at: start,
    mode: "highest"
  }), endNonEditable = Editor.void(operation.editor, {
    at: end,
    mode: "highest"
  }) ?? Editor.elementReadOnly(operation.editor, {
    at: end,
    mode: "highest"
  }), matches = [];
  let lastPath;
  for (const entry of Editor.nodes(operation.editor, {
    at,
    voids: !1
  })) {
    const [node, path] = entry;
    lastPath && Path.compare(path, lastPath) === 0 || (Element$1.isElement(node) && (Editor.isVoid(operation.editor, node) || Editor.isElementReadOnly(operation.editor, node)) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) && (matches.push(entry), lastPath = path);
  }
  const pathRefs = Array.from(matches, ([, path]) => Editor.pathRef(operation.editor, path)), startRef = Editor.pointRef(operation.editor, start), endRef = Editor.pointRef(operation.editor, end);
  if (startBlock && endBlock && Point.equals(start, Editor.start(operation.editor, startBlock[1])) && Point.equals(end, Editor.end(operation.editor, endBlock[1])) && isAcrossBlocks && !startNonEditable && !endNonEditable) {
    if (!startNonEditable) {
      const point = startRef.current, [node] = Editor.leaf(operation.editor, point);
      node.text.length > 0 && operation.editor.apply({
        type: "remove_text",
        path: point.path,
        offset: 0,
        text: node.text
      });
    }
    for (const pathRef of pathRefs.reverse()) {
      const path = pathRef.unref();
      path && Transforms.removeNodes(operation.editor, {
        at: path,
        voids: !1
      });
    }
    if (!endNonEditable) {
      const point = endRef.current, [node] = Editor.leaf(operation.editor, point), {
        path
      } = point, offset = 0, text = node.text.slice(offset, end.offset);
      text.length > 0 && operation.editor.apply({
        type: "remove_text",
        path,
        offset,
        text
      });
    }
    endRef.current && startRef.current && Transforms.removeNodes(operation.editor, {
      at: endRef.current,
      voids: !1
    });
    return;
  }
  const reverse = operation.direction === "backward", hanging = reverse ? end ? isTextBlock(context, endBlock) ? end.offset === 0 : !0 : !1 : start ? isTextBlock(context, startBlock) ? start.offset === 0 : !0 : !1;
  operation.at ? deleteText(operation.editor, {
    at,
    hanging,
    reverse
  }) : deleteText(operation.editor, {
    hanging,
    reverse
  });
};
function findCurrentLineRange(editor, parentRange) {
  const parentRangeBoundary = Editor.range(editor, Range.end(parentRange)), positions = Array.from(Editor.positions(editor, {
    at: parentRange
  }));
  let left = 0, right = positions.length, middle = Math.floor(right / 2);
  if (rangesAreOnSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary))
    return Editor.range(editor, positions[left], parentRangeBoundary);
  if (positions.length < 2)
    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);
  for (; middle !== positions.length && middle !== left; )
    rangesAreOnSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary) ? right = middle : left = middle, middle = Math.floor((left + right) / 2);
  return Editor.range(editor, positions[left], parentRangeBoundary);
}
function rangesAreOnSameLine(editor, range1, range2) {
  const rect1 = DOMEditor.toDOMRange(editor, range1).getBoundingClientRect(), rect2 = DOMEditor.toDOMRange(editor, range2).getBoundingClientRect();
  return domRectsIntersect(rect1, rect2) && domRectsIntersect(rect2, rect1);
}
function domRectsIntersect(rect, compareRect) {
  const middle = (compareRect.top + compareRect.bottom) / 2;
  return rect.top <= middle && rect.bottom >= middle;
}
function pluginRedoing(editor, fn) {
  const prev = editor.isRedoing;
  editor.isRedoing = !0, fn(), editor.isRedoing = prev;
}
const debug$5 = debugWithName("transformOperation");
function transformOperation(editor, patch, operation, snapshot, previousSnapshot) {
  const transformedOperation = {
    ...operation
  };
  if (patch.type === "insert" && patch.path.length === 1) {
    const pathSegment = patch.path[0], insertBlockIndex = (snapshot || []).findIndex((blk) => isKeyedSegment(pathSegment) && blk._key === pathSegment._key);
    return debug$5(`Adjusting block path (+${patch.items.length}) for '${transformedOperation.type}' operation and patch '${patch.type}'`), [adjustBlockPath(transformedOperation, patch.items.length, insertBlockIndex)];
  }
  if (patch.type === "unset" && patch.path.length === 1) {
    const pathSegment = patch.path[0], unsetBlockIndex = (previousSnapshot || []).findIndex((blk) => isKeyedSegment(pathSegment) && blk._key === pathSegment._key);
    return "path" in transformedOperation && Array.isArray(transformedOperation.path) && transformedOperation.path[0] === unsetBlockIndex ? (debug$5("Skipping transformation that targeted removed block"), []) : [adjustBlockPath(transformedOperation, -1, unsetBlockIndex)];
  }
  if (patch.type === "unset" && patch.path.length === 0)
    return debug$5(`Adjusting selection for unset everything patch and ${operation.type} operation`), [];
  if (patch.type === "diffMatchPatch") {
    const operationTargetBlock = findOperationTargetBlock(editor, transformedOperation), pathSegment = patch.path[0];
    return !operationTargetBlock || !isKeyedSegment(pathSegment) || operationTargetBlock._key !== pathSegment._key ? [transformedOperation] : (parse(patch.value).forEach((diffPatch) => {
      let adjustOffsetBy = 0, changedOffset = diffPatch.utf8Start1;
      const {
        diffs
      } = diffPatch;
      if (diffs.forEach((diff2, index) => {
        const [diffType, text] = diff2;
        diffType === DIFF_INSERT ? (adjustOffsetBy += text.length, changedOffset += text.length) : diffType === DIFF_DELETE ? (adjustOffsetBy -= text.length, changedOffset -= text.length) : diffType === DIFF_EQUAL && (diffs.slice(index).every(([dType]) => dType === DIFF_EQUAL) || (changedOffset += text.length));
      }), transformedOperation.type === "insert_text" && changedOffset < transformedOperation.offset && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "remove_text" && changedOffset <= transformedOperation.offset - transformedOperation.text.length && (transformedOperation.offset += adjustOffsetBy), transformedOperation.type === "set_selection") {
        const currentFocus = transformedOperation.properties?.focus ? {
          ...transformedOperation.properties.focus
        } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {
          ...transformedOperation.properties.anchor
        } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {
          ...transformedOperation.newProperties.focus
        } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {
          ...transformedOperation.newProperties.anchor
        } : void 0;
        (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {
          point && changedOffset < point.offset && (point.offset += adjustOffsetBy);
        }), currentFocus && currentAnchor && (transformedOperation.properties = {
          focus: currentFocus,
          anchor: currentAnchor
        }), newFocus && newAnchor && (transformedOperation.newProperties = {
          focus: newFocus,
          anchor: newAnchor
        }));
      }
    }), [transformedOperation]);
  }
  return [transformedOperation];
}
function adjustBlockPath(operation, level, blockIndex) {
  const transformedOperation = {
    ...operation
  };
  if (blockIndex >= 0 && transformedOperation.type !== "set_selection" && Array.isArray(transformedOperation.path) && transformedOperation.path[0] >= blockIndex + level && transformedOperation.path[0] + level > -1) {
    const newPath = [transformedOperation.path[0] + level, ...transformedOperation.path.slice(1)];
    transformedOperation.path = newPath;
  }
  if (transformedOperation.type === "set_selection") {
    const currentFocus = transformedOperation.properties?.focus ? {
      ...transformedOperation.properties.focus
    } : void 0, currentAnchor = transformedOperation?.properties?.anchor ? {
      ...transformedOperation.properties.anchor
    } : void 0, newFocus = transformedOperation?.newProperties?.focus ? {
      ...transformedOperation.newProperties.focus
    } : void 0, newAnchor = transformedOperation?.newProperties?.anchor ? {
      ...transformedOperation.newProperties.anchor
    } : void 0;
    (currentFocus && currentAnchor || newFocus && newAnchor) && ([currentFocus, currentAnchor, newFocus, newAnchor].forEach((point) => {
      point && point.path[0] >= blockIndex + level && point.path[0] + level > -1 && (point.path = [point.path[0] + level, ...point.path.slice(1)]);
    }), currentFocus && currentAnchor && (transformedOperation.properties = {
      focus: currentFocus,
      anchor: currentAnchor
    }), newFocus && newAnchor && (transformedOperation.newProperties = {
      focus: newFocus,
      anchor: newAnchor
    }));
  }
  return transformedOperation;
}
function findOperationTargetBlock(editor, operation) {
  let block;
  return operation.type === "set_selection" && editor.selection ? block = editor.children[editor.selection.focus.path[0]] : "path" in operation && (block = editor.children[operation.path[0]]), block;
}
const historyRedoOperationImplementation = ({
  operation
}) => {
  const editor = operation.editor, {
    redos
  } = editor.history;
  if (redos.length > 0) {
    const step = redos[redos.length - 1];
    if (step.operations.length > 0) {
      const otherPatches = editor.remotePatches.filter((item) => item.time >= step.timestamp);
      let transformedOperations = step.operations;
      otherPatches.forEach((item) => {
        transformedOperations = transformedOperations.flatMap((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot));
      });
      try {
        Editor.withoutNormalizing(editor, () => {
          pluginRedoing(editor, () => {
            pluginWithoutHistory(editor, () => {
              transformedOperations.forEach((op) => {
                editor.apply(op);
              });
            });
          });
        });
      } catch (err) {
        console.error(`Could not perform 'history.redo' operation: ${err.message}`), editor.remotePatches.splice(0, editor.remotePatches.length), Transforms.deselect(editor), editor.history = {
          undos: [],
          redos: []
        }, editor.withHistory = !0, editor.isRedoing = !1, editor.onChange();
        return;
      }
      editor.history.undos.push(step), editor.history.redos.pop();
    }
  }
};
function pluginUndoing(editor, fn) {
  const prev = editor.isUndoing;
  editor.isUndoing = !0, fn(), editor.isUndoing = prev;
}
const historyUndoOperationImplementation = ({
  operation
}) => {
  const editor = operation.editor, {
    undos
  } = editor.history;
  if (undos.length > 0) {
    const step = undos[undos.length - 1];
    if (step.operations.length > 0) {
      const otherPatches = editor.remotePatches.filter((item) => item.time >= step.timestamp);
      let transformedOperations = step.operations;
      otherPatches.forEach((item) => {
        transformedOperations = transformedOperations.flatMap((op) => transformOperation(editor, item.patch, op, item.snapshot, item.previousSnapshot));
      });
      const reversedOperations = transformedOperations.map(Operation.inverse).reverse();
      try {
        Editor.withoutNormalizing(editor, () => {
          pluginUndoing(editor, () => {
            pluginWithoutHistory(editor, () => {
              reversedOperations.forEach((op) => {
                editor.apply(op);
              });
            });
          });
        });
      } catch (err) {
        console.error(`Could not perform 'history.undo' operation: ${err.message}`), editor.remotePatches.splice(0, editor.remotePatches.length), Transforms.deselect(editor), editor.history = {
          undos: [],
          redos: []
        }, editor.withHistory = !0, editor.isUndoing = !1, editor.onChange();
        return;
      }
      editor.history.redos.push(step), editor.history.undos.pop();
    }
  }
}, insertBlockOperationImplementation = ({
  context,
  operation
}) => {
  const parsedBlock = parseBlock({
    block: operation.block,
    context,
    options: {
      normalize: !0,
      removeUnusedMarkDefs: !0,
      validateFields: !0
    }
  });
  if (!parsedBlock)
    throw new Error(`Failed to parse block ${JSON.stringify(operation.block)}`);
  const block = toSlateBlock(parsedBlock, {
    schemaTypes: context.schema
  });
  insertBlock({
    context,
    block,
    placement: operation.placement,
    select: operation.select ?? "start",
    at: operation.at,
    editor: operation.editor
  });
};
function insertBlock(options) {
  const {
    context,
    block,
    placement,
    select,
    editor
  } = options, at = options.at ? toSlateRange({
    context: {
      schema: context.schema,
      value: editor.value,
      selection: options.at
    },
    blockIndexMap: editor.blockIndexMap
  }) : editor.selection;
  editor.children.length === 0 && Transforms.insertNodes(editor, createPlaceholderBlock(context), {
    at: [0]
  });
  const start = at ? Range.start(at) : Editor.start(editor, []), end = at ? Range.end(at) : Editor.end(editor, []), [startBlock, startBlockPath] = Array.from(Editor.nodes(editor, {
    at: start,
    mode: "lowest",
    match: (node, path) => Element$1.isElement(node) && path.length <= start.path.length
  })).at(0) ?? [void 0, void 0], [endBlock, endBlockPath] = Array.from(Editor.nodes(editor, {
    at: end,
    mode: "lowest",
    match: (node, path) => Element$1.isElement(node) && path.length <= end.path.length
  })).at(0) ?? [void 0, void 0];
  if (!startBlock || !startBlockPath || !endBlock || !endBlockPath)
    throw new Error("Unable to insert block without a start and end block");
  if (!editor.selection && select !== "none" && DOMEditor.focus(editor), !at) {
    if (placement === "before")
      Transforms.insertNodes(editor, [block], {
        at: [0]
      }), select === "start" ? Transforms.select(editor, Editor.start(editor, [0])) : select === "end" && Transforms.select(editor, Editor.end(editor, [0]));
    else if (placement === "after") {
      const nextPath = Path.next(endBlockPath);
      Transforms.insertNodes(editor, [block], {
        at: nextPath
      }), select === "start" ? Transforms.select(editor, Editor.start(editor, nextPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, nextPath));
    } else {
      if (isEmptyTextBlock(context, endBlock)) {
        Transforms.insertNodes(editor, [block], {
          at: endBlockPath,
          select: !1
        }), Transforms.removeNodes(editor, {
          at: Path.next(endBlockPath)
        }), Transforms.deselect(editor), select === "start" ? Transforms.select(editor, Editor.start(editor, endBlockPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, endBlockPath));
        return;
      }
      if (editor.isTextBlock(block) && endBlock && editor.isTextBlock(endBlock)) {
        const selectionBefore = Editor.end(editor, endBlockPath);
        Transforms.insertFragment(editor, [block], {
          at: Editor.end(editor, endBlockPath)
        }), select === "start" ? Transforms.select(editor, selectionBefore) : select === "none" && Transforms.deselect(editor);
        return;
      }
      const nextPath = Path.next(endBlockPath);
      Transforms.insertNodes(editor, [block], {
        at: nextPath,
        select: !1
      }), select === "start" ? Transforms.select(editor, Editor.start(editor, nextPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, nextPath));
    }
    return;
  }
  if (!at)
    throw new Error("Unable to insert block without a selection");
  if (placement === "before")
    Transforms.insertNodes(editor, [block], {
      at: startBlockPath,
      select: !1
    }), select === "start" ? Transforms.select(editor, Editor.start(editor, startBlockPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, startBlockPath));
  else if (placement === "after") {
    const nextPath = Path.next(endBlockPath);
    Transforms.insertNodes(editor, [block], {
      at: nextPath,
      select: !1
    }), select === "start" ? Transforms.select(editor, Editor.start(editor, nextPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, nextPath));
  } else {
    const endBlockEndPoint = Editor.start(editor, endBlockPath);
    if (Range.isExpanded(at) && !editor.isTextBlock(block)) {
      const atBeforeDelete = Editor.rangeRef(editor, at, {
        affinity: "inward"
      });
      Transforms.delete(editor, {
        at
      });
      const [focusBlock, focusBlockPath] = getFocusBlock({
        editor
      }), atAfterDelete = atBeforeDelete.unref() ?? editor.selection, atBeforeInsert = atAfterDelete ? Editor.rangeRef(editor, atAfterDelete, {
        affinity: "inward"
      }) : void 0;
      Transforms.insertNodes(editor, [block], {
        voids: !0,
        at: atAfterDelete ?? void 0,
        select: select !== "none"
      });
      const atAfterInsert = atBeforeInsert?.unref() ?? editor.selection;
      select === "none" && atAfterInsert && Transforms.select(editor, atAfterInsert), isEmptyTextBlock(context, focusBlock) && Transforms.removeNodes(editor, {
        at: focusBlockPath
      });
      return;
    }
    if (editor.isTextBlock(endBlock) && editor.isTextBlock(block)) {
      const selectionStartPoint = Range.start(at);
      if (isEmptyTextBlock(context, endBlock)) {
        Transforms.insertNodes(editor, [block], {
          at: endBlockPath,
          select: !1
        }), Transforms.removeNodes(editor, {
          at: Path.next(endBlockPath)
        }), select === "start" ? Transforms.select(editor, selectionStartPoint) : select === "end" ? Transforms.select(editor, Editor.end(editor, endBlockPath)) : Transforms.select(editor, at);
        return;
      }
      const endBlockChildKeys = endBlock.children.map((child) => child._key), endBlockMarkDefsKeys = endBlock.markDefs?.map((markDef) => markDef._key) ?? [], markDefKeyMap = /* @__PURE__ */ new Map(), adjustedMarkDefs = block.markDefs?.map((markDef) => {
        if (endBlockMarkDefsKeys.includes(markDef._key)) {
          const newKey = context.keyGenerator();
          return markDefKeyMap.set(markDef._key, newKey), {
            ...markDef,
            _key: newKey
          };
        }
        return markDef;
      }), adjustedChildren = block.children.map((child) => {
        if (isSpan(context, child)) {
          const marks = child.marks?.map((mark) => markDefKeyMap.get(mark) || mark) ?? [];
          if (!isEqualMarks(child.marks, marks))
            return {
              ...child,
              _key: endBlockChildKeys.includes(child._key) ? context.keyGenerator() : child._key,
              marks
            };
        }
        return endBlockChildKeys.includes(child._key) ? {
          ...child,
          _key: context.keyGenerator()
        } : child;
      });
      Transforms.setNodes(editor, {
        markDefs: [...endBlock.markDefs ?? [], ...adjustedMarkDefs ?? []]
      }, {
        at: endBlockPath
      });
      const adjustedBlock = isEqualChildren(block.children, adjustedChildren) ? block : {
        ...block,
        children: adjustedChildren
      };
      if (select === "end") {
        Transforms.insertFragment(editor, [adjustedBlock], {
          voids: !0
        });
        return;
      }
      Transforms.insertFragment(editor, [adjustedBlock], {
        at,
        voids: !0
      }), select === "start" ? Transforms.select(editor, selectionStartPoint) : Point.equals(selectionStartPoint, endBlockEndPoint) || Transforms.select(editor, selectionStartPoint);
    } else if (editor.isTextBlock(endBlock)) {
      const endBlockStartPoint = Editor.start(editor, endBlockPath), endBlockEndPoint2 = Editor.end(editor, endBlockPath), selectionStartPoint = Range.start(at), selectionEndPoint = Range.end(at);
      if (Range.isCollapsed(at) && Point.equals(selectionStartPoint, endBlockStartPoint))
        Transforms.insertNodes(editor, [block], {
          at: endBlockPath,
          select: !1
        }), (select === "start" || select === "end") && Transforms.select(editor, Editor.start(editor, endBlockPath)), isEmptyTextBlock(context, endBlock) && Transforms.removeNodes(editor, {
          at: Path.next(endBlockPath)
        });
      else if (Range.isCollapsed(at) && Point.equals(selectionEndPoint, endBlockEndPoint2)) {
        const nextPath = [endBlockPath[0] + 1];
        Transforms.insertNodes(editor, [block], {
          at: nextPath,
          select: !1
        }), (select === "start" || select === "end") && Transforms.select(editor, Editor.start(editor, nextPath));
      } else if (Range.isExpanded(at) && Point.equals(selectionStartPoint, endBlockStartPoint) && Point.equals(selectionEndPoint, endBlockEndPoint2))
        Transforms.insertFragment(editor, [block], {
          at
        }), select === "start" ? Transforms.select(editor, Editor.start(editor, endBlockPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, endBlockPath));
      else if (Range.isExpanded(at) && Point.equals(selectionStartPoint, endBlockStartPoint))
        Transforms.insertFragment(editor, [block], {
          at
        }), select === "start" ? Transforms.select(editor, Editor.start(editor, endBlockPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, endBlockPath));
      else if (Range.isExpanded(at) && Point.equals(selectionEndPoint, endBlockEndPoint2))
        Transforms.insertFragment(editor, [block], {
          at
        }), select === "start" ? Transforms.select(editor, Editor.start(editor, Path.next(endBlockPath))) : select === "end" && Transforms.select(editor, Editor.end(editor, Path.next(endBlockPath)));
      else {
        const [focusChild] = getFocusChild({
          editor
        });
        if (focusChild && editor.isTextSpan(focusChild))
          Transforms.splitNodes(editor, {
            at
          }), Transforms.insertFragment(editor, [block], {
            at
          }), select === "start" || select === "end" ? Transforms.select(editor, [endBlockPath[0] + 1]) : Transforms.select(editor, at);
        else {
          const nextPath = [endBlockPath[0] + 1];
          Transforms.insertNodes(editor, [block], {
            at: nextPath,
            select: !1
          }), Transforms.select(editor, at), select === "start" ? Transforms.select(editor, Editor.start(editor, nextPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, nextPath));
        }
      }
    } else {
      Transforms.insertNodes(editor, [block], {
        select: !1
      });
      const nextPath = [endBlockPath[0] + 1];
      select === "start" ? Transforms.select(editor, Editor.start(editor, nextPath)) : select === "end" && Transforms.select(editor, Editor.end(editor, nextPath));
    }
  }
}
const insertChildOperationImplementation = ({
  context,
  operation
}) => {
  const focus = operation.editor.selection?.focus, focusBlockIndex = focus?.path.at(0), focusChildIndex = focus?.path.at(1);
  if (focusBlockIndex === void 0 || focusChildIndex === void 0)
    throw new Error("Unable to insert child without a focus");
  const [focusBlock, focusBlockPath] = getFocusBlock({
    editor: operation.editor
  });
  if (!focus || !focusBlock || !focusBlockPath)
    throw new Error("Unable to insert child without a focus block");
  if (!isTextBlock(context, focusBlock))
    throw new Error("Unable to insert child into a non-text block");
  const markDefs = focusBlock.markDefs ?? [], markDefKeyMap = /* @__PURE__ */ new Map();
  for (const markDef of markDefs)
    markDefKeyMap.set(markDef._key, markDef._key);
  const span = parseSpan({
    span: operation.child,
    context,
    markDefKeyMap,
    options: {
      validateFields: !0
    }
  });
  if (span) {
    const [focusSpan] = getFocusSpan({
      editor: operation.editor
    });
    focusSpan ? Transforms.insertNodes(operation.editor, span, {
      at: focus,
      select: !0
    }) : Transforms.insertNodes(operation.editor, span, {
      at: [focusBlockIndex, focusChildIndex + 1],
      select: !0
    }), EDITOR_TO_PENDING_SELECTION.set(operation.editor, operation.editor.selection);
    return;
  }
  const inlineObject = parseInlineObject({
    inlineObject: operation.child,
    context,
    options: {
      validateFields: !0
    }
  });
  if (inlineObject) {
    const {
      _key,
      _type,
      ...rest
    } = inlineObject, [focusSpan] = getFocusSpan({
      editor: operation.editor
    });
    focusSpan ? Transforms.insertNodes(operation.editor, {
      _key,
      _type,
      children: [{
        _key: VOID_CHILD_KEY,
        _type: "span",
        text: "",
        marks: []
      }],
      value: rest,
      __inline: !0
    }, {
      at: focus,
      select: !0
    }) : Transforms.insertNodes(operation.editor, {
      _key,
      _type,
      children: [{
        _key: VOID_CHILD_KEY,
        _type: "span",
        text: "",
        marks: []
      }],
      value: rest,
      __inline: !0
    }, {
      at: [focusBlockIndex, focusChildIndex + 1],
      select: !0
    });
    return;
  }
  throw new Error("Unable to parse child");
}, insertTextOperationImplementation = ({
  operation
}) => {
  Transforms.insertText(operation.editor, operation.text);
}, moveBackwardOperationImplementation = ({
  operation
}) => {
  Transforms.move(operation.editor, {
    unit: "character",
    distance: operation.distance,
    reverse: !0
  });
}, moveBlockOperationImplementation = ({
  operation
}) => {
  const originKey = getBlockKeyFromSelectionPoint({
    path: operation.at
  });
  if (!originKey)
    throw new Error("Failed to get block key from selection point");
  const originBlockIndex = operation.editor.blockIndexMap.get(originKey);
  if (originBlockIndex === void 0)
    throw new Error("Failed to get block index from block key");
  const destinationKey = getBlockKeyFromSelectionPoint({
    path: operation.to
  });
  if (!destinationKey)
    throw new Error("Failed to get block key from selection point");
  const destinationBlockIndex = operation.editor.blockIndexMap.get(destinationKey);
  if (destinationBlockIndex === void 0)
    throw new Error("Failed to get block index from block key");
  Transforms.moveNodes(operation.editor, {
    at: [originBlockIndex],
    to: [destinationBlockIndex],
    mode: "highest"
  });
}, moveForwardOperationImplementation = ({
  operation
}) => {
  Transforms.move(operation.editor, {
    unit: "character",
    distance: operation.distance
  });
}, selectOperationImplementation = ({
  context,
  operation
}) => {
  const newSelection = toSlateRange({
    context: {
      schema: context.schema,
      value: operation.editor.value,
      selection: operation.at
    },
    blockIndexMap: operation.editor.blockIndexMap
  });
  newSelection ? Transforms.select(operation.editor, newSelection) : Transforms.deselect(operation.editor), IS_FOCUSED.get(operation.editor) && IS_READ_ONLY.get(operation.editor) && IS_FOCUSED.set(operation.editor, !1);
}, operationImplementations = {
  "annotation.add": addAnnotationOperationImplementation,
  "annotation.remove": removeAnnotationOperationImplementation,
  "block.set": blockSetOperationImplementation,
  "block.unset": blockUnsetOperationImplementation,
  "child.set": childSetOperationImplementation,
  "child.unset": childUnsetOperationImplementation,
  "decorator.add": decoratorAddOperationImplementation,
  "decorator.remove": decoratorRemoveOperationImplementation,
  delete: deleteOperationImplementation,
  "history.redo": historyRedoOperationImplementation,
  "history.undo": historyUndoOperationImplementation,
  "insert.block": insertBlockOperationImplementation,
  "insert.child": insertChildOperationImplementation,
  "insert.text": insertTextOperationImplementation,
  "move.backward": moveBackwardOperationImplementation,
  "move.block": moveBlockOperationImplementation,
  "move.forward": moveForwardOperationImplementation,
  select: selectOperationImplementation
};
function performOperation({
  context,
  operation
}) {
  Editor.withoutNormalizing(operation.editor, () => {
    try {
      switch (operation.type) {
        case "annotation.add": {
          operationImplementations["annotation.add"]({
            context,
            operation
          });
          break;
        }
        case "annotation.remove": {
          operationImplementations["annotation.remove"]({
            context,
            operation
          });
          break;
        }
        case "block.set": {
          operationImplementations["block.set"]({
            context,
            operation
          });
          break;
        }
        case "block.unset": {
          operationImplementations["block.unset"]({
            context,
            operation
          });
          break;
        }
        case "child.set": {
          operationImplementations["child.set"]({
            context,
            operation
          });
          break;
        }
        case "child.unset": {
          operationImplementations["child.unset"]({
            context,
            operation
          });
          break;
        }
        case "decorator.add": {
          operationImplementations["decorator.add"]({
            context,
            operation
          });
          break;
        }
        case "decorator.remove": {
          operationImplementations["decorator.remove"]({
            context,
            operation
          });
          break;
        }
        case "delete": {
          operationImplementations.delete({
            context,
            operation
          });
          break;
        }
        case "history.redo": {
          operationImplementations["history.redo"]({
            context,
            operation
          });
          break;
        }
        case "history.undo": {
          operationImplementations["history.undo"]({
            context,
            operation
          });
          break;
        }
        case "insert.block": {
          operationImplementations["insert.block"]({
            context,
            operation
          });
          break;
        }
        case "insert.child": {
          operationImplementations["insert.child"]({
            context,
            operation
          });
          break;
        }
        case "insert.text": {
          operationImplementations["insert.text"]({
            context,
            operation
          });
          break;
        }
        case "move.backward": {
          operationImplementations["move.backward"]({
            context,
            operation
          });
          break;
        }
        case "move.block": {
          operationImplementations["move.block"]({
            context,
            operation
          });
          break;
        }
        case "move.forward": {
          operationImplementations["move.forward"]({
            context,
            operation
          });
          break;
        }
        default: {
          operationImplementations.select({
            context,
            operation
          });
          break;
        }
      }
    } catch (error) {
      console.error(new Error(`Executing "${operation.type}" failed due to: ${error.message}`));
    }
  });
}
const abstractAnnotationBehaviors = [defineBehavior({
  on: "annotation.set",
  guard: ({
    snapshot,
    event
  }) => {
    const blockKey = event.at[0]._key, markDefKey = event.at[2]._key, block = getFocusTextBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: {
            path: [{
              _key: blockKey
            }],
            offset: 0
          },
          focus: {
            path: [{
              _key: blockKey
            }],
            offset: 0
          }
        }
      }
    });
    if (!block)
      return !1;
    const updatedMarkDefs = block.node.markDefs?.map((markDef) => markDef._key === markDefKey ? {
      ...markDef,
      ...event.props
    } : markDef);
    return {
      blockKey,
      updatedMarkDefs
    };
  },
  actions: [(_, {
    blockKey,
    updatedMarkDefs
  }) => [raise({
    type: "block.set",
    at: [{
      _key: blockKey
    }],
    props: {
      markDefs: updatedMarkDefs
    }
  })]]
}), defineBehavior({
  on: "annotation.toggle",
  guard: ({
    snapshot,
    event
  }) => isActiveAnnotation(event.annotation.name)(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "annotation.remove",
    annotation: event.annotation
  })]]
}), defineBehavior({
  on: "annotation.toggle",
  guard: ({
    snapshot,
    event
  }) => !isActiveAnnotation(event.annotation.name)(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "annotation.add",
    annotation: event.annotation
  })]]
})], abstractDecoratorBehaviors = [defineBehavior({
  on: "decorator.toggle",
  guard: ({
    snapshot,
    event
  }) => isActiveDecorator(event.decorator)(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "decorator.remove",
    decorator: event.decorator
  })]]
}), defineBehavior({
  on: "decorator.toggle",
  guard: ({
    snapshot,
    event
  }) => event.at ? !isActiveDecorator(event.decorator)({
    ...snapshot,
    context: {
      ...snapshot.context,
      selection: event.at
    }
  }) : !isActiveDecorator(event.decorator)(snapshot),
  actions: [({
    event
  }) => [raise({
    ...event,
    type: "decorator.add"
  })]]
})], abstractDeleteBehaviors = [defineBehavior({
  on: "delete.backward",
  guard: ({
    snapshot
  }) => snapshot.context.selection,
  actions: [({
    event
  }) => [raise({
    type: "delete",
    direction: "backward",
    unit: event.unit
  })]]
}), defineBehavior({
  on: "delete",
  guard: ({
    snapshot,
    event
  }) => {
    if (event.direction !== "backward")
      return !1;
    const previousBlock = getPreviousBlock(snapshot), focusTextBlock = getFocusTextBlock(snapshot);
    if (!previousBlock || !focusTextBlock || !isAtTheStartOfBlock(focusTextBlock)(snapshot))
      return !1;
    const previousBlockEndPoint = getBlockEndPoint({
      context: snapshot.context,
      block: previousBlock
    });
    return isTextBlock(snapshot.context, previousBlock.node) ? {
      previousBlockEndPoint,
      focusTextBlock
    } : !1;
  },
  actions: [(_, {
    previousBlockEndPoint,
    focusTextBlock
  }) => [raise({
    type: "delete.block",
    at: focusTextBlock.path
  }), raise({
    type: "select",
    at: {
      anchor: previousBlockEndPoint,
      focus: previousBlockEndPoint
    }
  }), raise({
    type: "insert.block",
    block: focusTextBlock.node,
    placement: "auto",
    select: "start"
  })]]
}), defineBehavior({
  on: "delete.forward",
  guard: ({
    snapshot
  }) => snapshot.context.selection,
  actions: [({
    event
  }) => [raise({
    type: "delete",
    direction: "forward",
    unit: event.unit
  })]]
}), defineBehavior({
  on: "delete",
  guard: ({
    snapshot,
    event
  }) => {
    if (event.direction !== "forward")
      return !1;
    const at = event.at ?? snapshot.context.selection;
    if (!at)
      return !1;
    const nextBlock = getNextBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: at
      }
    }), focusTextBlock = getFocusTextBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: at
      }
    });
    if (!nextBlock || !focusTextBlock || !isEmptyTextBlock(snapshot.context, focusTextBlock.node))
      return !1;
    const nextBlockStartPoint = getBlockStartPoint({
      context: snapshot.context,
      block: nextBlock
    });
    return {
      focusTextBlock,
      nextBlockStartPoint
    };
  },
  actions: [(_, {
    focusTextBlock,
    nextBlockStartPoint
  }) => [raise({
    type: "delete.block",
    at: focusTextBlock.path
  }), raise({
    type: "select",
    at: {
      anchor: nextBlockStartPoint,
      focus: nextBlockStartPoint
    }
  })]]
}), defineBehavior({
  on: "delete",
  guard: ({
    snapshot,
    event
  }) => {
    if (event.direction !== "forward")
      return !1;
    const nextBlock = getNextBlock(snapshot), focusTextBlock = getFocusTextBlock(snapshot);
    return !nextBlock || !focusTextBlock || !isAtTheEndOfBlock(focusTextBlock)(snapshot) || !isTextBlock(snapshot.context, nextBlock.node) ? !1 : {
      nextBlock
    };
  },
  actions: [(_, {
    nextBlock
  }) => [raise({
    type: "delete.block",
    at: nextBlock.path
  }), raise({
    type: "insert.block",
    block: nextBlock.node,
    placement: "auto",
    select: "none"
  })]]
}), defineBehavior({
  on: "delete.block",
  actions: [({
    event
  }) => [raise({
    type: "delete",
    at: {
      anchor: {
        path: event.at,
        offset: 0
      },
      focus: {
        path: event.at,
        offset: 0
      }
    },
    unit: "block"
  })]]
}), defineBehavior({
  on: "delete.child",
  guard: ({
    snapshot,
    event
  }) => {
    const focusChild = getFocusChild$1({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: {
            path: event.at,
            offset: 0
          },
          focus: {
            path: event.at,
            offset: 0
          }
        }
      }
    });
    return focusChild ? isSpan(snapshot.context, focusChild.node) ? {
      selection: {
        anchor: {
          path: event.at,
          offset: 0
        },
        focus: {
          path: event.at,
          offset: focusChild.node.text.length
        }
      }
    } : {
      selection: {
        anchor: {
          path: event.at,
          offset: 0
        },
        focus: {
          path: event.at,
          offset: 0
        }
      }
    } : !1;
  },
  actions: [(_, {
    selection
  }) => [raise({
    type: "delete",
    at: selection
  })]]
}), defineBehavior({
  on: "delete.text",
  actions: [({
    event
  }) => [raise({
    ...event,
    type: "delete"
  })]]
})], mimeTypePriority = ["application/x-portable-text", "application/json", "text/markdown", "text/html", "text/plain"];
function getFirstAvailableData({
  dataTransfer,
  startAfter
}) {
  const startIndex = startAfter ? mimeTypePriority.indexOf(startAfter) + 1 : 0;
  for (let index = startIndex; index < mimeTypePriority.length; index++) {
    const mimeType = mimeTypePriority.at(index);
    if (!mimeType)
      continue;
    const data = dataTransfer.getData(mimeType);
    if (data)
      return {
        mimeType,
        data
      };
  }
}
const abstractDeserializeBehaviors = [
  defineBehavior({
    on: "deserialize",
    guard: ({
      event
    }) => {
      const availableData = getFirstAvailableData({
        dataTransfer: event.originEvent.originEvent.dataTransfer
      });
      return availableData ? {
        type: "deserialize.data",
        mimeType: availableData.mimeType,
        data: availableData.data,
        originEvent: event.originEvent
      } : !1;
    },
    actions: [(_, deserializeEvent) => [raise(deserializeEvent)]]
  }),
  defineBehavior({
    on: "deserialize",
    actions: [({
      event
    }) => [raise({
      type: "deserialization.failure",
      mimeType: "*/*",
      reason: "No Behavior was able to handle the incoming data",
      originEvent: event.originEvent
    })]]
  }),
  defineBehavior({
    on: "deserialize.data",
    guard: ({
      event
    }) => {
      if (event.mimeType !== "text/html")
        return !1;
      const plainText = event.originEvent.originEvent.dataTransfer.getData("text/plain");
      return event.data !== plainText ? !1 : {
        type: "deserialize.data",
        mimeType: "text/plain",
        data: plainText,
        originEvent: event.originEvent
      };
    },
    actions: [(_, deserializeDataEvent) => [raise(deserializeDataEvent)]]
  }),
  defineBehavior({
    on: "deserialize.data",
    guard: ({
      snapshot,
      event
    }) => {
      const converter = snapshot.context.converters.find((converter2) => converter2.mimeType === event.mimeType);
      return converter ? converter.deserialize({
        snapshot,
        event: {
          type: "deserialize",
          data: event.data
        }
      }) : !1;
    },
    actions: [({
      event
    }, deserializeEvent) => [raise({
      ...deserializeEvent,
      originEvent: event.originEvent
    })]]
  }),
  /**
   * If we are pasting text/plain into a text block then we can probably
   * assume that the intended behavior is that the pasted text inherits
   * formatting from the text it's pasted into.
   */
  defineBehavior({
    on: "deserialization.success",
    guard: ({
      snapshot,
      event
    }) => {
      if (getFocusTextBlock(snapshot) && event.mimeType === "text/plain" && event.originEvent.type !== "drag.drop") {
        const activeDecorators = getActiveDecorators(snapshot);
        return {
          activeAnnotations: getActiveAnnotations(snapshot),
          activeDecorators,
          textRuns: event.data.flatMap((block) => isTextBlock(snapshot.context, block) ? [getTextBlockText(block)] : [])
        };
      }
      return !1;
    },
    actions: [(_, {
      activeAnnotations,
      activeDecorators,
      textRuns
    }) => textRuns.flatMap((textRun, index) => index !== textRuns.length - 1 ? [raise({
      type: "insert.span",
      text: textRun,
      decorators: activeDecorators,
      annotations: activeAnnotations.map(({
        _key,
        _type,
        ...value
      }) => ({
        name: _type,
        value
      }))
    }), raise({
      type: "insert.break"
    })] : [raise({
      type: "insert.span",
      text: textRun,
      decorators: activeDecorators,
      annotations: activeAnnotations.map(({
        _key,
        _type,
        ...value
      }) => ({
        name: _type,
        value
      }))
    })])]
  }),
  defineBehavior({
    on: "deserialization.success",
    actions: [({
      event
    }) => [raise({
      type: "insert.blocks",
      blocks: event.data,
      placement: "auto"
    })]]
  }),
  defineBehavior({
    on: "deserialization.failure",
    guard: ({
      event
    }) => {
      if (event.mimeType === "*/*")
        return !1;
      const availableData = getFirstAvailableData({
        dataTransfer: event.originEvent.originEvent.dataTransfer,
        startAfter: event.mimeType
      });
      return availableData ? {
        type: "deserialize.data",
        mimeType: availableData.mimeType,
        data: availableData.data,
        originEvent: event.originEvent
      } : !1;
    },
    actions: [(_, deserializeDataEvent) => [raise(deserializeDataEvent)]]
  }),
  defineBehavior({
    on: "deserialization.failure",
    actions: [({
      event
    }) => [{
      type: "effect",
      effect: () => {
        console.warn(`Deserialization of ${event.mimeType} failed with reason "${event.reason}"`);
      }
    }]]
  })
], abstractInputBehaviors = [
  defineBehavior({
    on: "input.*",
    guard: ({
      snapshot
    }) => isSelectionExpanded(snapshot),
    actions: [({
      event
    }) => [raise({
      type: "delete"
    }), forward(event)]]
  }),
  /**
   * Handle input events where HTML equals plain text (e.g., Safari autocorrect).
   * In this case, we use insert.text to preserve existing marks.
   */
  defineBehavior({
    on: "input.*",
    guard: ({
      event
    }) => {
      const text = event.originEvent.dataTransfer.getData("text/plain"), html = event.originEvent.dataTransfer.getData("text/html"), types = event.originEvent.dataTransfer.types;
      return !text || text.includes(`
`) ? !1 : types.length === 1 ? {
        text
      } : types.length > 2 ? !1 : html && text === html ? {
        text
      } : !1;
    },
    actions: [(_, {
      text
    }) => [raise({
      type: "insert.text",
      text
    })]]
  }),
  defineBehavior({
    on: "input.*",
    actions: [({
      event
    }) => [raise({
      type: "deserialize",
      originEvent: event
    })]]
  })
];
function getUniqueBlockKey(blockKey) {
  return (snapshot) => !blockKey || snapshot.blockIndexMap.has(blockKey) ? snapshot.context.keyGenerator() : blockKey;
}
const abstractInsertBehaviors = [
  defineBehavior({
    on: "insert.blocks",
    guard: ({
      event
    }) => {
      const onlyBlock = event.blocks.length === 1 ? event.blocks.at(0) : void 0;
      return onlyBlock ? {
        onlyBlock
      } : !1;
    },
    actions: [({
      event
    }, {
      onlyBlock
    }) => [raise({
      type: "insert.block",
      block: onlyBlock,
      placement: event.placement,
      select: event.select ?? "end"
    })]]
  }),
  defineBehavior({
    on: "insert.blocks",
    guard: ({
      snapshot,
      event
    }) => {
      if (event.placement !== "before")
        return !1;
      const firstBlockKey = getUniqueBlockKey(event.blocks.at(0)?._key)(snapshot), lastBlockKey = getUniqueBlockKey(event.blocks.at(-1)?._key)(snapshot);
      return {
        firstBlockKey,
        lastBlockKey
      };
    },
    actions: [({
      snapshot,
      event
    }, {
      firstBlockKey,
      lastBlockKey
    }) => [...event.blocks.map((block, index) => raise({
      type: "insert.block",
      block: index === 0 ? {
        ...block,
        _key: firstBlockKey
      } : index === event.blocks.length - 1 ? {
        ...block,
        _key: lastBlockKey
      } : block,
      placement: index === 0 ? "before" : "after",
      select: index !== event.blocks.length - 1 ? "end" : "none"
    })), ...event.select === "none" ? [raise({
      type: "select",
      at: snapshot.context.selection
    })] : event.select === "start" ? [raise({
      type: "select.block",
      at: [{
        _key: firstBlockKey
      }],
      select: "start"
    })] : [raise({
      type: "select.block",
      at: [{
        _key: lastBlockKey
      }],
      select: "end"
    })]]]
  }),
  defineBehavior({
    on: "insert.blocks",
    guard: ({
      snapshot,
      event
    }) => {
      if (event.placement !== "after")
        return !1;
      const firstBlockKey = getUniqueBlockKey(event.blocks.at(0)?._key)(snapshot), lastBlockKey = getUniqueBlockKey(event.blocks.at(-1)?._key)(snapshot);
      return {
        firstBlockKey,
        lastBlockKey
      };
    },
    actions: [({
      snapshot,
      event
    }, {
      firstBlockKey,
      lastBlockKey
    }) => [...event.blocks.map((block, index) => raise({
      type: "insert.block",
      block: index === 0 ? {
        ...block,
        _key: firstBlockKey
      } : index === event.blocks.length - 1 ? {
        ...block,
        _key: lastBlockKey
      } : block,
      placement: "after",
      select: index !== event.blocks.length - 1 ? "end" : "none"
    })), ...event.select === "none" ? [raise({
      type: "select",
      at: snapshot.context.selection
    })] : event.select === "start" ? [raise({
      type: "select.block",
      at: [{
        _key: firstBlockKey
      }],
      select: "start"
    })] : [raise({
      type: "select.block",
      at: [{
        _key: lastBlockKey
      }],
      select: "end"
    })]]]
  }),
  defineBehavior({
    on: "insert.blocks",
    guard: ({
      snapshot,
      event
    }) => {
      if (event.placement !== "auto")
        return !1;
      const focusTextBlock = getFocusTextBlock(snapshot);
      if (!focusTextBlock || !isEmptyTextBlock(snapshot.context, focusTextBlock.node))
        return !1;
      const firstBlockKey = getUniqueBlockKey(event.blocks.at(0)?._key)(snapshot), lastBlockKey = getUniqueBlockKey(event.blocks.at(-1)?._key)(snapshot);
      return {
        focusTextBlock,
        firstBlockKey,
        lastBlockKey
      };
    },
    actions: [({
      event
    }, {
      firstBlockKey,
      lastBlockKey
    }) => [...event.blocks.map((block, index) => raise({
      type: "insert.block",
      block: index === 0 ? {
        ...block,
        _key: firstBlockKey
      } : index === event.blocks.length - 1 ? {
        ...block,
        _key: lastBlockKey
      } : block,
      placement: index === 0 ? "auto" : "after",
      select: index !== event.blocks.length - 1 ? "end" : "none"
    })), ...event.select === "none" ? [raise({
      type: "select.block",
      at: [{
        _key: firstBlockKey
      }],
      select: "start"
    })] : event.select === "start" ? [raise({
      type: "select.block",
      at: [{
        _key: firstBlockKey
      }],
      select: "start"
    })] : [raise({
      type: "select.block",
      at: [{
        _key: lastBlockKey
      }],
      select: "end"
    })]]]
  }),
  defineBehavior({
    on: "insert.blocks",
    guard: ({
      snapshot,
      event
    }) => {
      if (event.placement !== "auto")
        return !1;
      const focusTextBlock = getFocusTextBlock(snapshot);
      if (!focusTextBlock || !snapshot.context.selection)
        return !1;
      const focusBlockStartPoint = getBlockStartPoint({
        context: snapshot.context,
        block: focusTextBlock
      }), focusBlockEndPoint = getBlockEndPoint({
        context: snapshot.context,
        block: focusTextBlock
      }), focusTextBlockAfter = sliceTextBlock({
        context: {
          schema: snapshot.context.schema,
          selection: {
            anchor: snapshot.context.selection.focus,
            focus: focusBlockEndPoint
          }
        },
        block: focusTextBlock.node
      }), firstBlockKey = getUniqueBlockKey(event.blocks.at(0)?._key)(snapshot), lastBlockKey = getUniqueBlockKey(event.blocks.at(-1)?._key)(snapshot), isFirstBlockTextBlock = isTextBlock(snapshot.context, event.blocks.at(0));
      return {
        firstBlockKey,
        lastBlockKey,
        focusBlockStartPoint,
        focusBlockEndPoint,
        focusTextBlockAfter,
        selection: snapshot.context.selection,
        isFirstBlockTextBlock
      };
    },
    actions: [({
      snapshot,
      event
    }, {
      focusBlockEndPoint,
      focusTextBlockAfter,
      selection,
      firstBlockKey,
      lastBlockKey,
      focusBlockStartPoint,
      isFirstBlockTextBlock
    }) => [...event.blocks.flatMap((block, index) => index === 0 ? [...isEqualSelectionPoints(selection.focus, focusBlockEndPoint) ? [] : [raise({
      type: "delete",
      at: {
        anchor: selection.focus,
        focus: focusBlockEndPoint
      }
    })], raise({
      type: "insert.block",
      block: {
        ...block,
        _key: firstBlockKey
      },
      placement: "auto",
      select: "end"
    })] : index === event.blocks.length - 1 ? [raise({
      type: "insert.block",
      block: {
        ...block,
        _key: lastBlockKey
      },
      placement: "after",
      select: "end"
    }), ...isEmptyTextBlock(snapshot.context, focusTextBlockAfter) ? [] : [raise({
      type: "insert.block",
      block: focusTextBlockAfter,
      placement: "auto",
      select: event.select === "end" ? "none" : "end"
    })]] : [raise({
      type: "insert.block",
      block,
      placement: "after",
      select: "end"
    })]), ...event.select === "none" ? [raise({
      type: "select",
      at: selection
    })] : event.select === "start" ? [isEqualSelectionPoints(selection.focus, focusBlockStartPoint) || !isFirstBlockTextBlock ? raise({
      type: "select.block",
      at: [{
        _key: firstBlockKey
      }],
      select: "start"
    }) : raise({
      type: "select",
      at: {
        anchor: selection.focus,
        focus: selection.focus
      }
    })] : []]]
  }),
  defineBehavior({
    on: "insert.blocks",
    guard: ({
      snapshot,
      event
    }) => {
      if (event.placement !== "auto")
        return !1;
      const selection = snapshot.context.selection, firstBlockKey = getUniqueBlockKey(event.blocks.at(0)?._key)(snapshot), lastBlockKey = getUniqueBlockKey(event.blocks.at(-1)?._key)(snapshot);
      return {
        firstBlockKey,
        lastBlockKey,
        selection
      };
    },
    actions: [({
      event
    }, {
      firstBlockKey,
      lastBlockKey,
      selection
    }) => [...event.blocks.map((block, index) => raise({
      type: "insert.block",
      block: index === 0 ? {
        ...block,
        _key: firstBlockKey
      } : index === event.blocks.length - 1 ? {
        ...block,
        _key: lastBlockKey
      } : block,
      placement: index === 0 ? "auto" : "after",
      select: index !== event.blocks.length - 1 ? "end" : event.select ?? "end"
    })), ...event.select === "none" ? [raise({
      type: "select",
      at: selection
    })] : event.select === "start" ? [raise({
      type: "select.block",
      at: [{
        _key: firstBlockKey
      }],
      select: "start"
    })] : [raise({
      type: "select.block",
      at: [{
        _key: lastBlockKey
      }],
      select: "end"
    })]]]
  }),
  defineBehavior({
    on: "insert.break",
    actions: [() => [raise({
      type: "split"
    })]]
  }),
  defineBehavior({
    on: "insert.child",
    guard: ({
      snapshot
    }) => {
      const lastBlock = getLastBlock$1(snapshot);
      return !lastBlock || snapshot.context.selection ? !1 : {
        lastBlockEndPoint: getBlockEndPoint({
          context: snapshot.context,
          block: lastBlock
        })
      };
    },
    actions: [({
      event
    }, {
      lastBlockEndPoint
    }) => [raise({
      type: "select",
      at: {
        anchor: lastBlockEndPoint,
        focus: lastBlockEndPoint
      }
    }), raise(event)]]
  }),
  defineBehavior({
    on: "insert.child",
    guard: ({
      snapshot
    }) => {
      const focusTextBlock = getFocusTextBlock(snapshot);
      return snapshot.context.selection && !focusTextBlock;
    },
    actions: [({
      snapshot,
      event
    }) => [raise({
      type: "insert.block",
      block: {
        _type: snapshot.context.schema.block.name,
        children: [{
          _type: snapshot.context.schema.span.name,
          text: "",
          marks: []
        }]
      },
      placement: "auto",
      select: "end"
    }), raise(event)]]
  }),
  defineBehavior({
    on: "insert.inline object",
    actions: [({
      event
    }) => [raise({
      type: "insert.child",
      child: {
        _type: event.inlineObject.name,
        ...event.inlineObject.value
      }
    })]]
  }),
  defineBehavior({
    on: "insert.soft break",
    actions: [() => [raise({
      type: "insert.text",
      text: `
`
    })]]
  }),
  defineBehavior({
    on: "insert.span",
    guard: ({
      snapshot
    }) => !getFocusTextBlock(snapshot),
    actions: [({
      snapshot,
      event
    }) => [raise({
      type: "insert.block",
      block: {
        _type: snapshot.context.schema.block.name,
        children: [{
          _type: snapshot.context.schema.span.name,
          text: "",
          marks: []
        }]
      },
      placement: "auto",
      select: "end"
    }), raise(event)]]
  }),
  defineBehavior({
    on: "insert.span",
    guard: ({
      snapshot,
      event
    }) => {
      const focusTextBlock = getFocusTextBlock(snapshot);
      return {
        markDefs: event.annotations?.map((annotation) => ({
          _type: annotation.name,
          _key: snapshot.context.keyGenerator(),
          ...annotation.value
        })) ?? [],
        focusTextBlock
      };
    },
    actions: [({
      snapshot,
      event
    }, {
      markDefs,
      focusTextBlock
    }) => [...focusTextBlock ? [raise({
      type: "block.set",
      at: focusTextBlock.path,
      props: {
        markDefs: [...focusTextBlock.node.markDefs ?? [], ...markDefs]
      }
    })] : [], raise({
      type: "insert.child",
      child: {
        _type: snapshot.context.schema.span.name,
        text: event.text,
        marks: [...event.decorators ?? [], ...markDefs.map((markDef) => markDef._key)]
      }
    })]]
  }),
  /**
   * If there's an expanded selection, then we delete the selection before we
   * insert the text.
   */
  defineBehavior({
    on: "insert.text",
    guard: ({
      snapshot
    }) => isSelectionExpanded(snapshot),
    actions: [({
      event
    }) => [raise({
      type: "delete"
    }), raise(event)]]
  }),
  /**
   * If there's no selection, then we select the end of the editor before we
   * we insert the text.
   */
  defineBehavior({
    on: "insert.text",
    guard: ({
      snapshot
    }) => {
      if (snapshot.context.selection)
        return !1;
      const lastBlok = getLastBlock$1(snapshot);
      return lastBlok ? {
        endPoint: getBlockEndPoint({
          context: snapshot.context,
          block: lastBlok
        })
      } : !1;
    },
    actions: [({
      event
    }, {
      endPoint
    }) => [raise({
      type: "select",
      at: {
        anchor: endPoint,
        focus: endPoint
      }
    }), raise(event)]]
  })
], shiftLeft = createKeyboardShortcut({
  default: [{
    key: "ArrowLeft",
    shift: !0,
    meta: !1,
    ctrl: !1,
    alt: !1
  }]
}), abstractKeyboardBehaviors = [
  /**
   * When Backspace is pressed on an inline object, Slate will raise a
   * `delete.backward` event with `unit: 'block'`. This is wrong and this
   * Behavior adjusts that.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.backspace.guard(event.originEvent) && isSelectionCollapsed$1(snapshot) && getFocusInlineObject(snapshot),
    actions: [() => [raise({
      type: "delete.backward",
      unit: "character"
    })]]
  }),
  /**
   * When Delete is pressed on an inline object, Slate will raise a
   * `delete.forward` event with `unit: 'block'`. This is wrong and this
   * Behavior adjusts that.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.delete.guard(event.originEvent) && isSelectionCollapsed$1(snapshot) && getFocusInlineObject(snapshot),
    actions: [() => [raise({
      type: "delete.forward",
      unit: "character"
    })]]
  }),
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      event
    }) => defaultKeyboardShortcuts.deleteWord.backward.guard(event.originEvent),
    actions: [() => [raise({
      type: "delete.backward",
      unit: "word"
    })]]
  }),
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      event
    }) => defaultKeyboardShortcuts.deleteWord.forward.guard(event.originEvent),
    actions: [() => [raise({
      type: "delete.forward",
      unit: "word"
    })]]
  }),
  /**
   * Allow raising an `insert.break` event when pressing Enter on an inline
   * object.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.break.guard(event.originEvent) && isSelectionCollapsed$1(snapshot) && getFocusInlineObject(snapshot),
    actions: [() => [raise({
      type: "insert.break"
    })]]
  }),
  /**
   * On Firefox, Enter might collapse the selection. To mitigate this, we
   * `raise` an `insert.break` event manually.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => defaultKeyboardShortcuts.break.guard(event.originEvent) && isSelectionExpanded(snapshot),
    actions: [() => [raise({
      type: "insert.break"
    })]]
  }),
  /**
   * On WebKit, Shift+Enter results in an `insertParagraph` input event rather
   * than an `insertLineBreak` input event. This Behavior makes sure we catch
   * that `keyboard.keydown` event beforehand and raise an `insert.soft break` manually.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      event
    }) => defaultKeyboardShortcuts.lineBreak.guard(event.originEvent),
    actions: [() => [raise({
      type: "insert.soft break"
    })]]
  }),
  /**
   * Manual handling of undo shortcuts.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      event
    }) => defaultKeyboardShortcuts.history.undo.guard(event.originEvent),
    actions: [() => [raise({
      type: "history.undo"
    })]]
  }),
  /**
   * Manual handling of redo shortcuts.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      event
    }) => defaultKeyboardShortcuts.history.redo.guard(event.originEvent),
    actions: [() => [raise({
      type: "history.redo"
    })]]
  }),
  /**
   * Fix edge case where Shift+ArrowLeft didn't reduce a selection hanging
   * onto an empty text block.
   */
  defineBehavior({
    on: "keyboard.keydown",
    guard: ({
      snapshot,
      event
    }) => {
      if (!snapshot.context.selection || !shiftLeft.guard(event.originEvent))
        return !1;
      const focusBlock = getFocusBlock$1(snapshot);
      if (!focusBlock)
        return !1;
      const previousBlock = getPreviousBlock({
        ...snapshot,
        context: {
          ...snapshot.context,
          selection: {
            anchor: {
              path: focusBlock.path,
              offset: 0
            },
            focus: {
              path: focusBlock.path,
              offset: 0
            }
          }
        }
      });
      return previousBlock && isTextBlock(snapshot.context, focusBlock.node) && snapshot.context.selection.focus.offset === 0 && isEmptyTextBlock(snapshot.context, focusBlock.node) ? {
        previousBlock,
        selection: snapshot.context.selection
      } : !1;
    },
    actions: [({
      snapshot
    }, {
      previousBlock,
      selection
    }) => [raise({
      type: "select",
      at: {
        anchor: selection.anchor,
        focus: getBlockEndPoint({
          context: snapshot.context,
          block: previousBlock
        })
      }
    })]]
  })
], abstractListItemBehaviors = [defineBehavior({
  on: "list item.add",
  guard: ({
    snapshot,
    event
  }) => snapshot.context.schema.lists.some((list) => list.name === event.listItem) ? {
    selectedTextBlocks: getSelectedTextBlocks(snapshot)
  } : !1,
  actions: [({
    event
  }, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => raise({
    type: "block.set",
    at: block.path,
    props: {
      level: block.node.level ?? 1,
      listItem: event.listItem
    }
  }))]
}), defineBehavior({
  on: "list item.remove",
  guard: ({
    snapshot
  }) => ({
    selectedTextBlocks: getSelectedTextBlocks(snapshot)
  }),
  actions: [(_, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => raise({
    type: "block.unset",
    at: block.path,
    props: ["level", "listItem"]
  }))]
}), defineBehavior({
  on: "list item.toggle",
  guard: ({
    snapshot,
    event
  }) => isActiveListItem(event.listItem)(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "list item.remove",
    listItem: event.listItem
  })]]
}), defineBehavior({
  on: "list item.toggle",
  guard: ({
    snapshot,
    event
  }) => !isActiveListItem(event.listItem)(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "list item.add",
    listItem: event.listItem
  })]]
})], abstractMoveBehaviors = [defineBehavior({
  on: "move.block up",
  guard: ({
    snapshot,
    event
  }) => {
    const previousBlock = getPreviousBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: {
            path: event.at,
            offset: 0
          },
          focus: {
            path: event.at,
            offset: 0
          }
        }
      }
    });
    return previousBlock ? {
      previousBlock
    } : !1;
  },
  actions: [({
    event
  }, {
    previousBlock
  }) => [raise({
    type: "move.block",
    at: event.at,
    to: previousBlock.path
  })]]
}), defineBehavior({
  on: "move.block down",
  guard: ({
    snapshot,
    event
  }) => {
    const nextBlock = getNextBlock({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: {
            path: event.at,
            offset: 0
          },
          focus: {
            path: event.at,
            offset: 0
          }
        }
      }
    });
    return nextBlock ? {
      nextBlock
    } : !1;
  },
  actions: [({
    event
  }, {
    nextBlock
  }) => [raise({
    type: "move.block",
    at: event.at,
    to: nextBlock.path
  })]]
})], abstractSelectBehaviors = [defineBehavior({
  on: "select.block",
  guard: ({
    snapshot,
    event
  }) => {
    if (event.select !== "end")
      return !1;
    const block = getFocusBlock$1({
      ...snapshot,
      context: {
        ...snapshot.context,
        selection: {
          anchor: {
            path: event.at,
            offset: 0
          },
          focus: {
            path: event.at,
            offset: 0
          }
        }
      }
    });
    return block ? {
      blockEndPoint: getBlockEndPoint({
        context: snapshot.context,
        block
      })
    } : !1;
  },
  actions: [(_, {
    blockEndPoint
  }) => [raise({
    type: "select",
    at: {
      anchor: blockEndPoint,
      focus: blockEndPoint
    }
  })]]
}), defineBehavior({
  on: "select.block",
  actions: [({
    event
  }) => [raise({
    type: "select",
    at: {
      anchor: {
        path: event.at,
        offset: 0
      },
      focus: {
        path: event.at,
        offset: 0
      }
    }
  })]]
}), defineBehavior({
  on: "select.previous block",
  guard: ({
    snapshot
  }) => {
    const previousBlock = getPreviousBlock(snapshot);
    return previousBlock ? {
      previousBlock
    } : !1;
  },
  actions: [({
    event
  }, {
    previousBlock
  }) => [raise({
    type: "select.block",
    at: previousBlock.path,
    select: event.select
  })]]
}), defineBehavior({
  on: "select.next block",
  guard: ({
    snapshot
  }) => {
    const nextBlock = getNextBlock(snapshot);
    return nextBlock ? {
      nextBlock
    } : !1;
  },
  actions: [({
    event
  }, {
    nextBlock
  }) => [raise({
    type: "select.block",
    at: nextBlock.path,
    select: event.select
  })]]
})], abstractSerializeBehaviors = [defineBehavior({
  on: "serialize",
  actions: [({
    event
  }) => [raise({
    type: "serialize.data",
    mimeType: "application/x-portable-text",
    originEvent: event.originEvent
  }), raise({
    type: "serialize.data",
    mimeType: "application/json",
    originEvent: event.originEvent
  }), raise({
    type: "serialize.data",
    mimeType: "text/markdown",
    originEvent: event.originEvent
  }), raise({
    type: "serialize.data",
    mimeType: "text/html",
    originEvent: event.originEvent
  }), raise({
    type: "serialize.data",
    mimeType: "text/plain",
    originEvent: event.originEvent
  })]]
}), defineBehavior({
  on: "serialize.data",
  guard: ({
    snapshot,
    event
  }) => {
    const converter = snapshot.context.converters.find((converter2) => converter2.mimeType === event.mimeType);
    return converter ? converter.serialize({
      snapshot,
      event: {
        type: "serialize",
        originEvent: event.originEvent.type
      }
    }) : !1;
  },
  actions: [({
    event
  }, serializeEvent) => [raise({
    ...serializeEvent,
    originEvent: event.originEvent
  })]]
}), defineBehavior({
  on: "serialization.success",
  actions: [({
    event
  }) => [{
    type: "effect",
    effect: () => {
      event.originEvent.originEvent.dataTransfer.setData(event.mimeType, event.data);
    }
  }]]
}), defineBehavior({
  on: "serialization.failure",
  actions: [({
    event
  }) => [{
    type: "effect",
    effect: () => {
      console.warn(`Serialization of ${event.mimeType} failed with reason "${event.reason}"`);
    }
  }]]
})], abstractSplitBehaviors = [
  /**
   * You can't split an inline object.
   */
  defineBehavior({
    on: "split",
    guard: ({
      snapshot
    }) => isSelectionCollapsed(snapshot.context.selection) && getFocusInlineObject(snapshot),
    actions: []
  }),
  /**
   * You can't split a block object.
   */
  defineBehavior({
    on: "split",
    guard: ({
      snapshot
    }) => isSelectionCollapsed(snapshot.context.selection) && getFocusBlockObject(snapshot),
    actions: []
  }),
  defineBehavior({
    on: "split",
    guard: ({
      snapshot
    }) => {
      const selection = snapshot.context.selection;
      if (!selection || isSelectionCollapsed(selection))
        return !1;
      const startPoint = getSelectionStartPoint$1(selection), endPoint = getSelectionEndPoint$1(selection);
      if (!startPoint || !endPoint)
        return !1;
      const startBlock = getSelectionStartBlock(snapshot), endBlock = getSelectionEndBlock(snapshot);
      if (!startBlock || !endBlock)
        return !1;
      const startBlockStartPoint = getBlockStartPoint({
        context: snapshot.context,
        block: startBlock
      }), endBlockEndPoint = getBlockEndPoint({
        context: snapshot.context,
        block: endBlock
      });
      return !!(isTextBlock(snapshot.context, startBlock.node) && isTextBlock(snapshot.context, endBlock.node) && !isEqualSelectionPoints(startPoint, startBlockStartPoint) && !isEqualSelectionPoints(endPoint, endBlockEndPoint));
    },
    actions: [() => [raise({
      type: "delete"
    }), raise({
      type: "split"
    })]]
  }),
  defineBehavior({
    on: "split",
    guard: ({
      snapshot
    }) => isSelectionExpanded(snapshot),
    actions: [() => [raise({
      type: "delete"
    })]]
  }),
  defineBehavior({
    on: "split",
    guard: ({
      snapshot
    }) => {
      const selection = snapshot.context.selection;
      if (!selection || !isSelectionCollapsed(selection))
        return !1;
      const selectionStartPoint = getSelectionStartPoint$1(selection), focusTextBlock = getFocusTextBlock(snapshot);
      if (!focusTextBlock)
        return !1;
      const blockEndPoint = getBlockEndPoint({
        context: snapshot.context,
        block: focusTextBlock
      }), newTextBlockSelection = {
        anchor: selectionStartPoint,
        focus: blockEndPoint
      }, newTextBlock = parseBlock({
        block: sliceTextBlock({
          context: {
            ...snapshot.context,
            selection: newTextBlockSelection
          },
          block: focusTextBlock.node
        }),
        context: snapshot.context,
        options: {
          normalize: !1,
          removeUnusedMarkDefs: !0,
          validateFields: !1
        }
      });
      return newTextBlock ? {
        newTextBlock,
        newTextBlockSelection
      } : !1;
    },
    actions: [(_, {
      newTextBlock,
      newTextBlockSelection
    }) => isSelectionCollapsed(newTextBlockSelection) ? [raise({
      type: "insert.block",
      block: newTextBlock,
      placement: "after",
      select: "start"
    })] : [raise({
      type: "delete",
      at: newTextBlockSelection
    }), raise({
      type: "insert.block",
      block: newTextBlock,
      placement: "after",
      select: "start"
    })]]
  })
], abstractStyleBehaviors = [defineBehavior({
  on: "style.add",
  guard: ({
    snapshot
  }) => ({
    selectedTextBlocks: getSelectedTextBlocks(snapshot)
  }),
  actions: [({
    event
  }, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => raise({
    type: "block.set",
    at: block.path,
    props: {
      style: event.style
    }
  }))]
}), defineBehavior({
  on: "style.remove",
  guard: ({
    snapshot
  }) => ({
    selectedTextBlocks: getSelectedTextBlocks(snapshot)
  }),
  actions: [(_, {
    selectedTextBlocks
  }) => selectedTextBlocks.map((block) => raise({
    type: "block.unset",
    at: block.path,
    props: ["style"]
  }))]
}), defineBehavior({
  on: "style.toggle",
  guard: ({
    snapshot,
    event
  }) => isActiveStyle(event.style)(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "style.remove",
    style: event.style
  })]]
}), defineBehavior({
  on: "style.toggle",
  guard: ({
    snapshot,
    event
  }) => !isActiveStyle(event.style)(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "style.add",
    style: event.style
  })]]
})], abstractBehaviors = [defineBehavior({
  on: "clipboard.copy",
  guard: ({
    snapshot
  }) => {
    const focusSpan = getFocusSpan$1(snapshot), selectionCollapsed = isSelectionCollapsed$1(snapshot);
    return focusSpan && selectionCollapsed;
  },
  actions: []
}), defineBehavior({
  on: "clipboard.copy",
  actions: [({
    event
  }) => [raise({
    type: "serialize",
    originEvent: event
  })]]
}), defineBehavior({
  on: "clipboard.cut",
  guard: ({
    snapshot
  }) => {
    const focusSpan = getFocusSpan$1(snapshot), selectionCollapsed = isSelectionCollapsed$1(snapshot);
    return focusSpan && selectionCollapsed;
  },
  actions: []
}), defineBehavior({
  on: "clipboard.cut",
  guard: ({
    snapshot
  }) => snapshot.context.selection,
  actions: [({
    event
  }) => [raise({
    type: "serialize",
    originEvent: event
  }), raise({
    type: "delete"
  })]]
}), defineBehavior({
  on: "drag.dragstart",
  actions: [({
    event
  }) => [raise({
    type: "serialize",
    originEvent: event
  })]]
}), defineBehavior({
  on: "clipboard.paste",
  guard: ({
    snapshot
  }) => isSelectionExpanded(snapshot),
  actions: [({
    event
  }) => [raise({
    type: "delete"
  }), forward(event)]]
}), defineBehavior({
  on: "clipboard.paste",
  actions: [({
    event
  }) => [raise({
    type: "deserialize",
    originEvent: event
  })]]
}), ...abstractAnnotationBehaviors, ...abstractDecoratorBehaviors, ...abstractDeleteBehaviors, ...abstractDeserializeBehaviors, ...abstractInputBehaviors, ...abstractInsertBehaviors, ...abstractKeyboardBehaviors, ...abstractListItemBehaviors, ...abstractMoveBehaviors, ...abstractStyleBehaviors, ...abstractSelectBehaviors, ...abstractSerializeBehaviors, ...abstractSplitBehaviors];
function isSyntheticBehaviorEvent(event) {
  return !isCustomBehaviorEvent(event) && !isNativeBehaviorEvent(event) && !isAbstractBehaviorEvent(event);
}
const abstractBehaviorEventTypes = ["annotation.set", "annotation.toggle", "decorator.toggle", "delete.backward", "delete.block", "delete.child", "delete.forward", "delete.text", "deserialize", "deserialize.data", "deserialization.success", "deserialization.failure", "insert.blocks", "insert.break", "insert.inline object", "insert.soft break", "insert.span", "list item.add", "list item.remove", "list item.toggle", "move.block down", "move.block up", "select.block", "select.previous block", "select.next block", "serialize", "serialize.data", "serialization.success", "serialization.failure", "split", "style.add", "style.remove", "style.toggle"];
function isAbstractBehaviorEvent(event) {
  return abstractBehaviorEventTypes.includes(event.type);
}
const nativeBehaviorEventTypes = ["clipboard.copy", "clipboard.cut", "clipboard.paste", "drag.dragstart", "drag.drag", "drag.dragend", "drag.dragenter", "drag.dragover", "drag.dragleave", "drag.drop", "input.*", "keyboard.keydown", "keyboard.keyup", "mouse.click"];
function isNativeBehaviorEvent(event) {
  return nativeBehaviorEventTypes.includes(event.type);
}
function isCustomBehaviorEvent(event) {
  return event.type.startsWith("custom.");
}
const debugEvent = debugWithName("behaviors:event"), debugOperation = debugWithName("operation");
function eventCategory(event) {
  return isNativeBehaviorEvent(event) ? "native" : isAbstractBehaviorEvent(event) ? "synthetic" : isCustomBehaviorEvent(event) ? "custom" : "synthetic";
}
function performEvent({
  mode,
  behaviors,
  remainingEventBehaviors,
  event,
  editor,
  keyGenerator,
  schema,
  getSnapshot,
  nativeEvent,
  sendBack
}) {
  mode === "send" && !isNativeBehaviorEvent(event) && (editor.undoStepId = defaultKeyGenerator()), debugEvent(`(${mode}:${eventCategory(event)})`, JSON.stringify(event, null, 2));
  const eventBehaviors = [...remainingEventBehaviors, ...abstractBehaviors].filter((behavior) => {
    if (behavior.on === "*")
      return !0;
    const [listenedNamespace] = behavior.on.includes("*") && behavior.on.includes(".") ? behavior.on.split(".") : [void 0], [eventNamespace] = event.type.includes(".") ? event.type.split(".") : [void 0];
    return listenedNamespace !== void 0 && eventNamespace !== void 0 && listenedNamespace === eventNamespace || listenedNamespace !== void 0 && eventNamespace === void 0 && listenedNamespace === event.type ? !0 : behavior.on === event.type;
  });
  if (eventBehaviors.length === 0 && isSyntheticBehaviorEvent(event)) {
    nativeEvent?.preventDefault(), mode === "send" && (editor.undoStepId = void 0), withPerformingBehaviorOperation(editor, () => {
      debugOperation(JSON.stringify(event, null, 2)), performOperation({
        context: {
          keyGenerator,
          schema
        },
        operation: {
          ...event,
          editor
        }
      });
    }), editor.onChange();
    return;
  }
  const guardSnapshot = getSnapshot();
  let nativeEventPrevented = !1, defaultBehaviorOverwritten = !1, eventBehaviorIndex = -1;
  for (const eventBehavior of eventBehaviors) {
    eventBehaviorIndex++;
    let shouldRun = !1;
    try {
      shouldRun = eventBehavior.guard === void 0 || eventBehavior.guard({
        snapshot: guardSnapshot,
        event,
        dom: createEditorDom(sendBack, editor)
      });
    } catch (error) {
      console.error(new Error(`Evaluating guard for "${event.type}" failed due to: ${error.message}`));
    }
    if (!shouldRun)
      continue;
    defaultBehaviorOverwritten = !0, eventBehavior.actions.length === 0 && (nativeEventPrevented = !0);
    let actionSetIndex = -1;
    for (const actionSet of eventBehavior.actions) {
      actionSetIndex++;
      const actionsSnapshot = getSnapshot();
      let actions = [];
      try {
        actions = actionSet({
          snapshot: actionsSnapshot,
          event,
          dom: createEditorDom(sendBack, editor)
        }, shouldRun);
      } catch (error) {
        console.error(new Error(`Evaluating actions for "${event.type}" failed due to: ${error.message}`));
      }
      if (actions.length === 0)
        continue;
      nativeEventPrevented = actions.some((action) => action.type === "raise" || action.type === "execute") || !actions.some((action) => action.type === "forward");
      let undoStepCreated = !1;
      actionSetIndex > 0 && (editor.undoStepId = defaultKeyGenerator(), undoStepCreated = !0), !undoStepCreated && actions.some((action) => action.type === "execute") && (editor.undoStepId = defaultKeyGenerator(), undoStepCreated = !0);
      const actionTypes = actions.map((action) => action.type), uniqueActionTypes = new Set(actionTypes), raiseGroup = actionTypes.length > 1 && uniqueActionTypes.size === 1 && uniqueActionTypes.has("raise"), executeGroup = actionTypes.length > 1 && uniqueActionTypes.size === 1 && uniqueActionTypes.has("execute");
      withoutNormalizingConditional(editor, () => raiseGroup || executeGroup, () => {
        for (const action of actions) {
          if (action.type === "effect") {
            try {
              action.effect({
                send: sendBack
              });
            } catch (error) {
              console.error(new Error(`Executing effect as a result of "${event.type}" failed due to: ${error.message}`));
            }
            continue;
          }
          if (action.type === "forward") {
            const remainingEventBehaviors2 = eventBehaviors.slice(eventBehaviorIndex + 1);
            performEvent({
              mode: mode === "execute" ? "execute" : "forward",
              behaviors,
              remainingEventBehaviors: remainingEventBehaviors2,
              event: action.event,
              editor,
              keyGenerator,
              schema,
              getSnapshot,
              nativeEvent,
              sendBack
            });
            continue;
          }
          if (action.type === "raise") {
            performEvent({
              mode: mode === "execute" ? "execute" : "raise",
              behaviors,
              remainingEventBehaviors: mode === "execute" ? remainingEventBehaviors : behaviors,
              event: action.event,
              editor,
              keyGenerator,
              schema,
              getSnapshot,
              nativeEvent,
              sendBack
            });
            continue;
          }
          performEvent({
            mode: "execute",
            behaviors,
            remainingEventBehaviors: [],
            event: action.event,
            editor,
            keyGenerator,
            schema,
            getSnapshot,
            nativeEvent: void 0,
            sendBack
          });
        }
      }), undoStepCreated && (editor.undoStepId = void 0);
    }
    break;
  }
  !defaultBehaviorOverwritten && isSyntheticBehaviorEvent(event) ? (nativeEvent?.preventDefault(), mode === "send" && (editor.undoStepId = void 0), withPerformingBehaviorOperation(editor, () => {
    debugOperation(JSON.stringify(event, null, 2)), performOperation({
      context: {
        keyGenerator,
        schema
      },
      operation: {
        ...event,
        editor
      }
    });
  }), editor.onChange()) : nativeEventPrevented && nativeEvent?.preventDefault();
}
function sortByPriority(items) {
  if (items.length === 0)
    return [];
  const itemsWithPriority = items.filter((item) => item.priority !== void 0), itemsWithoutPriority = items.filter((item) => item.priority === void 0);
  if (itemsWithPriority.length === 0)
    return items;
  const itemsByPriorityId = new Map(itemsWithPriority.map((item) => [item.priority.id, item])), graph = /* @__PURE__ */ new Map(), inDegree = /* @__PURE__ */ new Map();
  function ensureNode(id) {
    graph.has(id) || (graph.set(id, /* @__PURE__ */ new Set()), inDegree.set(id, 0));
  }
  for (const item of itemsWithPriority) {
    const id = item.priority.id;
    ensureNode(id);
  }
  function addEdge(fromId, toId) {
    !graph.has(fromId) || !graph.has(toId) || (graph.get(fromId)?.add(toId), inDegree.set(toId, (inDegree.get(toId) ?? 0) + 1));
  }
  for (const item of itemsWithPriority) {
    const id = item.priority.id, visited = /* @__PURE__ */ new Set();
    let ref = item.priority.reference;
    for (; ref; ) {
      const refId = ref.priority.id;
      if (ensureNode(refId), visited.has(refId))
        throw new Error("Circular dependency detected in priorities");
      visited.add(refId), ref.importance === "higher" ? addEdge(id, refId) : addEdge(refId, id), ref = ref.priority.reference;
    }
  }
  const queue = [];
  for (const [id, degree] of inDegree)
    degree === 0 && queue.push(id);
  const result = [];
  for (; queue.length > 0; ) {
    const currentId = queue.shift(), currentItem = itemsByPriorityId.get(currentId);
    currentItem && result.push(currentItem);
    for (const neighborId of graph.get(currentId) ?? []) {
      const newDegree = (inDegree.get(neighborId) ?? 0) - 1;
      inDegree.set(neighborId, newDegree), newDegree === 0 && queue.push(neighborId);
    }
  }
  for (const item of itemsWithPriority)
    result.includes(item) || result.push(item);
  return [...result, ...itemsWithoutPriority];
}
function createEditorSnapshot({
  converters,
  editor,
  keyGenerator,
  readOnly,
  schema
}) {
  const selection = editor.selection ? slateRangeToSelection({
    schema,
    editor,
    range: editor.selection
  }) : null, context = {
    converters,
    keyGenerator,
    readOnly,
    schema,
    selection,
    value: editor.value
  };
  return {
    blockIndexMap: editor.blockIndexMap,
    context,
    decoratorState: editor.decoratorState
  };
}
const debug$4 = debugWithName("editor machine");
function rerouteExternalBehaviorEvent({
  event,
  slateEditor
}) {
  switch (event.type) {
    case "blur":
      return {
        type: "blur",
        editor: slateEditor
      };
    case "focus":
      return {
        type: "focus",
        editor: slateEditor
      };
    case "insert.block object":
      return {
        type: "behavior event",
        behaviorEvent: {
          type: "insert.block",
          block: {
            _type: event.blockObject.name,
            ...event.blockObject.value ?? {}
          },
          placement: event.placement
        },
        editor: slateEditor
      };
    default:
      return {
        type: "behavior event",
        behaviorEvent: event,
        editor: slateEditor
      };
  }
}
const editorMachine = setup({
  types: {
    context: {},
    events: {},
    emitted: {},
    input: {},
    tags: {}
  },
  actions: {
    "add behavior to context": assign({
      behaviors: ({
        context,
        event
      }) => (assertEvent(event, "add behavior"), /* @__PURE__ */ new Set([...context.behaviors, event.behaviorConfig])),
      behaviorsSorted: !1
    }),
    "remove behavior from context": assign({
      behaviors: ({
        context,
        event
      }) => (assertEvent(event, "remove behavior"), context.behaviors.delete(event.behaviorConfig), /* @__PURE__ */ new Set([...context.behaviors]))
    }),
    "add slate editor to context": assign({
      slateEditor: ({
        context,
        event
      }) => event.type === "add slate editor" ? event.editor : context.slateEditor
    }),
    "emit patch event": emit(({
      event
    }) => (assertEvent(event, "internal.patch"), event)),
    "emit mutation event": emit(({
      event
    }) => (assertEvent(event, "mutation"), event)),
    "emit read only": emit({
      type: "read only"
    }),
    "emit editable": emit({
      type: "editable"
    }),
    "defer event": assign({
      pendingEvents: ({
        context,
        event
      }) => (assertEvent(event, ["internal.patch", "mutation"]), [...context.pendingEvents, event])
    }),
    "emit pending events": enqueueActions(({
      context,
      enqueue
    }) => {
      for (const event of context.pendingEvents)
        enqueue.emit(event);
    }),
    "emit ready": emit({
      type: "ready"
    }),
    "clear pending events": assign({
      pendingEvents: []
    }),
    "defer incoming patches": assign({
      pendingIncomingPatchesEvents: ({
        context,
        event
      }) => event.type === "patches" ? [...context.pendingIncomingPatchesEvents, event] : context.pendingIncomingPatchesEvents
    }),
    "emit pending incoming patches": enqueueActions(({
      context,
      enqueue
    }) => {
      for (const event of context.pendingIncomingPatchesEvents)
        enqueue.emit(event);
    }),
    "clear pending incoming patches": assign({
      pendingIncomingPatchesEvents: []
    }),
    "handle blur": ({
      event
    }) => {
      assertEvent(event, "blur");
      try {
        ReactEditor.blur(event.editor);
      } catch (error) {
        console.error(new Error(`Failed to blur editor: ${error.message}`));
      }
    },
    "handle focus": ({
      context
    }) => {
      const slateEditor = context.slateEditor;
      if (!slateEditor) {
        console.error("No Slate editor found to focus");
        return;
      }
      try {
        const currentSelection = slateEditor.selection;
        ReactEditor.focus(slateEditor), currentSelection && (Transforms.select(slateEditor, currentSelection), EDITOR_TO_PENDING_SELECTION.set(slateEditor, slateEditor.selection), slateEditor.onChange());
      } catch (error) {
        console.error(new Error(`Failed to focus editor: ${error.message}`));
      }
    },
    "handle behavior event": ({
      context,
      event,
      self
    }) => {
      assertEvent(event, ["behavior event"]);
      try {
        const behaviors = [...context.behaviors.values()].map((config) => config.behavior);
        performEvent({
          mode: "send",
          behaviors,
          remainingEventBehaviors: behaviors,
          event: event.behaviorEvent,
          editor: event.editor,
          keyGenerator: context.keyGenerator,
          schema: context.schema,
          getSnapshot: () => createEditorSnapshot({
            converters: [...context.converters],
            editor: event.editor,
            keyGenerator: context.keyGenerator,
            readOnly: self.getSnapshot().matches({
              "edit mode": "read only"
            }),
            schema: context.schema
          }),
          nativeEvent: event.nativeEvent,
          sendBack: (eventSentBack) => {
            if (eventSentBack.type === "set drag ghost") {
              self.send(eventSentBack);
              return;
            }
            self.send(rerouteExternalBehaviorEvent({
              event: eventSentBack,
              slateEditor: event.editor
            }));
          }
        });
      } catch (error) {
        console.error(new Error(`Raising "${event.behaviorEvent.type}" failed due to: ${error.message}`));
      }
    },
    "sort behaviors": assign({
      behaviors: ({
        context
      }) => context.behaviorsSorted ? context.behaviors : new Set(sortByPriority([...context.behaviors.values()])),
      behaviorsSorted: !0
    })
  },
  guards: {
    "slate is busy": ({
      context
    }) => context.slateEditor ? context.slateEditor.operations.length > 0 : !1,
    "slate is normalizing node": ({
      context
    }) => context.slateEditor ? context.slateEditor.isNormalizingNode : !1
  }
}).createMachine({
  id: "editor",
  context: ({
    input
  }) => ({
    behaviors: new Set(coreBehaviorsConfig),
    behaviorsSorted: !1,
    converters: new Set(input.converters ?? []),
    getLegacySchema: input.getLegacySchema,
    keyGenerator: input.keyGenerator,
    pendingEvents: [],
    pendingIncomingPatchesEvents: [],
    schema: input.schema,
    selection: null,
    initialReadOnly: input.readOnly ?? !1,
    initialValue: input.initialValue
  }),
  on: {
    "add behavior": {
      actions: "add behavior to context"
    },
    "remove behavior": {
      actions: "remove behavior from context"
    },
    "add slate editor": {
      actions: "add slate editor to context"
    },
    "update selection": {
      actions: [assign({
        selection: ({
          event
        }) => event.selection
      }), emit(({
        event
      }) => ({
        ...event,
        type: "selection"
      }))]
    },
    "set drag ghost": {
      actions: assign({
        dragGhost: ({
          event
        }) => event.ghost
      })
    }
  },
  type: "parallel",
  states: {
    "edit mode": {
      initial: "read only",
      states: {
        "read only": {
          initial: "determine initial edit mode",
          on: {
            "behavior event": {
              actions: ["sort behaviors", "handle behavior event"],
              guard: ({
                event
              }) => event.behaviorEvent.type === "clipboard.copy" || event.behaviorEvent.type === "mouse.click" || event.behaviorEvent.type === "serialize" || event.behaviorEvent.type === "serialization.failure" || event.behaviorEvent.type === "serialization.success" || event.behaviorEvent.type === "select"
            }
          },
          states: {
            "determine initial edit mode": {
              entry: [() => {
                debug$4("entry: edit mode->read only->determine initial edit mode");
              }],
              exit: [() => {
                debug$4("exit: edit mode->read only->determine initial edit mode");
              }],
              on: {
                "done syncing value": [{
                  target: "#editor.edit mode.read only.read only",
                  guard: ({
                    context
                  }) => context.initialReadOnly
                }, {
                  target: "#editor.edit mode.editable"
                }]
              }
            },
            "read only": {
              entry: [() => {
                debug$4("entry: edit mode->read only->read only");
              }],
              exit: [() => {
                debug$4("exit: edit mode->read only->read only");
              }],
              on: {
                "update readOnly": {
                  guard: ({
                    event
                  }) => !event.readOnly,
                  target: "#editor.edit mode.editable",
                  actions: ["emit editable"]
                }
              }
            }
          }
        },
        editable: {
          on: {
            "update readOnly": {
              guard: ({
                event
              }) => event.readOnly,
              target: "#editor.edit mode.read only.read only",
              actions: ["emit read only"]
            },
            "behavior event": {
              actions: ["sort behaviors", "handle behavior event"]
            },
            blur: {
              actions: "handle blur"
            },
            focus: {
              target: ".focusing",
              actions: [assign({
                slateEditor: ({
                  event
                }) => event.editor
              })]
            }
          },
          initial: "idle",
          states: {
            idle: {
              entry: [() => {
                debug$4("entry: edit mode->editable->idle");
              }],
              exit: [() => {
                debug$4("exit: edit mode->editable-idle");
              }],
              on: {
                dragstart: {
                  actions: [assign({
                    internalDrag: ({
                      event
                    }) => ({
                      origin: event.origin
                    })
                  })],
                  target: "dragging internally"
                }
              }
            },
            focusing: {
              initial: "checking if busy",
              states: {
                "checking if busy": {
                  entry: [() => {
                    debug$4("entry: edit mode->editable->focusing->checking if busy");
                  }],
                  exit: [() => {
                    debug$4("exit: edit mode->editable->focusing->checking if busy");
                  }],
                  always: [{
                    guard: "slate is busy",
                    target: "busy"
                  }, {
                    target: "#editor.edit mode.editable.idle",
                    actions: ["handle focus"]
                  }]
                },
                busy: {
                  entry: [() => {
                    debug$4("entry: edit mode->editable->focusing-busy");
                  }],
                  exit: [() => {
                    debug$4("exit: edit mode->editable->focusing->busy");
                  }],
                  after: {
                    10: {
                      target: "checking if busy"
                    }
                  }
                }
              }
            },
            "dragging internally": {
              entry: [() => {
                debug$4("entry: edit mode->editable->dragging internally");
              }],
              exit: [() => {
                debug$4("exit: edit mode->editable->dragging internally");
              }, ({
                context
              }) => {
                if (context.dragGhost)
                  try {
                    context.dragGhost.parentNode?.removeChild(context.dragGhost);
                  } catch (error) {
                    console.error(new Error(`Removing the drag ghost failed due to: ${error.message}`));
                  }
              }, assign({
                dragGhost: void 0
              }), assign({
                internalDrag: void 0
              })],
              tags: ["dragging internally"],
              on: {
                dragend: {
                  target: "idle"
                },
                drop: {
                  target: "idle"
                }
              }
            }
          }
        }
      }
    },
    setup: {
      initial: "setting up",
      states: {
        "setting up": {
          entry: [() => {
            debug$4("entry: setup->setting up");
          }],
          exit: [() => {
            debug$4("exit: setup->setting up");
          }, "emit ready", "emit pending incoming patches", "clear pending incoming patches"],
          on: {
            "internal.patch": {
              actions: "defer event"
            },
            mutation: {
              actions: "defer event"
            },
            "done syncing value": {
              target: "set up"
            },
            patches: {
              actions: ["defer incoming patches"]
            }
          }
        },
        "set up": {
          type: "parallel",
          states: {
            "value sync": {
              initial: "idle",
              states: {
                idle: {
                  entry: [() => {
                    debug$4("entry: setup->set up->value sync->idle");
                  }],
                  exit: [() => {
                    debug$4("exit: setup->set up->value sync->idle");
                  }],
                  on: {
                    patches: {
                      actions: [emit(({
                        event
                      }) => event)]
                    },
                    "syncing value": {
                      target: "syncing value"
                    }
                  }
                },
                "syncing value": {
                  entry: [() => {
                    debug$4("entry: setup->set up->value sync->syncing value");
                  }],
                  exit: [() => {
                    debug$4("exit: setup->set up->value sync->syncing value");
                  }, "emit pending incoming patches", "clear pending incoming patches"],
                  on: {
                    patches: {
                      actions: ["defer incoming patches"]
                    },
                    "done syncing value": {
                      target: "idle"
                    }
                  }
                }
              }
            },
            writing: {
              initial: "pristine",
              states: {
                pristine: {
                  initial: "idle",
                  states: {
                    idle: {
                      entry: [() => {
                        debug$4("entry: setup->set up->writing->pristine->idle");
                      }],
                      exit: [() => {
                        debug$4("exit: setup->set up->writing->pristine->idle");
                      }],
                      on: {
                        "internal.patch": [{
                          guard: "slate is normalizing node",
                          actions: "defer event"
                        }, {
                          actions: "defer event",
                          target: "#editor.setup.set up.writing.dirty"
                        }],
                        mutation: [{
                          guard: "slate is normalizing node",
                          actions: "defer event"
                        }, {
                          actions: "defer event",
                          target: "#editor.setup.set up.writing.dirty"
                        }]
                      }
                    }
                  }
                },
                dirty: {
                  entry: [() => {
                    debug$4("entry: setup->set up->writing->dirty");
                  }, "emit pending events", "clear pending events"],
                  exit: [() => {
                    debug$4("exit: setup->set up->writing->dirty");
                  }],
                  on: {
                    "internal.patch": {
                      actions: "emit patch event"
                    },
                    mutation: {
                      actions: "emit mutation event"
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}), debug$3 = debugWithName("mutation-machine"), mutationMachine = setup({
  types: {
    context: {},
    events: {},
    input: {},
    emitted: {}
  },
  actions: {
    "assign readOnly": assign({
      readOnly: ({
        context,
        event
      }) => event.type === "update readOnly" ? event.readOnly : context.readOnly
    }),
    "emit patch": emit(({
      event
    }) => (assertEvent(event, "patch"), {
      type: "patch",
      patch: event.patch
    })),
    "set is deferring mutations": ({
      context
    }) => {
      context.slateEditor.isDeferringMutations = !0;
    },
    "emit mutations": enqueueActions(({
      context,
      enqueue
    }) => {
      for (const bulk of context.pendingMutations)
        enqueue.emit({
          type: "mutation",
          patches: bulk.patches,
          snapshot: bulk.value
        });
      context.slateEditor.isDeferringMutations = !1;
    }),
    "clear pending mutations": assign({
      pendingMutations: []
    }),
    "defer mutation": assign({
      pendingMutations: ({
        context,
        event
      }) => {
        if (assertEvent(event, "patch"), context.pendingMutations.length === 0)
          return [{
            operationId: event.operationId,
            value: event.value,
            patches: [event.patch]
          }];
        const lastBulk = context.pendingMutations.at(-1);
        return lastBulk && lastBulk.operationId === event.operationId ? context.pendingMutations.slice(0, -1).concat({
          value: event.value,
          operationId: lastBulk.operationId,
          patches: [...lastBulk.patches, event.patch]
        }) : context.pendingMutations.concat({
          value: event.value,
          operationId: event.operationId,
          patches: [event.patch]
        });
      }
    }),
    "clear pending patch events": assign({
      pendingPatchEvents: []
    }),
    "defer patch": assign({
      pendingPatchEvents: ({
        context,
        event
      }) => event.type === "patch" ? [...context.pendingPatchEvents, event] : context.pendingPatchEvents
    }),
    "emit pending patch events": enqueueActions(({
      context,
      enqueue
    }) => {
      for (const event of context.pendingPatchEvents)
        enqueue.emit(event);
    })
  },
  actors: {
    "type listener": fromCallback(({
      input,
      sendBack
    }) => {
      const originalApply = input.slateEditor.apply;
      return input.slateEditor.apply = (op) => {
        op.type === "insert_text" || op.type === "remove_text" ? sendBack({
          type: "typing"
        }) : sendBack({
          type: "not typing"
        }), originalApply(op);
      }, () => {
        input.slateEditor.apply = originalApply;
      };
    }),
    "mutation interval": fromCallback(({
      sendBack
    }) => {
      const interval = setInterval(() => {
        sendBack({
          type: "emit changes"
        });
      }, process.env.NODE_ENV === "test" ? 250 : 1e3);
      return () => {
        clearInterval(interval);
      };
    })
  },
  guards: {
    "is read-only": ({
      context
    }) => context.readOnly,
    "slate is normalizing": ({
      context
    }) => Editor.isNormalizing(context.slateEditor)
  },
  delays: {
    "type debounce": 250
  }
}).createMachine({
  id: "mutation",
  context: ({
    input
  }) => ({
    pendingMutations: [],
    pendingPatchEvents: [],
    readOnly: input.readOnly,
    schema: input.schema,
    slateEditor: input.slateEditor
  }),
  on: {
    "update readOnly": {
      actions: ["assign readOnly"]
    }
  },
  type: "parallel",
  states: {
    typing: {
      initial: "idle",
      invoke: {
        src: "type listener",
        input: ({
          context
        }) => ({
          slateEditor: context.slateEditor
        })
      },
      states: {
        idle: {
          entry: [() => {
            debug$3("entry: typing->idle");
          }],
          exit: [() => {
            debug$3("exit: typing->idle"), debug$3("entry: typing->typing");
          }],
          on: {
            typing: {
              target: "typing"
            }
          }
        },
        typing: {
          after: {
            "type debounce": {
              target: "idle",
              actions: [raise$1({
                type: "emit changes"
              }), () => {
                debug$3("exit: typing->typing");
              }]
            }
          },
          on: {
            "not typing": {
              target: "idle",
              actions: [raise$1({
                type: "emit changes"
              })]
            },
            typing: {
              target: "typing",
              reenter: !0
            }
          }
        }
      }
    },
    mutations: {
      initial: "idle",
      states: {
        idle: {
          entry: [() => {
            debug$3("entry: mutations->idle");
          }],
          exit: [() => {
            debug$3("exit: mutations->idle");
          }],
          on: {
            patch: [{
              guard: "is read-only",
              actions: ["set is deferring mutations", "defer patch", "defer mutation"],
              target: "has pending mutations"
            }, {
              actions: ["set is deferring mutations", "emit patch", "defer mutation"],
              target: "has pending mutations"
            }]
          }
        },
        "has pending mutations": {
          entry: [() => {
            debug$3("entry: mutations->has pending mutations");
          }],
          exit: [() => {
            debug$3("exit: mutations->has pending mutations");
          }],
          invoke: {
            src: "mutation interval"
          },
          on: {
            "emit changes": {
              guard: and([not("is read-only"), "slate is normalizing"]),
              target: "idle",
              actions: ["emit pending patch events", "clear pending patch events", "emit mutations", "clear pending mutations"]
            },
            patch: [{
              guard: "is read-only",
              actions: ["defer patch", "defer mutation"]
            }, {
              actions: ["emit patch", "defer mutation"]
            }]
          }
        }
      }
    }
  }
}), relayMachine = setup({
  types: {
    context: {},
    events: {},
    emitted: {}
  }
}).createMachine({
  id: "relay",
  context: {
    prevSelection: null,
    lastEventWasFocused: !1
  },
  on: {
    focused: {
      actions: [assign({
        lastEventWasFocused: !0
      }), emit(({
        event
      }) => event)]
    },
    selection: [{
      guard: ({
        context
      }) => context.lastEventWasFocused,
      actions: [assign({
        prevSelection: ({
          event
        }) => event.selection
      }), emit(({
        event
      }) => event), assign({
        lastEventWasFocused: !1
      })]
    }, {
      guard: ({
        context,
        event
      }) => context.prevSelection !== event.selection,
      actions: [assign({
        prevSelection: ({
          event
        }) => event.selection
      }), emit(({
        event
      }) => event), assign({
        lastEventWasFocused: !1
      })]
    }],
    "*": {
      actions: [emit(({
        event
      }) => event), assign({
        lastEventWasFocused: !1
      })]
    }
  }
});
function validateValue(value, types, keyGenerator) {
  let resolution = null, valid = !0;
  const validChildTypes = [types.span.name, ...types.inlineObjects.map((t) => t.name)], validBlockTypes = [types.block.name, ...types.blockObjects.map((t) => t.name)];
  return value === void 0 ? {
    valid: !0,
    resolution: null,
    value
  } : !Array.isArray(value) || value.length === 0 ? {
    valid: !1,
    resolution: {
      patches: [unset([])],
      description: "Editor value must be an array of Portable Text blocks, or undefined.",
      action: "Unset the value",
      item: value,
      i18n: {
        description: "inputs.portable-text.invalid-value.not-an-array.description",
        action: "inputs.portable-text.invalid-value.not-an-array.action"
      }
    },
    value
  } : (value.some((blk, index) => {
    if (typeof blk != "object" || blk === null)
      return resolution = {
        patches: [unset([index])],
        description: `Block must be an object, got ${String(blk)}`,
        action: "Unset invalid item",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.not-an-object.description",
          action: "inputs.portable-text.invalid-value.not-an-object.action",
          values: {
            index
          }
        }
      }, !0;
    if (!blk._key || typeof blk._key != "string")
      return resolution = {
        patches: [set({
          ...blk,
          _key: keyGenerator()
        }, [index])],
        description: `Block at index ${index} is missing required _key.`,
        action: "Set the block with a random _key value",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-key.description",
          action: "inputs.portable-text.invalid-value.missing-key.action",
          values: {
            index
          }
        }
      }, !0;
    if (!blk._type || !validBlockTypes.includes(blk._type)) {
      if (blk._type === "block") {
        const currentBlockTypeName = types.block.name;
        return resolution = {
          patches: [set({
            ...blk,
            _type: currentBlockTypeName
          }, [{
            _key: blk._key
          }])],
          description: `Block with _key '${blk._key}' has invalid type name '${blk._type}'. According to the schema, the block type name is '${currentBlockTypeName}'`,
          action: `Use type '${currentBlockTypeName}'`,
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.incorrect-block-type.description",
            action: "inputs.portable-text.invalid-value.incorrect-block-type.action",
            values: {
              key: blk._key,
              expectedTypeName: currentBlockTypeName
            }
          }
        }, !0;
      }
      return !blk._type && isTextBlock({
        schema: types
      }, {
        ...blk,
        _type: types.block.name
      }) ? (resolution = {
        patches: [set({
          ...blk,
          _type: types.block.name
        }, [{
          _key: blk._key
        }])],
        description: `Block with _key '${blk._key}' is missing a type name. According to the schema, the block type name is '${types.block.name}'`,
        action: `Use type '${types.block.name}'`,
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-block-type.description",
          action: "inputs.portable-text.invalid-value.missing-block-type.action",
          values: {
            key: blk._key,
            expectedTypeName: types.block.name
          }
        }
      }, !0) : blk._type ? (resolution = {
        patches: [unset([{
          _key: blk._key
        }])],
        description: `Block with _key '${blk._key}' has invalid _type '${blk._type}'`,
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.disallowed-type.description",
          action: "inputs.portable-text.invalid-value.disallowed-type.action",
          values: {
            key: blk._key,
            typeName: blk._type
          }
        }
      }, !0) : (resolution = {
        patches: [unset([{
          _key: blk._key
        }])],
        description: `Block with _key '${blk._key}' is missing an _type property`,
        action: "Remove the block",
        item: blk,
        i18n: {
          description: "inputs.portable-text.invalid-value.missing-type.description",
          action: "inputs.portable-text.invalid-value.missing-type.action",
          values: {
            key: blk._key
          }
        }
      }, !0);
    }
    if (blk._type === types.block.name) {
      const textBlock = blk;
      if (textBlock.children && !Array.isArray(textBlock.children))
        return resolution = {
          patches: [set({
            children: []
          }, [{
            _key: textBlock._key
          }])],
          description: `Text block with _key '${textBlock._key}' has a invalid required property 'children'.`,
          action: "Reset the children property",
          item: textBlock,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-or-invalid-children.description",
            action: "inputs.portable-text.invalid-value.missing-or-invalid-children.action",
            values: {
              key: textBlock._key
            }
          }
        }, !0;
      if (textBlock.children === void 0 || Array.isArray(textBlock.children) && textBlock.children.length === 0) {
        const newSpan = {
          _type: types.span.name,
          _key: keyGenerator(),
          text: "",
          marks: []
        };
        return resolution = {
          autoResolve: !0,
          patches: [setIfMissing([], [{
            _key: blk._key
          }, "children"]), insert([newSpan], "after", [{
            _key: blk._key
          }, "children", 0])],
          description: `Children for text block with _key '${blk._key}' is empty.`,
          action: "Insert an empty text",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.empty-children.description",
            action: "inputs.portable-text.invalid-value.empty-children.action",
            values: {
              key: blk._key
            }
          }
        }, !0;
      }
      const allUsedMarks = [...new Set(textBlock.children.filter((child) => isSpan({
        schema: types
      }, child)).flatMap((cld) => cld.marks || []))];
      if (Array.isArray(blk.markDefs) && blk.markDefs.length > 0) {
        const unusedMarkDefs = [...new Set(blk.markDefs.map((def) => def._key).filter((key) => !allUsedMarks.includes(key)))];
        if (unusedMarkDefs.length > 0)
          return resolution = {
            autoResolve: !0,
            patches: unusedMarkDefs.map((markDefKey) => unset([{
              _key: blk._key
            }, "markDefs", {
              _key: markDefKey
            }])),
            description: `Block contains orphaned data (unused mark definitions): ${unusedMarkDefs.join(", ")}.`,
            action: "Remove unused mark definition item",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.orphaned-mark-defs.description",
              action: "inputs.portable-text.invalid-value.orphaned-mark-defs.action",
              values: {
                key: blk._key,
                unusedMarkDefs: unusedMarkDefs.map((m) => m.toString())
              }
            }
          }, !0;
      }
      const orphanedMarks = allUsedMarks.filter((mark) => !types.decorators.map((dec) => dec.name).includes(mark)).filter((mark) => textBlock.markDefs === void 0 || !textBlock.markDefs.find((def) => def._key === mark));
      if (orphanedMarks.length > 0) {
        const spanChildren = textBlock.children.filter((cld) => cld._type === types.span.name && Array.isArray(cld.marks) && cld.marks.some((mark) => orphanedMarks.includes(mark)));
        if (spanChildren) {
          const orphaned = orphanedMarks.join(", ");
          return resolution = {
            autoResolve: !0,
            patches: spanChildren.map((child) => set((child.marks || []).filter((cMrk) => !orphanedMarks.includes(cMrk)), [{
              _key: blk._key
            }, "children", {
              _key: child._key
            }, "marks"])),
            description: `Block with _key '${blk._key}' contains marks (${orphaned}) not supported by the current content model.`,
            action: "Remove invalid marks",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.orphaned-marks.description",
              action: "inputs.portable-text.invalid-value.orphaned-marks.action",
              values: {
                key: blk._key,
                orphanedMarks: orphanedMarks.map((m) => m.toString())
              }
            }
          }, !0;
        }
      }
      textBlock.children.some((child, cIndex) => {
        if (typeof child != "object" || child === null)
          return resolution = {
            patches: [unset([{
              _key: blk._key
            }, "children", cIndex])],
            description: `Child at index '${cIndex}' in block with key '${blk._key}' is not an object.`,
            action: "Remove the item",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.non-object-child.description",
              action: "inputs.portable-text.invalid-value.non-object-child.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          }, !0;
        if (!child._key || typeof child._key != "string") {
          const newChild = {
            ...child,
            _key: keyGenerator()
          };
          return resolution = {
            autoResolve: !0,
            patches: [set(newChild, [{
              _key: blk._key
            }, "children", cIndex])],
            description: `Child at index ${cIndex} is missing required _key in block with _key ${blk._key}.`,
            action: "Set a new random _key on the object",
            item: blk,
            i18n: {
              description: "inputs.portable-text.invalid-value.missing-child-key.description",
              action: "inputs.portable-text.invalid-value.missing-child-key.action",
              values: {
                key: blk._key,
                index: cIndex
              }
            }
          }, !0;
        }
        return child._type ? validChildTypes.includes(child._type) ? child._type === types.span.name && typeof child.text != "string" ? (resolution = {
          patches: [set({
            ...child,
            text: ""
          }, [{
            _key: blk._key
          }, "children", {
            _key: child._key
          }])],
          description: `Child with _key '${child._key}' in block with key '${blk._key}' has missing or invalid text property!`,
          action: "Write an empty text property to the object",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.invalid-span-text.description",
            action: "inputs.portable-text.invalid-value.invalid-span-text.action",
            values: {
              key: blk._key,
              childKey: child._key
            }
          }
        }, !0) : !1 : (resolution = {
          patches: [unset([{
            _key: blk._key
          }, "children", {
            _key: child._key
          }])],
          description: `Child with _key '${child._key}' in block with key '${blk._key}' has invalid '_type' property (${child._type}).`,
          action: "Remove the object",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.disallowed-child-type.description",
            action: "inputs.portable-text.invalid-value.disallowed-child-type.action",
            values: {
              key: blk._key,
              childKey: child._key,
              childType: child._type
            }
          }
        }, !0) : (resolution = {
          patches: [unset([{
            _key: blk._key
          }, "children", {
            _key: child._key
          }])],
          description: `Child with _key '${child._key}' in block with key '${blk._key}' is missing '_type' property.`,
          action: "Remove the object",
          item: blk,
          i18n: {
            description: "inputs.portable-text.invalid-value.missing-child-type.description",
            action: "inputs.portable-text.invalid-value.missing-child-type.action",
            values: {
              key: blk._key,
              childKey: child._key
            }
          }
        }, !0);
      }) && (valid = !1);
    }
    return !1;
  }) && (valid = !1), {
    valid,
    resolution,
    value
  });
}
const debug$2 = debugWithName("sync machine"), syncValueCallback = ({
  sendBack,
  input
}) => {
  updateValue({
    context: input.context,
    sendBack,
    slateEditor: input.slateEditor,
    value: input.value,
    streamBlocks: input.streamBlocks
  });
}, syncValueLogic = fromCallback(syncValueCallback), syncMachine = setup({
  types: {
    context: {},
    input: {},
    events: {},
    emitted: {}
  },
  actions: {
    "assign initial value synced": assign({
      initialValueSynced: !0
    }),
    "assign readOnly": assign({
      readOnly: ({
        event
      }) => (assertEvent(event, "update readOnly"), event.readOnly)
    }),
    "assign pending value": assign({
      pendingValue: ({
        event
      }) => (assertEvent(event, "update value"), event.value)
    }),
    "clear pending value": assign({
      pendingValue: void 0
    }),
    "assign previous value": assign({
      previousValue: ({
        event
      }) => (assertEvent(event, "done syncing"), event.value)
    }),
    "emit done syncing value": emit({
      type: "done syncing value"
    }),
    "emit syncing value": emit({
      type: "syncing value"
    })
  },
  guards: {
    "initial value synced": ({
      context
    }) => context.initialValueSynced,
    "is busy": ({
      context
    }) => {
      const isDeferringMutations = context.slateEditor.isDeferringMutations, isChanging = context.slateEditor.isProcessingRemoteChanges ?? !1, isBusy = isDeferringMutations || isChanging;
      return debug$2("isBusy", {
        isBusy,
        isDeferringMutations,
        isChanging
      }), isBusy;
    },
    "is empty value": ({
      event
    }) => event.type === "update value" && event.value === void 0,
    "is empty array": ({
      event
    }) => event.type === "update value" && Array.isArray(event.value) && event.value.length === 0,
    "is new value": ({
      context,
      event
    }) => event.type !== "update value" || context.previousValue === event.value ? !1 : !isEqualValues({
      schema: context.schema
    }, context.previousValue, event.value),
    "value changed while syncing": ({
      context,
      event
    }) => event.type !== "done syncing" || context.pendingValue === event.value ? !1 : !isEqualValues({
      schema: context.schema
    }, context.pendingValue, event.value),
    "pending value equals previous value": ({
      context
    }) => isEqualValues({
      schema: context.schema
    }, context.pendingValue, context.previousValue)
  },
  actors: {
    "sync value": syncValueLogic
  }
}).createMachine({
  id: "sync",
  context: ({
    input
  }) => ({
    initialValue: input.initialValue,
    initialValueSynced: !1,
    keyGenerator: input.keyGenerator,
    schema: input.schema,
    readOnly: input.readOnly,
    slateEditor: input.slateEditor,
    pendingValue: void 0,
    previousValue: void 0
  }),
  entry: [raise$1(({
    context
  }) => ({
    type: "update value",
    value: context.initialValue
  }))],
  on: {
    "update readOnly": {
      actions: ["assign readOnly"]
    }
  },
  initial: "idle",
  states: {
    idle: {
      entry: [() => {
        debug$2("entry: syncing->idle");
      }],
      exit: [() => {
        debug$2("exit: syncing->idle");
      }],
      on: {
        "update value": [{
          guard: and(["is empty value", not("initial value synced")]),
          actions: ["assign initial value synced", "emit done syncing value"]
        }, {
          guard: and(["is empty array", not("initial value synced")]),
          actions: ["assign initial value synced", emit({
            type: "value changed",
            value: []
          }), "emit done syncing value"]
        }, {
          guard: and(["is busy", "is new value"]),
          target: "busy",
          actions: ["assign pending value"]
        }, {
          guard: "is new value",
          target: "syncing",
          actions: ["assign pending value"]
        }, {
          guard: not("initial value synced"),
          actions: [() => {
            debug$2("no new value \u2013 setting initial value as synced");
          }, "assign initial value synced", "emit done syncing value"]
        }, {
          actions: [() => {
            debug$2("no new value and initial value already synced");
          }]
        }]
      }
    },
    busy: {
      entry: [() => {
        debug$2("entry: syncing->busy");
      }],
      exit: [() => {
        debug$2("exit: syncing->busy");
      }],
      after: {
        1e3: [{
          guard: "is busy",
          target: ".",
          reenter: !0,
          actions: [() => {
            debug$2("reenter: syncing->busy");
          }]
        }, {
          target: "syncing"
        }]
      },
      on: {
        "update value": [{
          guard: "is new value",
          actions: ["assign pending value"]
        }]
      }
    },
    syncing: {
      entry: [() => {
        debug$2("entry: syncing->syncing");
      }, "emit syncing value"],
      exit: [() => {
        debug$2("exit: syncing->syncing");
      }, "emit done syncing value"],
      invoke: {
        src: "sync value",
        id: "sync value",
        input: ({
          context
        }) => ({
          context: {
            keyGenerator: context.keyGenerator,
            previousValue: context.previousValue,
            readOnly: context.readOnly,
            schema: context.schema
          },
          slateEditor: context.slateEditor,
          streamBlocks: !context.initialValueSynced,
          value: context.pendingValue
        })
      },
      on: {
        "update value": {
          guard: "is new value",
          actions: ["assign pending value"]
        },
        patch: {
          actions: [emit(({
            event
          }) => event)]
        },
        "invalid value": {
          actions: [emit(({
            event
          }) => event)]
        },
        "value changed": {
          actions: [emit(({
            event
          }) => event)]
        },
        "done syncing": [{
          guard: "value changed while syncing",
          actions: ["assign previous value", "assign initial value synced"],
          target: "syncing",
          reenter: !0
        }, {
          target: "idle",
          actions: ["clear pending value", "assign previous value", "assign initial value synced"]
        }]
      }
    }
  }
});
async function updateValue({
  context,
  sendBack,
  slateEditor,
  streamBlocks,
  value
}) {
  let doneSyncing = !1, isChanged = !1, isValid = !0;
  const hadSelection = !!slateEditor.selection;
  if ((!value || value.length === 0) && (debug$2("Value is empty"), clearEditor({
    slateEditor,
    doneSyncing
  }), isChanged = !0), value && value.length > 0)
    if (streamBlocks)
      await new Promise((resolve) => {
        if (doneSyncing) {
          resolve();
          return;
        }
        isChanged = removeExtraBlocks({
          slateEditor,
          value
        }), (async () => {
          for await (const [currentBlock, currentBlockIndex] of getStreamedBlocks({
            value
          })) {
            const {
              blockChanged,
              blockValid
            } = syncBlock({
              context,
              sendBack,
              block: currentBlock,
              index: currentBlockIndex,
              slateEditor,
              value
            });
            if (isChanged = blockChanged || isChanged, isValid = isValid && blockValid, !isValid)
              break;
          }
          resolve();
        })();
      });
    else {
      if (doneSyncing)
        return;
      isChanged = removeExtraBlocks({
        slateEditor,
        value
      });
      let index = 0;
      for (const block of value) {
        const {
          blockChanged,
          blockValid
        } = syncBlock({
          context,
          sendBack,
          block,
          index,
          slateEditor,
          value
        });
        if (isChanged = blockChanged || isChanged, isValid = isValid && blockValid, !blockValid)
          break;
        index++;
      }
    }
  if (!isValid) {
    debug$2("Invalid value, returning"), doneSyncing = !0, sendBack({
      type: "done syncing",
      value
    });
    return;
  }
  if (isChanged) {
    debug$2("Server value changed, syncing editor");
    try {
      slateEditor.onChange();
    } catch (err) {
      console.error(err), sendBack({
        type: "invalid value",
        resolution: null,
        value
      }), doneSyncing = !0, sendBack({
        type: "done syncing",
        value
      });
      return;
    }
    hadSelection && !slateEditor.selection && slateEditor.children.length > 0 && (Transforms.select(slateEditor, Editor.start(slateEditor, [])), slateEditor.onChange()), sendBack({
      type: "value changed",
      value
    });
  } else
    debug$2("Server value and editor value is equal, no need to sync.");
  doneSyncing = !0, sendBack({
    type: "done syncing",
    value
  });
}
async function* getStreamedBlocks({
  value
}) {
  let index = 0;
  for await (const block of value)
    index % 10 === 0 && await new Promise((resolve) => setTimeout(resolve, 0)), yield [block, index], index++;
}
function clearEditor({
  slateEditor,
  doneSyncing
}) {
  Editor.withoutNormalizing(slateEditor, () => {
    pluginWithoutHistory(slateEditor, () => {
      withRemoteChanges(slateEditor, () => {
        withoutPatching(slateEditor, () => {
          if (doneSyncing)
            return;
          const childrenLength = slateEditor.children.length;
          slateEditor.children.forEach((_, index) => {
            Transforms.removeNodes(slateEditor, {
              at: [childrenLength - 1 - index]
            });
          });
        });
      });
    });
  });
}
function removeExtraBlocks({
  slateEditor,
  value
}) {
  let isChanged = !1;
  return Editor.withoutNormalizing(slateEditor, () => {
    withRemoteChanges(slateEditor, () => {
      withoutPatching(slateEditor, () => {
        const childrenLength = slateEditor.children.length;
        if (value.length < childrenLength) {
          for (let i = childrenLength - 1; i > value.length - 1; i--)
            Transforms.removeNodes(slateEditor, {
              at: [i]
            });
          isChanged = !0;
        }
      });
    });
  }), isChanged;
}
function syncBlock({
  context,
  sendBack,
  block,
  index,
  slateEditor,
  value
}) {
  const oldSlateBlock = slateEditor.children.at(index), oldBlock = slateEditor.value.at(index);
  if (!oldSlateBlock || !oldBlock) {
    const validation2 = validateValue([block], context.schema, context.keyGenerator);
    if (debug$2.enabled && debug$2("Validating and inserting new block in the end of the value", block), validation2.valid || validation2.resolution?.autoResolve) {
      const slateBlock = toSlateBlock(block, {
        schemaTypes: context.schema
      });
      return Editor.withoutNormalizing(slateEditor, () => {
        withRemoteChanges(slateEditor, () => {
          withoutPatching(slateEditor, () => {
            Transforms.insertNodes(slateEditor, slateBlock, {
              at: [index]
            });
          });
        });
      }), {
        blockChanged: !0,
        blockValid: !0
      };
    }
    return debug$2("Invalid", validation2), sendBack({
      type: "invalid value",
      resolution: validation2.resolution,
      value
    }), {
      blockChanged: !1,
      blockValid: !1
    };
  }
  if (isEqualBlocks(context, block, oldBlock))
    return {
      blockChanged: !1,
      blockValid: !0
    };
  const validationValue = [value[index]], validation = validateValue(validationValue, context.schema, context.keyGenerator);
  return !validation.valid && validation.resolution?.autoResolve && validation.resolution?.patches.length > 0 && !context.readOnly && context.previousValue && context.previousValue !== value && (console.warn(`${validation.resolution.action} for block with _key '${validationValue[0]._key}'. ${validation.resolution?.description}`), validation.resolution.patches.forEach((patch) => {
    sendBack({
      type: "patch",
      patch
    });
  })), validation.valid || validation.resolution?.autoResolve ? (oldBlock._key === block._key ? (debug$2.enabled && debug$2("Updating block", oldBlock, block), Editor.withoutNormalizing(slateEditor, () => {
    withRemoteChanges(slateEditor, () => {
      withoutPatching(slateEditor, () => {
        updateBlock({
          context,
          slateEditor,
          oldSlateBlock,
          block,
          index
        });
      });
    });
  })) : (debug$2.enabled && debug$2("Replacing block", oldBlock, block), Editor.withoutNormalizing(slateEditor, () => {
    withRemoteChanges(slateEditor, () => {
      withoutPatching(slateEditor, () => {
        replaceBlock({
          context,
          slateEditor,
          block,
          index
        });
      });
    });
  })), {
    blockChanged: !0,
    blockValid: !0
  }) : (sendBack({
    type: "invalid value",
    resolution: validation.resolution,
    value
  }), {
    blockChanged: !1,
    blockValid: !1
  });
}
function replaceBlock({
  context,
  slateEditor,
  block,
  index
}) {
  const slateBlock = toSlateBlock(block, {
    schemaTypes: context.schema
  }), currentSelection = slateEditor.selection, selectionFocusOnBlock = currentSelection && currentSelection.focus.path[0] === index;
  selectionFocusOnBlock && Transforms.deselect(slateEditor), Transforms.removeNodes(slateEditor, {
    at: [index]
  }), Transforms.insertNodes(slateEditor, slateBlock, {
    at: [index]
  }), slateEditor.onChange(), selectionFocusOnBlock && Transforms.select(slateEditor, currentSelection);
}
function updateBlock({
  context,
  slateEditor,
  oldSlateBlock,
  block,
  index
}) {
  const slateBlock = toSlateBlock(block, {
    schemaTypes: context.schema
  });
  if (Transforms.setNodes(slateEditor, slateBlock, {
    at: [index]
  }), slateEditor.isTextBlock(slateBlock) && slateEditor.isTextBlock(oldSlateBlock)) {
    const oldBlockChildrenLength = oldSlateBlock.children.length;
    slateBlock.children.length < oldBlockChildrenLength && Array.from(Array(oldBlockChildrenLength - slateBlock.children.length)).forEach((_, i) => {
      const childIndex = oldBlockChildrenLength - 1 - i;
      childIndex > 0 && (debug$2("Removing child"), Transforms.removeNodes(slateEditor, {
        at: [index, childIndex]
      }));
    }), slateBlock.children.forEach((currentBlockChild, currentBlockChildIndex) => {
      const oldBlockChild = oldSlateBlock.children.at(currentBlockChildIndex), isChildChanged = oldBlockChild && !isEqualChild(currentBlockChild, oldBlockChild), isTextChanged = oldBlockChild && Text.isText(oldBlockChild) && currentBlockChild.text !== oldBlockChild.text, path = [index, currentBlockChildIndex];
      if (isChildChanged)
        if (currentBlockChild._key === oldBlockChild?._key) {
          debug$2("Updating changed child", currentBlockChild, oldBlockChild), Transforms.setNodes(slateEditor, currentBlockChild, {
            at: path
          });
          const isSpanNode2 = isSpan({
            schema: context.schema
          }, currentBlockChild) && isSpan({
            schema: context.schema
          }, oldBlockChild);
          isSpanNode2 && isTextChanged ? (oldBlockChild.text.length > 0 && deleteText(slateEditor, {
            at: {
              focus: {
                path,
                offset: 0
              },
              anchor: {
                path,
                offset: oldBlockChild.text.length
              }
            }
          }), Transforms.insertText(slateEditor, currentBlockChild.text, {
            at: path
          }), slateEditor.onChange()) : isSpanNode2 || (debug$2("Updating changed inline object child", currentBlockChild), Transforms.setNodes(slateEditor, {
            _key: VOID_CHILD_KEY
          }, {
            at: [...path, 0],
            voids: !0
          }));
        } else oldBlockChild ? (debug$2("Replacing child", currentBlockChild), Transforms.removeNodes(slateEditor, {
          at: [index, currentBlockChildIndex]
        }), Transforms.insertNodes(slateEditor, currentBlockChild, {
          at: [index, currentBlockChildIndex]
        }), slateEditor.onChange()) : oldBlockChild || (debug$2("Inserting new child", currentBlockChild), Transforms.insertNodes(slateEditor, currentBlockChild, {
          at: [index, currentBlockChildIndex]
        }), slateEditor.onChange());
    });
  }
}
const debug$1 = debugWithName("setup");
function createInternalEditor(config) {
  debug$1("Creating new Editor instance");
  const subscriptions = [], editorActor = createActor(editorMachine, {
    input: editorConfigToMachineInput(config)
  }), relayActor = createActor(relayMachine), slateEditor = createSlateEditor({
    editorActor,
    relayActor,
    subscriptions
  }), editable = createEditableAPI(slateEditor.instance, editorActor), {
    mutationActor,
    syncActor
  } = createActors({
    editorActor,
    relayActor,
    slateEditor: slateEditor.instance,
    subscriptions
  }), editor = {
    dom: createEditorDom((event) => editorActor.send(event), slateEditor.instance),
    getSnapshot: () => getEditorSnapshot({
      editorActorSnapshot: editorActor.getSnapshot(),
      slateEditorInstance: slateEditor.instance
    }),
    registerBehavior: (behaviorConfig) => {
      const priority = createEditorPriority({
        name: "custom",
        reference: {
          priority: corePriority,
          importance: "higher"
        }
      }), behaviorConfigWithPriority = {
        ...behaviorConfig,
        priority
      };
      return editorActor.send({
        type: "add behavior",
        behaviorConfig: behaviorConfigWithPriority
      }), () => {
        editorActor.send({
          type: "remove behavior",
          behaviorConfig: behaviorConfigWithPriority
        });
      };
    },
    send: (event) => {
      switch (event.type) {
        case "update value":
          syncActor.send(event);
          break;
        case "update readOnly":
        case "patches":
          editorActor.send(event);
          break;
        default:
          editorActor.send(rerouteExternalBehaviorEvent({
            event,
            slateEditor: slateEditor.instance
          }));
      }
    },
    on: (event, listener) => relayActor.on(event, (event2) => {
      switch (event2.type) {
        case "blurred":
        case "done loading":
        case "editable":
        case "focused":
        case "invalid value":
        case "loading":
        case "mutation":
        case "patch":
        case "read only":
        case "ready":
        case "selection":
        case "value changed":
          listener(event2);
          break;
      }
    }),
    _internal: {
      editable,
      editorActor,
      slateEditor
    }
  };
  return {
    actors: {
      editorActor,
      mutationActor,
      relayActor,
      syncActor
    },
    editor,
    subscriptions
  };
}
function editorConfigToMachineInput(config) {
  const {
    legacySchema,
    schema
  } = compileSchemasFromEditorConfig(config);
  return {
    converters: createCoreConverters(legacySchema),
    getLegacySchema: () => legacySchema,
    keyGenerator: config.keyGenerator ?? defaultKeyGenerator,
    readOnly: config.readOnly,
    schema,
    initialValue: config.initialValue
  };
}
function compileSchemasFromEditorConfig(config) {
  const legacySchema = config.schemaDefinition ? compileSchemaDefinitionToPortableTextMemberSchemaTypes(config.schemaDefinition) : createPortableTextMemberSchemaTypes(config.schema.hasOwnProperty("jsonType") ? config.schema : compileType(config.schema)), schema = config.schemaDefinition ? compileSchema(config.schemaDefinition) : portableTextMemberSchemaTypesToSchema(legacySchema);
  return {
    legacySchema,
    schema
  };
}
function createActors(config) {
  debug$1("Creating new Actors");
  const mutationActor = createActor(mutationMachine, {
    input: {
      readOnly: config.editorActor.getSnapshot().matches({
        "edit mode": "read only"
      }),
      schema: config.editorActor.getSnapshot().context.schema,
      slateEditor: config.slateEditor
    }
  }), syncActor = createActor(syncMachine, {
    input: {
      initialValue: config.editorActor.getSnapshot().context.initialValue,
      keyGenerator: config.editorActor.getSnapshot().context.keyGenerator,
      readOnly: config.editorActor.getSnapshot().matches({
        "edit mode": "read only"
      }),
      schema: config.editorActor.getSnapshot().context.schema,
      slateEditor: config.slateEditor
    }
  });
  return config.subscriptions.push(() => {
    const subscription = mutationActor.on("*", (event) => {
      event.type === "mutation" && config.editorActor.send({
        type: "mutation",
        patches: event.patches,
        value: event.snapshot
      }), event.type === "patch" && config.relayActor.send(event);
    });
    return () => {
      mutationActor.send({
        type: "emit changes"
      }), subscription.unsubscribe();
    };
  }), config.subscriptions.push(() => {
    const subscription = syncActor.on("*", (event) => {
      switch (event.type) {
        case "invalid value":
          config.relayActor.send(event);
          break;
        case "value changed":
          config.relayActor.send(event);
          break;
        case "patch":
          config.editorActor.send({
            ...event,
            type: "internal.patch",
            value: config.slateEditor.value
          });
          break;
        default:
          config.editorActor.send(event);
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }), config.subscriptions.push(() => {
    const subscription = config.editorActor.subscribe((snapshot) => {
      snapshot.matches({
        "edit mode": "read only"
      }) ? (mutationActor.send({
        type: "update readOnly",
        readOnly: !0
      }), syncActor.send({
        type: "update readOnly",
        readOnly: !0
      })) : (mutationActor.send({
        type: "update readOnly",
        readOnly: !1
      }), syncActor.send({
        type: "update readOnly",
        readOnly: !1
      }));
    });
    return () => {
      subscription.unsubscribe();
    };
  }), config.subscriptions.push(() => {
    const subscription = config.editorActor.on("*", (event) => {
      switch (event.type) {
        case "editable":
        case "mutation":
        case "ready":
        case "read only":
        case "selection":
          config.relayActor.send(event);
          break;
        case "internal.patch":
          mutationActor.send({
            ...event,
            type: "patch"
          });
          break;
      }
    });
    return () => {
      subscription.unsubscribe();
    };
  }), {
    mutationActor,
    syncActor
  };
}
function eventToChange(event) {
  switch (event.type) {
    case "blurred":
      return {
        type: "blur",
        event: event.event
      };
    case "patch":
      return event;
    case "loading":
      return {
        type: "loading",
        isLoading: !0
      };
    case "done loading":
      return {
        type: "loading",
        isLoading: !1
      };
    case "focused":
      return {
        type: "focus",
        event: event.event
      };
    case "value changed":
      return {
        type: "value",
        value: event.value
      };
    case "invalid value":
      return {
        type: "invalidValue",
        resolution: event.resolution,
        value: event.value
      };
    case "mutation":
      return {
        type: "mutation",
        patches: event.patches,
        snapshot: event.value
      };
    case "ready":
      return event;
    case "selection":
      return event;
    case "unset":
      return event;
  }
}
const debug = debugWithName("component:PortableTextEditor");
class PortableTextEditor extends Component {
  static displayName = "PortableTextEditor";
  /**
   * An observable of all the editor changes.
   */
  change$ = new Subject();
  /**
   * A lookup table for all the relevant schema types for this portable text type.
   */
  /**
   * The editor instance
   */
  /*
   * The editor API (currently implemented with Slate).
   */
  subscriptions = [];
  unsubscribers = [];
  constructor(props) {
    if (super(props), props.editor)
      this.editor = props.editor, this.schemaTypes = this.editor._internal.editorActor.getSnapshot().context.getLegacySchema();
    else {
      const {
        actors,
        editor,
        subscriptions
      } = createInternalEditor({
        initialValue: props.value,
        keyGenerator: props.keyGenerator,
        readOnly: props.readOnly,
        schema: props.schemaType
      });
      this.subscriptions = subscriptions, this.actors = actors, this.editor = editor, this.schemaTypes = actors.editorActor.getSnapshot().context.getLegacySchema();
    }
    this.editable = this.editor._internal.editable;
  }
  componentDidMount() {
    if (!this.actors)
      return;
    for (const subscription of this.subscriptions)
      this.unsubscribers.push(subscription());
    const relayActorSubscription = this.actors.relayActor.on("*", (event) => {
      const change = eventToChange(event);
      change && (this.props.editor || this.props.onChange(change), this.change$.next(change));
    });
    this.unsubscribers.push(relayActorSubscription.unsubscribe), this.actors.editorActor.start(), this.actors.mutationActor.start(), this.actors.relayActor.start(), this.actors.syncActor.start();
  }
  componentDidUpdate(prevProps) {
    !this.props.editor && !prevProps.editor && this.props.schemaType !== prevProps.schemaType && console.warn("Updating schema type is no longer supported"), !this.props.editor && !prevProps.editor && (this.props.readOnly !== prevProps.readOnly && this.editor._internal.editorActor.send({
      type: "update readOnly",
      readOnly: this.props.readOnly ?? !1
    }), this.props.value !== prevProps.value && this.editor.send({
      type: "update value",
      value: this.props.value
    }), this.props.editorRef !== prevProps.editorRef && this.props.editorRef && (this.props.editorRef.current = this));
  }
  componentWillUnmount() {
    for (const unsubscribe of this.unsubscribers)
      unsubscribe();
    this.actors && (stopActor(this.actors.editorActor), stopActor(this.actors.mutationActor), stopActor(this.actors.relayActor), stopActor(this.actors.syncActor));
  }
  setEditable = (editable) => {
    this.editor._internal.editable = {
      ...this.editor._internal.editable,
      ...editable
    };
  };
  render() {
    const legacyPatches = this.props.editor ? void 0 : this.props.incomingPatches$ ?? this.props.patches$;
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      legacyPatches ? /* @__PURE__ */ jsx(RoutePatchesObservableToEditorActor, { editorActor: this.editor._internal.editorActor, patches$: legacyPatches }) : null,
      /* @__PURE__ */ jsx(EditorActorContext.Provider, { value: this.editor._internal.editorActor, children: /* @__PURE__ */ jsx(RelayActorContext.Provider, { value: this.actors.relayActor, children: /* @__PURE__ */ jsx(Slate, { editor: this.editor._internal.slateEditor.instance, initialValue: this.editor._internal.slateEditor.initialValue, children: /* @__PURE__ */ jsx(PortableTextEditorContext.Provider, { value: this, children: this.props.children }) }) }) })
    ] });
  }
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.getActiveAnnotations)
   * ```
   */
  static activeAnnotations = (editor) => editor && editor.editable ? editor.editable.activeAnnotations() : [];
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveAnnotation(...))
   * ```
   */
  static isAnnotationActive = (editor, annotationType) => editor && editor.editable ? editor.editable.isAnnotationActive(annotationType) : !1;
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.add',
   *  annotation: {
   *    name: '...',
   *    value: {...},
   *  }
   * })
   * ```
   */
  static addAnnotation = (editor, type, value) => editor.editable?.addAnnotation(type, value);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'blur',
   * })
   * ```
   */
  static blur = (editor) => {
    debug("Host blurred"), editor.editable?.blur();
  };
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'delete',
   *  at: {...},
   *  direction: '...',
   *  unit: '...',
   * })
   * ```
   */
  static delete = (editor, selection, options) => editor.editable?.delete(selection, options);
  static findDOMNode = (editor, element) => editor.editable?.findDOMNode(element);
  static findByPath = (editor, path) => editor.editable?.findByPath(path) || [];
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'focus',
   * })
   * ```
   */
  static focus = (editor) => {
    debug("Host requesting focus"), editor.editable?.focus();
  };
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusBlock = useEditorSelector(editor, selectors.getFocusBlock)
   * ```
   */
  static focusBlock = (editor) => editor.editable?.focusBlock();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const focusChild = useEditorSelector(editor, selectors.getFocusChild)
   * ```
   */
  static focusChild = (editor) => editor.editable?.focusChild();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selection = useEditorSelector(editor, selectors.getSelection)
   * ```
   */
  static getSelection = (editor) => editor.editable ? editor.editable.getSelection() : null;
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const value = useEditorSelector(editor, selectors.getValue)
   * ```
   */
  static getValue = (editor) => editor.editable?.getValue();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveStyle(...))
   * ```
   */
  static hasBlockStyle = (editor, blockStyle) => editor.editable?.hasBlockStyle(blockStyle);
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveListItem(...))
   * ```
   */
  static hasListStyle = (editor, listStyle) => editor.editable?.hasListStyle(listStyle);
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionCollapsed = useEditorSelector(editor, selectors.isSelectionCollapsed)
   * ```
   */
  static isCollapsedSelection = (editor) => editor.editable?.isCollapsedSelection();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isSelectionExpanded = useEditorSelector(editor, selectors.isSelectionExpanded)
   * ```
   */
  static isExpandedSelection = (editor) => editor.editable?.isExpandedSelection();
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isActive = useEditorSelector(editor, selectors.isActiveDecorator(...))
   * ```
   */
  static isMarkActive = (editor, mark) => editor.editable?.isMarkActive(mark);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.span',
   *  text: '...',
   *  annotations: [{name: '...', value: {...}}],
   *  decorators: ['...'],
   * })
   * editor.send({
   *  type: 'insert.inline object',
   *  inlineObject: {
   *    name: '...',
   *    value: {...},
   *  },
   * })
   * ```
   */
  static insertChild = (editor, type, value) => (debug("Host inserting child"), editor.editable?.insertChild(type, value));
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.block object',
   *  blockObject: {
   *    name: '...',
   *    value: {...},
   *  },
   *  placement: 'auto' | 'after' | 'before',
   * })
   * ```
   */
  static insertBlock = (editor, type, value) => editor.editable?.insertBlock(type, value);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'insert.break',
   * })
   * ```
   */
  static insertBreak = (editor) => editor.editable?.insertBreak();
  static isVoid = (editor, element) => editor.editable?.isVoid(element);
  static isObjectPath = (_editor, path) => {
    if (!path || !Array.isArray(path))
      return !1;
    const isChildObjectEditPath = path.length > 3 && path[1] === "children";
    return path.length > 1 && path[1] !== "children" || isChildObjectEditPath;
  };
  static marks = (editor) => editor.editable?.marks();
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'select',
   *  selection: {...},
   * })
   * ```
   */
  static select = (editor, selection) => {
    debug("Host setting selection", selection), editor.editable?.select(selection);
  };
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'annotation.remove',
   *  annotation: {
   *    name: '...',
   *  },
   * })
   * ```
   */
  static removeAnnotation = (editor, type) => editor.editable?.removeAnnotation(type);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'style.toggle',
   *  style: '...',
   * })
   * ```
   */
  static toggleBlockStyle = (editor, blockStyle) => (debug("Host is toggling block style"), editor.editable?.toggleBlockStyle(blockStyle));
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'list item.toggle',
   *  listItem: '...',
   * })
   * ```
   */
  static toggleList = (editor, listStyle) => editor.editable?.toggleList(listStyle);
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *  type: 'decorator.toggle',
   *  decorator: '...',
   * })
   * ```
   */
  static toggleMark = (editor, mark) => {
    debug("Host toggling mark", mark), editor.editable?.toggleMark(mark);
  };
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const selectedValue = useEditorSelector(editor, selectors.getSelectedValue)
   * ```
   */
  static getFragment = (editor) => editor.editable?.getFragment();
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.undo',
   * })
   * ```
   */
  static undo = (editor) => {
    debug("Host undoing"), editor.editable?.undo();
  };
  /**
   * @deprecated
   * Use `editor.send(...)` instead
   *
   * ```
   * const editor = useEditor()
   * editor.send({
   *   type: 'history.redo',
   * })
   * ```
   */
  static redo = (editor) => {
    debug("Host redoing"), editor.editable?.redo();
  };
  /**
   * @deprecated
   * Use built-in selectors or write your own: https://www.portabletext.org/reference/selectors/
   *
   * ```
   * import * as selectors from '@portabletext/editor/selectors'
   * const editor = useEditor()
   * const isOverlapping = useEditorSelector(editor, selectors.isOverlappingSelection(selectionB))
   * ```
   */
  static isSelectionsOverlapping = (editor, selectionA, selectionB) => editor.editable?.isSelectionsOverlapping(selectionA, selectionB);
}
function RoutePatchesObservableToEditorActor(props) {
  const $ = c(4);
  let t0, t1;
  return $[0] !== props.editorActor || $[1] !== props.patches$ ? (t0 = () => {
    const subscription = props.patches$.subscribe((payload) => {
      props.editorActor.send({
        type: "patches",
        ...payload
      });
    });
    return () => {
      subscription.unsubscribe();
    };
  }, t1 = [props.editorActor, props.patches$], $[0] = props.editorActor, $[1] = props.patches$, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), useEffect(t0, t1), null;
}
function EditorProvider(props) {
  const $ = c(29);
  let t0;
  $[0] !== props.initialConfig ? (t0 = () => {
    const internalEditor = createInternalEditor(props.initialConfig), portableTextEditor = new PortableTextEditor({
      editor: internalEditor.editor
    });
    return {
      internalEditor,
      portableTextEditor
    };
  }, $[0] = props.initialConfig, $[1] = t0) : t0 = $[1];
  const [t1] = useState(t0), {
    internalEditor: internalEditor_0,
    portableTextEditor: portableTextEditor_0
  } = t1;
  let t2;
  $[2] !== internalEditor_0.actors.editorActor || $[3] !== internalEditor_0.actors.mutationActor || $[4] !== internalEditor_0.actors.relayActor || $[5] !== internalEditor_0.actors.syncActor || $[6] !== internalEditor_0.editor._internal.slateEditor.instance || $[7] !== internalEditor_0.subscriptions || $[8] !== portableTextEditor_0 ? (t2 = () => {
    const unsubscribers = [];
    for (const subscription of internalEditor_0.subscriptions)
      unsubscribers.push(subscription());
    const relayActorSubscription = internalEditor_0.actors.relayActor.on("*", (event) => {
      const change = eventToChange(event);
      change && portableTextEditor_0.change$.next(change);
    });
    return unsubscribers.push(relayActorSubscription.unsubscribe), internalEditor_0.actors.editorActor.start(), internalEditor_0.actors.editorActor.send({
      type: "add slate editor",
      editor: internalEditor_0.editor._internal.slateEditor.instance
    }), internalEditor_0.actors.mutationActor.start(), internalEditor_0.actors.relayActor.start(), internalEditor_0.actors.syncActor.start(), () => {
      for (const unsubscribe of unsubscribers)
        unsubscribe();
      stopActor(internalEditor_0.actors.editorActor), stopActor(internalEditor_0.actors.mutationActor), stopActor(internalEditor_0.actors.relayActor), stopActor(internalEditor_0.actors.syncActor);
    };
  }, $[2] = internalEditor_0.actors.editorActor, $[3] = internalEditor_0.actors.mutationActor, $[4] = internalEditor_0.actors.relayActor, $[5] = internalEditor_0.actors.syncActor, $[6] = internalEditor_0.editor._internal.slateEditor.instance, $[7] = internalEditor_0.subscriptions, $[8] = portableTextEditor_0, $[9] = t2) : t2 = $[9];
  let t3;
  $[10] !== internalEditor_0 || $[11] !== portableTextEditor_0 ? (t3 = [internalEditor_0, portableTextEditor_0], $[10] = internalEditor_0, $[11] = portableTextEditor_0, $[12] = t3) : t3 = $[12], useEffect(t2, t3);
  let t4;
  $[13] !== portableTextEditor_0 || $[14] !== props.children ? (t4 = /* @__PURE__ */ jsx(PortableTextEditorContext.Provider, { value: portableTextEditor_0, children: props.children }), $[13] = portableTextEditor_0, $[14] = props.children, $[15] = t4) : t4 = $[15];
  let t5;
  $[16] !== internalEditor_0.editor._internal.slateEditor.initialValue || $[17] !== internalEditor_0.editor._internal.slateEditor.instance || $[18] !== t4 ? (t5 = /* @__PURE__ */ jsx(Slate, { editor: internalEditor_0.editor._internal.slateEditor.instance, initialValue: internalEditor_0.editor._internal.slateEditor.initialValue, children: t4 }), $[16] = internalEditor_0.editor._internal.slateEditor.initialValue, $[17] = internalEditor_0.editor._internal.slateEditor.instance, $[18] = t4, $[19] = t5) : t5 = $[19];
  let t6;
  $[20] !== internalEditor_0.actors.relayActor || $[21] !== t5 ? (t6 = /* @__PURE__ */ jsx(RelayActorContext.Provider, { value: internalEditor_0.actors.relayActor, children: t5 }), $[20] = internalEditor_0.actors.relayActor, $[21] = t5, $[22] = t6) : t6 = $[22];
  let t7;
  $[23] !== internalEditor_0.actors.editorActor || $[24] !== t6 ? (t7 = /* @__PURE__ */ jsx(EditorActorContext.Provider, { value: internalEditor_0.actors.editorActor, children: t6 }), $[23] = internalEditor_0.actors.editorActor, $[24] = t6, $[25] = t7) : t7 = $[25];
  let t8;
  return $[26] !== internalEditor_0.editor || $[27] !== t7 ? (t8 = /* @__PURE__ */ jsx(EditorContext.Provider, { value: internalEditor_0.editor, children: t7 }), $[26] = internalEditor_0.editor, $[27] = t7, $[28] = t8) : t8 = $[28], t8;
}
const usePortableTextEditorSelection = () => {
  const $ = c(5), editorActor = useContext(EditorActorContext);
  let t0;
  $[0] !== editorActor ? (t0 = editorActor.getSnapshot(), $[0] = editorActor, $[1] = t0) : t0 = $[1];
  const [selection, setSelection] = useState(t0.context.selection);
  let t1, t2;
  return $[2] !== editorActor ? (t1 = () => {
    const subscription = editorActor.on("selection", (event) => {
      startTransition(() => {
        setSelection(event.selection);
      });
    });
    return () => {
      subscription.unsubscribe();
    };
  }, t2 = [editorActor], $[2] = editorActor, $[3] = t1, $[4] = t2) : (t1 = $[3], t2 = $[4]), useEffect(t1, t2), selection;
};
export {
  EditorProvider,
  PortableTextEditable,
  PortableTextEditor,
  defineSchema,
  defaultKeyGenerator as keyGenerator,
  useEditor,
  useEditorSelector,
  usePortableTextEditor,
  usePortableTextEditorSelection
};
//# sourceMappingURL=index.js.map
