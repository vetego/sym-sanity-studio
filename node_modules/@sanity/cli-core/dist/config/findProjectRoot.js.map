{"version":3,"sources":["../../src/config/findProjectRoot.ts"],"sourcesContent":["import {findAppConfigPath} from './util/findAppConfigPath.js'\nimport {findStudioConfigPath} from './util/findStudioConfigPath.js'\nimport {\n  type ProjectRootResult,\n  recursivelyResolveProjectRoot,\n} from './util/recursivelyResolveProjectRoot.js'\n\n/**\n * Resolve project root directory and type.\n *\n * Project root is:\n * - `studio` - A pre-blueprints Sanity studio root (containing `sanity.config.(ts|js)`)\n * - `app` - A Sanity app root (containing `sanity.cli.(ts|js)`)\n *\n * If a Sanity Studio v2/v1 root is found (containing `sanity.json` with `root: true`),\n * an error is thrown, as v2/v1 is no longer supported.\n *\n * @internal\n */\nexport async function findProjectRoot(cwd: string): Promise<ProjectRootResult> {\n  try {\n    // First try to find a studio project root, looks for `sanity.config.(ts|js)`\n    const studioProjectRoot = await resolveProjectRootForStudio(cwd)\n    if (studioProjectRoot) {\n      return studioProjectRoot\n    }\n\n    // Second try to find a app project root, looks for `sanity.cli.(ts|js)`\n    const appProjectRoot = await resolveProjectRootForApp(cwd)\n    if (appProjectRoot) {\n      return appProjectRoot\n    }\n\n    // If nothing is found throw an error\n    throw new Error('No project root found')\n  } catch (err: unknown) {\n    const message = err instanceof Error ? err.message : `${err}`\n    throw new Error(`Error occurred trying to resolve project root:\\n${message}`)\n  }\n}\n\n/**\n * Recursively searches for a project configuration file in the given directory and its parents.\n * Throws if Sanity v2 studio root is found.\n *\n * @param basePath - The base path to start searching from\n * @param iterations - Current iteration count, passed internally to prevent infinite recursion.\n * @returns A promise that resolves to an object if config is found, false otherwise\n * @internal\n */\nasync function resolveProjectRootForStudio(\n  basePath: string,\n  iterations = 0,\n): Promise<false | ProjectRootResult> {\n  return recursivelyResolveProjectRoot(basePath, findStudioConfigPath, 'studio', iterations)\n}\n\n/**\n * Recursively searches for a app project configuration file in the given directory and its parents.\n *\n * @param basePath - The base path to start searching from\n * @param iterations - Current iteration count, passed internally to prevent infinite recursion.\n * @returns A promise that resolves to an object if config is found, false otherwise\n * @internal\n */\nasync function resolveProjectRootForApp(\n  basePath: string,\n  iterations = 0,\n): Promise<false | ProjectRootResult> {\n  return recursivelyResolveProjectRoot(basePath, findAppConfigPath, 'app', iterations)\n}\n"],"names":["findAppConfigPath","findStudioConfigPath","recursivelyResolveProjectRoot","findProjectRoot","cwd","studioProjectRoot","resolveProjectRootForStudio","appProjectRoot","resolveProjectRootForApp","Error","err","message","basePath","iterations"],"mappings":"AAAA,SAAQA,iBAAiB,QAAO,8BAA6B;AAC7D,SAAQC,oBAAoB,QAAO,iCAAgC;AACnE,SAEEC,6BAA6B,QACxB,0CAAyC;AAEhD;;;;;;;;;;;CAWC,GACD,OAAO,eAAeC,gBAAgBC,GAAW;IAC/C,IAAI;QACF,6EAA6E;QAC7E,MAAMC,oBAAoB,MAAMC,4BAA4BF;QAC5D,IAAIC,mBAAmB;YACrB,OAAOA;QACT;QAEA,wEAAwE;QACxE,MAAME,iBAAiB,MAAMC,yBAAyBJ;QACtD,IAAIG,gBAAgB;YAClB,OAAOA;QACT;QAEA,qCAAqC;QACrC,MAAM,IAAIE,MAAM;IAClB,EAAE,OAAOC,KAAc;QACrB,MAAMC,UAAUD,eAAeD,QAAQC,IAAIC,OAAO,GAAG,GAAGD,KAAK;QAC7D,MAAM,IAAID,MAAM,CAAC,gDAAgD,EAAEE,SAAS;IAC9E;AACF;AAEA;;;;;;;;CAQC,GACD,eAAeL,4BACbM,QAAgB,EAChBC,aAAa,CAAC;IAEd,OAAOX,8BAA8BU,UAAUX,sBAAsB,UAAUY;AACjF;AAEA;;;;;;;CAOC,GACD,eAAeL,yBACbI,QAAgB,EAChBC,aAAa,CAAC;IAEd,OAAOX,8BAA8BU,UAAUZ,mBAAmB,OAAOa;AAC3E"}