{"version":3,"sources":["../../src/services/apiClient.ts"],"sourcesContent":["import {ux} from '@oclif/core'\nimport {\n  type ClientConfig,\n  type ClientError,\n  createClient,\n  requester as defaultRequester,\n  type SanityClient,\n  type ServerError,\n} from '@sanity/client'\n\nimport {generateHelpUrl} from '../util/generateHelpUrl.js'\nimport {isHttpError} from '../util/isHttpError.js'\nimport {getCliToken} from './getCliToken.js'\n\nconst apiHosts: Record<string, string | undefined> = {\n  staging: 'https://api.sanity.work',\n}\n\nconst CLI_REQUEST_TAG_PREFIX = 'sanity.cli'\n\n/**\n * @internal\n */\nexport interface GlobalCliClientOptions extends ClientConfig {\n  /**\n   * The API version to use for this client.\n   */\n  apiVersion: string\n\n  /**\n   * Whether to require a user to be authenticated to use this client.\n   * Default: `false`.\n   * Throws an error if `true` and user is not authenticated.\n   */\n  requireUser?: boolean\n}\n\n/**\n * Create a \"global\" (unscoped) Sanity API client.\n *\n * @param options - The options to use for the client.\n * @returns Promise that resolves to a configured Sanity API client.\n */\nexport async function getGlobalCliClient({\n  requireUser,\n  ...config\n}: GlobalCliClientOptions): Promise<SanityClient> {\n  const requester = defaultRequester.clone()\n  requester.use(authErrors())\n\n  const sanityEnv = process.env.SANITY_INTERNAL_ENV || 'production'\n\n  const token = await getCliToken()\n  const apiHost = apiHosts[sanityEnv]\n\n  if (requireUser && !token) {\n    throw new Error('You must login first - run \"sanity login\"')\n  }\n\n  return createClient({\n    ...(apiHost ? {apiHost} : {}),\n    requester,\n    requestTagPrefix: CLI_REQUEST_TAG_PREFIX,\n    token,\n    useCdn: false,\n    useProjectHostname: false,\n    ...config,\n  })\n}\n\n/**\n * @internal\n */\nexport interface ProjectCliClientOptions extends ClientConfig {\n  /**\n   * The API version to use for this client.\n   */\n  apiVersion: string\n\n  /**\n   * The project ID to use for this client.\n   */\n  projectId: string\n\n  /**\n   * The dataset to use for this client.\n   */\n  dataset?: string\n\n  /**\n   * Whether to require a user to be authenticated to use this client.\n   * Default: `false`.\n   * Throws an error if `true` and user is not authenticated.\n   */\n  requireUser?: boolean\n}\n\n/**\n * Create a \"global\" (unscoped) Sanity API client.\n *\n * @param options - The options to use for the client.\n * @returns Promise that resolves to a configured Sanity API client.\n */\nexport async function getProjectCliClient({\n  requireUser,\n  ...config\n}: ProjectCliClientOptions): Promise<SanityClient> {\n  const requester = defaultRequester.clone()\n  requester.use(authErrors())\n\n  const sanityEnv = process.env.SANITY_INTERNAL_ENV || 'production'\n\n  const token = await getCliToken()\n  const apiHost = apiHosts[sanityEnv]\n\n  if (requireUser && !token) {\n    throw new Error('You must login first - run \"sanity login\"')\n  }\n\n  return createClient({\n    ...(apiHost ? {apiHost} : {}),\n    requester,\n    requestTagPrefix: CLI_REQUEST_TAG_PREFIX,\n    token,\n    useCdn: false,\n    useProjectHostname: true,\n    ...config,\n  })\n}\n\n/**\n * `get-it` middleware that checks for 401 authentication errors and extends the error with more\n * helpful guidance on what to do next.\n *\n * @returns get-it middleware with `onError` handler\n * @internal\n */\nfunction authErrors() {\n  return {\n    onError: (err: Error | null) => {\n      if (!err || !isReqResError(err)) {\n        return err\n      }\n\n      const statusCode = isHttpError(err) && err.response.body.statusCode\n      if (statusCode === 401) {\n        err.message = `${err.message}. You may need to login again with ${ux.colorize('cyan', 'sanity login')}.\\nFor more information, see ${generateHelpUrl('cli-errors')}.`\n      }\n\n      return err\n    },\n  }\n}\n\nfunction isReqResError(err: Error): err is ClientError | ServerError {\n  return Object.prototype.hasOwnProperty.call(err, 'response')\n}\n"],"names":["ux","createClient","requester","defaultRequester","generateHelpUrl","isHttpError","getCliToken","apiHosts","staging","CLI_REQUEST_TAG_PREFIX","getGlobalCliClient","requireUser","config","clone","use","authErrors","sanityEnv","process","env","SANITY_INTERNAL_ENV","token","apiHost","Error","requestTagPrefix","useCdn","useProjectHostname","getProjectCliClient","onError","err","isReqResError","statusCode","response","body","message","colorize","Object","prototype","hasOwnProperty","call"],"mappings":"AAAA,SAAQA,EAAE,QAAO,cAAa;AAC9B,SAGEC,YAAY,EACZC,aAAaC,gBAAgB,QAGxB,iBAAgB;AAEvB,SAAQC,eAAe,QAAO,6BAA4B;AAC1D,SAAQC,WAAW,QAAO,yBAAwB;AAClD,SAAQC,WAAW,QAAO,mBAAkB;AAE5C,MAAMC,WAA+C;IACnDC,SAAS;AACX;AAEA,MAAMC,yBAAyB;AAmB/B;;;;;CAKC,GACD,OAAO,eAAeC,mBAAmB,EACvCC,WAAW,EACX,GAAGC,QACoB;IACvB,MAAMV,YAAYC,iBAAiBU,KAAK;IACxCX,UAAUY,GAAG,CAACC;IAEd,MAAMC,YAAYC,QAAQC,GAAG,CAACC,mBAAmB,IAAI;IAErD,MAAMC,QAAQ,MAAMd;IACpB,MAAMe,UAAUd,QAAQ,CAACS,UAAU;IAEnC,IAAIL,eAAe,CAACS,OAAO;QACzB,MAAM,IAAIE,MAAM;IAClB;IAEA,OAAOrB,aAAa;QAClB,GAAIoB,UAAU;YAACA;QAAO,IAAI,CAAC,CAAC;QAC5BnB;QACAqB,kBAAkBd;QAClBW;QACAI,QAAQ;QACRC,oBAAoB;QACpB,GAAGb,MAAM;IACX;AACF;AA6BA;;;;;CAKC,GACD,OAAO,eAAec,oBAAoB,EACxCf,WAAW,EACX,GAAGC,QACqB;IACxB,MAAMV,YAAYC,iBAAiBU,KAAK;IACxCX,UAAUY,GAAG,CAACC;IAEd,MAAMC,YAAYC,QAAQC,GAAG,CAACC,mBAAmB,IAAI;IAErD,MAAMC,QAAQ,MAAMd;IACpB,MAAMe,UAAUd,QAAQ,CAACS,UAAU;IAEnC,IAAIL,eAAe,CAACS,OAAO;QACzB,MAAM,IAAIE,MAAM;IAClB;IAEA,OAAOrB,aAAa;QAClB,GAAIoB,UAAU;YAACA;QAAO,IAAI,CAAC,CAAC;QAC5BnB;QACAqB,kBAAkBd;QAClBW;QACAI,QAAQ;QACRC,oBAAoB;QACpB,GAAGb,MAAM;IACX;AACF;AAEA;;;;;;CAMC,GACD,SAASG;IACP,OAAO;QACLY,SAAS,CAACC;YACR,IAAI,CAACA,OAAO,CAACC,cAAcD,MAAM;gBAC/B,OAAOA;YACT;YAEA,MAAME,aAAazB,YAAYuB,QAAQA,IAAIG,QAAQ,CAACC,IAAI,CAACF,UAAU;YACnE,IAAIA,eAAe,KAAK;gBACtBF,IAAIK,OAAO,GAAG,GAAGL,IAAIK,OAAO,CAAC,mCAAmC,EAAEjC,GAAGkC,QAAQ,CAAC,QAAQ,gBAAgB,6BAA6B,EAAE9B,gBAAgB,cAAc,CAAC,CAAC;YACvK;YAEA,OAAOwB;QACT;IACF;AACF;AAEA,SAASC,cAAcD,GAAU;IAC/B,OAAOO,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAACV,KAAK;AACnD"}