{"version":3,"sources":["../../src/util/createExpiringConfig.ts"],"sourcesContent":["import type ConfigStore from 'configstore'\n\nexport interface ExpiringConfigOptions<Type> {\n  /** Fetch value */\n  fetchValue: () => Promise<Type> | Type\n  /** Config key */\n  key: string\n  /** Config store */\n  store: ConfigStore\n  /** TTL (milliseconds) */\n  ttl: number\n\n  /** Subscribe to cache hit event */\n  onCacheHit?: () => void\n  /** Subscribe to fetch event */\n  onFetch?: () => void\n  /** Subscribe to revalidate event */\n  onRevalidate?: () => void\n}\n\nexport interface ExpiringConfigApi<Type> {\n  /**\n   * Delete the cached value.\n   */\n  delete: () => void\n  /**\n   * Attempt to get the cached value. If there is no cached value, or the cached value has expired,\n   * fetch, cache, and return the value.\n   */\n  get: () => Promise<Type>\n}\n\n/**\n * Create a config in the provided config store that expires after the provided TTL.\n */\nexport function createExpiringConfig<Type>({\n  fetchValue,\n  key,\n  onCacheHit = () => null,\n  onFetch = () => null,\n  onRevalidate = () => null,\n  store,\n  ttl,\n}: ExpiringConfigOptions<Type>): ExpiringConfigApi<Type> {\n  let currentFetch: Promise<Type> | null = null\n  return {\n    delete() {\n      store.delete(key)\n    },\n    async get() {\n      const {updatedAt, value} = store.get(key) ?? {}\n\n      if (value && updatedAt) {\n        const hasExpired = Date.now() - updatedAt > ttl\n\n        if (!hasExpired) {\n          onCacheHit()\n          return value\n        }\n\n        onRevalidate()\n      }\n\n      if (currentFetch) {\n        return currentFetch\n      }\n      onFetch()\n\n      currentFetch = Promise.resolve(fetchValue())\n      const nextValue = await currentFetch\n      currentFetch = null\n\n      store.set(key, {\n        updatedAt: Date.now(),\n        value: nextValue,\n      })\n\n      return nextValue\n    },\n  }\n}\n"],"names":["createExpiringConfig","fetchValue","key","onCacheHit","onFetch","onRevalidate","store","ttl","currentFetch","delete","get","updatedAt","value","hasExpired","Date","now","Promise","resolve","nextValue","set"],"mappings":"AAgCA;;CAEC,GACD,OAAO,SAASA,qBAA2B,EACzCC,UAAU,EACVC,GAAG,EACHC,aAAa,IAAM,IAAI,EACvBC,UAAU,IAAM,IAAI,EACpBC,eAAe,IAAM,IAAI,EACzBC,KAAK,EACLC,GAAG,EACyB;IAC5B,IAAIC,eAAqC;IACzC,OAAO;QACLC;YACEH,MAAMG,MAAM,CAACP;QACf;QACA,MAAMQ;YACJ,MAAM,EAACC,SAAS,EAAEC,KAAK,EAAC,GAAGN,MAAMI,GAAG,CAACR,QAAQ,CAAC;YAE9C,IAAIU,SAASD,WAAW;gBACtB,MAAME,aAAaC,KAAKC,GAAG,KAAKJ,YAAYJ;gBAE5C,IAAI,CAACM,YAAY;oBACfV;oBACA,OAAOS;gBACT;gBAEAP;YACF;YAEA,IAAIG,cAAc;gBAChB,OAAOA;YACT;YACAJ;YAEAI,eAAeQ,QAAQC,OAAO,CAAChB;YAC/B,MAAMiB,YAAY,MAAMV;YACxBA,eAAe;YAEfF,MAAMa,GAAG,CAACjB,KAAK;gBACbS,WAAWG,KAAKC,GAAG;gBACnBH,OAAOM;YACT;YAEA,OAAOA;QACT;IACF;AACF"}