{"version":3,"sources":["../../../src/util/__tests__/createExpiringConfig.test.ts"],"sourcesContent":["import type ConfigStore from 'configstore'\n\nimport {beforeEach, describe, expect, test, vi} from 'vitest'\n\nimport {createExpiringConfig} from '../createExpiringConfig.js'\n\ndescribe('createExpiringConfig', () => {\n  let mockStore: ConfigStore\n  let fetchValue: ReturnType<typeof vi.fn>\n  let onCacheHit: ReturnType<typeof vi.fn>\n  let onFetch: ReturnType<typeof vi.fn>\n  let onRevalidate: ReturnType<typeof vi.fn>\n\n  beforeEach(() => {\n    // Mock ConfigStore\n    mockStore = {\n      delete: vi.fn(),\n      get: vi.fn(),\n      set: vi.fn(),\n    } as unknown as ConfigStore\n\n    // Reset all mocks\n    fetchValue = vi.fn()\n    onCacheHit = vi.fn()\n    onFetch = vi.fn()\n    onRevalidate = vi.fn()\n  })\n\n  test('returns fetched value when cache is empty', async () => {\n    const testValue = 'test-value'\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(testValue),\n      key: 'test-key',\n      onCacheHit,\n      onFetch,\n      onRevalidate,\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache\n    vi.mocked(mockStore.get).mockReturnValue(undefined)\n\n    const result = await config.get()\n\n    expect(result).toBe(testValue)\n    expect(fetchValue).toHaveBeenCalledOnce()\n    expect(onFetch).toHaveBeenCalledOnce()\n    expect(onCacheHit).not.toHaveBeenCalled()\n    expect(onRevalidate).not.toHaveBeenCalled()\n    expect(mockStore.set).toHaveBeenCalledWith('test-key', {\n      updatedAt: expect.any(Number),\n      value: testValue,\n    })\n  })\n\n  test('returns cached value when it has not expired', async () => {\n    const cachedValue = 'cached-value'\n    const ttl = 5000\n    const updatedAt = Date.now() - 1000 // 1 second ago (not expired)\n\n    const config = createExpiringConfig({\n      fetchValue,\n      key: 'test-key',\n      onCacheHit,\n      onFetch,\n      onRevalidate,\n      store: mockStore,\n      ttl,\n    })\n\n    // Mock cached value that hasn't expired\n    vi.mocked(mockStore.get).mockReturnValue({\n      updatedAt,\n      value: cachedValue,\n    })\n\n    const result = await config.get()\n\n    expect(result).toBe(cachedValue)\n    expect(fetchValue).not.toHaveBeenCalled()\n    expect(onCacheHit).toHaveBeenCalledOnce()\n    expect(onFetch).not.toHaveBeenCalled()\n    expect(onRevalidate).not.toHaveBeenCalled()\n    expect(mockStore.set).not.toHaveBeenCalled()\n  })\n\n  test('fetches new value when cached value has expired', async () => {\n    const newValue = 'new-value'\n    const ttl = 1000\n    const updatedAt = Date.now() - 2000 // 2 seconds ago (expired)\n\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(newValue),\n      key: 'test-key',\n      onCacheHit,\n      onFetch,\n      onRevalidate,\n      store: mockStore,\n      ttl,\n    })\n\n    // Mock expired cached value\n    vi.mocked(mockStore.get).mockReturnValue({\n      updatedAt,\n      value: 'old-value',\n    })\n\n    const result = await config.get()\n\n    expect(result).toBe(newValue)\n    expect(fetchValue).toHaveBeenCalledOnce()\n    expect(onRevalidate).toHaveBeenCalledOnce()\n    expect(onFetch).toHaveBeenCalledOnce()\n    expect(onCacheHit).not.toHaveBeenCalled()\n    expect(mockStore.set).toHaveBeenCalledWith('test-key', {\n      updatedAt: expect.any(Number),\n      value: newValue,\n    })\n  })\n\n  test('deletes cached value from store', () => {\n    const config = createExpiringConfig({\n      fetchValue,\n      key: 'test-key',\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    config.delete()\n\n    expect(mockStore.delete).toHaveBeenCalledWith('test-key')\n  })\n\n  test('handles concurrent get() calls correctly', async () => {\n    const testValue = 'test-value'\n    let resolvePromise: (value: string) => void\n    const delayedFetch = new Promise<string>((resolve) => {\n      resolvePromise = resolve\n    })\n\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockReturnValue(delayedFetch),\n      key: 'test-key',\n      onFetch,\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache\n    vi.mocked(mockStore.get).mockReturnValue(undefined)\n\n    // Start multiple concurrent get() calls\n    const promise1 = config.get()\n    const promise2 = config.get()\n    const promise3 = config.get()\n\n    // Resolve the fetch\n    resolvePromise!(testValue)\n\n    const [result1, result2, result3] = await Promise.all([promise1, promise2, promise3])\n\n    expect(result1).toBe(testValue)\n    expect(result2).toBe(testValue)\n    expect(result3).toBe(testValue)\n    expect(fetchValue).toHaveBeenCalledOnce() // Only one fetch should happen\n    expect(onFetch).toHaveBeenCalledOnce()\n  })\n\n  test('handles synchronous fetchValue function', async () => {\n    const testValue = 'sync-value'\n    const syncFetchValue = vi.fn().mockReturnValue(testValue)\n\n    const config = createExpiringConfig({\n      fetchValue: syncFetchValue,\n      key: 'test-key',\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache\n    vi.mocked(mockStore.get).mockReturnValue(undefined)\n\n    const result = await config.get()\n\n    expect(result).toBe(testValue)\n    expect(syncFetchValue).toHaveBeenCalledOnce()\n  })\n\n  test('handles fetchValue throwing an error', async () => {\n    const error = new Error('Fetch failed')\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockRejectedValue(error),\n      key: 'test-key',\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache\n    vi.mocked(mockStore.get).mockReturnValue(undefined)\n\n    await expect(config.get()).rejects.toThrow('Fetch failed')\n    expect(fetchValue).toHaveBeenCalledOnce()\n    expect(mockStore.set).not.toHaveBeenCalled()\n  })\n\n  test('handles different data types as cached values', async () => {\n    const objectValue = {key: 'value', number: 42}\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(objectValue),\n      key: 'test-key',\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache\n    vi.mocked(mockStore.get).mockReturnValue(undefined)\n\n    const result = await config.get()\n\n    expect(result).toEqual(objectValue)\n    expect(mockStore.set).toHaveBeenCalledWith('test-key', {\n      updatedAt: expect.any(Number),\n      value: objectValue,\n    })\n  })\n\n  test('works with TTL of 0 (immediate expiration)', async () => {\n    const testValue = 'test-value'\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(testValue),\n      key: 'test-key',\n      onRevalidate,\n      store: mockStore,\n      ttl: 0,\n    })\n\n    // Mock cached value that would be immediately expired\n    // Use a timestamp from 1ms ago to ensure it's > ttl (0)\n    vi.mocked(mockStore.get).mockReturnValue({\n      updatedAt: Date.now() - 1,\n      value: 'old-value',\n    })\n\n    const result = await config.get()\n\n    expect(result).toBe(testValue)\n    expect(fetchValue).toHaveBeenCalledOnce()\n    expect(onRevalidate).toHaveBeenCalledOnce()\n  })\n\n  test('works without optional callback functions', async () => {\n    const testValue = 'test-value'\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(testValue),\n      key: 'test-key',\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache\n    vi.mocked(mockStore.get).mockReturnValue(undefined)\n\n    const result = await config.get()\n\n    expect(result).toBe(testValue)\n    expect(fetchValue).toHaveBeenCalledOnce()\n  })\n\n  test('handles cached value without updatedAt timestamp', async () => {\n    const newValue = 'new-value'\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(newValue),\n      key: 'test-key',\n      onFetch,\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock cached value without updatedAt (invalid cache entry)\n    vi.mocked(mockStore.get).mockReturnValue({\n      value: 'old-value',\n      // updatedAt is missing\n    })\n\n    const result = await config.get()\n\n    expect(result).toBe(newValue)\n    expect(fetchValue).toHaveBeenCalledOnce()\n    expect(onFetch).toHaveBeenCalledOnce()\n  })\n\n  test('handles cached value without value property', async () => {\n    const newValue = 'new-value'\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(newValue),\n      key: 'test-key',\n      onFetch,\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock cached entry without value property\n    vi.mocked(mockStore.get).mockReturnValue({\n      updatedAt: Date.now(),\n      // value is missing\n    })\n\n    const result = await config.get()\n\n    expect(result).toBe(newValue)\n    expect(fetchValue).toHaveBeenCalledOnce()\n    expect(onFetch).toHaveBeenCalledOnce()\n  })\n\n  test('stores timestamp correctly when caching new values', async () => {\n    const testValue = 'test-value'\n\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(testValue),\n      key: 'test-key',\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache\n    vi.mocked(mockStore.get).mockReturnValue(undefined)\n\n    await config.get()\n\n    expect(mockStore.set).toHaveBeenCalledWith('test-key', {\n      updatedAt: expect.any(Number),\n      value: testValue,\n    })\n  })\n\n  test('subsequent requests after cache is populated use cached value', async () => {\n    const testValue = 'test-value'\n    const config = createExpiringConfig({\n      fetchValue: fetchValue.mockResolvedValue(testValue),\n      key: 'test-key',\n      onCacheHit,\n      onFetch,\n      store: mockStore,\n      ttl: 5000,\n    })\n\n    // Mock empty cache for first request\n    vi.mocked(mockStore.get).mockReturnValueOnce(undefined)\n\n    // First request should fetch\n    const result1 = await config.get()\n\n    // Mock cache populated for subsequent request\n    vi.mocked(mockStore.get).mockReturnValueOnce({\n      updatedAt: Date.now(),\n      value: testValue,\n    })\n\n    // Second request should hit cache\n    const result2 = await config.get()\n\n    expect(result1).toBe(testValue)\n    expect(result2).toBe(testValue)\n    expect(fetchValue).toHaveBeenCalledOnce()\n    expect(onFetch).toHaveBeenCalledOnce()\n    expect(onCacheHit).toHaveBeenCalledOnce()\n  })\n})\n"],"names":["beforeEach","describe","expect","test","vi","createExpiringConfig","mockStore","fetchValue","onCacheHit","onFetch","onRevalidate","delete","fn","get","set","testValue","config","mockResolvedValue","key","store","ttl","mocked","mockReturnValue","undefined","result","toBe","toHaveBeenCalledOnce","not","toHaveBeenCalled","toHaveBeenCalledWith","updatedAt","any","Number","value","cachedValue","Date","now","newValue","resolvePromise","delayedFetch","Promise","resolve","promise1","promise2","promise3","result1","result2","result3","all","syncFetchValue","error","Error","mockRejectedValue","rejects","toThrow","objectValue","number","toEqual","mockReturnValueOnce"],"mappings":"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"}