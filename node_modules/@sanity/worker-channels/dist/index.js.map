{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {type EventEmitter} from 'node:events'\n\nfunction withResolvers<T = void>(Promise: PromiseConstructor) {\n  let resolve!: (value: T) => void\n  let reject!: (error: unknown) => void\n  const promise = new Promise<T>((thisResolve, thisReject) => {\n    resolve = thisResolve\n    reject = thisReject\n  })\n\n  return {promise, resolve, reject}\n}\n\n/**\n * Worker channel namespace containing types for defining structured communication\n * channels between worker threads and their parent processes.\n *\n * @example\n * ```ts\n * // Define the channel interface (shared between parent and worker)\n * // --- In a types file (e.g., types.ts) ---\n * export type MyWorkerChannel = WorkerChannel.Definition<{\n *   compileStart: WorkerChannel.Event<void>\n *   compileProgress: WorkerChannel.Stream<{ file: string; progress: number }>\n *   compileEnd: WorkerChannel.Event<{ duration: number }>\n * }>\n *\n * // --- In the worker file (e.g., worker.ts) ---\n * import {type MyWorkerChannel} from './types.ts'\n * import {parentPort} from 'node:worker_threads';\n *\n * const report = WorkerChannelReporter.from<MyWorkerChannel>(parentPort);\n *\n * async function runCompilation() {\n *   report.event.compileStart(); // Signal start\n *\n *   const files = ['a.js', 'b.js', 'c.js'];\n *   for (const file of files) {\n *     // Simulate work and report progress\n *     await new Promise(resolve => setTimeout(resolve, 100));\n *     report.stream.compileProgress.emit({ file, progress: 100 });\n *   }\n *   report.stream.compileProgress.end(); // Signal end of progress stream\n *\n *   report.event.compileEnd({ duration: 300 }); // Signal end with result\n * }\n *\n * runCompilation();\n *\n * // --- In the parent file (e.g., main.ts) ---\n * import {type MyWorkerChannel} from './types.ts'\n * import {Worker} from 'node:worker_threads';\n *\n * const worker = new Worker('./worker.js');\n * const receiver = WorkerChannelReceiver.from<MyWorkerChannel>(worker);\n *\n * async function monitorCompilation() {\n *   console.log('Waiting for compilation to start...');\n *   await receiver.event.compileStart();\n *   console.log('Compilation started.');\n *\n *   console.log('Receiving progress:');\n *   for await (const progress of receiver.stream.compileProgress()) {\n *     console.log(`  - ${progress.file}: ${progress.progress}%`);\n *   }\n *\n *   console.log('Waiting for compilation to end...');\n *   const { duration } = await receiver.event.compileEnd();\n *   console.log(`Compilation finished in ${duration}ms.`);\n *\n *   receiver.unsubscribe(); // Clean up listeners\n * }\n *\n * monitorCompilation();\n * ```\n *\n * @public\n */\nexport namespace WorkerChannel {\n  /**\n   * Allows declaring the names of events and stream types for a worker channel,\n   * acting as the contract that specifying what events and streams can be\n   * communicated between a worker and its parent process.\n   *\n   * @public\n   */\n  export interface Definition<\n    TDefinition extends Record<string, Event<unknown> | Stream<unknown>> = Record<\n      string,\n      Event<unknown> | Stream<unknown>\n    >,\n  > {\n    readonly __kind: 'definition'\n    readonly __definition: TDefinition\n  }\n\n  /**\n   * Represents a one-time event that can be sent from worker to parent.\n   * Events are fire-and-forget messages that can only be sent once per channel.\n   *\n   * @public\n   */\n  export interface Event<TPayload = void> {\n    readonly __kind: 'event'\n    readonly __payload: TPayload\n  }\n\n  /**\n   * Represents a stream of data that can be sent from worker to parent.\n   * Streams allow multiple emissions of data followed by an end signal.\n   *\n   * @public\n   */\n  export interface Stream<TPayload = void> {\n    readonly __kind: 'stream'\n    readonly __payload: TPayload\n  }\n}\n\ntype DefinitionKeys<TDefinition extends WorkerChannel.Definition> =\n  keyof TDefinition['__definition']\ntype PickDefinition<\n  TDefinition extends WorkerChannel.Definition,\n  K extends DefinitionKeys<TDefinition>,\n> = TDefinition['__definition'][K]\n\ntype EventKeys<TDefinition extends WorkerChannel.Definition> = {\n  [K in DefinitionKeys<TDefinition>]: PickDefinition<\n    TDefinition,\n    K\n  > extends WorkerChannel.Event<any>\n    ? K\n    : never\n}[DefinitionKeys<TDefinition>]\ntype StreamKeys<TDefinition extends WorkerChannel.Definition> = {\n  [K in DefinitionKeys<TDefinition>]: PickDefinition<\n    TDefinition,\n    K\n  > extends WorkerChannel.Stream<any>\n    ? K\n    : never\n}[DefinitionKeys<TDefinition>]\n\ntype EventReporter<TPayload = unknown> = (payload: TPayload) => void\ntype EventReporters<TDefinition extends WorkerChannel.Definition> = {\n  [K in EventKeys<TDefinition>]: PickDefinition<TDefinition, K> extends WorkerChannel.Event<\n    infer TPayload\n  >\n    ? EventReporter<TPayload>\n    : never\n}\n\ntype StreamReporter<TPayload = unknown> = {emit: (payload: TPayload) => void; end: () => void}\ntype StreamReporters<TDefinition extends WorkerChannel.Definition> = {\n  [K in StreamKeys<TDefinition>]: PickDefinition<TDefinition, K> extends WorkerChannel.Stream<\n    infer TPayload\n  >\n    ? StreamReporter<TPayload>\n    : never\n}\n\ntype EventReceiver<TPayload = unknown> = () => Promise<TPayload>\ntype EventReceivers<TDefinition extends WorkerChannel.Definition> = {\n  [K in EventKeys<TDefinition>]: PickDefinition<TDefinition, K> extends WorkerChannel.Event<\n    infer TPayload\n  >\n    ? EventReceiver<TPayload>\n    : never\n}\n\ntype StreamReceiver<TPayload = unknown> = () => AsyncIterable<TPayload>\ntype StreamReceivers<TDefinition extends WorkerChannel.Definition> = {\n  [K in StreamKeys<TDefinition>]: PickDefinition<TDefinition, K> extends WorkerChannel.Stream<\n    infer TPayload\n  >\n    ? StreamReceiver<TPayload>\n    : never\n}\n\ntype EventMessage<TPayload = unknown> = {\n  type: 'channel-event'\n  name: string\n  payload: TPayload\n}\ntype StreamEmissionMessage<TPayload = unknown> = {\n  type: 'channel-emission'\n  name: string\n  payload: TPayload\n}\ntype StreamEndMessage = {\n  type: 'channel-end'\n  name: string\n}\n\nconst MESSAGE_TYPES = new Set(\n  Object.keys({\n    'channel-emission': null,\n    'channel-end': null,\n    'channel-event': null,\n  } satisfies Record<WorkerChannelMessage['type'], null>),\n)\n\n/**\n * Union type representing all possible message types that can be sent through worker channels.\n * These messages are used for communication between worker and parent processes.\n *\n * @public\n */\nexport type WorkerChannelMessage = EventMessage | StreamEmissionMessage | StreamEndMessage\n\n/**\n * Type guard function that checks if an unknown value is a valid WorkerChannelMessage.\n * This is used to validate incoming messages from worker threads.\n *\n * @public\n */\nexport function isWorkerChannelMessage(message: unknown): message is WorkerChannelMessage {\n  if (typeof message !== 'object') return false\n  if (!message) return false\n  if (!('type' in message)) return false\n  if (typeof message.type !== 'string') return false\n  return MESSAGE_TYPES.has(message.type)\n}\n\ninterface ReceiverSubscriber {\n  next: (message: unknown) => void\n  error: (error: unknown) => void\n}\n\n// Originally used EventTarget but compatibility is better with something inline\nclass SimpleEmitter {\n  #subscribers = new Map<object, () => void>()\n\n  notify() {\n    for (const subscriber of this.#subscribers.values()) {\n      subscriber()\n    }\n  }\n\n  subscribe(subscriber: () => void): () => void {\n    const id = {}\n    this.#subscribers.set(id, subscriber)\n\n    return () => {\n      this.#subscribers.delete(id)\n    }\n  }\n}\n\n/**\n * Internal buffer for managing stream data flow between worker and parent.\n * Handles buffering incoming messages when the worker produces data faster than\n * the parent consumes it, and provides async iteration capabilities.\n */\nclass StreamBuffer<T> {\n  #finished = false\n  #buffer: T[] = []\n  #error = withResolvers<never>(Promise)\n  #target = new SimpleEmitter()\n\n  emit = (payload: T) => {\n    this.#buffer.push(payload)\n    this.#target.notify()\n  }\n\n  end = () => {\n    this.#finished = true\n    this.#target.notify()\n  }\n\n  error = (error: unknown) => {\n    this.#error.reject(error)\n  }\n\n  #ready() {\n    const {promise, resolve} = withResolvers<void>(Promise)\n\n    const handler = () => {\n      if (this.#buffer.length || this.#finished) {\n        unsubscribe()\n        resolve()\n      }\n    }\n    const unsubscribe = this.#target.subscribe(handler)\n    handler()\n\n    return Promise.race([promise, this.#error.promise])\n  }\n\n  async *[Symbol.asyncIterator]() {\n    while (!this.#finished || this.#buffer.length) {\n      while (this.#buffer.length) {\n        yield this.#buffer.shift()\n      }\n      await this.#ready()\n    }\n  }\n}\n\n/**\n * Receives messages from a worker thread and provides typed access to events and streams\n * defined in the worker channel definition. This class subscribes to incoming messages\n * from the worker and returns promises for events and async iterators for streams.\n *\n * @example\n * ```ts\n * // Create receiver from a Node.js Worker\n * import {Worker} from 'node:worker_threads';\n * import {type WorkerChannel, WorkerChannelReceiver} from '@sanity/worker-channels'\n *\n * type MyChannel = WorkerChannel.Definition<{\n *   myEvent: WorkerChannel.Event<string>\n *   myStream: WorkerChannel.Stream<string>\n * }>\n * const worker = new Worker('./my-worker.js');\n * const receiver = WorkerChannelReceiver.from<MyChannel>(worker);\n *\n * // Listen for events\n * const result = await receiver.event.myEvent();\n *\n * // Iterate over stream data\n * for await (const data of receiver.stream.myStream()) {\n *   console.log('Received:', data);\n * }\n *\n * // Clean up when done\n * receiver.unsubscribe();\n * ```\n *\n * @public\n */\nexport class WorkerChannelReceiver<TDefinition extends WorkerChannel.Definition> {\n  /**\n   * Creates a WorkerChannelReceiver from a worker that supports either EventEmitter\n   * or EventTarget interfaces (Node.js Worker or Web Worker).\n   *\n   * @param worker - The worker instance to receive messages from\n   * @returns A new WorkerChannelReceiver instance\n   */\n  static from<TDefinition extends WorkerChannel.Definition>(worker: EventTarget | EventEmitter) {\n    if ('addListener' in worker) {\n      return new WorkerChannelReceiver<TDefinition>((subscriber) => {\n        worker.addListener('message', subscriber.next)\n        worker.addListener('error', subscriber.error)\n\n        return () => {\n          worker.removeListener('message', subscriber.next)\n          worker.removeListener('error', subscriber.error)\n        }\n      })\n    }\n\n    if ('addEventListener' in worker) {\n      return new WorkerChannelReceiver<TDefinition>((subscriber) => {\n        worker.addEventListener('message', subscriber.next)\n        worker.addEventListener('error', subscriber.error)\n\n        return () => {\n          worker.removeEventListener('message', subscriber.next)\n          worker.removeEventListener('error', subscriber.error)\n        }\n      })\n    }\n\n    throw new TypeError(\n      'WorkerChannelReceiver.from() requires a worker that implements either the EventEmitter (Node.js Worker) or EventTarget (Web Worker) interface. ' +\n        'Expected an object with addListener/removeListener methods or addEventListener/removeEventListener methods.',\n    )\n  }\n\n  #events = new Map<string, PromiseWithResolvers<unknown>>()\n  #streams = new Map<string, StreamBuffer<unknown>>()\n  #error = withResolvers<never>(Promise)\n\n  /** Function to call to unsubscribe from worker messages and clean up listeners */\n  unsubscribe: () => void\n\n  /**\n   * Creates a new WorkerChannelReceiver instance.\n   *\n   * @param subscribe - Function that sets up message listeners and returns cleanup function\n   */\n  constructor(subscribe: (subscriber: ReceiverSubscriber) => () => void) {\n    this.unsubscribe = subscribe({\n      next: this.#handleMessage,\n      error: this.#handleError,\n    })\n  }\n\n  #handleMessage = (e: unknown): void => {\n    if (!e) return\n    if (typeof e !== 'object') return\n    if ('data' in e && isWorkerChannelMessage(e.data)) return this.#handleMessage(e.data)\n    if ('detail' in e && isWorkerChannelMessage(e.detail)) return this.#handleMessage(e.detail)\n    if (!isWorkerChannelMessage(e)) return\n\n    if (e.type === 'channel-event') this.#getEvent(e.name).resolve(e.payload)\n    if (e.type === 'channel-emission') this.#getStream(e.name).emit(e.payload)\n    if (e.type === 'channel-end') this.#getStream(e.name).end()\n  }\n\n  #handleError = (e: unknown): void => {\n    if (typeof CustomEvent !== 'undefined' && e instanceof CustomEvent) {\n      this.#error.reject(e.detail)\n    } else {\n      this.#error.reject(e)\n    }\n  }\n\n  #getEvent(name: string) {\n    const event = this.#events.get(name) ?? withResolvers(Promise)\n    if (!this.#events.has(name)) this.#events.set(name, event)\n    return event\n  }\n\n  #getStream(name: string) {\n    const stream = this.#streams.get(name) ?? new StreamBuffer()\n    if (!this.#streams.has(name)) this.#streams.set(name, stream)\n    this.#error.promise.catch(stream.error)\n    return stream\n  }\n\n  /**\n   * Provides typed access to event receivers. Each property corresponds to an event\n   * defined in the channel definition and returns a function that resolves when\n   * the event is received from the worker.\n   */\n  event = new Proxy({} as EventReceivers<TDefinition>, {\n    get: (...[, name]): EventReceiver | undefined => {\n      if (typeof name !== 'string') return undefined\n      return () => Promise.race([this.#getEvent(name).promise, this.#error.promise])\n    },\n  })\n\n  /**\n   * Provides typed access to stream receivers. Each property corresponds to a stream\n   * defined in the channel definition and returns a function that returns an async\n   * iterator for receiving streamed data from the worker.\n   */\n  stream = new Proxy({} as StreamReceivers<TDefinition>, {\n    get: (...[, name]): StreamReceiver | undefined => {\n      if (typeof name !== 'string') return undefined\n      return () => this.#getStream(name)\n    },\n  })\n}\n\n/**\n * Interface for objects that can send messages to a parent process.\n * This provides a common abstraction for different types of parent ports\n * used in various worker environments.\n *\n * @public\n */\nexport interface ParentPortLike {\n  /** Sends a message to the parent process */\n  postMessage: (message: unknown) => void\n}\n\n/**\n * Reports events and streams from a worker thread to its parent process.\n * This class provides typed methods for sending events and streaming data\n * according to the worker channel definition.\n *\n * @param TDefinition - The worker channel definition interface\n *\n * @example\n * ```ts\n * // Inside a worker thread\n * import {parentPort} from 'node:worker_threads';\n * import {type WorkerChannel, WorkerChannelReporter} from '@sanity/worker-channels'\n *\n * type MyChannel = WorkerChannel.Definition<{\n *   taskCompleted: WorkerChannel.Event<{result: 'success' | 'failure'}>\n *   progress: WorkerChannel.Stream<{percent: number}>\n * }>\n *\n * const report = WorkerChannelReporter.from<MyChannel>(parentPort);\n *\n * // Report a one-time event\n * report.event.taskCompleted({ result: 'success' });\n *\n * // Stream progress updates\n * for (let i = 0; i <= 100; i += 10) {\n *   report.stream.progress.emit({ percent: i });\n *   await new Promise(resolve => setTimeout(resolve, 100));\n * }\n * report.stream.progress.end();\n * ```\n *\n * @public\n */\nexport class WorkerChannelReporter<TDefinition extends WorkerChannel.Definition> {\n  /**\n   * Creates a WorkerChannelReporter from a parent port or event target.\n   * Supports Node.js parentPort, EventTarget, EventEmitter, or custom ParentPortLike objects.\n   *\n   * @param parentPort - The parent port or event target to send messages to\n   * @returns A new WorkerChannelReporter instance\n   * @throws Error if parentPort is null or doesn't implement required interface\n   */\n  static from<TDefinition extends WorkerChannel.Definition>(\n    parentPort: ParentPortLike | EventTarget | EventEmitter | null,\n  ) {\n    if (!parentPort) {\n      throw new Error(\n        `WorkerChannelReporter.from() requires a valid parent port. ` +\n          `Expected a non-null object, but received: ${String(parentPort)}.`,\n      )\n    }\n    if ('postMessage' in parentPort) {\n      return new WorkerChannelReporter<TDefinition>((message) => parentPort.postMessage(message))\n    }\n    if (\n      'dispatchEvent' in parentPort &&\n      'addEventListener' in parentPort &&\n      typeof CustomEvent !== 'undefined'\n    ) {\n      return new WorkerChannelReporter<TDefinition>((message) =>\n        parentPort.dispatchEvent(new CustomEvent('message', {detail: message})),\n      )\n    }\n    if ('emit' in parentPort && 'addListener' in parentPort) {\n      return new WorkerChannelReporter<TDefinition>((message) =>\n        parentPort.emit('message', message),\n      )\n    }\n\n    throw new TypeError(\n      `WorkerChannelReporter.from() requires a parent port that implements one ` +\n        `of the supported interfaces: ParentPortLike (with a postMessage method), ` +\n        `EventTarget (with dispatchEvent), or EventEmitter (with emit method). ` +\n        `The provided object does not implement any of these interfaces.`,\n    )\n  }\n\n  #postMessage: (message: WorkerChannelMessage) => void\n  #reportedEvents = new Set<string>()\n  #finishedStreams = new Set<string>()\n\n  /**\n   * Creates a new WorkerChannelReporter instance.\n   *\n   * @param postMessage - Function to send messages to the parent process\n   */\n  constructor(postMessage: (message: WorkerChannelMessage) => void) {\n    this.#postMessage = postMessage\n  }\n\n  /**\n   * Provides typed access to event reporters. Each property corresponds to an event\n   * defined in the channel definition and returns a function that sends the event\n   * to the parent process. Each event can only be reported once.\n   */\n  event = new Proxy({} as EventReporters<TDefinition>, {\n    get: (...[, name]): EventReporter | undefined => {\n      if (typeof name !== 'string') return undefined\n      return (payload) => {\n        if (this.#reportedEvents.has(name)) {\n          throw new Error(\n            `Cannot report event \"${name}\" because it has already been reported. ` +\n              `Each event in a worker channel can only be reported and received once.`,\n          )\n        }\n        this.#reportedEvents.add(name)\n        this.#postMessage({type: 'channel-event', name, payload})\n      }\n    },\n  })\n\n  /**\n   * Provides typed access to stream reporters. Each property corresponds to a stream\n   * defined in the channel definition and returns an object with `emit()` and `end()`\n   * methods for sending streaming data to the parent process.\n   */\n  stream = new Proxy({} as StreamReporters<TDefinition>, {\n    get: (...[, name]): StreamReporter | undefined => {\n      if (typeof name !== 'string') return undefined\n      return {\n        emit: (payload) => {\n          if (this.#finishedStreams.has(name)) {\n            throw new Error(\n              `Cannot emit to stream \"${name}\" because it has already been finished. ` +\n                `Once a stream is ended with .end(), no more data can be emitted to it.`,\n            )\n          }\n          this.#postMessage({type: 'channel-emission', name, payload})\n        },\n        end: () => {\n          if (this.#finishedStreams.has(name)) {\n            throw new Error(\n              `Cannot end stream \"${name}\" because it has already been finished. ` +\n                'Each stream can only be ended once.',\n            )\n          }\n          this.#finishedStreams.add(name)\n          this.#postMessage({type: 'channel-end', name})\n        },\n      }\n    },\n  })\n}\n"],"names":["Promise"],"mappings":"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"}