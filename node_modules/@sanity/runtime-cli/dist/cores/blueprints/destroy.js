import { setTimeout } from 'node:timers/promises';
import { confirm } from '@inquirer/prompts';
import chalk from 'chalk';
import ora from 'ora';
import { setupLogStreaming } from '../../actions/blueprints/logs-streaming.js';
import { destroyStack, getStack } from '../../actions/blueprints/stacks.js';
import { niceId } from '../../utils/display/presenters.js';
export async function blueprintDestroyCore(options) {
    const { log, token, blueprint, flags } = options;
    const { force = false, 'project-id': flagProjectId, 'organization-id': flagOrganizationId, 'stack-id': flagStackId, 'no-wait': noWait = false, verbose: _verbose = false, } = flags;
    // 3-flag combo: just destroy it
    if ((flagProjectId || flagOrganizationId) && flagStackId && force) {
        let scopeType;
        let scopeId;
        if (flagOrganizationId) {
            scopeType = 'organization';
            scopeId = flagOrganizationId;
        }
        else if (flagProjectId) {
            scopeType = 'project';
            scopeId = flagProjectId;
        }
        else {
            return { success: false, error: 'Unable to determine scope for Blueprint Destroy' };
        }
        const { ok, error, stack } = await destroyStack({
            stackId: flagStackId,
            auth: { token, scopeType, scopeId },
        });
        if (!ok)
            return { success: false, error: error || 'Failed to destroy Stack deployment' };
        log(`Stack deployment "${stack.name}" ${niceId(stack.id)} destroyed`);
        return { success: true };
    }
    const { scopeType, scopeId, stackId } = blueprint;
    if (!scopeType || !scopeId)
        return { success: false, error: 'Scope is required' };
    const auth = { token, scopeType, scopeId };
    let stack;
    try {
        if (flagStackId) {
            const flagStack = await getStack({ stackId: flagStackId, auth });
            if (!flagStack.ok)
                return { success: false, error: flagStack.error || 'Failed to get Stack' };
            stack = flagStack.stack;
        }
        else if (stackId) {
            const blueprintStack = await getStack({ stackId, auth });
            if (!blueprintStack.ok)
                return { success: false, error: blueprintStack.error || 'Failed to get Stack' };
            stack = blueprintStack.stack;
        }
        if (!stack)
            return { success: false, error: 'Stack deployment not found' };
        const destroySpinner = ora({
            text: `Destroying Stack deployment "${chalk.bold(stack.name)}" ${niceId(stack.id)}...`,
            color: 'red',
        });
        if (!force) {
            const confirmed = await confirm({
                message: `Are you sure you want to destroy stack "${stack.name}" ${niceId(stack.id)}?`,
                default: false,
            });
            if (!confirmed) {
                log('Stack deployment destruction cancelled');
                return { success: true };
            }
            destroySpinner.start();
            // 5 second countdown
            let i = 5;
            while (i >= 0) {
                destroySpinner.text = `Destroying Stack deployment in ${chalk.bold((i--).toString())} seconds...`;
                await setTimeout(1000);
            }
            destroySpinner.text = 'Destroying Stack deployment ðŸ’¥';
            await setTimeout(500);
        }
        else {
            destroySpinner.start();
        }
        const isoNow = new Date().toISOString();
        const { ok, error } = await destroyStack({ stackId: stack.id, auth });
        if (!ok) {
            destroySpinner.fail('Failed to destroy Stack deployment');
            return { success: false, error: error || 'Failed to destroy Stack deployment' };
        }
        destroySpinner.stop().clear();
        if (noWait) {
            log(chalk.bold.magenta('Stack destruction started!'));
            return { success: true };
        }
        log(chalk.dim('Stack destruction progress:'));
        let logStreamCleanup = null;
        try {
            logStreamCleanup = await setupLogStreaming({
                stackId: stack.id,
                after: isoNow,
                auth,
                log,
            });
            while (true) {
                const { ok, stack: currentStack } = await getStack({ stackId: stack.id, auth });
                const operation = currentStack?.recentOperation;
                if (!ok || !operation || operation?.status === 'COMPLETED') {
                    // Operation is also marked destroyed when stack is deleted;
                    // it's possible that the operation is "gone" or available and "COMPLETED"
                    if (logStreamCleanup)
                        logStreamCleanup();
                    log(chalk.bold.magenta('Stack destruction completed!'));
                    return { success: true };
                }
                if (operation.status === 'FAILED') {
                    if (logStreamCleanup)
                        logStreamCleanup();
                    return { success: false, error: 'Stack destruction failed' };
                }
                await setTimeout(1500);
            }
        }
        catch (error) {
            if (logStreamCleanup)
                logStreamCleanup();
            throw error;
        }
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        return { success: false, error: errorMessage };
    }
}
