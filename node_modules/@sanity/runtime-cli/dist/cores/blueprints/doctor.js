import { cwd } from 'node:process';
import chalk from 'chalk';
import { findBlueprintFile, readLocalBlueprint, } from '../../actions/blueprints/blueprint.js';
import { getStack } from '../../actions/blueprints/stacks.js';
import config from '../../config.js';
import { capitalize, check, filePathRelativeToCwd, indent, niceId, severe, unsure, } from '../../utils/display/presenters.js';
import { validTokenOrErrorMessage } from '../../utils/validated-token.js';
import { blueprintConfigCore } from './config.js';
const diagLookup = {
    online: 'Online',
    tokenPresent: 'Auth token present',
    tokenValid: 'Auth token valid',
    configFilePresent: 'Blueprint config file present',
    configFileValid: 'Blueprint config file valid',
    blueprintPresent: 'Blueprint file present',
    blueprintValid: 'Blueprint file valid',
    stackReady: 'Stack deployment ready',
    userHasAccess: 'User has access to deployed "Stack"',
};
export async function blueprintDoctorCore(options) {
    const { bin, log, token, flags: { verbose: v, path: p, fix }, } = options;
    const yikes = (s) => {
        log(chalk.bgRedBright.whiteBright.bold(` ${s} `));
    };
    const here = cwd();
    const path = p || here;
    let tokenOrError;
    if (v)
        log(`Checking ${filePathRelativeToCwd(path)}`);
    // 3 states: null == unknown, true == good, false == bad
    const diagnostics = {};
    for (const key in diagLookup) {
        diagnostics[key] = null;
    }
    // ONLINE
    try {
        const res = await fetch(config.apiUrl);
        if (res.ok) {
            if (v)
                log(`Successfully pinged ${config.apiUrl}`);
            diagnostics.online = res.ok;
        }
        else {
            yikes(`Failed to ping ${config.apiUrl}: ${res.status} ${res.statusText}`);
            diagnostics.online = false;
        }
    }
    catch {
        yikes(`Failed to ping ${config.apiUrl}`);
    }
    // TOKEN
    if (token) {
        diagnostics.tokenPresent = true;
        tokenOrError = await validTokenOrErrorMessage(token);
        if (tokenOrError.ok) {
            diagnostics.tokenValid = true;
        }
        else {
            yikes(`Token error: ${tokenOrError.error}`);
            diagnostics.tokenValid = false;
        }
    }
    else {
        diagnostics.tokenPresent = false;
    }
    // BLUEPRINT file
    const blueprintFile = findBlueprintFile(path);
    if (blueprintFile?.blueprintFilePath) {
        if (v)
            log(`Found blueprint file at ${blueprintFile.blueprintFilePath.replace(here, '.')}`);
        diagnostics.blueprintPresent = true;
    }
    else {
        diagnostics.blueprintPresent = false;
    }
    let blueprint;
    try {
        blueprint = await readLocalBlueprint(path);
        if (blueprint.errors.length === 0) {
            if (v)
                log(`Blueprint has no errors`);
            diagnostics.blueprintValid = true;
        }
        else {
            if (v)
                log(`Blueprint errors: \n${blueprint.errors.join('\n  ')}`);
            diagnostics.blueprintValid = false;
        }
    }
    catch {
        if (v)
            yikes(`Unable to read blueprint`);
        diagnostics.blueprintValid = false;
    }
    if (blueprint) {
        const { blueprintConfig, scopeType, scopeId, stackId, projectId } = blueprint;
        const configPath = blueprintConfig?.configPath;
        // CONFIG file
        if (configPath) {
            if (v)
                log(`Found config file at ${configPath.replace(here, '.')}`);
            diagnostics.configFilePresent = true;
            if (scopeType && scopeId && stackId) {
                diagnostics.configFileValid = true;
                if (v) {
                    const configOutput = [
                        `${capitalize(scopeType)}: ${niceId(scopeId)}`,
                        `Deployment: ${niceId(stackId)}`,
                    ].join('\n');
                    log(indent(configOutput));
                }
            }
            else {
                diagnostics.configFileValid = false;
            }
        }
        else {
            diagnostics.configFilePresent = false;
        }
        // STACK + ACCESS
        if (diagnostics.online && diagnostics.tokenValid && token && stackId && projectId) {
            const stackResponse = await getStack({
                auth: { token, scopeType: 'project', scopeId: projectId },
                stackId,
            });
            if (stackResponse.ok) {
                if (v)
                    log(`Deployment "Stack" ${niceId(stackId)} ready`);
                diagnostics.stackReady = true;
                diagnostics.userHasAccess = true;
            }
            else if (stackResponse.response?.status === 404) {
                yikes(`Deployment "Stack" <${stackId}> not found`);
                diagnostics.stackReady = false;
            }
            else if (stackResponse.response?.status === 403 || stackResponse.response?.status === 401) {
                yikes(`User does not have access to "Stack" <${stackId}>`);
                diagnostics.userHasAccess = false;
            }
            else {
                yikes(`Unknown error with "Stack" <${stackId}>: ${stackResponse.error}`);
            }
        }
        else {
            if (!diagnostics.online)
                yikes('Unable to connect to Sanity API.');
            if (!diagnostics.tokenValid)
                yikes('Invalid authentication token.');
            if (!stackId)
                yikes(`Blueprints configuration is missing a Stack ID`);
            if (!projectId)
                yikes(`Blueprints configuration is missing a Project ID`);
        }
    }
    log('');
    let allGood = true;
    for (const [key, value] of Object.entries(diagnostics)) {
        switch (value) {
            case true:
                log(check(diagLookup[key]));
                break;
            case false:
                allGood = false;
                log(severe(diagLookup[key]));
                break;
            case null:
                allGood = false;
                log(unsure(diagLookup[key]));
                break;
            default:
                allGood = false;
                log(severe(`${key} is ${value}`));
        }
    }
    const errorMessage = 'One or more checks failed';
    if (allGood) {
        log(chalk.bold.green('All checks passed'));
        if (fix)
            log(chalk.bold.yellow('Nothing to fix; --fix flag is ignored'));
        return { success: true, data: { diagnostics } };
    }
    else if (fix) {
        if (p) {
            return { success: false, error: `${errorMessage}. --fix cannot be used with --path` };
        }
        if (!tokenOrError) {
            return { success: false, error: `${errorMessage}. Unable to fix: Missing authentication token` };
        }
        if (tokenOrError?.ok === false) {
            return {
                success: false,
                error: `${errorMessage}. Unable to fix: ${tokenOrError.error.message}`,
            };
        }
        if (!blueprint) {
            return {
                success: false,
                error: `${errorMessage}. Unable to fix: Blueprint is missing or invalid`,
            };
        }
        return blueprintConfigCore({
            bin,
            log,
            token: tokenOrError.value,
            blueprint,
            flags: { edit: true, verbose: v },
        });
    }
    return { success: false, error: errorMessage, data: { diagnostics } };
}
