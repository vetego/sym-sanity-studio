// * https://oclif.io/docs/base_class
import { Command, Flags as OclifFlags } from '@oclif/core';
import { initBlueprintConfig, initDeployedBlueprintConfig } from './cores/index.js';
const baseFlags = {
    verbose: OclifFlags.boolean({
        description: 'Verbose output',
        default: false,
        hidden: true, // prevent help output on all commands
    }),
};
/**
 * @description Guarantees flags, args, sanityToken, and blueprint.
 * Blueprint parser errors are logged and the command exits with an error
 * @extends Command
 */
export class BlueprintCommand extends Command {
    sanityToken;
    blueprint;
    flags;
    args;
    static baseFlags = baseFlags;
    async init() {
        const { args, flags } = await this.parse({
            flags: this.ctor.flags,
            baseFlags: super.ctor.baseFlags,
            enableJsonFlag: this.ctor.enableJsonFlag,
            args: this.ctor.args,
            strict: this.ctor.strict,
        });
        this.flags = flags;
        this.args = args;
        await super.init();
        const result = await initBlueprintConfig({
            bin: this.config.bin,
            log: (msg) => this.log(msg),
        });
        if (!result.ok) {
            this.error(result.error);
        }
        this.sanityToken = result.value.token;
        this.blueprint = result.value.blueprint;
    }
    async catch(err) {
        // add any custom logic to handle errors from the command
        // or simply return the parent class error handling
        return super.catch(err);
    }
    async finally(_) {
        // called after run and catch regardless of whether or not the command errored
        return super.finally(_);
    }
}
/**
 * @description Guarantees flags, args, sanityToken, blueprint, scopeType, scopeId, stackId, auth, and deployedStack.
 * If scope or stack is missing, the command exits with an error
 * @extends BlueprintCommand
 */
export class DeployedBlueprintCommand extends BlueprintCommand {
    auth;
    deployedStack;
    scopeType;
    scopeId;
    stackId;
    static baseFlags = baseFlags;
    async init() {
        await super.init();
        const result = await initDeployedBlueprintConfig({
            bin: this.config.bin,
            blueprint: this.blueprint,
            log: (msg) => this.log(msg),
            token: this.sanityToken,
            validateToken: false,
        });
        if (!result.ok) {
            this.error(result.error);
        }
        this.scopeType = result.value.scopeType;
        this.scopeId = result.value.scopeId;
        this.stackId = result.value.stackId;
        this.auth = result.value.auth;
        this.deployedStack = result.value.deployedStack;
    }
}
