import { treeify } from 'array-treeify';
import chalk from 'chalk';
import { SANITY_ACCESS_ROLE, SANITY_FUNCTION_DOCUMENT, SANITY_FUNCTION_MEDIA_LIBRARY_ASSET, SANITY_FUNCTION_SCHEDULE, SANITY_PROJECT_CORS, SANITY_PROJECT_DATASET, SANITY_PROJECT_WEBHOOK, } from '../../constants.js';
import { isCorsOriginResource, isDatasetResource, isRoleResource, isWebhookResource, } from '../types.js';
import { formatDate, formatDuration } from './dates.js';
import { niceId } from './presenters.js';
import { arrayifyCors, arrayifyDataset, arrayifyFunction, arrayifyRole, arrayifyWebhook, } from './resources-formatting.js';
const functionCategory = {
    label: 'Functions',
    displayNameAttribute: 'displayName',
    formatDetails: arrayifyFunction,
};
const RESOURCE_CATEGORIES = {
    [SANITY_ACCESS_ROLE]: {
        label: 'Roles',
        displayNameAttribute: 'title',
        formatDetails(res) {
            return isRoleResource(res) ? arrayifyRole(res) : [];
        },
    },
    [SANITY_FUNCTION_DOCUMENT]: functionCategory,
    [SANITY_FUNCTION_MEDIA_LIBRARY_ASSET]: functionCategory,
    [SANITY_FUNCTION_SCHEDULE]: functionCategory,
    [SANITY_PROJECT_CORS]: {
        label: 'CORS Origins',
        formatDetails(res) {
            return isCorsOriginResource(res) ? arrayifyCors(res) : [];
        },
    },
    [SANITY_PROJECT_DATASET]: {
        label: 'Datasets',
        displayNameAttribute: 'datasetName',
        formatDetails(res) {
            return isDatasetResource(res) ? arrayifyDataset(res) : [];
        },
    },
    [SANITY_PROJECT_WEBHOOK]: {
        label: 'Webhooks',
        displayNameAttribute: 'displayName',
        formatDetails(res) {
            return isWebhookResource(res) ? arrayifyWebhook(res) : [];
        },
    },
};
const categoryByLabel = Object.values(RESOURCE_CATEGORIES).reduce((acc, curr) => {
    acc[curr.label] = curr;
    return acc;
}, {});
function resourceName(res, displayNameAttribute) {
    const displayName = displayNameAttribute &&
        displayNameAttribute in res &&
        typeof res[displayNameAttribute] === 'string' &&
        res[displayNameAttribute];
    const name = displayName || res.name || 'unnamed';
    return chalk.bold.green(name);
}
function deployedResourceName(res, displayNameAttribute) {
    const displayName = displayNameAttribute &&
        typeof res.parameters[displayNameAttribute] === 'string' &&
        res.parameters[displayNameAttribute];
    const name = displayName || res.name || 'unnamed';
    const ids = idList(res).join(' ');
    return `${chalk.bold.green(name)} ${ids}`;
}
function idList(res) {
    return [
        'id' in res && typeof res.id === 'string' && res.id ? `${niceId(res.id)}` : '',
        'externalId' in res && typeof res.externalId === 'string' && res.externalId
            ? `<${niceId(res.externalId)}>`
            : '',
    ];
}
export function formatTitle(title, name) {
    return `${chalk.bold.blue(title)} ${chalk.bold(`"${name}"`)}`;
}
function categorizeResources(resources) {
    const categorized = {};
    const otherResources = [];
    for (const resource of resources) {
        const cat = RESOURCE_CATEGORIES[resource.type];
        if (cat) {
            if (!categorized[cat.label])
                categorized[cat.label] = [];
            categorized[cat.label].push(resource);
        }
        else {
            otherResources.push(resource);
        }
    }
    // unmatched resources are 'Other Resources'
    if (otherResources.length > 0) {
        categorized['Other Resources'] = otherResources;
    }
    return categorized;
}
function buildOutputTree(resources, name, mapToResource) {
    const output = [`${chalk.bold.underline('Resources')} [${resources.length}]`];
    const categorized = categorizeResources(resources);
    for (const category of Object.values(categoryByLabel)) {
        const catResources = categorized[category.label];
        if (catResources && catResources.length > 0) {
            const catOutput = [`${chalk.bold(category.label)} [${catResources.length}]`];
            const details = [];
            for (const res of catResources) {
                details.push(name(category, res));
                if (category.formatDetails) {
                    details.push(category.formatDetails(mapToResource(res)));
                }
            }
            catOutput.push(details);
            output.push(catOutput);
        }
    }
    if (categorized['Other Resources'] && categorized['Other Resources'].length > 0) {
        const otherOutput = [
            `${chalk.bold('Other Resources')} [${categorized['Other Resources'].length}]`,
        ];
        const otherResourcesOutput = categorized['Other Resources'].map((other) => {
            return `${chalk.yellow(other.name ?? 'unnamed')} ${chalk.dim(other.type)}`;
        });
        otherOutput.push(otherResourcesOutput);
        output.push(otherOutput);
    }
    return output;
}
export function formatDeployedResourceTree(resources) {
    if (!resources || resources.length === 0)
        return '  Zero deployed resources';
    const output = buildOutputTree(resources, (category, res) => deployedResourceName(res, category.displayNameAttribute), (res) => ({ name: res.name, type: res.type, ...res.parameters }));
    return `${treeify(output)}\n`;
}
export function formatResourceTree(resources) {
    if (!resources || resources.length === 0)
        return '  Zero resources';
    const output = buildOutputTree(resources, (category, res) => resourceName(res, category.displayNameAttribute), (res) => res);
    return `${treeify(output)}\n`;
}
export function formatStackInfo(stack, isCurrentStack = false) {
    const isStack = 'id' in stack; // type narrowing
    const isProjectBasedStack = isStack && stack.id === `ST-${stack.scopeId}`;
    const output = [];
    if (isStack) {
        let stackName = chalk.bold(`"${stack.name}"`);
        if (isCurrentStack)
            stackName = `${chalk.blue(stackName)} (current)`;
        if (isProjectBasedStack)
            stackName += ' (project-based)';
        output.push(`${stackName} ${niceId(stack.id)}`);
    }
    else {
        output.push('Local Blueprint');
    }
    const infoOutput = [];
    if (stack.resources) {
        infoOutput.push(`${stack.resources.length} resource${stack.resources.length === 1 ? '' : 's'}`);
    }
    else {
        infoOutput.push('No resources');
    }
    if (isStack) {
        if (stack.createdAt)
            infoOutput.push(`Created: ${formatDate(stack.createdAt)}`);
        if (stack.updatedAt)
            infoOutput.push(`Updated: ${formatDate(stack.updatedAt)}`);
        if (stack.recentOperation) {
            const operation = stack.recentOperation;
            const operationOutput = [];
            if (operation.id)
                operationOutput.push(`Recent Operation ${niceId(operation.id)}:`);
            if (operation.status) {
                const operationColor = operation.status === 'COMPLETED' ? chalk.green : chalk.red;
                const status = operation.status || 'UNKNOWN';
                operationOutput.push(`Status: ${operationColor(status)}`);
            }
            if (operation.createdAt)
                operationOutput.push(`Started: ${formatDate(operation.createdAt)}`);
            if (operation.status === 'COMPLETED' && operation.completedAt && operation.createdAt) {
                operationOutput.push(`Completed: ${formatDate(operation.completedAt)}`);
                operationOutput.push(`Duration: ${chalk.yellow(formatDuration(operation.createdAt, operation.completedAt))}`);
            }
            infoOutput.push(operationOutput);
        }
    }
    output.push(infoOutput);
    return treeify(output, { plain: true });
}
export function formatStacksListing(stacks, currentStackId) {
    if (!stacks || stacks.length === 0)
        return 'No stacks found';
    const output = [];
    for (const stack of stacks) {
        const isCurrentStack = currentStackId === stack.id;
        output.push(formatStackInfo(stack, isCurrentStack));
    }
    return output.join('\n');
}
export function stackDeployDiff(localBlueprint, deployedStack) {
    const added = [];
    const removed = [];
    // look for new resources
    for (const resource of localBlueprint.resources ?? []) {
        const deployedResource = deployedStack.resources.find(({ name, type }) => resource.name === name && resource.type === type);
        if (!deployedResource)
            added.push(resource);
    }
    // look for destroyed resources
    for (const resource of deployedStack.resources) {
        const localResource = localBlueprint.resources?.find(({ name, type }) => resource.name === name && resource.type === type);
        if (!localResource)
            removed.push(resource);
    }
    if (added.length === 0 && removed.length === 0)
        return null;
    const output = [];
    if (added.length > 0) {
        output.push(`  ${chalk.bold.greenBright('++')} ${added.map(({ name }) => chalk.bgGreen.whiteBright(`"${name}"`)).join(' ')}`);
    }
    if (removed.length > 0) {
        output.push(`  ${chalk.bold.redBright('--')} ${removed.map(({ name }) => chalk.bgRed.whiteBright(`"${name}"`)).join(' ')}`);
    }
    return output.join('\n');
}
