{"version":3,"file":"typegenGenerate.js","sources":["../../src/workers/typegenGenerate.ts"],"sourcesContent":["import {stat} from 'node:fs/promises'\nimport path from 'node:path'\nimport {isMainThread, parentPort, workerData} from 'node:worker_threads'\n\nimport {\n  findQueriesInPath,\n  getResolver,\n  readSchema,\n  registerBabel,\n  TypeGenerator,\n  type TypegenWorkerChannel as CodegenTypegenWorkerChannel,\n} from '@sanity/codegen'\nimport {type WorkerChannel, WorkerChannelReporter} from '@sanity/worker-channels'\n\nexport interface TypegenGenerateTypesWorkerData {\n  workDir: string\n  schemaPath: string\n  searchPath: string | string[]\n  overloadClientMethods?: boolean\n}\n\nif (isMainThread || !parentPort) {\n  throw new Error('This module must be run as a worker thread')\n}\n\nregisterBabel()\n\nexport type TypegenWorkerChannel = WorkerChannel.Definition<\n  {\n    loadedSchema: WorkerChannel.Event\n    typegenStarted: WorkerChannel.Event<{expectedFileCount: number}>\n    typegenComplete: WorkerChannel.Event<{code: string}>\n  } & CodegenTypegenWorkerChannel['__definition']\n>\n\nasync function main({\n  schemaPath,\n  searchPath,\n  workDir,\n  overloadClientMethods,\n}: TypegenGenerateTypesWorkerData) {\n  const report = WorkerChannelReporter.from<TypegenWorkerChannel>(parentPort)\n\n  const fullPath = path.join(workDir, schemaPath)\n\n  try {\n    const schemaStats = await stat(fullPath)\n    if (!schemaStats.isFile()) {\n      throw new Error(`Schema path is not a file: ${schemaPath}`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      // If the user has not provided a specific schema path (eg we're using the default), give some help\n      const hint = schemaPath === './schema.json' ? ` - did you run \"sanity schema extract\"?` : ''\n      throw new Error(`Schema file not found: ${fullPath}${hint}`, {cause: err})\n    }\n    throw err\n  }\n\n  const schema = await readSchema(fullPath)\n\n  report.event.loadedSchema()\n\n  const typeGenerator = new TypeGenerator()\n\n  const {files, queries} = findQueriesInPath({\n    path: searchPath,\n    resolver: getResolver(workDir),\n  })\n  report.event.typegenStarted({expectedFileCount: files.length})\n\n  const result = await typeGenerator.generateTypes({\n    queries,\n    schema,\n    reporter: report,\n    schemaPath,\n    root: workDir,\n    overloadClientMethods,\n  })\n  report.event.typegenComplete(result)\n}\n\nmain(workerData).catch((err) => {\n  // worker will terminate and parent will catch the error\n  throw err\n})\n"],"names":["isMainThread","parentPort","registerBabel","WorkerChannelReporter","path","stat","readSchema","TypeGenerator","findQueriesInPath","getResolver","workerData"],"mappings":";;;;;;AAqBA,IAAIA,oBAAAA,gBAAgB,CAACC,oBAAAA;AACnB,QAAM,IAAI,MAAM,4CAA4C;AAG9DC,QAAAA,cAAA;AAUA,eAAe,KAAK;AAAA,EAClB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAmC;AACjC,QAAM,SAASC,qCAAsB,KAA2BF,oBAAAA,UAAU,GAEpE,WAAWG,sBAAK,KAAK,SAAS,UAAU;AAE9C,MAAI;AAEF,QAAI,EADgB,MAAMC,GAAAA,KAAK,QAAQ,GACtB,OAAA;AACf,YAAM,IAAI,MAAM,8BAA8B,UAAU,EAAE;AAAA,EAE9D,SAAS,KAAK;AACZ,QAAI,IAAI,SAAS,UAAU;AAEzB,YAAM,OAAO,eAAe,kBAAkB,4CAA4C;AAC1F,YAAM,IAAI,MAAM,0BAA0B,QAAQ,GAAG,IAAI,IAAI,EAAC,OAAO,KAAI;AAAA,IAC3E;AACA,UAAM;AAAA,EACR;AAEA,QAAM,SAAS,MAAMC,QAAAA,WAAW,QAAQ;AAExC,SAAO,MAAM,aAAA;AAEb,QAAM,gBAAgB,IAAIC,sBAAA,GAEpB,EAAC,OAAO,QAAA,IAAWC,0BAAkB;AAAA,IACzC,MAAM;AAAA,IACN,UAAUC,QAAAA,YAAY,OAAO;AAAA,EAAA,CAC9B;AACD,SAAO,MAAM,eAAe,EAAC,mBAAmB,MAAM,QAAO;AAE7D,QAAM,SAAS,MAAM,cAAc,cAAc;AAAA,IAC/C;AAAA,IACA;AAAA,IACA,UAAU;AAAA,IACV;AAAA,IACA,MAAM;AAAA,IACN;AAAA,EAAA,CACD;AACD,SAAO,MAAM,gBAAgB,MAAM;AACrC;AAEA,KAAKC,8BAAU,EAAE,MAAM,CAAC,QAAQ;AAE9B,QAAM;AACR,CAAC;"}