"use strict";
var fs = require("node:fs"), path = require("node:path"), node_worker_threads = require("node:worker_threads"), debugIt = require("debug"), cliWorker = require("./cliWorker.js");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var fs__default = /* @__PURE__ */ _interopDefaultCompat(fs), path__default = /* @__PURE__ */ _interopDefaultCompat(path), debugIt__default = /* @__PURE__ */ _interopDefaultCompat(debugIt);
const debug = debugIt__default.default("sanity:cli"), requireFunc = typeof __webpack_require__ == "function" ? __non_webpack_require__ : require;
function dynamicRequire(request) {
  const mod = requireFunc(request);
  return mod.__esModule && mod.default ? mod.default : mod;
}
dynamicRequire.resolve = requireFunc.resolve;
dynamicRequire.cache = requireFunc.cache;
async function getCliConfig(cwd, { forked } = {}) {
  let clearCache = !1;
  if (forked)
    try {
      return await getCliConfigForked(cwd);
    } catch (err) {
      debug("Error in getCliConfigForked", err), clearCache = !0;
    }
  const { unregister } = (
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    require("esbuild-register/dist/node").register({
      target: `node${process.version.slice(1)}`,
      supported: { "dynamic-import": !0 },
      // Force CJS output since we use require() to load the config
      format: "cjs"
    })
  );
  try {
    return getSanityCliConfig(cwd, clearCache);
  } finally {
    unregister();
  }
}
async function getCliConfigForked(cwd) {
  const workerPath = await cliWorker.getCliWorkerPath("getCliConfig");
  return new Promise((resolve, reject) => {
    const worker = new node_worker_threads.Worker(workerPath, {
      workerData: cwd,
      env: process.env
    });
    worker.on("message", (message) => {
      if (message.type === "config")
        resolve(message.config);
      else {
        const error = new Error(message.error);
        error.type = message.errorType, reject(new Error(message.error));
      }
    }), worker.on("error", reject), worker.on("exit", (code) => {
      code !== 0 && reject(new Error(`Worker stopped with exit code ${code}`));
    });
  });
}
function getSanityCliConfig(cwd, clearCache = !1) {
  let configName = "sanity.cli";
  process.env.SANITY_CLI_TEST_CONFIG_NAME && process.env.TEST === "true" && (configName = process.env.SANITY_CLI_TEST_CONFIG_NAME);
  const jsConfigPath = path__default.default.join(cwd, `${configName}.js`), tsConfigPath = path__default.default.join(cwd, `${configName}.ts`), [js, ts] = [fs__default.default.existsSync(jsConfigPath), fs__default.default.existsSync(tsConfigPath)];
  return !js && !ts ? null : !js && ts ? {
    config: importConfig(tsConfigPath, clearCache),
    path: tsConfigPath
  } : (js && ts && warn(`Found both \`${configName}.js\` and \`${configName}.ts\` - using ${configName}.js`), {
    config: importConfig(jsConfigPath, clearCache),
    path: jsConfigPath
  });
}
function importConfig(filePath, clearCache) {
  try {
    if (clearCache) {
      const resolvedPath = dynamicRequire.resolve(filePath);
      delete dynamicRequire.cache[resolvedPath];
    }
    const config = dynamicRequire(filePath);
    if (config === null || typeof config != "object")
      throw new Error("Module export is not a configuration object");
    return "default" in config ? config.default : config;
  } catch (err) {
    return err.code === "MODULE_NOT_FOUND" && err.message.includes("sanity/cli") || console.error(`Error reading "${filePath}": ${err.message}`), null;
  }
}
function warn(warning) {
  typeof process.send == "function" ? process.send({ type: "warning", warning }) : console.warn(warning);
}
exports.debug = debug;
exports.dynamicRequire = dynamicRequire;
exports.getCliConfig = getCliConfig;
exports.getSanityCliConfig = getSanityCliConfig;
//# sourceMappingURL=getCliConfig.js.map
