import fs$1, { readFile } from "node:fs/promises";
import json5 from "json5";
import * as z from "zod";
import { parse, typeEvaluate } from "groq-js";
import createDebug from "debug";
import glob from "globby";
import fs, { existsSync } from "node:fs";
import path, { dirname, join, resolve } from "node:path";
import { fileURLToPath } from "node:url";
import { createRequire } from "node:module";
import { parse as parse$1, traverse } from "@babel/core";
import * as t from "@babel/types";
import { Scope } from "@babel/traverse";
import { loadConfig, createMatchPath } from "tsconfig-paths";
import register from "@babel/register";
import process from "node:process";
import { createSelector } from "reselect";
import { CodeGenerator } from "@babel/generator";
const configDefinition = z.object({
  path: z.string().or(z.array(z.string())).default([
    "./src/**/*.{ts,tsx,js,jsx,mjs,cjs,astro}",
    "./app/**/*.{ts,tsx,js,jsx,mjs,cjs}",
    "./sanity/**/*.{ts,tsx,js,jsx,mjs,cjs}"
  ]),
  schema: z.string().default("./schema.json"),
  generates: z.string().default("./sanity.types.ts"),
  formatGeneratedCode: z.boolean().default(!0),
  overloadClientMethods: z.boolean().default(!0)
});
async function readConfig(path2) {
  try {
    const content = await readFile(path2, "utf-8"), json = json5.parse(content);
    return configDefinition.parseAsync(json);
  } catch (error) {
    if (error instanceof z.ZodError)
      throw new Error(
        `Error in config file
 ${error.errors.map((err) => err.message).join(`
`)}`,
        { cause: error }
      );
    if (typeof error == "object" && error !== null && "code" in error && error.code === "ENOENT")
      return configDefinition.parse({});
    throw error;
  }
}
async function readSchema(path2) {
  const content = await readFile(path2, "utf-8");
  return JSON.parse(content);
}
function safeParseQuery(query) {
  const params = {};
  for (const param of extractSliceParams(query))
    params[param] = 0;
  return parse(query, { params });
}
function* extractSliceParams(query) {
  const sliceRegex = /\[(\$(\w+)|\d)\.\.\.?(\$(\w+)|\d)\]/g, matches = query.matchAll(sliceRegex);
  if (matches)
    for (const match of matches) {
      const start = match[1] === `$${match[2]}` ? match[2] : null;
      start !== null && (yield start);
      const end = match[3] === `$${match[4]}` ? match[4] : null;
      end !== null && (yield end);
    }
}
const __dirname$1 = dirname(fileURLToPath(import.meta.url));
function findBabelConfig(path2) {
  const configPath = join(path2, "babel.config.json");
  if (existsSync(configPath))
    return configPath;
  const parent = resolve(join(path2, ".."));
  if (parent && parent !== path2)
    return findBabelConfig(parent);
  throw new Error("Could not find `babel.config.json` in @sanity/codegen");
}
function getBabelConfig(path2) {
  return { extends: findBabelConfig(__dirname$1) };
}
function parseSourceFile(_source, _filename, babelOptions) {
  let source = _source, filename = _filename;
  filename.endsWith(".astro") ? (filename += ".ts", source = parseAstro(source)) : filename.endsWith(".vue") && (filename += ".ts", source = parseVue(source));
  const result = parse$1(source, {
    ...babelOptions,
    filename
  });
  if (!result)
    throw new Error(`Failed to parse ${filename}`);
  return result;
}
function parseAstro(source) {
  const codeFences = source.match(/---\n([\s\S]*?)\n---/g);
  return codeFences ? codeFences.map((codeFence) => codeFence.split(`
`).slice(1, -1).join(`
`)).join(`
`) : "";
}
function parseVue(source) {
  const matches = matchAllPolyfill(source, /<script(?:\s+generic=["'][^"']*["'])?[^>]*>([\s\S]*?)<\/script>/g);
  return matches.length ? matches.map((match) => match[1]).join(`
`) : "";
}
function matchAllPolyfill(str, regex) {
  if (!regex.global)
    throw new Error("matchAll polyfill requires a global regex (with /g flag)");
  const matches = [];
  let match;
  for (; (match = regex.exec(str)) !== null; )
    matches.push(match);
  return matches;
}
const debug$2 = createDebug("sanity:codegen:findQueries:debug"), TAGGED_TEMPLATE_ALLOW_LIST = ["groq"], FUNCTION_WRAPPER_ALLOW_LIST = ["defineQuery"];
function resolveExpression({
  node,
  file,
  scope,
  filename,
  resolver,
  babelConfig,
  params = [],
  fnArguments = []
}) {
  if (debug$2(
    `Resolving node ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`
  ), t.isTaggedTemplateExpression(node) && t.isIdentifier(node.tag) && TAGGED_TEMPLATE_ALLOW_LIST.includes(node.tag.name))
    return resolveExpression({
      node: node.quasi,
      scope,
      filename,
      file,
      resolver,
      params,
      babelConfig,
      fnArguments
    });
  if (t.isTemplateLiteral(node)) {
    const resolvedExpressions = node.expressions.map(
      (expression) => resolveExpression({
        node: expression,
        scope,
        filename,
        file,
        resolver,
        params,
        babelConfig,
        fnArguments
      })
    );
    return node.quasis.map((quasi, idx) => (quasi.value.cooked || "") + (resolvedExpressions[idx] || "")).join("");
  }
  if (t.isLiteral(node)) {
    if (node.type === "NullLiteral" || node.type === "RegExpLiteral")
      throw new Error(`Unsupported literal type: ${node.type}`);
    return node.value.toString();
  }
  if (t.isIdentifier(node))
    return resolveIdentifier({
      node,
      scope,
      filename,
      file,
      resolver,
      fnArguments,
      babelConfig,
      params
    });
  if (t.isVariableDeclarator(node)) {
    const init = node.init ?? (t.isAssignmentPattern(node.id) && node.id.right);
    if (!init)
      throw new Error("Unsupported variable declarator");
    return resolveExpression({
      node: init,
      fnArguments,
      scope,
      filename,
      file,
      babelConfig,
      resolver
    });
  }
  if (t.isCallExpression(node) && t.isIdentifier(node.callee) && FUNCTION_WRAPPER_ALLOW_LIST.includes(node.callee.name))
    return resolveExpression({
      node: node.arguments[0],
      scope,
      filename,
      file,
      resolver,
      babelConfig,
      params
    });
  if (t.isCallExpression(node))
    return resolveCallExpression({
      node,
      scope,
      filename,
      file,
      resolver,
      babelConfig,
      params
    });
  if (t.isArrowFunctionExpression(node) || t.isFunctionDeclaration(node) || t.isFunctionExpression(node)) {
    const newScope = new Scope(scope.path, scope);
    return params.forEach((param, i) => {
      newScope.push({
        id: param,
        init: fnArguments[i]
      });
    }), resolveExpression({
      node: node.body,
      params: node.params,
      fnArguments,
      scope: newScope,
      filename,
      file,
      babelConfig,
      resolver
    });
  }
  if (t.isNewExpression(node))
    return resolveExpression({
      node: node.callee,
      scope,
      filename,
      file,
      babelConfig,
      resolver
    });
  if (t.isImportDefaultSpecifier(node) || t.isImportSpecifier(node))
    return resolveImportSpecifier({ node, file, filename, fnArguments, resolver, babelConfig });
  if (t.isAssignmentPattern(node))
    return resolveExpression({
      node: node.right,
      scope,
      filename,
      file,
      resolver,
      params,
      babelConfig,
      fnArguments
    });
  if (t.isTSAsExpression(node))
    return resolveExpression({
      node: node.expression,
      scope,
      filename,
      file,
      resolver,
      params,
      babelConfig,
      fnArguments
    });
  throw new Error(
    `Unsupported expression type: ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`
  );
}
function resolveIdentifier({
  node,
  scope,
  filename,
  file,
  resolver,
  babelConfig,
  fnArguments,
  params
}) {
  const paramIndex = params.findIndex(
    (param) => t.isIdentifier(param) && node.name === param.name || t.isAssignmentPattern(param) && t.isIdentifier(param.left) && node.name === param.left.name
  );
  let argument = fnArguments[paramIndex];
  if (!argument && paramIndex >= 0 && t.isAssignmentPattern(params[paramIndex]) && (argument = params[paramIndex].right), argument && t.isLiteral(argument))
    return resolveExpression({
      node: argument,
      scope,
      filename,
      file,
      resolver,
      params,
      babelConfig,
      fnArguments
    });
  const binding = scope.getBinding(node.name);
  if (binding) {
    if (t.isIdentifier(binding.path.node) && binding.path.node.name === node.name)
      throw new Error(
        `Could not resolve same identifier "${node.name}" in "${filename}:${node.loc?.start.line}:${node.loc?.start.column}"`
      );
    return resolveExpression({
      node: binding.path.node,
      params,
      fnArguments,
      scope,
      filename,
      babelConfig,
      file,
      resolver
    });
  }
  throw new Error(
    `Could not find binding for node "${node.name}" in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`
  );
}
function resolveCallExpression({
  node,
  scope,
  filename,
  file,
  resolver,
  babelConfig,
  params
}) {
  const { callee } = node;
  return resolveExpression({
    node: callee,
    scope,
    filename,
    file,
    resolver,
    babelConfig,
    params,
    fnArguments: node.arguments
  });
}
function resolveImportSpecifier({
  node,
  file,
  filename,
  fnArguments,
  resolver,
  babelConfig
}) {
  let importDeclaration;
  if (traverse(file, {
    ImportDeclaration(n) {
      if (t.isImportDeclaration(n.node))
        for (const specifier of n.node.specifiers) {
          if (t.isImportDefaultSpecifier(specifier) && specifier.local.loc?.identifierName === node.local.name) {
            importDeclaration = n.node;
            break;
          }
          specifier.local.name === node.local.name && (importDeclaration = n.node);
        }
    }
  }), !importDeclaration)
    throw new Error(`Could not find import declaration for ${node.local.name}`);
  const importName = node.local.name, importFileName = importDeclaration.source.value, importPath = importFileName.startsWith("./") || importFileName.startsWith("../") ? path.resolve(path.dirname(filename), importFileName) : importFileName, resolvedFile = resolver(importPath), source = fs.readFileSync(resolvedFile), tree = parseSourceFile(source.toString(), resolvedFile, babelConfig);
  let newScope;
  if (traverse(tree, {
    Program(p) {
      newScope = p.scope;
    }
  }), !newScope)
    throw new Error(`Could not find scope for ${filename}`);
  const binding = newScope.getBinding(importName);
  if (binding)
    return resolveExpression({
      node: binding.path.node,
      file: tree,
      scope: newScope,
      fnArguments,
      babelConfig,
      filename: resolvedFile,
      resolver
    });
  let namedExport, newImportName;
  if (traverse(tree, {
    ExportDeclaration(p) {
      if (p.node.type === "ExportNamedDeclaration")
        for (const specifier of p.node.specifiers)
          specifier.type === "ExportSpecifier" && specifier.exported.type === "Identifier" && specifier.exported.name === importName && (namedExport = p.node, newImportName = specifier.exported.name);
    }
  }), namedExport && newImportName)
    return resolveExportSpecifier({
      node: namedExport,
      importName: newImportName,
      filename: resolvedFile,
      fnArguments,
      resolver,
      babelConfig
    });
  let result;
  if (traverse(tree, {
    ExportDeclaration(p) {
      if (p.node.type === "ExportAllDeclaration")
        try {
          result = resolveExportSpecifier({
            node: p.node,
            importName,
            filename: resolvedFile,
            fnArguments,
            resolver,
            babelConfig
          });
        } catch (e) {
          if (e.cause !== `noBinding:${importName}`) throw e;
        }
    }
  }), result) return result;
  throw new Error(`Could not find binding for import "${importName}" in ${importFileName}`);
}
function resolveExportSpecifier({
  node,
  importName,
  filename,
  fnArguments,
  babelConfig,
  resolver
}) {
  if (!node.source)
    throw new Error(`Could not find source for export "${importName}" in ${filename}`);
  const importFileName = node.source.value, importPath = path.resolve(path.dirname(filename), importFileName), resolvedFile = resolver(importPath), source = fs.readFileSync(resolvedFile), tree = parseSourceFile(source.toString(), resolvedFile, babelConfig);
  let newScope;
  if (traverse(tree, {
    Program(p) {
      newScope = p.scope;
    }
  }), !newScope)
    throw new Error(`Could not find scope for ${filename}`);
  const binding = newScope.getBinding(importName);
  if (binding)
    return resolveExpression({
      node: binding.path.node,
      file: tree,
      scope: newScope,
      filename: resolvedFile,
      babelConfig,
      resolver,
      fnArguments
    });
  throw new Error(`Could not find binding for export "${importName}" in ${importFileName}`, {
    cause: `noBinding:${importName}`
  });
}
const isRecord = (value) => (typeof value == "object" || typeof value == "function") && !!value;
class QueryExtractionError extends Error {
  variable;
  filename;
  constructor({ variable, cause, filename }) {
    super(
      `Error while extracting query ${variable ? `from variable '${variable.id.name}' ` : ""}in ${filename}: ${isRecord(cause) && typeof cause.message == "string" ? cause.message : "Unknown error"}`
    ), this.name = "QueryExtractionError", this.cause = cause, this.variable = variable, this.filename = filename;
  }
}
class QueryEvaluationError extends Error {
  variable;
  filename;
  constructor({ variable, cause, filename }) {
    super(
      `Error while evaluating query ${variable ? `from variable '${variable.id.name}' ` : ""}in ${filename}: ${isRecord(cause) && typeof cause.message == "string" ? cause.message : "Unknown error"}`
    ), this.name = "QueryEvaluationError", this.cause = cause, this.variable = variable, this.filename = filename;
  }
}
const require$2 = createRequire(import.meta.url), groqTagName = "groq", defineQueryFunctionName = "defineQuery", groqModuleName = "groq", nextSanityModuleName = "next-sanity", ignoreValue = "@sanity-typegen-ignore";
function findQueriesInSource(source, filename, babelConfig = getBabelConfig(), resolver = require$2.resolve) {
  const queries = [], errors = [], file = parseSourceFile(source, filename, babelConfig);
  return traverse(file, {
    // Look for variable declarations, e.g. `const myQuery = groq`... and extract the query.
    // The variable name is used as the name of the query result type
    VariableDeclarator(path2) {
      const { node, scope } = path2, init = node.init, isGroqTemplateTag = t.isTaggedTemplateExpression(init) && t.isIdentifier(init.tag) && init.tag.name === groqTagName, isDefineQueryCall = t.isCallExpression(init) && (isImportFrom(groqModuleName, defineQueryFunctionName, scope, init.callee) || isImportFrom(nextSanityModuleName, defineQueryFunctionName, scope, init.callee));
      if (t.isIdentifier(node.id) && (isGroqTemplateTag || isDefineQueryCall)) {
        if (declarationLeadingCommentContains(path2, ignoreValue))
          return;
        const { id, start, end } = node, variable = { id, ...start && { start }, ...end && { end } };
        try {
          const query = resolveExpression({
            node: init,
            file,
            scope,
            babelConfig,
            filename,
            resolver
          });
          queries.push({ variable, query, filename });
        } catch (cause) {
          errors.push(new QueryExtractionError({ filename, variable, cause }));
        }
      }
    }
  }), { filename, queries, errors };
}
function declarationLeadingCommentContains(path2, comment) {
  const variableDeclaration = path2.find((node) => node.isVariableDeclaration());
  return variableDeclaration ? !!(variableDeclaration.node.leadingComments?.find(
    (commentItem) => commentItem.value.trim() === comment
  ) || variableDeclaration.parent.leadingComments?.find(
    (commentItem) => commentItem.value.trim() === comment
  )) : !1;
}
function isImportFrom(moduleName, importName, scope, node) {
  if (t.isIdentifier(node)) {
    const binding = scope.getBinding(node.name);
    if (!binding)
      return !1;
    const { path: path2 } = binding;
    if (t.isImportSpecifier(path2.node))
      return path2.node.importKind === "value" && path2.parentPath && t.isImportDeclaration(path2.parentPath.node) && path2.parentPath.node.source.value === moduleName && t.isIdentifier(path2.node.imported) && path2.node.imported.name === importName;
    if (t.isVariableDeclarator(path2.node)) {
      const { init } = path2.node;
      return t.isCallExpression(init) && t.isIdentifier(init.callee) && init.callee.name === "require" && t.isStringLiteral(init.arguments[0]) && init.arguments[0].value === moduleName;
    }
  }
  if (t.isMemberExpression(node)) {
    const { object, property } = node;
    if (!t.isIdentifier(object))
      return !1;
    const binding = scope.getBinding(object.name);
    if (!binding)
      return !1;
    const { path: path2 } = binding;
    return t.isIdentifier(object) && t.isIdentifier(property) && property.name === importName && t.isImportNamespaceSpecifier(path2.node) && path2.parentPath && t.isImportDeclaration(path2.parentPath.node) && path2.parentPath.node.source.value === moduleName;
  }
  return !1;
}
const require$1 = createRequire(import.meta.url), debug$1 = createDebug("sanity:codegen:moduleResolver");
function getResolver(cwd) {
  const tsConfig = loadConfig(cwd);
  if (tsConfig.resultType === "failed")
    return debug$1("Could not load tsconfig, using default resolver: %s", tsConfig.message), require$1.resolve;
  const matchPath = createMatchPath(
    tsConfig.absoluteBaseUrl,
    tsConfig.paths,
    tsConfig.mainFields,
    tsConfig.addMatchAll
  ), resolve2 = function(request, options) {
    const found = matchPath(request);
    return found !== void 0 ? require$1.resolve(found, options) : require$1.resolve(request, options);
  };
  return resolve2.paths = (request) => require$1.resolve.paths(request), resolve2;
}
const debug = createDebug("sanity:codegen:findQueries:debug");
function findQueriesInPath({
  path: path2,
  babelOptions = getBabelConfig(),
  resolver = getResolver()
}) {
  const queryNames = /* @__PURE__ */ new Set();
  debug(`Globing ${path2}`);
  const files = glob.sync(path2, {
    absolute: !1,
    ignore: ["**/node_modules/**"],
    // we never want to look in node_modules
    onlyFiles: !0
  }).sort();
  async function* getQueries() {
    for (const filename of files)
      if (typeof filename == "string") {
        debug(`Found file "${filename}"`);
        try {
          const source = await fs$1.readFile(filename, "utf8"), pluckedModuleResult = findQueriesInSource(source, filename, babelOptions, resolver);
          for (const { variable } of pluckedModuleResult.queries) {
            if (queryNames.has(variable.id.name))
              throw new Error(
                `Duplicate query name found: "${variable.id.name}". Query names must be unique across all files.`
              );
            queryNames.add(variable.id.name);
          }
          yield pluckedModuleResult;
        } catch (cause) {
          debug(`Error in file "${filename}"`, cause), yield {
            filename,
            queries: [],
            errors: [new QueryExtractionError({ cause, filename })]
          };
        }
      }
  }
  return { files, queries: getQueries() };
}
function registerBabel(babelOptions) {
  const options = babelOptions || getBabelConfig();
  register({ ...options, extensions: [".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs"] });
}
function resultSuffix(variableName) {
  if (!variableName) return "result";
  const isUpperSnake = /^[A-Z0-9_]+$/.test(variableName), isSnake = /^[a-z0-9_]+$/.test(variableName) && variableName.includes("_");
  return /^[a-z][A-Za-z0-9]*$/.test(variableName) ? `${variableName}Result` : isUpperSnake ? `${variableName}_RESULT` : isSnake ? `${variableName}_result` : `${variableName.replace(/[^A-Za-z0-9]/g, "")}Result`;
}
const INTERNAL_REFERENCE_SYMBOL = t.identifier("internalGroqTypeReferenceTo"), ALL_SANITY_SCHEMA_TYPES = t.identifier("AllSanitySchemaTypes"), SANITY_QUERIES = t.identifier("SanityQueries"), RESERVED_IDENTIFIERS = /* @__PURE__ */ new Set();
RESERVED_IDENTIFIERS.add(SANITY_QUERIES.name);
RESERVED_IDENTIFIERS.add(ALL_SANITY_SCHEMA_TYPES.name);
RESERVED_IDENTIFIERS.add(INTERNAL_REFERENCE_SYMBOL.name);
function normalizePath(root, filename) {
  const resolved = path.resolve(root, filename);
  return path.relative(root, resolved);
}
function sanitizeIdentifier(input) {
  return `${input.replace(/^\d/, "_").replace(/[^$\w]+(.)/g, (_, char) => char.toUpperCase())}`;
}
function normalizeIdentifier(input) {
  const sanitized = sanitizeIdentifier(input);
  return `${sanitized.charAt(0).toUpperCase()}${sanitized.slice(1)}`;
}
function getUniqueIdentifierForName(name, currentIdentifiers) {
  const desiredName = normalizeIdentifier(name);
  let resultingName = desiredName, index = 2;
  for (; currentIdentifiers.has(resultingName) || RESERVED_IDENTIFIERS.has(resultingName); )
    resultingName = `${desiredName}_${index}`, index++;
  return t.identifier(resultingName);
}
function computeOnce(fn) {
  const ref = { current: void 0, computed: !1 };
  return function() {
    return ref.computed || (ref.current = fn(), ref.computed = !0), ref.current;
  };
}
function weakMapMemo(fn) {
  const cache = /* @__PURE__ */ new WeakMap();
  return function(arg) {
    if (cache.has(arg)) return cache.get(arg);
    const result = fn(arg);
    return cache.set(arg, result), result;
  };
}
function generateCode(node) {
  return `${new CodeGenerator(node).generate().code.trim()}

`;
}
class SchemaTypeGenerator {
  schema;
  tsTypes = /* @__PURE__ */ new Map();
  identifiers = /* @__PURE__ */ new Map();
  constructor(schema) {
    this.schema = schema;
    const uniqueTypeNames = /* @__PURE__ */ new Set();
    for (const type of schema) {
      if (uniqueTypeNames.has(type.name))
        throw new Error(
          `Duplicate type name "${type.name}" in schema. Type names must be unique within the same schema.`
        );
      uniqueTypeNames.add(type.name);
    }
    for (const type of schema) {
      const currentIdentifierNames = new Set(
        Array.from(this.identifiers.values()).map((id) => id.name)
      ), uniqueIdentifier = getUniqueIdentifierForName(type.name, currentIdentifierNames);
      this.identifiers.set(type.name, uniqueIdentifier);
    }
    for (const type of schema)
      this.tsTypes.set(type.name, this.generateTsType(type));
  }
  generateTsType(typeNode) {
    switch (typeNode.type) {
      case "string":
        return typeNode.value !== void 0 ? t.tsLiteralType(t.stringLiteral(typeNode.value)) : t.tsStringKeyword();
      case "number":
        return typeNode.value !== void 0 ? t.tsLiteralType(t.numericLiteral(typeNode.value)) : t.tsNumberKeyword();
      case "boolean":
        return typeNode.value !== void 0 ? t.tsLiteralType(t.booleanLiteral(typeNode.value)) : t.tsBooleanKeyword();
      case "unknown":
        return t.tsUnknownKeyword();
      case "document":
        return this.generateDocumentTsType(typeNode);
      case "type":
        return this.generateTsType(typeNode.value);
      case "array":
        return this.generateArrayTsType(typeNode);
      case "object":
        return this.generateObjectTsType(typeNode);
      case "union":
        return this.generateUnionTsType(typeNode);
      case "inline":
        return this.generateInlineTsType(typeNode);
      case "null":
        return t.tsNullKeyword();
      default:
        throw new Error(
          `Encountered unsupported node type "${// @ts-expect-error This should never happen
          typeNode.type}" while generating schema types`
        );
    }
  }
  // Helper function used to generate TS types for array type nodes.
  generateArrayTsType(typeNode) {
    const typeNodes = this.generateTsType(typeNode.of);
    return t.tsTypeReference(t.identifier("Array"), t.tsTypeParameterInstantiation([typeNodes]));
  }
  // Helper function used to generate TS types for object properties.
  generateTsObjectProperty(key, attribute) {
    const type = this.generateTsType(attribute.value), propertySignature = t.tsPropertySignature(
      t.identifier(sanitizeIdentifier(key)),
      t.tsTypeAnnotation(type)
    );
    return propertySignature.optional = attribute.optional, propertySignature;
  }
  // Helper function used to generate TS types for object type nodes.
  generateObjectTsType(typeNode) {
    const props = [];
    Object.entries(typeNode.attributes).forEach(([key, attribute]) => {
      props.push(this.generateTsObjectProperty(key, attribute));
    });
    const rest = typeNode.rest;
    if (rest)
      switch (rest.type) {
        case "unknown":
          return t.tsUnknownKeyword();
        case "object": {
          Object.entries(rest.attributes).forEach(([key, attribute]) => {
            props.push(this.generateTsObjectProperty(key, attribute));
          });
          break;
        }
        case "inline": {
          const resolved = this.generateInlineTsType(rest);
          return t.isTSUnknownKeyword(resolved) ? resolved : t.tsIntersectionType([t.tsTypeLiteral(props), resolved]);
        }
        default:
          throw new Error(`Type "${rest.type}" not found in schema`);
      }
    if (typeNode.dereferencesTo) {
      const derefType = Object.assign(
        t.tsPropertySignature(
          INTERNAL_REFERENCE_SYMBOL,
          t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(typeNode.dereferencesTo)))
        ),
        { computed: !0, optional: !0 }
      );
      props.push(derefType);
    }
    return t.tsTypeLiteral(props);
  }
  generateInlineTsType(typeNode) {
    const id = this.identifiers.get(typeNode.name);
    return id ? t.tsTypeReference(id) : t.addComment(
      t.tsUnknownKeyword(),
      "trailing",
      ` Unable to locate the referenced type "${typeNode.name}" in schema`,
      !0
    );
  }
  // Helper function used to generate TS types for union type nodes.
  generateUnionTsType(typeNode) {
    return typeNode.of.length === 0 ? t.tsNeverKeyword() : typeNode.of.length === 1 ? this.generateTsType(typeNode.of[0]) : t.tsUnionType(typeNode.of.map((node) => this.generateTsType(node)));
  }
  // Helper function used to generate TS types for document type nodes.
  generateDocumentTsType(document) {
    const props = Object.entries(document.attributes).map(
      ([key, node]) => this.generateTsObjectProperty(key, node)
    );
    return t.tsTypeLiteral(props);
  }
  typeNames() {
    return this.schema.map((schemaType) => schemaType.name);
  }
  getType(typeName) {
    const tsType = this.tsTypes.get(typeName), id = this.identifiers.get(typeName);
    if (tsType && id) return { tsType, id };
  }
  hasType(typeName) {
    return this.tsTypes.has(typeName);
  }
  evaluateQuery = weakMapMemo(
    ({ query }) => {
      const ast = safeParseQuery(query), typeNode = typeEvaluate(ast, this.schema), tsType = this.generateTsType(typeNode), stats = walkAndCountQueryTypeNodeStats(typeNode);
      return { tsType, stats };
    }
  );
  *[Symbol.iterator]() {
    for (const { name } of this.schema)
      yield { name, ...this.getType(name) };
  }
}
function walkAndCountQueryTypeNodeStats(typeNode) {
  switch (typeNode.type) {
    case "unknown":
      return { allTypes: 1, unknownTypes: 1, emptyUnions: 0 };
    case "array": {
      const acc = walkAndCountQueryTypeNodeStats(typeNode.of);
      return acc.allTypes += 1, acc;
    }
    case "object": {
      if (typeNode.rest && typeNode.rest.type === "unknown")
        return { allTypes: 2, unknownTypes: 1, emptyUnions: 0 };
      const restStats = typeNode.rest ? walkAndCountQueryTypeNodeStats(typeNode.rest) : { allTypes: 0, unknownTypes: 0, emptyUnions: 0 };
      return restStats.allTypes += 1, Object.values(typeNode.attributes).reduce((acc, attribute) => {
        const { allTypes, unknownTypes, emptyUnions } = walkAndCountQueryTypeNodeStats(
          attribute.value
        );
        return {
          allTypes: acc.allTypes + allTypes,
          unknownTypes: acc.unknownTypes + unknownTypes,
          emptyUnions: acc.emptyUnions + emptyUnions
        };
      }, restStats);
    }
    case "union":
      return typeNode.of.length === 0 ? { allTypes: 1, unknownTypes: 0, emptyUnions: 1 } : typeNode.of.reduce(
        (acc, type) => {
          const { allTypes, unknownTypes, emptyUnions } = walkAndCountQueryTypeNodeStats(type);
          return {
            allTypes: acc.allTypes + allTypes,
            unknownTypes: acc.unknownTypes + unknownTypes,
            emptyUnions: acc.emptyUnions + emptyUnions
          };
        },
        { allTypes: 1, unknownTypes: 0, emptyUnions: 0 }
        // count the union type itself
      );
    default:
      return { allTypes: 1, unknownTypes: 0, emptyUnions: 0 };
  }
}
class TypeGenerator {
  getInternalReferenceSymbolDeclaration = computeOnce(() => {
    const typeOperator = t.tsTypeOperator(t.tsSymbolKeyword(), "unique"), id = INTERNAL_REFERENCE_SYMBOL;
    id.typeAnnotation = t.tsTypeAnnotation(typeOperator);
    const declaration = t.variableDeclaration("const", [t.variableDeclarator(id)]);
    declaration.declare = !0;
    const ast = t.exportNamedDeclaration(declaration), code = generateCode(ast);
    return { id, code, ast };
  });
  getSchemaTypeGenerator = createSelector(
    [(options) => options.schema],
    (schema) => new SchemaTypeGenerator(schema)
  );
  getSchemaTypeDeclarations = createSelector(
    [
      (options) => options.root,
      (options) => options.schemaPath,
      this.getSchemaTypeGenerator
    ],
    (root = process.cwd(), schemaPath, schema) => Array.from(schema).map(({ id, name, tsType }, index) => {
      const typeAlias = t.tsTypeAliasDeclaration(id, null, tsType);
      let ast = t.exportNamedDeclaration(typeAlias);
      index === 0 && schemaPath && (ast = t.addComments(ast, "leading", [
        { type: "CommentLine", value: ` Source: ${normalizePath(root, schemaPath)}` }
      ]));
      const code = generateCode(ast);
      return { id, code, name, tsType, ast };
    })
  );
  getAllSanitySchemaTypesDeclaration = createSelector(
    [this.getSchemaTypeDeclarations],
    (schemaTypes) => {
      const ast = t.exportNamedDeclaration(
        t.tsTypeAliasDeclaration(
          ALL_SANITY_SCHEMA_TYPES,
          null,
          schemaTypes.length ? t.tsUnionType(schemaTypes.map(({ id }) => t.tsTypeReference(id))) : t.tsNeverKeyword()
        )
      ), code = generateCode(ast);
      return { id: ALL_SANITY_SCHEMA_TYPES, code, ast };
    }
  );
  static async getEvaluatedModules({
    root = process.cwd(),
    reporter: report,
    schemaTypeGenerator,
    schemaTypeDeclarations,
    queries: extractedModules
  }) {
    if (!extractedModules)
      return report?.stream.evaluatedModules.end(), [];
    const currentIdentifiers = new Set(schemaTypeDeclarations.map(({ id }) => id.name)), evaluatedModuleResults = [];
    for await (const { filename, ...extractedModule } of extractedModules) {
      const queries = [], errors = [...extractedModule.errors];
      for (const extractedQuery of extractedModule.queries) {
        const { variable } = extractedQuery;
        try {
          const { tsType, stats } = schemaTypeGenerator.evaluateQuery(extractedQuery), id = getUniqueIdentifierForName(resultSuffix(variable.id.name), currentIdentifiers), typeAlias = t.tsTypeAliasDeclaration(id, null, tsType), trimmedQuery = extractedQuery.query.replace(/(\r\n|\n|\r)/gm, "").trim(), ast = t.addComments(t.exportNamedDeclaration(typeAlias), "leading", [
            { type: "CommentLine", value: ` Source: ${normalizePath(root, filename)}` },
            { type: "CommentLine", value: ` Variable: ${variable.id.name}` },
            { type: "CommentLine", value: ` Query: ${trimmedQuery}` }
          ]), evaluatedQueryResult = {
            id,
            code: generateCode(ast),
            ast,
            stats,
            tsType,
            ...extractedQuery
          };
          currentIdentifiers.add(id.name), queries.push(evaluatedQueryResult);
        } catch (cause) {
          errors.push(new QueryEvaluationError({ variable, cause, filename }));
        }
      }
      const evaluatedModule = {
        filename,
        queries,
        errors
      };
      report?.stream.evaluatedModules.emit(evaluatedModule), evaluatedModuleResults.push(evaluatedModule);
    }
    return report?.stream.evaluatedModules.end(), evaluatedModuleResults;
  }
  static async getQueryMapDeclaration({
    overloadClientMethods = !0,
    evaluatedModules
  }) {
    if (!overloadClientMethods) return { code: "", ast: t.program([]) };
    const queries = evaluatedModules.flatMap((module) => module.queries);
    if (!queries.length) return { code: "", ast: t.program([]) };
    const typesByQuerystring = {};
    for (const { id, query } of queries)
      typesByQuerystring[query] ??= [], typesByQuerystring[query].push(id.name);
    const queryReturnInterface = t.tsInterfaceDeclaration(
      SANITY_QUERIES,
      null,
      [],
      t.tsInterfaceBody(
        Object.entries(typesByQuerystring).map(([query, types]) => t.tsPropertySignature(
          t.stringLiteral(query),
          t.tsTypeAnnotation(
            types.length ? t.tsUnionType(types.map((type) => t.tsTypeReference(t.identifier(type)))) : t.tsNeverKeyword()
          )
        ))
      )
    ), declareModule = t.declareModule(
      t.stringLiteral("@sanity/client"),
      t.blockStatement([queryReturnInterface])
    ), clientImport = t.addComments(
      t.importDeclaration([], t.stringLiteral("@sanity/client")),
      "leading",
      [{ type: "CommentLine", value: " Query TypeMap" }]
    ), ast = t.program([clientImport, declareModule]);
    return { code: generateCode(ast), ast };
  }
  async generateTypes(options) {
    const { reporter: report } = options, internalReferenceSymbol = this.getInternalReferenceSymbolDeclaration(), schemaTypeDeclarations = this.getSchemaTypeDeclarations(options), allSanitySchemaTypesDeclaration = this.getAllSanitySchemaTypesDeclaration(options);
    report?.event.generatedSchemaTypes({
      internalReferenceSymbol,
      schemaTypeDeclarations,
      allSanitySchemaTypesDeclaration
    });
    const program = t.program([]);
    let code = "";
    for (const declaration of schemaTypeDeclarations)
      program.body.push(declaration.ast), code += declaration.code;
    program.body.push(allSanitySchemaTypesDeclaration.ast), code += allSanitySchemaTypesDeclaration.code, program.body.push(internalReferenceSymbol.ast), code += internalReferenceSymbol.code;
    const evaluatedModules = await TypeGenerator.getEvaluatedModules({
      ...options,
      schemaTypeDeclarations,
      schemaTypeGenerator: this.getSchemaTypeGenerator(options)
    });
    for (const { queries } of evaluatedModules)
      for (const query of queries)
        program.body.push(query.ast), code += query.code;
    const queryMapDeclaration = await TypeGenerator.getQueryMapDeclaration({
      ...options,
      evaluatedModules
    });
    return program.body.push(...queryMapDeclaration.ast.body), code += queryMapDeclaration.code, report?.event.generatedQueryTypes({ queryMapDeclaration }), { code, ast: program };
  }
}
export {
  QueryExtractionError,
  TypeGenerator,
  configDefinition,
  findQueriesInPath,
  findQueriesInSource,
  getResolver,
  readConfig,
  readSchema,
  registerBabel,
  safeParseQuery
};
//# sourceMappingURL=index.js.map
