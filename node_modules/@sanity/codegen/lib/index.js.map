{"version":3,"file":"index.js","sources":["../src/readConfig.ts","../src/readSchema.ts","../src/safeParseQuery.ts","../src/getBabelConfig.ts","../src/typescript/parseSource.ts","../src/typescript/expressionResolvers.ts","../src/typescript/types.ts","../src/typescript/findQueriesInSource.ts","../src/typescript/moduleResolver.ts","../src/typescript/findQueriesInPath.ts","../src/typescript/registerBabel.ts","../src/casing.ts","../src/typescript/constants.ts","../src/typescript/helpers.ts","../src/typescript/schemaTypeGenerator.ts","../src/typescript/typeGenerator.ts"],"sourcesContent":["import {readFile} from 'node:fs/promises'\n\nimport json5 from 'json5'\nimport * as z from 'zod'\n\n/**\n * @internal\n */\nexport const configDefinition = z.object({\n  path: z\n    .string()\n    .or(z.array(z.string()))\n    .default([\n      './src/**/*.{ts,tsx,js,jsx,mjs,cjs,astro}',\n      './app/**/*.{ts,tsx,js,jsx,mjs,cjs}',\n      './sanity/**/*.{ts,tsx,js,jsx,mjs,cjs}',\n    ]),\n  schema: z.string().default('./schema.json'),\n  generates: z.string().default('./sanity.types.ts'),\n  formatGeneratedCode: z.boolean().default(true),\n  overloadClientMethods: z.boolean().default(true),\n})\n\nexport type TypeGenConfig = z.infer<typeof configDefinition>\n\n/**\n * @deprecated use TypeGenConfig\n */\nexport type CodegenConfig = TypeGenConfig\n\n/**\n * Read, parse and process a config file\n * @internal\n */\nexport async function readConfig(path: string): Promise<TypeGenConfig> {\n  try {\n    const content = await readFile(path, 'utf-8')\n    const json = json5.parse(content)\n    return configDefinition.parseAsync(json)\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new Error(\n        `Error in config file\\n ${error.errors.map((err) => err.message).join('\\n')}`,\n        {cause: error},\n      )\n    }\n    if (typeof error === 'object' && error !== null && 'code' in error && error.code === 'ENOENT') {\n      return configDefinition.parse({})\n    }\n\n    throw error\n  }\n}\n","import {readFile} from 'node:fs/promises'\n\nimport {type SchemaType} from 'groq-js'\n\n/**\n * Read a schema from a given path\n * @param path - The path to the schema\n * @returns The schema\n * @internal\n * @beta\n **/\nexport async function readSchema(path: string): Promise<SchemaType> {\n  const content = await readFile(path, 'utf-8')\n  return JSON.parse(content) // todo: ZOD validation?\n}\n","import {parse} from 'groq-js'\n\n/**\n * safeParseQuery parses a GROQ query string, but first attempts to extract any parameters used in slices. This method is _only_\n * intended for use in type generation where we don't actually execute the parsed AST on a dataset, and should not be used elsewhere.\n * @internal\n */\nexport function safeParseQuery(query: string) {\n  const params: Record<string, unknown> = {}\n\n  for (const param of extractSliceParams(query)) {\n    params[param] = 0 // we don't care about the value, just the type\n  }\n  return parse(query, {params})\n}\n\n/**\n * Finds occurences of `[($start|{number})..($end|{number})]` in a query string and returns the start and end values, and return\n * the names of the start and end variables.\n * @internal\n */\nexport function* extractSliceParams(query: string): Generator<string> {\n  const sliceRegex = /\\[(\\$(\\w+)|\\d)\\.\\.\\.?(\\$(\\w+)|\\d)\\]/g\n  const matches = query.matchAll(sliceRegex)\n  if (!matches) {\n    return\n  }\n  const params = new Set<string>()\n  for (const match of matches) {\n    const start = match[1] === `$${match[2]}` ? match[2] : null\n    if (start !== null) {\n      yield start\n    }\n    const end = match[3] === `$${match[4]}` ? match[4] : null\n    if (end !== null) {\n      yield end\n    }\n  }\n}\n","import {existsSync} from 'node:fs'\nimport {dirname, join, resolve} from 'node:path'\nimport {fileURLToPath} from 'node:url'\n\nimport {type TransformOptions} from '@babel/core'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\n\n/**\n * Because of bundlers and compilers, knowing the exact path the babel configuration will be\n * located at post - build is not always trivial. We traverse from the current directory upwards\n * until we find the first `babel.config.json` and use that path.\n *\n * @param path - The path to start looking for the babel configuration\n * @returns The path to the `babel.config.json` file\n * @internal\n */\nexport function findBabelConfig(path: string): string {\n  const configPath = join(path, 'babel.config.json')\n  if (existsSync(configPath)) {\n    return configPath\n  }\n\n  const parent = resolve(join(path, '..'))\n  if (parent && parent !== path) {\n    return findBabelConfig(parent)\n  }\n\n  throw new Error('Could not find `babel.config.json` in @sanity/codegen')\n}\n\n/**\n * Get the default babel configuration for `@sanity/codegen`\n *\n * @param path - The path to start looking for the babel configuration. Defaults to `__dirname`\n * @returns A babel configuration object\n * @internal\n */\nexport function getBabelConfig(path?: string): TransformOptions {\n  const configPath = findBabelConfig(path || __dirname)\n  return {extends: configPath}\n}\n","import {parse, type TransformOptions} from '@babel/core'\nimport type * as babelTypes from '@babel/types'\n\n// helper function to parse a source file\nexport function parseSourceFile(\n  _source: string,\n  _filename: string,\n  babelOptions: TransformOptions,\n): babelTypes.File {\n  let source = _source\n  let filename = _filename\n  if (filename.endsWith('.astro')) {\n    // append .ts to the filename so babel will parse it as typescript\n    filename += '.ts'\n    source = parseAstro(source)\n  } else if (filename.endsWith('.vue')) {\n    // append .ts to the filename so babel will parse it as typescript\n    filename += '.ts'\n    source = parseVue(source)\n  }\n  const result = parse(source, {\n    ...babelOptions,\n    filename,\n  })\n\n  if (!result) {\n    throw new Error(`Failed to parse ${filename}`)\n  }\n\n  return result\n}\n\nfunction parseAstro(source: string): string {\n  // find all code fences, the js code is between --- and ---\n  const codeFences = source.match(/---\\n([\\s\\S]*?)\\n---/g)\n  if (!codeFences) {\n    return ''\n  }\n\n  return codeFences\n    .map((codeFence) => {\n      return codeFence.split('\\n').slice(1, -1).join('\\n')\n    })\n    .join('\\n')\n}\n\nfunction parseVue(source: string): string {\n  // find all script tags, the js code is between <script> and </script>\n  const scriptRegex = /<script(?:\\s+generic=[\"'][^\"']*[\"'])?[^>]*>([\\s\\S]*?)<\\/script>/g\n  // const matches = [...source.matchAll(scriptRegex)]\n  // TODO: swap once this code runs in `ES2020`\n  const matches = matchAllPolyfill(source, scriptRegex)\n  if (!matches.length) {\n    return ''\n  }\n\n  return matches.map((match) => match[1]).join('\\n')\n}\n\n// TODO: remove once this code runs in `ES2020`\nfunction matchAllPolyfill(str: string, regex: RegExp): RegExpMatchArray[] {\n  if (!regex.global) {\n    throw new Error('matchAll polyfill requires a global regex (with /g flag)')\n  }\n\n  const matches = []\n  let match\n  while ((match = regex.exec(str)) !== null) {\n    matches.push(match)\n  }\n  return matches\n}\n","import fs from 'node:fs'\nimport path from 'node:path'\n\nimport {type TransformOptions, traverse} from '@babel/core'\nimport {Scope} from '@babel/traverse'\nimport * as babelTypes from '@babel/types'\nimport createDebug from 'debug'\n\nimport {parseSourceFile} from './parseSource'\n\nconst debug = createDebug('sanity:codegen:findQueries:debug')\n\ntype resolveExpressionReturnType = string\n\nconst TAGGED_TEMPLATE_ALLOW_LIST = ['groq']\nconst FUNCTION_WRAPPER_ALLOW_LIST = ['defineQuery']\n\n/**\n * resolveExpression takes a node and returns the resolved value of the expression.\n * @beta\n * @internal\n */\nexport function resolveExpression({\n  node,\n  file,\n  scope,\n  filename,\n  resolver,\n  babelConfig,\n  params = [],\n  fnArguments = [],\n}: {\n  node: babelTypes.Node\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n  params?: babelTypes.Node[]\n  fnArguments?: babelTypes.Node[]\n}): resolveExpressionReturnType {\n  debug(\n    `Resolving node ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n  if (\n    babelTypes.isTaggedTemplateExpression(node) &&\n    babelTypes.isIdentifier(node.tag) &&\n    TAGGED_TEMPLATE_ALLOW_LIST.includes(node.tag.name)\n  ) {\n    return resolveExpression({\n      node: node.quasi,\n      scope,\n      filename,\n      file,\n      resolver,\n      params,\n      babelConfig,\n      fnArguments,\n    })\n  }\n\n  if (babelTypes.isTemplateLiteral(node)) {\n    const resolvedExpressions = node.expressions.map((expression) =>\n      resolveExpression({\n        node: expression,\n        scope,\n        filename,\n        file,\n        resolver,\n        params,\n        babelConfig,\n        fnArguments,\n      }),\n    )\n    return node.quasis\n      .map((quasi, idx) => {\n        return (quasi.value.cooked || '') + (resolvedExpressions[idx] || '')\n      })\n      .join('')\n  }\n\n  if (babelTypes.isLiteral(node)) {\n    if (node.type === 'NullLiteral' || node.type === 'RegExpLiteral') {\n      throw new Error(`Unsupported literal type: ${node.type}`)\n    }\n\n    return node.value.toString()\n  }\n\n  if (babelTypes.isIdentifier(node)) {\n    return resolveIdentifier({\n      node,\n      scope,\n      filename,\n      file,\n      resolver,\n      fnArguments,\n      babelConfig,\n      params,\n    })\n  }\n\n  if (babelTypes.isVariableDeclarator(node)) {\n    const init = node.init ?? (babelTypes.isAssignmentPattern(node.id) && node.id.right)\n    if (!init) {\n      throw new Error(`Unsupported variable declarator`)\n    }\n\n    return resolveExpression({\n      node: init,\n      fnArguments,\n      scope,\n      filename,\n      file,\n      babelConfig,\n      resolver,\n    })\n  }\n\n  if (\n    babelTypes.isCallExpression(node) &&\n    babelTypes.isIdentifier(node.callee) &&\n    FUNCTION_WRAPPER_ALLOW_LIST.includes(node.callee.name)\n  ) {\n    return resolveExpression({\n      node: node.arguments[0],\n      scope,\n      filename,\n      file,\n      resolver,\n      babelConfig,\n      params,\n    })\n  }\n\n  if (babelTypes.isCallExpression(node)) {\n    return resolveCallExpression({\n      node,\n      scope,\n      filename,\n      file,\n      resolver,\n      babelConfig,\n      params,\n      fnArguments,\n    })\n  }\n\n  if (\n    babelTypes.isArrowFunctionExpression(node) ||\n    babelTypes.isFunctionDeclaration(node) ||\n    babelTypes.isFunctionExpression(node)\n  ) {\n    const newScope = new Scope(scope.path, scope)\n\n    params.forEach((param, i) => {\n      newScope.push({\n        id: param as babelTypes.LVal,\n        init: fnArguments[i] as babelTypes.Expression | undefined,\n      })\n    })\n\n    return resolveExpression({\n      node: node.body,\n      params: node.params,\n      fnArguments,\n      scope: newScope,\n      filename,\n      file,\n      babelConfig,\n      resolver,\n    })\n  }\n\n  if (babelTypes.isNewExpression(node)) {\n    return resolveExpression({\n      node: node.callee,\n      scope,\n      filename,\n      file,\n      babelConfig,\n      resolver,\n    })\n  }\n\n  if (babelTypes.isImportDefaultSpecifier(node) || babelTypes.isImportSpecifier(node)) {\n    return resolveImportSpecifier({node, file, scope, filename, fnArguments, resolver, babelConfig})\n  }\n\n  if (babelTypes.isAssignmentPattern(node)) {\n    return resolveExpression({\n      node: node.right,\n      scope,\n      filename,\n      file,\n      resolver,\n      params,\n      babelConfig,\n      fnArguments,\n    })\n  }\n\n  // Handle TypeScript type assertions (e.g., `'foo' as string`)\n  if (babelTypes.isTSAsExpression(node)) {\n    return resolveExpression({\n      node: node.expression,\n      scope,\n      filename,\n      file,\n      resolver,\n      params,\n      babelConfig,\n      fnArguments,\n    })\n  }\n\n  throw new Error(\n    `Unsupported expression type: ${node.type} in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveIdentifier({\n  node,\n  scope,\n  filename,\n  file,\n  resolver,\n  babelConfig,\n  fnArguments,\n  params,\n}: {\n  node: babelTypes.Identifier\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n  fnArguments: babelTypes.Node[]\n  params: babelTypes.Node[]\n}): resolveExpressionReturnType {\n  const paramIndex = params.findIndex(\n    (param) =>\n      (babelTypes.isIdentifier(param) && node.name === param.name) ||\n      (babelTypes.isAssignmentPattern(param) &&\n        babelTypes.isIdentifier(param.left) &&\n        node.name === param.left.name),\n  )\n  let argument = fnArguments[paramIndex]\n  if (!argument && paramIndex >= 0 && babelTypes.isAssignmentPattern(params[paramIndex])) {\n    argument = params[paramIndex].right\n  }\n  if (argument && babelTypes.isLiteral(argument)) {\n    return resolveExpression({\n      node: argument,\n      scope,\n      filename,\n      file,\n      resolver,\n      params,\n      babelConfig,\n      fnArguments,\n    })\n  }\n  const binding = scope.getBinding(node.name)\n  if (binding) {\n    if (babelTypes.isIdentifier(binding.path.node)) {\n      const isSame = binding.path.node.name === node.name\n      if (isSame) {\n        throw new Error(\n          `Could not resolve same identifier \"${node.name}\" in \"${filename}:${node.loc?.start.line}:${node.loc?.start.column}\"`,\n        )\n      }\n    }\n    return resolveExpression({\n      node: binding.path.node,\n      params,\n      fnArguments,\n      scope,\n      filename,\n      babelConfig,\n      file,\n      resolver,\n    })\n  }\n\n  throw new Error(\n    `Could not find binding for node \"${node.name}\" in ${filename}:${node.loc?.start.line}:${node.loc?.start.column}`,\n  )\n}\n\nfunction resolveCallExpression({\n  node,\n  scope,\n  filename,\n  file,\n  resolver,\n  babelConfig,\n  params,\n}: {\n  node: babelTypes.CallExpression\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n  fnArguments: babelTypes.Node[]\n  params: babelTypes.Node[]\n}): resolveExpressionReturnType {\n  const {callee} = node\n  return resolveExpression({\n    node: callee,\n    scope,\n    filename,\n    file,\n    resolver,\n    babelConfig,\n    params,\n    fnArguments: node.arguments,\n  })\n}\n\nfunction resolveImportSpecifier({\n  node,\n  file,\n  filename,\n  fnArguments,\n  resolver,\n  babelConfig,\n}: {\n  node: babelTypes.ImportDefaultSpecifier | babelTypes.ImportSpecifier | babelTypes.ExportSpecifier\n  file: babelTypes.File\n  scope: Scope\n  filename: string\n  fnArguments: babelTypes.Node[]\n  resolver: NodeJS.RequireResolve\n  babelConfig: TransformOptions\n}): resolveExpressionReturnType {\n  let importDeclaration: babelTypes.ImportDeclaration | undefined\n  traverse(file, {\n    ImportDeclaration(n) {\n      if (!babelTypes.isImportDeclaration(n.node)) {\n        return\n      }\n      for (const specifier of n.node.specifiers) {\n        if (babelTypes.isImportDefaultSpecifier(specifier)) {\n          if (specifier.local.loc?.identifierName === node.local.name) {\n            importDeclaration = n.node\n            break\n          }\n        }\n        if (specifier.local.name === node.local.name) {\n          importDeclaration = n.node\n        }\n      }\n    },\n  })\n\n  if (!importDeclaration) {\n    throw new Error(`Could not find import declaration for ${node.local.name}`)\n  }\n\n  const importName = node.local.name // the name of the variable to import\n  const importFileName = importDeclaration.source.value // the file to import from\n\n  const importPath =\n    importFileName.startsWith('./') || importFileName.startsWith('../')\n      ? path.resolve(path.dirname(filename), importFileName)\n      : importFileName\n\n  const resolvedFile = resolver(importPath)\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let newScope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      newScope = p.scope\n    },\n  })\n  if (!newScope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = newScope.getBinding(importName)\n  if (binding) {\n    return resolveExpression({\n      node: binding.path.node,\n      file: tree,\n      scope: newScope,\n      fnArguments,\n      babelConfig,\n      filename: resolvedFile,\n      resolver,\n    })\n  }\n\n  // It's not a global binding, but it might be a named export\n  let namedExport: babelTypes.ExportNamedDeclaration | undefined\n  let newImportName: string | undefined\n  traverse(tree, {\n    ExportDeclaration(p) {\n      if (p.node.type === 'ExportNamedDeclaration') {\n        for (const specifier of p.node.specifiers) {\n          if (\n            specifier.type === 'ExportSpecifier' &&\n            specifier.exported.type === 'Identifier' &&\n            specifier.exported.name === importName\n          ) {\n            namedExport = p.node\n            newImportName = specifier.exported.name\n          }\n        }\n      }\n    },\n  })\n\n  if (namedExport && newImportName) {\n    return resolveExportSpecifier({\n      node: namedExport,\n      importName: newImportName,\n      filename: resolvedFile,\n      fnArguments,\n      resolver,\n      babelConfig,\n    })\n  }\n\n  let result: resolveExpressionReturnType | undefined\n  traverse(tree, {\n    ExportDeclaration(p) {\n      if (p.node.type === 'ExportAllDeclaration') {\n        try {\n          result = resolveExportSpecifier({\n            node: p.node,\n            importName,\n            filename: resolvedFile,\n            fnArguments,\n            resolver,\n            babelConfig,\n          })\n        } catch (e) {\n          if (e.cause !== `noBinding:${importName}`) throw e\n        }\n      }\n    },\n  })\n  if (result) return result\n\n  throw new Error(`Could not find binding for import \"${importName}\" in ${importFileName}`)\n}\n\nfunction resolveExportSpecifier({\n  node,\n  importName,\n  filename,\n  fnArguments,\n  babelConfig,\n  resolver,\n}: {\n  node: babelTypes.ExportNamedDeclaration | babelTypes.ExportAllDeclaration\n  importName: string\n  filename: string\n  fnArguments: babelTypes.Node[]\n  babelConfig: TransformOptions\n  resolver: NodeJS.RequireResolve\n}): resolveExpressionReturnType {\n  if (!node.source) {\n    throw new Error(`Could not find source for export \"${importName}\" in ${filename}`)\n  }\n\n  const importFileName = node.source.value\n  const importPath = path.resolve(path.dirname(filename), importFileName)\n  const resolvedFile = resolver(importPath)\n  const source = fs.readFileSync(resolvedFile)\n  const tree = parseSourceFile(source.toString(), resolvedFile, babelConfig)\n\n  let newScope: Scope | undefined\n  traverse(tree, {\n    Program(p) {\n      newScope = p.scope\n    },\n  })\n  if (!newScope) {\n    throw new Error(`Could not find scope for ${filename}`)\n  }\n\n  const binding = newScope.getBinding(importName)\n  if (binding) {\n    return resolveExpression({\n      node: binding.path.node,\n      file: tree,\n      scope: newScope,\n      filename: resolvedFile,\n      babelConfig,\n      resolver,\n      fnArguments,\n    })\n  }\n\n  throw new Error(`Could not find binding for export \"${importName}\" in ${importFileName}`, {\n    cause: `noBinding:${importName}`,\n  })\n}\n","import type * as t from '@babel/types'\n\nconst isRecord = (value: unknown): value is Record<string, unknown> =>\n  (typeof value === 'object' || typeof value === 'function') && !!value\n\n/**\n * Statistics from the query type evaluation process.\n * @public\n */\nexport interface TypeEvaluationStats {\n  allTypes: number\n  unknownTypes: number\n  emptyUnions: number\n}\n\ninterface QueryVariable {\n  id: t.Identifier\n  start?: number\n  end?: number\n}\n\n/**\n * A GROQ query extracted from a source file.\n * @public\n */\nexport interface ExtractedQuery {\n  variable: QueryVariable\n  query: string\n  filename: string\n}\n\n/**\n * A module (file) containing extracted GROQ queries.\n * @public\n */\nexport interface ExtractedModule {\n  filename: string\n  queries: ExtractedQuery[]\n  errors: QueryExtractionError[]\n}\n\n/**\n * An `ExtractedQuery` that has been evaluated against a schema, yielding a TypeScript type.\n * @public\n */\nexport interface EvaluatedQuery extends ExtractedQuery {\n  id: t.Identifier\n  code: string\n  tsType: t.TSType\n  ast: t.ExportNamedDeclaration\n  stats: TypeEvaluationStats\n}\n\n/**\n * A module containing queries that have been evaluated.\n * @public\n */\nexport interface EvaluatedModule {\n  filename: string\n  queries: EvaluatedQuery[]\n  errors: (QueryExtractionError | QueryEvaluationError)[]\n}\n\ninterface QueryExtractionErrorOptions {\n  variable?: QueryVariable\n  cause: unknown\n  filename: string\n}\n\n/**\n * An error that occurred during query extraction.\n * @public\n */\nexport class QueryExtractionError extends Error {\n  variable?: QueryVariable\n  filename: string\n  constructor({variable, cause, filename}: QueryExtractionErrorOptions) {\n    super(\n      `Error while extracting query ${variable ? `from variable '${variable.id.name}' ` : ''}in ${filename}: ${\n        isRecord(cause) && typeof cause.message === 'string' ? cause.message : 'Unknown error'\n      }`,\n    )\n    this.name = 'QueryExtractionError'\n    this.cause = cause\n    this.variable = variable\n    this.filename = filename\n  }\n}\n\ninterface QueryEvaluationErrorOptions {\n  variable?: QueryVariable\n  cause: unknown\n  filename: string\n}\n\n/**\n * An error that occurred during query evaluation.\n * @public\n */\nexport class QueryEvaluationError extends Error {\n  variable?: QueryVariable\n  filename: string\n  constructor({variable, cause, filename}: QueryEvaluationErrorOptions) {\n    super(\n      `Error while evaluating query ${variable ? `from variable '${variable.id.name}' ` : ''}in ${filename}: ${\n        isRecord(cause) && typeof cause.message === 'string' ? cause.message : 'Unknown error'\n      }`,\n    )\n    this.name = 'QueryEvaluationError'\n    this.cause = cause\n    this.variable = variable\n    this.filename = filename\n  }\n}\n","import {createRequire} from 'node:module'\n\nimport {type NodePath, type TransformOptions, traverse} from '@babel/core'\nimport {type Scope} from '@babel/traverse'\nimport * as babelTypes from '@babel/types'\n\nimport {getBabelConfig} from '../getBabelConfig'\nimport {resolveExpression} from './expressionResolvers'\nimport {parseSourceFile} from './parseSource'\nimport {type ExtractedModule, type ExtractedQuery, QueryExtractionError} from './types'\n\nconst require = createRequire(import.meta.url)\n\nconst groqTagName = 'groq'\nconst defineQueryFunctionName = 'defineQuery'\nconst groqModuleName = 'groq'\nconst nextSanityModuleName = 'next-sanity'\n\nconst ignoreValue = '@sanity-typegen-ignore'\n\n/**\n * findQueriesInSource takes a source string and returns all GROQ queries in it.\n * @param source - The source code to search for queries\n * @param filename - The filename of the source code\n * @param babelConfig - The babel configuration to use when parsing the source\n * @param resolver - A resolver function to use when resolving module imports\n * @returns\n * @beta\n * @internal\n */\nexport function findQueriesInSource(\n  source: string,\n  filename: string,\n  babelConfig: TransformOptions = getBabelConfig(),\n  resolver: NodeJS.RequireResolve = require.resolve,\n): ExtractedModule {\n  const queries: ExtractedQuery[] = []\n  const errors: QueryExtractionError[] = []\n  const file = parseSourceFile(source, filename, babelConfig)\n\n  traverse(file, {\n    // Look for variable declarations, e.g. `const myQuery = groq`... and extract the query.\n    // The variable name is used as the name of the query result type\n    VariableDeclarator(path) {\n      const {node, scope} = path\n\n      const init = node.init\n\n      // Look for tagged template expressions that are called with the `groq` tag\n      const isGroqTemplateTag =\n        babelTypes.isTaggedTemplateExpression(init) &&\n        babelTypes.isIdentifier(init.tag) &&\n        init.tag.name === groqTagName\n\n      // Look for strings wrapped in a defineQuery function call\n      const isDefineQueryCall =\n        babelTypes.isCallExpression(init) &&\n        (isImportFrom(groqModuleName, defineQueryFunctionName, scope, init.callee) ||\n          isImportFrom(nextSanityModuleName, defineQueryFunctionName, scope, init.callee))\n\n      if (babelTypes.isIdentifier(node.id) && (isGroqTemplateTag || isDefineQueryCall)) {\n        // If we find a comment leading the decleration which macthes with ignoreValue we don't add\n        // the query\n        if (declarationLeadingCommentContains(path, ignoreValue)) {\n          return\n        }\n\n        const {id, start, end} = node\n        const variable = {id, ...(start && {start}), ...(end && {end})}\n\n        try {\n          const query = resolveExpression({\n            node: init,\n            file,\n            scope,\n            babelConfig,\n            filename,\n            resolver,\n          })\n          queries.push({variable, query, filename})\n        } catch (cause) {\n          errors.push(new QueryExtractionError({filename, variable, cause}))\n        }\n      }\n    },\n  })\n\n  return {filename, queries, errors}\n}\n\nfunction declarationLeadingCommentContains(path: NodePath, comment: string): boolean {\n  /*\n   * We have to consider these cases:\n   *\n   * // @sanity-typegen-ignore\n   * const query = groq`...`\n   *\n   * // AST\n   * VariableDeclaration {\n   *   declarations: [\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *   ],\n   *   leadingComments: ...\n   * }\n   *\n   * // @sanity-typegen-ignore\n   * const query1 = groq`...`, query2 = groq`...`\n   *\n   * // AST\n   * VariableDeclaration {\n   *   declarations: [\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *     VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *   ],\n   *   leadingComments: ...\n   * }\n   *\n   * // @sanity-typegen-ignore\n   * export const query = groq`...`\n   *\n   * // AST\n   * ExportNamedDeclaration {\n   *   declaration: VariableDeclaration {\n   *     declarations: [\n   *       VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *       VariableDeclarator: {init: tag: {name: \"groq\"}}\n   *     ],\n   *   },\n   *   leadingComments: ...\n   * }\n   *\n   * In the case where multiple variables are under the same VariableDeclaration the leadingComments\n   * will still be on the VariableDeclaration\n   *\n   * In the case where the variable is exported, the leadingComments are on the\n   * ExportNamedDeclaration which includes the VariableDeclaration in its own declaration property\n   */\n\n  const variableDeclaration = path.find((node) => node.isVariableDeclaration())\n  if (!variableDeclaration) return false\n\n  if (\n    variableDeclaration.node.leadingComments?.find(\n      (commentItem) => commentItem.value.trim() === comment,\n    )\n  ) {\n    return true\n  }\n\n  // If the declaration is exported, the comment lies on the parent of the export declaration\n  if (\n    variableDeclaration.parent.leadingComments?.find(\n      (commentItem) => commentItem.value.trim() === comment,\n    )\n  ) {\n    return true\n  }\n\n  return false\n}\n\nfunction isImportFrom(\n  moduleName: string,\n  importName: string,\n  scope: Scope,\n  node: babelTypes.Expression | babelTypes.V8IntrinsicIdentifier,\n) {\n  if (babelTypes.isIdentifier(node)) {\n    const binding = scope.getBinding(node.name)\n    if (!binding) {\n      return false\n    }\n\n    const {path} = binding\n\n    // import { foo } from 'groq'\n    if (babelTypes.isImportSpecifier(path.node)) {\n      return (\n        path.node.importKind === 'value' &&\n        path.parentPath &&\n        babelTypes.isImportDeclaration(path.parentPath.node) &&\n        path.parentPath.node.source.value === moduleName &&\n        babelTypes.isIdentifier(path.node.imported) &&\n        path.node.imported.name === importName\n      )\n    }\n\n    // const { defineQuery } = require('groq')\n    if (babelTypes.isVariableDeclarator(path.node)) {\n      const {init} = path.node\n      return (\n        babelTypes.isCallExpression(init) &&\n        babelTypes.isIdentifier(init.callee) &&\n        init.callee.name === 'require' &&\n        babelTypes.isStringLiteral(init.arguments[0]) &&\n        init.arguments[0].value === moduleName\n      )\n    }\n  }\n\n  // import * as foo from 'groq'\n  // foo.defineQuery(...)\n  if (babelTypes.isMemberExpression(node)) {\n    const {object, property} = node\n\n    if (!babelTypes.isIdentifier(object)) {\n      return false\n    }\n\n    const binding = scope.getBinding(object.name)\n    if (!binding) {\n      return false\n    }\n    const {path} = binding\n\n    return (\n      babelTypes.isIdentifier(object) &&\n      babelTypes.isIdentifier(property) &&\n      property.name === importName &&\n      babelTypes.isImportNamespaceSpecifier(path.node) &&\n      path.parentPath &&\n      babelTypes.isImportDeclaration(path.parentPath.node) &&\n      path.parentPath.node.source.value === moduleName\n    )\n  }\n\n  return false\n}\n","import {createRequire} from 'node:module'\n\nimport createDebug from 'debug'\nimport {createMatchPath, loadConfig as loadTSConfig} from 'tsconfig-paths'\n\nconst require = createRequire(import.meta.url)\nconst debug = createDebug('sanity:codegen:moduleResolver')\n\n/**\n * This is a custom implementation of require.resolve that takes into account the paths\n * configuration in tsconfig.json. This is necessary if we want to resolve paths that are\n * custom defined in the tsconfig.json file.\n * Resolving here is best effort and might not work in all cases.\n * @beta\n */\nexport function getResolver(cwd?: string): NodeJS.RequireResolve {\n  const tsConfig = loadTSConfig(cwd)\n\n  if (tsConfig.resultType === 'failed') {\n    debug('Could not load tsconfig, using default resolver: %s', tsConfig.message)\n    return require.resolve\n  }\n\n  const matchPath = createMatchPath(\n    tsConfig.absoluteBaseUrl,\n    tsConfig.paths,\n    tsConfig.mainFields,\n    tsConfig.addMatchAll,\n  )\n\n  const resolve = function (request: string, options?: {paths?: string[]}): string {\n    const found = matchPath(request)\n    if (found !== undefined) {\n      return require.resolve(found, options)\n    }\n    return require.resolve(request, options)\n  }\n\n  // wrap the resolve.path function to make it available.\n  resolve.paths = (request: string): string[] | null => {\n    return require.resolve.paths(request)\n  }\n  return resolve\n}\n","import fs from 'node:fs/promises'\n\nimport {type TransformOptions} from '@babel/core'\nimport createDebug from 'debug'\nimport glob from 'globby'\n\nimport {getBabelConfig} from '../getBabelConfig'\nimport {findQueriesInSource} from './findQueriesInSource'\nimport {getResolver} from './moduleResolver'\nimport {type ExtractedModule, QueryExtractionError} from './types'\n\nconst debug = createDebug('sanity:codegen:findQueries:debug')\n\ninterface FindQueriesInPathOptions {\n  path: string | string[]\n  babelOptions?: TransformOptions\n  resolver?: NodeJS.RequireResolve\n}\n\n/**\n * findQueriesInPath takes a path or array of paths and returns all GROQ queries in the files.\n * @param path - The path or array of paths to search for queries\n * @param babelOptions - The babel configuration to use when parsing the source\n * @param resolver - A resolver function to use when resolving module imports\n * @returns An async generator that yields the results of the search\n * @beta\n * @internal\n */\nexport function findQueriesInPath({\n  path,\n  babelOptions = getBabelConfig(),\n  resolver = getResolver(),\n}: FindQueriesInPathOptions): {files: string[]; queries: AsyncIterable<ExtractedModule>} {\n  const queryNames = new Set()\n  // Holds all query names found in the source files\n  debug(`Globing ${path}`)\n\n  const files = glob\n    .sync(path, {\n      absolute: false,\n      ignore: ['**/node_modules/**'], // we never want to look in node_modules\n      onlyFiles: true,\n    })\n    .sort()\n\n  async function* getQueries(): AsyncGenerator<ExtractedModule> {\n    for (const filename of files) {\n      if (typeof filename !== 'string') {\n        continue\n      }\n\n      debug(`Found file \"${filename}\"`)\n      try {\n        const source = await fs.readFile(filename, 'utf8')\n        const pluckedModuleResult = findQueriesInSource(source, filename, babelOptions, resolver)\n        // Check and error on duplicate query names, because we can't generate types with the same name.\n        for (const {variable} of pluckedModuleResult.queries) {\n          if (queryNames.has(variable.id.name)) {\n            throw new Error(\n              `Duplicate query name found: \"${variable.id.name}\". Query names must be unique across all files.`,\n            )\n          }\n          queryNames.add(variable.id.name)\n        }\n\n        yield pluckedModuleResult\n      } catch (cause) {\n        debug(`Error in file \"${filename}\"`, cause)\n\n        yield {\n          filename,\n          queries: [],\n          errors: [new QueryExtractionError({cause, filename})],\n        }\n      }\n    }\n  }\n\n  return {files, queries: getQueries()}\n}\n","import {type TransformOptions} from '@babel/core'\nimport register from '@babel/register'\n\nimport {getBabelConfig} from '../getBabelConfig'\n\n/**\n * Register Babel with the given options\n *\n * @param babelOptions - The options to use when registering Babel\n * @beta\n */\nexport function registerBabel(babelOptions?: TransformOptions): void {\n  const options = babelOptions || getBabelConfig()\n\n  register({...options, extensions: ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.cjs']})\n}\n","/*\n * resultSuffix takes a variable name and appends \"result\" in the same casing style.\n * Supported: camelCase, PascalCase, snake_case, UPPER_SNAKE.\n * Falls back to camelCase-style suffix when casing is unknown.\n */\nexport function resultSuffix(variableName: string): string {\n  if (!variableName) return 'result'\n\n  const isUpperSnake = /^[A-Z0-9_]+$/.test(variableName) // VALUE, USER_NAME\n  const isSnake = /^[a-z0-9_]+$/.test(variableName) && variableName.includes('_') // user_name\n  const isCamel = /^[a-z][A-Za-z0-9]*$/.test(variableName) // userName\n\n  if (isCamel) {\n    return `${variableName}Result`\n  }\n\n  if (isUpperSnake) {\n    return `${variableName}_RESULT`\n  }\n\n  if (isSnake) {\n    return `${variableName}_result`\n  }\n\n  // Fallback: clean weird chars and use camel-style suffix\n  const cleaned = variableName.replace(/[^A-Za-z0-9]/g, '')\n\n  return `${cleaned}Result`\n}\n","import * as t from '@babel/types'\n\nexport const INTERNAL_REFERENCE_SYMBOL = t.identifier('internalGroqTypeReferenceTo')\nexport const ALL_SANITY_SCHEMA_TYPES = t.identifier('AllSanitySchemaTypes')\nexport const SANITY_QUERIES = t.identifier('SanityQueries')\n\nexport const RESERVED_IDENTIFIERS = new Set<string>()\nRESERVED_IDENTIFIERS.add(SANITY_QUERIES.name)\nRESERVED_IDENTIFIERS.add(ALL_SANITY_SCHEMA_TYPES.name)\nRESERVED_IDENTIFIERS.add(INTERNAL_REFERENCE_SYMBOL.name)\n","import path from 'node:path'\n\nimport {CodeGenerator} from '@babel/generator'\nimport * as t from '@babel/types'\n\nimport {RESERVED_IDENTIFIERS} from './constants'\n\nexport function normalizePath(root: string, filename: string) {\n  const resolved = path.resolve(root, filename)\n  return path.relative(root, resolved)\n}\n\nexport function sanitizeIdentifier(input: string): string {\n  return `${input.replace(/^\\d/, '_').replace(/[^$\\w]+(.)/g, (_, char) => char.toUpperCase())}`\n}\n\nexport function normalizeIdentifier(input: string): string {\n  const sanitized = sanitizeIdentifier(input)\n  return `${sanitized.charAt(0).toUpperCase()}${sanitized.slice(1)}`\n}\n\nexport function getUniqueIdentifierForName(name: string, currentIdentifiers: Set<string>) {\n  const desiredName = normalizeIdentifier(name)\n  let resultingName = desiredName\n  let index = 2\n  while (currentIdentifiers.has(resultingName) || RESERVED_IDENTIFIERS.has(resultingName)) {\n    resultingName = `${desiredName}_${index}`\n    index++\n  }\n  return t.identifier(resultingName)\n}\n\nexport function computeOnce<TReturn>(fn: () => TReturn): () => TReturn {\n  const ref = {current: undefined as TReturn | undefined, computed: false}\n\n  return function () {\n    if (ref.computed) return ref.current as TReturn\n    ref.current = fn()\n    ref.computed = true\n    return ref.current\n  }\n}\n\nexport function weakMapMemo<TParam extends object, TReturn>(fn: (arg: TParam) => TReturn) {\n  const cache = new WeakMap<object, TReturn>()\n\n  const wrapped = function (arg: TParam) {\n    if (cache.has(arg)) return cache.get(arg)!\n    const result = fn(arg)\n    cache.set(arg, result)\n    return result\n  }\n\n  return wrapped\n}\n\nexport function generateCode(node: t.Node) {\n  return `${new CodeGenerator(node).generate().code.trim()}\\n\\n`\n}\n","import * as t from '@babel/types'\nimport {\n  type ArrayTypeNode,\n  type DocumentSchemaType,\n  type InlineTypeNode,\n  type ObjectAttribute,\n  type ObjectTypeNode,\n  type SchemaType,\n  type TypeDeclarationSchemaType,\n  typeEvaluate,\n  type TypeNode,\n  type UnionTypeNode,\n} from 'groq-js'\n\nimport {safeParseQuery} from '../safeParseQuery'\nimport {INTERNAL_REFERENCE_SYMBOL} from './constants'\nimport {getUniqueIdentifierForName, sanitizeIdentifier, weakMapMemo} from './helpers'\nimport {type ExtractedQuery, type TypeEvaluationStats} from './types'\n\nexport class SchemaTypeGenerator {\n  public readonly schema: SchemaType\n  private tsTypes = new Map<string, t.TSType>()\n  private identifiers = new Map<string, t.Identifier>()\n\n  constructor(schema: SchemaType) {\n    this.schema = schema\n\n    const uniqueTypeNames = new Set<string>()\n    for (const type of schema) {\n      if (uniqueTypeNames.has(type.name)) {\n        throw new Error(\n          `Duplicate type name \"${type.name}\" in schema. Type names must be unique within the same schema.`,\n        )\n      }\n      uniqueTypeNames.add(type.name)\n    }\n\n    for (const type of schema) {\n      const currentIdentifierNames = new Set(\n        Array.from(this.identifiers.values()).map((id) => id.name),\n      )\n      const uniqueIdentifier = getUniqueIdentifierForName(type.name, currentIdentifierNames)\n      this.identifiers.set(type.name, uniqueIdentifier)\n    }\n\n    for (const type of schema) {\n      this.tsTypes.set(type.name, this.generateTsType(type))\n    }\n  }\n\n  private generateTsType(\n    typeNode: TypeNode | TypeDeclarationSchemaType | DocumentSchemaType,\n  ): t.TSType {\n    switch (typeNode.type) {\n      case 'string': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.stringLiteral(typeNode.value))\n        }\n        return t.tsStringKeyword()\n      }\n      case 'number': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.numericLiteral(typeNode.value))\n        }\n        return t.tsNumberKeyword()\n      }\n      case 'boolean': {\n        if (typeNode.value !== undefined) {\n          return t.tsLiteralType(t.booleanLiteral(typeNode.value))\n        }\n        return t.tsBooleanKeyword()\n      }\n      case 'unknown': {\n        return t.tsUnknownKeyword()\n      }\n      case 'document': {\n        return this.generateDocumentTsType(typeNode)\n      }\n      case 'type': {\n        return this.generateTsType(typeNode.value)\n      }\n      case 'array': {\n        return this.generateArrayTsType(typeNode)\n      }\n      case 'object': {\n        return this.generateObjectTsType(typeNode)\n      }\n      case 'union': {\n        return this.generateUnionTsType(typeNode)\n      }\n      case 'inline': {\n        return this.generateInlineTsType(typeNode)\n      }\n      case 'null': {\n        return t.tsNullKeyword()\n      }\n\n      default: {\n        throw new Error(\n          `Encountered unsupported node type \"${\n            // @ts-expect-error This should never happen\n            typeNode.type\n          }\" while generating schema types`,\n        )\n      }\n    }\n  }\n\n  // Helper function used to generate TS types for array type nodes.\n  private generateArrayTsType(typeNode: ArrayTypeNode): t.TSTypeReference {\n    const typeNodes = this.generateTsType(typeNode.of)\n    return t.tsTypeReference(t.identifier('Array'), t.tsTypeParameterInstantiation([typeNodes]))\n  }\n\n  // Helper function used to generate TS types for object properties.\n  private generateTsObjectProperty(key: string, attribute: ObjectAttribute): t.TSPropertySignature {\n    const type = this.generateTsType(attribute.value)\n    const propertySignature = t.tsPropertySignature(\n      t.identifier(sanitizeIdentifier(key)),\n      t.tsTypeAnnotation(type),\n    )\n    propertySignature.optional = attribute.optional\n\n    return propertySignature\n  }\n\n  // Helper function used to generate TS types for object type nodes.\n  private generateObjectTsType(typeNode: ObjectTypeNode): t.TSType {\n    const props: t.TSPropertySignature[] = []\n    Object.entries(typeNode.attributes).forEach(([key, attribute]) => {\n      props.push(this.generateTsObjectProperty(key, attribute))\n    })\n    const rest = typeNode.rest\n\n    if (rest) {\n      switch (rest.type) {\n        case 'unknown': {\n          return t.tsUnknownKeyword()\n        }\n        case 'object': {\n          Object.entries(rest.attributes).forEach(([key, attribute]) => {\n            props.push(this.generateTsObjectProperty(key, attribute))\n          })\n          break\n        }\n        case 'inline': {\n          const resolved = this.generateInlineTsType(rest)\n          // if object rest is unknown, we can't generate a type literal for it\n          if (t.isTSUnknownKeyword(resolved)) return resolved\n          return t.tsIntersectionType([t.tsTypeLiteral(props), resolved])\n        }\n        default: {\n          // @ts-expect-error This should never happen\n          throw new Error(`Type \"${rest.type}\" not found in schema`)\n        }\n      }\n    }\n\n    if (typeNode.dereferencesTo) {\n      const derefType = Object.assign(\n        t.tsPropertySignature(\n          INTERNAL_REFERENCE_SYMBOL,\n          t.tsTypeAnnotation(t.tsLiteralType(t.stringLiteral(typeNode.dereferencesTo))),\n        ),\n        {computed: true, optional: true},\n      )\n      props.push(derefType)\n    }\n\n    return t.tsTypeLiteral(props)\n  }\n\n  private generateInlineTsType(typeNode: InlineTypeNode): t.TSType {\n    const id = this.identifiers.get(typeNode.name)\n    if (!id) {\n      // Not found in schema, return unknown type\n      return t.addComment(\n        t.tsUnknownKeyword(),\n        'trailing',\n        ` Unable to locate the referenced type \"${typeNode.name}\" in schema`,\n        true,\n      )\n    }\n\n    return t.tsTypeReference(id)\n  }\n\n  // Helper function used to generate TS types for union type nodes.\n  private generateUnionTsType(typeNode: UnionTypeNode): t.TSType {\n    if (typeNode.of.length === 0) return t.tsNeverKeyword()\n    if (typeNode.of.length === 1) return this.generateTsType(typeNode.of[0])\n    return t.tsUnionType(typeNode.of.map((node) => this.generateTsType(node)))\n  }\n\n  // Helper function used to generate TS types for document type nodes.\n  private generateDocumentTsType(document: DocumentSchemaType): t.TSType {\n    const props = Object.entries(document.attributes).map(([key, node]) =>\n      this.generateTsObjectProperty(key, node),\n    )\n\n    return t.tsTypeLiteral(props)\n  }\n\n  typeNames(): string[] {\n    return this.schema.map((schemaType) => schemaType.name)\n  }\n\n  getType(typeName: string): {tsType: t.TSType; id: t.Identifier} | undefined {\n    const tsType = this.tsTypes.get(typeName)\n    const id = this.identifiers.get(typeName)\n    if (tsType && id) return {tsType, id}\n    return undefined\n  }\n\n  hasType(typeName: string): boolean {\n    return this.tsTypes.has(typeName)\n  }\n\n  evaluateQuery = weakMapMemo(\n    ({query}: Pick<ExtractedQuery, 'query'>): {tsType: t.TSType; stats: TypeEvaluationStats} => {\n      const ast = safeParseQuery(query)\n      const typeNode = typeEvaluate(ast, this.schema)\n      const tsType = this.generateTsType(typeNode)\n      const stats = walkAndCountQueryTypeNodeStats(typeNode)\n      return {tsType, stats}\n    },\n  );\n\n  *[Symbol.iterator]() {\n    for (const {name} of this.schema) {\n      yield {name, ...this.getType(name)!}\n    }\n  }\n}\n\nexport function walkAndCountQueryTypeNodeStats(typeNode: TypeNode): TypeEvaluationStats {\n  switch (typeNode.type) {\n    case 'unknown': {\n      return {allTypes: 1, unknownTypes: 1, emptyUnions: 0}\n    }\n    case 'array': {\n      const acc = walkAndCountQueryTypeNodeStats(typeNode.of)\n      acc.allTypes += 1 // count the array type itself\n      return acc\n    }\n    case 'object': {\n      // if the rest is unknown, we count it as one unknown type\n      if (typeNode.rest && typeNode.rest.type === 'unknown') {\n        return {allTypes: 2, unknownTypes: 1, emptyUnions: 0} // count the object type itself as well\n      }\n\n      const restStats = typeNode.rest\n        ? walkAndCountQueryTypeNodeStats(typeNode.rest)\n        : {allTypes: 0, unknownTypes: 0, emptyUnions: 0}\n\n      // count the object type itself\n      restStats.allTypes += 1\n\n      return Object.values(typeNode.attributes).reduce((acc, attribute) => {\n        const {allTypes, unknownTypes, emptyUnions} = walkAndCountQueryTypeNodeStats(\n          attribute.value,\n        )\n        return {\n          allTypes: acc.allTypes + allTypes,\n          unknownTypes: acc.unknownTypes + unknownTypes,\n          emptyUnions: acc.emptyUnions + emptyUnions,\n        }\n      }, restStats)\n    }\n    case 'union': {\n      if (typeNode.of.length === 0) {\n        return {allTypes: 1, unknownTypes: 0, emptyUnions: 1}\n      }\n\n      return typeNode.of.reduce(\n        (acc, type) => {\n          const {allTypes, unknownTypes, emptyUnions} = walkAndCountQueryTypeNodeStats(type)\n          return {\n            allTypes: acc.allTypes + allTypes,\n            unknownTypes: acc.unknownTypes + unknownTypes,\n            emptyUnions: acc.emptyUnions + emptyUnions,\n          }\n        },\n        {allTypes: 1, unknownTypes: 0, emptyUnions: 0}, // count the union type itself\n      )\n    }\n    default: {\n      return {allTypes: 1, unknownTypes: 0, emptyUnions: 0}\n    }\n  }\n}\n","import process from 'node:process'\n\nimport * as t from '@babel/types'\nimport {type WorkerChannel, type WorkerChannelReporter} from '@sanity/worker-channels'\nimport {type SchemaType} from 'groq-js'\nimport {createSelector} from 'reselect'\n\nimport {resultSuffix} from '../casing'\nimport {ALL_SANITY_SCHEMA_TYPES, INTERNAL_REFERENCE_SYMBOL, SANITY_QUERIES} from './constants'\nimport {computeOnce, generateCode, getUniqueIdentifierForName, normalizePath} from './helpers'\nimport {SchemaTypeGenerator} from './schemaTypeGenerator'\nimport {\n  type EvaluatedModule,\n  type EvaluatedQuery,\n  type ExtractedModule,\n  QueryEvaluationError,\n  type QueryExtractionError,\n} from './types'\n\nexport type TypegenWorkerChannel = WorkerChannel.Definition<{\n  generatedSchemaTypes: WorkerChannel.Event<{\n    internalReferenceSymbol: {\n      id: t.Identifier\n      code: string\n      ast: t.ExportNamedDeclaration\n    }\n    schemaTypeDeclarations: {\n      id: t.Identifier\n      name: string\n      code: string\n      tsType: t.TSType\n      ast: t.ExportNamedDeclaration\n    }[]\n    allSanitySchemaTypesDeclaration: {\n      code: string\n      id: t.Identifier\n      ast: t.ExportNamedDeclaration\n    }\n  }>\n  evaluatedModules: WorkerChannel.Stream<EvaluatedModule>\n  generatedQueryTypes: WorkerChannel.Event<{\n    queryMapDeclaration: {code: string; ast: t.Program}\n  }>\n}>\n\nexport interface GenerateTypesOptions {\n  schema: SchemaType\n  schemaPath?: string\n  queries?: AsyncIterable<ExtractedModule>\n  root?: string\n  overloadClientMethods?: boolean\n  reporter?: WorkerChannelReporter<TypegenWorkerChannel>\n}\n\ntype GetEvaluatedModulesOptions = GenerateTypesOptions & {\n  schemaTypeDeclarations: ReturnType<TypeGenerator['getSchemaTypeDeclarations']>\n  schemaTypeGenerator: SchemaTypeGenerator\n}\ntype GetQueryMapDeclarationOptions = GenerateTypesOptions & {\n  evaluatedModules: EvaluatedModule[]\n}\n\n/**\n * A class used to generate TypeScript types from a given schema\n * @beta\n */\nexport class TypeGenerator {\n  private getInternalReferenceSymbolDeclaration = computeOnce(() => {\n    const typeOperator = t.tsTypeOperator(t.tsSymbolKeyword(), 'unique')\n\n    const id = INTERNAL_REFERENCE_SYMBOL\n    id.typeAnnotation = t.tsTypeAnnotation(typeOperator)\n\n    const declaration = t.variableDeclaration('const', [t.variableDeclarator(id)])\n    declaration.declare = true\n    const ast = t.exportNamedDeclaration(declaration)\n    const code = generateCode(ast)\n\n    return {id, code, ast}\n  })\n\n  private getSchemaTypeGenerator = createSelector(\n    [(options: GenerateTypesOptions) => options.schema],\n    (schema) => new SchemaTypeGenerator(schema),\n  )\n\n  private getSchemaTypeDeclarations = createSelector(\n    [\n      (options: GenerateTypesOptions) => options.root,\n      (options: GenerateTypesOptions) => options.schemaPath,\n      this.getSchemaTypeGenerator,\n    ],\n    (root = process.cwd(), schemaPath, schema) =>\n      Array.from(schema).map(({id, name, tsType}, index) => {\n        const typeAlias = t.tsTypeAliasDeclaration(id, null, tsType)\n        let ast = t.exportNamedDeclaration(typeAlias)\n\n        if (index === 0 && schemaPath) {\n          ast = t.addComments(ast, 'leading', [\n            {type: 'CommentLine', value: ` Source: ${normalizePath(root, schemaPath)}`},\n          ])\n        }\n        const code = generateCode(ast)\n        return {id, code, name, tsType, ast}\n      }),\n  )\n\n  private getAllSanitySchemaTypesDeclaration = createSelector(\n    [this.getSchemaTypeDeclarations],\n    (schemaTypes) => {\n      const ast = t.exportNamedDeclaration(\n        t.tsTypeAliasDeclaration(\n          ALL_SANITY_SCHEMA_TYPES,\n          null,\n          schemaTypes.length\n            ? t.tsUnionType(schemaTypes.map(({id}) => t.tsTypeReference(id)))\n            : t.tsNeverKeyword(),\n        ),\n      )\n      const code = generateCode(ast)\n\n      return {id: ALL_SANITY_SCHEMA_TYPES, code, ast}\n    },\n  )\n\n  private static async getEvaluatedModules({\n    root = process.cwd(),\n    reporter: report,\n    schemaTypeGenerator,\n    schemaTypeDeclarations,\n    queries: extractedModules,\n  }: GetEvaluatedModulesOptions) {\n    if (!extractedModules) {\n      report?.stream.evaluatedModules.end()\n      return []\n    }\n\n    const currentIdentifiers = new Set<string>(schemaTypeDeclarations.map(({id}) => id.name))\n    const evaluatedModuleResults: EvaluatedModule[] = []\n\n    for await (const {filename, ...extractedModule} of extractedModules) {\n      const queries: EvaluatedQuery[] = []\n      const errors: (QueryExtractionError | QueryEvaluationError)[] = [...extractedModule.errors]\n\n      for (const extractedQuery of extractedModule.queries) {\n        const {variable} = extractedQuery\n        try {\n          const {tsType, stats} = schemaTypeGenerator.evaluateQuery(extractedQuery)\n          const id = getUniqueIdentifierForName(resultSuffix(variable.id.name), currentIdentifiers)\n          const typeAlias = t.tsTypeAliasDeclaration(id, null, tsType)\n          const trimmedQuery = extractedQuery.query.replace(/(\\r\\n|\\n|\\r)/gm, '').trim()\n          const ast = t.addComments(t.exportNamedDeclaration(typeAlias), 'leading', [\n            {type: 'CommentLine', value: ` Source: ${normalizePath(root, filename)}`},\n            {type: 'CommentLine', value: ` Variable: ${variable.id.name}`},\n            {type: 'CommentLine', value: ` Query: ${trimmedQuery}`},\n          ])\n\n          const evaluatedQueryResult: EvaluatedQuery = {\n            id,\n            code: generateCode(ast),\n            ast,\n            stats,\n            tsType,\n            ...extractedQuery,\n          }\n\n          currentIdentifiers.add(id.name)\n          queries.push(evaluatedQueryResult)\n        } catch (cause) {\n          errors.push(new QueryEvaluationError({variable, cause, filename}))\n        }\n      }\n\n      const evaluatedModule: EvaluatedModule = {\n        filename,\n        queries,\n        errors,\n      }\n      report?.stream.evaluatedModules.emit(evaluatedModule)\n      evaluatedModuleResults.push(evaluatedModule)\n    }\n    report?.stream.evaluatedModules.end()\n\n    return evaluatedModuleResults\n  }\n\n  private static async getQueryMapDeclaration({\n    overloadClientMethods = true,\n    evaluatedModules,\n  }: GetQueryMapDeclarationOptions) {\n    if (!overloadClientMethods) return {code: '', ast: t.program([])}\n\n    const queries = evaluatedModules.flatMap((module) => module.queries)\n    if (!queries.length) return {code: '', ast: t.program([])}\n\n    const typesByQuerystring: {[query: string]: string[]} = {}\n    for (const {id, query} of queries) {\n      typesByQuerystring[query] ??= []\n      typesByQuerystring[query].push(id.name)\n    }\n\n    const queryReturnInterface = t.tsInterfaceDeclaration(\n      SANITY_QUERIES,\n      null,\n      [],\n      t.tsInterfaceBody(\n        Object.entries(typesByQuerystring).map(([query, types]) => {\n          return t.tsPropertySignature(\n            t.stringLiteral(query),\n            t.tsTypeAnnotation(\n              types.length\n                ? t.tsUnionType(types.map((type) => t.tsTypeReference(t.identifier(type))))\n                : t.tsNeverKeyword(),\n            ),\n          )\n        }),\n      ),\n    )\n\n    const declareModule = t.declareModule(\n      t.stringLiteral('@sanity/client'),\n      t.blockStatement([queryReturnInterface]),\n    )\n\n    const clientImport = t.addComments(\n      t.importDeclaration([], t.stringLiteral('@sanity/client')),\n      'leading',\n      [{type: 'CommentLine', value: ' Query TypeMap'}],\n    )\n\n    const ast = t.program([clientImport, declareModule])\n    const code = generateCode(ast)\n    return {code, ast}\n  }\n\n  async generateTypes(options: GenerateTypesOptions) {\n    const {reporter: report} = options\n    const internalReferenceSymbol = this.getInternalReferenceSymbolDeclaration()\n    const schemaTypeDeclarations = this.getSchemaTypeDeclarations(options)\n    const allSanitySchemaTypesDeclaration = this.getAllSanitySchemaTypesDeclaration(options)\n\n    report?.event.generatedSchemaTypes({\n      internalReferenceSymbol,\n      schemaTypeDeclarations,\n      allSanitySchemaTypesDeclaration,\n    })\n\n    const program = t.program([])\n    let code = ''\n\n    for (const declaration of schemaTypeDeclarations) {\n      program.body.push(declaration.ast)\n      code += declaration.code\n    }\n\n    program.body.push(allSanitySchemaTypesDeclaration.ast)\n    code += allSanitySchemaTypesDeclaration.code\n\n    program.body.push(internalReferenceSymbol.ast)\n    code += internalReferenceSymbol.code\n\n    const evaluatedModules = await TypeGenerator.getEvaluatedModules({\n      ...options,\n      schemaTypeDeclarations,\n      schemaTypeGenerator: this.getSchemaTypeGenerator(options),\n    })\n    for (const {queries} of evaluatedModules) {\n      for (const query of queries) {\n        program.body.push(query.ast)\n        code += query.code\n      }\n    }\n\n    const queryMapDeclaration = await TypeGenerator.getQueryMapDeclaration({\n      ...options,\n      evaluatedModules,\n    })\n    program.body.push(...queryMapDeclaration.ast.body)\n    code += queryMapDeclaration.code\n\n    report?.event.generatedQueryTypes({queryMapDeclaration})\n\n    return {code, ast: program}\n  }\n}\n"],"names":["path","__dirname","parse","debug","babelTypes","require","loadTSConfig","resolve","fs"],"mappings":"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"}