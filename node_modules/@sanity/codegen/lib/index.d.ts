import {ExprNode} from 'groq-js'
import {SchemaType} from 'groq-js'
import * as t from '@babel/types'
import {TransformOptions} from '@babel/core'
import {WorkerChannel} from '@sanity/worker-channels'
import {WorkerChannelReporter} from '@sanity/worker-channels'
import * as z from 'zod'

/**
 * @deprecated use TypeGenConfig
 */
export declare type CodegenConfig = TypeGenConfig

/**
 * @internal
 */
export declare const configDefinition: z.ZodObject<
  {
    path: z.ZodDefault<z.ZodUnion<[z.ZodString, z.ZodArray<z.ZodString, 'many'>]>>
    schema: z.ZodDefault<z.ZodString>
    generates: z.ZodDefault<z.ZodString>
    formatGeneratedCode: z.ZodDefault<z.ZodBoolean>
    overloadClientMethods: z.ZodDefault<z.ZodBoolean>
  },
  'strip',
  z.ZodTypeAny,
  {
    path: string | string[]
    schema: string
    generates: string
    formatGeneratedCode: boolean
    overloadClientMethods: boolean
  },
  {
    path?: string | string[] | undefined
    schema?: string | undefined
    generates?: string | undefined
    formatGeneratedCode?: boolean | undefined
    overloadClientMethods?: boolean | undefined
  }
>

/**
 * A module containing queries that have been evaluated.
 * @public
 */
export declare interface EvaluatedModule {
  filename: string
  queries: EvaluatedQuery[]
  errors: (QueryExtractionError | QueryEvaluationError)[]
}

/**
 * An `ExtractedQuery` that has been evaluated against a schema, yielding a TypeScript type.
 * @public
 */
export declare interface EvaluatedQuery extends ExtractedQuery {
  id: t.Identifier
  code: string
  tsType: t.TSType
  ast: t.ExportNamedDeclaration
  stats: TypeEvaluationStats
}

/**
 * A module (file) containing extracted GROQ queries.
 * @public
 */
export declare interface ExtractedModule {
  filename: string
  queries: ExtractedQuery[]
  errors: QueryExtractionError[]
}

/**
 * A GROQ query extracted from a source file.
 * @public
 */
export declare interface ExtractedQuery {
  variable: QueryVariable
  query: string
  filename: string
}

/**
 * findQueriesInPath takes a path or array of paths and returns all GROQ queries in the files.
 * @param path - The path or array of paths to search for queries
 * @param babelOptions - The babel configuration to use when parsing the source
 * @param resolver - A resolver function to use when resolving module imports
 * @returns An async generator that yields the results of the search
 * @beta
 * @internal
 */
export declare function findQueriesInPath({
  path,
  babelOptions,
  resolver,
}: FindQueriesInPathOptions): {
  files: string[]
  queries: AsyncIterable<ExtractedModule>
}

declare interface FindQueriesInPathOptions {
  path: string | string[]
  babelOptions?: TransformOptions
  resolver?: NodeJS.RequireResolve
}

/**
 * findQueriesInSource takes a source string and returns all GROQ queries in it.
 * @param source - The source code to search for queries
 * @param filename - The filename of the source code
 * @param babelConfig - The babel configuration to use when parsing the source
 * @param resolver - A resolver function to use when resolving module imports
 * @returns
 * @beta
 * @internal
 */
export declare function findQueriesInSource(
  source: string,
  filename: string,
  babelConfig?: TransformOptions,
  resolver?: NodeJS.RequireResolve,
): ExtractedModule

export declare interface GenerateTypesOptions {
  schema: SchemaType
  schemaPath?: string
  queries?: AsyncIterable<ExtractedModule>
  root?: string
  overloadClientMethods?: boolean
  reporter?: WorkerChannelReporter<TypegenWorkerChannel>
}

/**
 * This is a custom implementation of require.resolve that takes into account the paths
 * configuration in tsconfig.json. This is necessary if we want to resolve paths that are
 * custom defined in the tsconfig.json file.
 * Resolving here is best effort and might not work in all cases.
 * @beta
 */
export declare function getResolver(cwd?: string): NodeJS.RequireResolve

/**
 * An error that occurred during query evaluation.
 * @public
 */
declare class QueryEvaluationError extends Error {
  variable?: QueryVariable
  filename: string
  constructor({variable, cause, filename}: QueryEvaluationErrorOptions)
}

declare interface QueryEvaluationErrorOptions {
  variable?: QueryVariable
  cause: unknown
  filename: string
}

/**
 * An error that occurred during query extraction.
 * @public
 */
export declare class QueryExtractionError extends Error {
  variable?: QueryVariable
  filename: string
  constructor({variable, cause, filename}: QueryExtractionErrorOptions)
}

declare interface QueryExtractionErrorOptions {
  variable?: QueryVariable
  cause: unknown
  filename: string
}

declare interface QueryVariable {
  id: t.Identifier
  start?: number
  end?: number
}

/**
 * Read, parse and process a config file
 * @internal
 */
export declare function readConfig(path: string): Promise<TypeGenConfig>

/**
 * Read a schema from a given path
 * @param path - The path to the schema
 * @returns The schema
 * @internal
 * @beta
 **/
export declare function readSchema(path: string): Promise<SchemaType>

/**
 * Register Babel with the given options
 *
 * @param babelOptions - The options to use when registering Babel
 * @beta
 */
export declare function registerBabel(babelOptions?: TransformOptions): void

/**
 * safeParseQuery parses a GROQ query string, but first attempts to extract any parameters used in slices. This method is _only_
 * intended for use in type generation where we don't actually execute the parsed AST on a dataset, and should not be used elsewhere.
 * @internal
 */
export declare function safeParseQuery(query: string): ExprNode

/**
 * Statistics from the query type evaluation process.
 * @public
 */
declare interface TypeEvaluationStats {
  allTypes: number
  unknownTypes: number
  emptyUnions: number
}

export declare type TypeGenConfig = z.infer<typeof configDefinition>

/**
 * A class used to generate TypeScript types from a given schema
 * @beta
 */
export declare class TypeGenerator {
  private getInternalReferenceSymbolDeclaration
  private getSchemaTypeGenerator
  private getSchemaTypeDeclarations
  private getAllSanitySchemaTypesDeclaration
  private static getEvaluatedModules
  private static getQueryMapDeclaration
  generateTypes(options: GenerateTypesOptions): Promise<{
    code: string
    ast: t.Program
  }>
}

export declare type TypegenWorkerChannel = WorkerChannel.Definition<{
  generatedSchemaTypes: WorkerChannel.Event<{
    internalReferenceSymbol: {
      id: t.Identifier
      code: string
      ast: t.ExportNamedDeclaration
    }
    schemaTypeDeclarations: {
      id: t.Identifier
      name: string
      code: string
      tsType: t.TSType
      ast: t.ExportNamedDeclaration
    }[]
    allSanitySchemaTypesDeclaration: {
      code: string
      id: t.Identifier
      ast: t.ExportNamedDeclaration
    }
  }>
  evaluatedModules: WorkerChannel.Stream<EvaluatedModule>
  generatedQueryTypes: WorkerChannel.Event<{
    queryMapDeclaration: {
      code: string
      ast: t.Program
    }
  }>
}>

export {}
