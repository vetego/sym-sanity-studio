{"version":3,"sources":["../src/importFromStream.ts"],"sourcesContent":["import os from 'node:os'\nimport path from 'node:path'\nimport {Transform} from 'node:stream'\nimport {pipeline} from 'node:stream/promises'\n\nimport createDebug from 'debug'\nimport gunzipMaybe from 'gunzip-maybe'\nimport tar from 'tar-fs'\nimport {glob} from 'tinyglobby'\n\nimport type {ImportOptions, ImportResult, SanityDocument} from './types.js'\nimport {getJsonStreamer} from './util/getJsonStreamer.js'\nimport {isTar} from './util/isTar.js'\n\nconst debug = createDebug('sanity:import:stream')\n\ninterface ImportersContext {\n  fromStream: (\n    stream: NodeJS.ReadableStream,\n    options: ImportOptions,\n    importers: ImportersContext,\n  ) => Promise<ImportResult>\n  fromArray: (documents: SanityDocument[], options: ImportOptions) => Promise<ImportResult>\n  fromFolder: (\n    fromDir: string,\n    options: ImportOptions & {deleteOnComplete?: boolean},\n    importers: ImportersContext,\n  ) => Promise<ImportResult>\n}\n\n// StreamRouter handles the peek functionality and routes to appropriate handler\nclass StreamRouter extends Transform {\n  private firstChunk: Buffer | null = null\n  private outputPath: string\n  private targetStream: NodeJS.WritableStream | null = null\n  private jsonDocuments: SanityDocument[] = []\n  private isTarFile = false\n\n  constructor(outputPath: string) {\n    super()\n    this.outputPath = outputPath\n  }\n\n  get isTar(): boolean {\n    return this.isTarFile\n  }\n\n  get documents(): SanityDocument[] {\n    return this.jsonDocuments\n  }\n\n  _transform(chunk: Buffer, _encoding: BufferEncoding, callback: (error?: Error | null) => void) {\n    if (!this.firstChunk) {\n      this.firstChunk = chunk\n\n      // Determine file type from first chunk\n      if (isTar(chunk)) {\n        debug('Stream is a tarball, extracting to %s', this.outputPath)\n        this.isTarFile = true\n        // tar.extract returns a writable stream for extracting files\n        this.targetStream = tar.extract(this.outputPath)\n      } else {\n        debug('Stream is an ndjson file, streaming JSON')\n        this.isTarFile = false\n        const jsonStreamer = getJsonStreamer()\n        this.targetStream = jsonStreamer\n\n        // Collect documents as they're parsed\n        jsonStreamer.on('data', (doc: SanityDocument) => {\n          this.jsonDocuments.push(doc)\n        })\n      }\n\n      // Set up error handling\n      if (this.targetStream) {\n        this.targetStream.on('error', (err: Error) => {\n          this.emit('error', err)\n        })\n      }\n    }\n\n    if (this.targetStream) {\n      const written = this.targetStream.write(chunk)\n      if (written) {\n        callback()\n      } else {\n        this.targetStream.once('drain', callback)\n      }\n    } else {\n      callback(new Error('Target stream not initialized'))\n    }\n  }\n\n  _flush(callback: (error?: Error | null) => void) {\n    if (this.targetStream) {\n      this.targetStream.end()\n      this.targetStream.on('finish', callback)\n      this.targetStream.on('error', callback)\n    } else {\n      callback()\n    }\n  }\n}\n\nexport async function importFromStream(\n  stream: NodeJS.ReadableStream,\n  options: ImportOptions,\n  importers: ImportersContext,\n): Promise<ImportResult> {\n  const slugDate = new Date()\n    .toISOString()\n    .replace(/[^a-z0-9]/gi, '-')\n    .toLowerCase()\n\n  const outputPath = path.join(os.tmpdir(), `sanity-import-${slugDate}`)\n  debug('Importing from stream')\n\n  const router = new StreamRouter(outputPath)\n\n  try {\n    // gunzipMaybe is an untyped library\n     \n    await pipeline(stream, gunzipMaybe(), router)\n\n    if (router.isTar) {\n      return await findAndImportFromTar(outputPath, options, importers)\n    }\n    return await importers.fromArray(router.documents, options)\n  } catch (err) {\n    throw err instanceof Error ? err : new Error(String(err))\n  }\n}\n\nasync function findAndImportFromTar(\n  outputPath: string,\n  options: ImportOptions,\n  importers: ImportersContext,\n): Promise<ImportResult> {\n  debug('Tarball extracted, looking for ndjson')\n\n  const files = await glob(['**/*.ndjson'], {cwd: outputPath, deep: 2, absolute: true})\n  if (!files.length) {\n    throw new Error('ndjson-file not found in tarball')\n  }\n\n  const importBaseDir = path.dirname(files[0]!)\n  return importers.fromFolder(importBaseDir, {...options, deleteOnComplete: true}, importers)\n}\n"],"names":["os","path","Transform","pipeline","createDebug","gunzipMaybe","tar","glob","getJsonStreamer","isTar","debug","StreamRouter","firstChunk","outputPath","targetStream","jsonDocuments","isTarFile","documents","_transform","chunk","_encoding","callback","extract","jsonStreamer","on","doc","push","err","emit","written","write","once","Error","_flush","end","importFromStream","stream","options","importers","slugDate","Date","toISOString","replace","toLowerCase","join","tmpdir","router","findAndImportFromTar","fromArray","String","files","cwd","deep","absolute","length","importBaseDir","dirname","fromFolder","deleteOnComplete"],"mappings":"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"}