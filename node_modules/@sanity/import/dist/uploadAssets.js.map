{"version":3,"sources":["../src/uploadAssets.ts"],"sourcesContent":["import {basename} from 'node:path'\nimport {parse as parseUrl} from 'node:url'\n\nimport {isSanityImageUrl} from '@sanity/asset-utils'\nimport type {SanityClient, Transaction} from '@sanity/client'\nimport debug from 'debug'\nimport pMap from 'p-map'\n\nimport type {AssetFailure, AssetUploadError, ImportOptions, SanityFetchResponse} from './types.js'\nimport {getHashedBufferForUri} from './util/getHashedBufferForUri.js'\nimport {progressStepper} from './util/progressStepper.js'\nimport {retryOnFailure} from './util/retryOnFailure.js'\nimport {suffixTag} from './util/suffixTag.js'\nimport {urlExists} from './util/urlExists.js'\n\nconst logger = debug('sanity:import')\n\nconst ASSET_UPLOAD_CONCURRENCY = 8\nconst ASSET_PATCH_CONCURRENCY = 30\nconst ASSET_PATCH_BATCH_SIZE = 50\nconst ASSET_PATCH_BATCH_TASK_SIZE = 1000\n\nexport interface AssetRef {\n  documentId: string\n  path: string\n  url: string\n  type: string\n}\n\nexport interface AssetRefMapItem {\n  documentId: string\n  path: string\n}\n\nexport interface UploadAssetsResult {\n  batches: number\n  failures: AssetFailure[]\n}\n\ninterface AssetData {\n  buffer: Buffer\n  sha1hash: string\n  type: string\n  url: string\n}\n\ninterface DocumentTasks {\n  documentId: string\n  tasks: Array<{path: string; assetId: string}>\n}\n\nexport async function uploadAssets(\n  assets: AssetRef[],\n  options: ImportOptions,\n): Promise<UploadAssetsResult> {\n  const concurrency = options.assetConcurrency || ASSET_UPLOAD_CONCURRENCY\n  logger('Uploading assets with a concurrency of %d', concurrency)\n\n  // Build a Map where the keys are `type#url` and the value is an array of all\n  // objects containing document id and path to inject asset reference to.\n  // `assets` is an array of objects with shape: {documentId, path, url, type}\n  const assetRefMap = getAssetRefMap(assets)\n\n  // We might have additional assets that is not referenced by any documents, but was part of a\n  // dataset when exporting, for instance. Add these to the map without any references to update.\n  const unreferencedAssets = options.unreferencedAssets || []\n  unreferencedAssets.forEach((asset) => {\n    if (!assetRefMap.has(asset)) {\n      assetRefMap.set(asset, [])\n    }\n  })\n\n  if (assetRefMap.size === 0) {\n    return {\n      batches: 0,\n      failures: [],\n    }\n  }\n\n  // Create a function we can call for every completed upload to report progress\n  const progress = progressStepper(options.onProgress, {\n    step: 'Importing assets (files/images)',\n    total: assetRefMap.size,\n  })\n\n  // If we should allow failures, we need to use a custom catch handler in order\n  // to not set the asset references for the broken assets\n  const ensureAssetExists = ensureAssetWithRetries.bind(null, options, progress)\n  const ensureMethod = options.allowFailingAssets\n    ? (assetKey: string, i: number) => ensureAssetExists(assetKey, i).catch((err: Error) => err)\n    : ensureAssetExists\n\n  // Loop over all unique URLs and ensure they exist, and if not, upload them\n  const mapOptions = {concurrency}\n  const assetIds = await pMap(assetRefMap.keys(), ensureMethod, mapOptions)\n\n  // Extract a list of all failures so we may report them and possibly retry them later\n  const assetFailures = getUploadFailures(assetRefMap, assetIds)\n\n  // Loop over all documents that need asset references to be set\n  const batches = await setAssetReferences(assetRefMap, assetIds, options)\n  return {\n    batches: batches.reduce((prev, add) => prev + add, 0),\n    failures: assetFailures,\n  }\n}\n\nfunction getAssetRefMap(assets: AssetRef[]): Map<string, AssetRefMapItem[]> {\n  return assets.reduce((assetRefMap, item) => {\n    const {documentId, path, url, type} = item\n    const key = `${type}#${url}`\n    let refs = assetRefMap.get(key)\n    if (!refs) {\n      refs = []\n      assetRefMap.set(key, refs)\n    }\n\n    refs.push({documentId, path})\n    return assetRefMap\n  }, new Map<string, AssetRefMapItem[]>())\n}\n\nasync function ensureAssetWithRetries(\n  options: ImportOptions,\n  progress: () => void,\n  assetKey: string,\n  i: number,\n): Promise<string> {\n  const [type, url] = assetKey.split('#', 2)\n\n  const {buffer, sha1hash} = await retryOnFailure(() => downloadAsset(url!, i)).catch(\n    (err: Error) => {\n      progress()\n      const assetError = err as AssetUploadError\n      assetError.type = type!\n      assetError.url = url!\n      assetError.message = assetError.message.includes(url!)\n        ? assetError.message\n        : `Failed to download ${type} @ ${url}:\\n${assetError.message}`\n\n      throw assetError\n    },\n  )\n\n  const asset = {buffer, sha1hash, type: type!, url: url!}\n  return retryOnFailure(() => ensureAsset(asset, options, i))\n    .then((result: string) => {\n      progress()\n      return result\n    })\n    .catch((err: Error) => {\n      progress()\n      const assetError = err as AssetUploadError\n      assetError.type = type!\n      assetError.url = url!\n      assetError.message = assetError.message.includes(url!)\n        ? assetError.message\n        : `Failed to upload ${type} @ ${url}:\\n${assetError.message}`\n\n      throw assetError\n    })\n}\n\nfunction downloadAsset(url: string, i: number): Promise<{buffer: Buffer; sha1hash: string}> {\n  // Download the asset in order for us to create a hash\n  logger('[Asset #%d] Downloading %s', i, url)\n  return getHashedBufferForUri(url)\n}\n\nasync function ensureAsset(asset: AssetData, options: ImportOptions, i: number): Promise<string> {\n  const {buffer, sha1hash, type, url} = asset\n  const {client, assetMap = {}, replaceAssets, tag} = options\n\n  // See if the item exists on the server\n  if (!replaceAssets) {\n    logger('[Asset #%d] Checking for asset with hash %s', i, sha1hash)\n    const assetDocId = await getAssetDocumentIdForHash(\n      client,\n      type,\n      sha1hash,\n      0,\n      suffixTag(tag, 'asset.get-id'),\n    )\n\n    if (assetDocId) {\n      // Same hash means we want to reuse the asset\n      logger('[Asset #%d] Found %s for hash %s', i, type, sha1hash)\n      return assetDocId\n    }\n  }\n\n  const assetMeta = assetMap[`${type}-${sha1hash}`]\n  const hasFilename = assetMeta && assetMeta.originalFilename\n  const hasNonFilenameMeta = assetMeta && Object.keys(assetMap).length > 1\n  const {pathname} = parseUrl(url)\n  const filename = hasFilename ? assetMeta.originalFilename : basename(pathname || '')\n\n  // If it doesn't exist, we want to upload it\n  logger('[Asset #%d] Uploading %s with URL %s', i, type, url)\n  const uploadOptions: {tag: string; filename?: string} = {\n    tag: suffixTag(tag, 'asset.upload'),\n  }\n  if (filename) {\n    uploadOptions.filename = filename\n  }\n\n  const assetDoc = await client.assets.upload(type as 'file' | 'image', buffer, uploadOptions)\n\n  // If we have more metadata to provide, update the asset document\n  if (hasNonFilenameMeta) {\n    await client\n      .patch(assetDoc._id)\n      .set(assetMeta)\n      .commit({visibility: 'async', tag: suffixTag(tag, 'asset.add-meta')})\n  }\n\n  return assetDoc._id\n}\n\nasync function getAssetDocumentIdForHash(\n  client: SanityClient,\n  type: string,\n  sha1hash: string,\n  attemptNum: number,\n  tag: string,\n): Promise<string | null> {\n  // eslint-disable-next-line no-warning-comments\n  // @todo remove retry logic when client has reintroduced it\n  try {\n    const dataType = type === 'file' ? 'sanity.fileAsset' : 'sanity.imageAsset'\n    const query = '*[_type == $dataType && sha1hash == $sha1hash][0]{_id, url}'\n    const assetDoc: SanityFetchResponse | null = await client.fetch(\n      query,\n      {dataType, sha1hash},\n      {tag},\n    )\n    if (!assetDoc || !assetDoc.url) {\n      return null\n    }\n\n    // By adding `fm=json` to image requests, we do a slightly cheaper operation\n    const assetUrl = isSanityImageUrl(assetDoc.url) ? `${assetDoc.url}?fm=json` : assetDoc.url\n    const exists = await urlExists(assetUrl)\n    if (!exists) {\n      logger(`Asset document ${assetDoc._id} exists, but file does not. Overwriting.`)\n      return null\n    }\n\n    return assetDoc._id\n  } catch (err) {\n    if (attemptNum < 3) {\n      return getAssetDocumentIdForHash(client, type, sha1hash, attemptNum + 1, tag)\n    }\n\n    const errorWithAttempts = err as AssetUploadError\n    errorWithAttempts.attempts = attemptNum\n    throw new Error(`Error while attempt to query Sanity API:\\n${errorWithAttempts.message}`)\n  }\n}\n\nfunction getUploadFailures(\n  assetRefMap: Map<string, AssetRefMapItem[]>,\n  assetIds: (string | Error)[],\n): AssetFailure[] {\n  const lookup = assetRefMap.values()\n\n  return assetIds.reduce((failures: AssetFailure[], assetId) => {\n    const documents = lookup.next().value\n    if (typeof assetId === 'string') {\n      return failures\n    }\n\n    const errorWithUrl = assetId as AssetUploadError\n    return failures.concat({\n      type: 'asset',\n      url: errorWithUrl.url,\n      documents: documents\n        ? documents.map(({documentId, path}) => ({\n            documentId,\n            path,\n          }))\n        : [],\n    })\n  }, [])\n}\n\nfunction setAssetReferences(\n  assetRefMap: Map<string, AssetRefMapItem[]>,\n  assetIds: (string | Error)[],\n  options: ImportOptions,\n): Promise<number[]> {\n  const {client, tag} = options\n  const lookup = assetRefMap.values()\n\n  // Collects patch tasks per document to avoid patching the same document multiple times\n  const patchTasksPerDoc: Record<string, Array<{path: string; assetId: string}>> = assetIds.reduce(\n    (tasks: Record<string, Array<{path: string; assetId: string}>>, assetId) => {\n      const documents = lookup.next().value\n      if (typeof assetId !== 'string') {\n        return tasks\n      }\n\n      if (documents) {\n        documents.forEach(({documentId, path}) => {\n          tasks[documentId] = tasks[documentId] || []\n          tasks[documentId].push({path, assetId})\n        })\n      }\n      return tasks\n    },\n    {},\n  )\n\n  const patchTasks: DocumentTasks[] = Object.entries(patchTasksPerDoc).map(\n    ([documentId, tasks]) => ({\n      documentId,\n      tasks,\n    }),\n  )\n\n  // We now have an array of tasks per document, each containing:\n  // {documentId: string, tasks: [{path, assetId}]}\n  // Instead of doing a single mutation per document, let's batch  them up\n  const batches = patchTasks.reduce((acc: DocumentTasks[][], task) => {\n    if (acc.length === 0) {\n      return [[task]]\n    }\n\n    const currentBatch = acc[acc.length - 1]!\n    const overallSize = currentBatch.reduce(\n      (prev: number, add) => prev + (add.tasks ? add.tasks.length : 0),\n      0,\n    )\n\n    if (\n      overallSize + task.tasks.length > ASSET_PATCH_BATCH_TASK_SIZE ||\n      currentBatch.length >= ASSET_PATCH_BATCH_SIZE\n    ) {\n      // Create a new batch if the current one is full\n      acc.push([task])\n      return acc\n    }\n\n    currentBatch.push(task)\n    return acc\n  }, [])\n\n  if (batches.length === 0) {\n    return Promise.resolve([0])\n  }\n\n  // Since separate progress step for batches of reference sets\n  const progress = progressStepper(options.onProgress, {\n    step: 'Setting asset references to documents',\n    total: batches.length,\n  })\n\n  // Now perform the batch operations in parallel with a given concurrency\n  const mapOptions = {concurrency: ASSET_PATCH_CONCURRENCY}\n  const setAssetRefs = setAssetReferenceBatch.bind(null, client, progress, tag)\n  return pMap(batches, setAssetRefs, mapOptions)\n}\n\nfunction setAssetReferenceBatch(\n  client: SanityClient,\n  progress: () => void,\n  tag: string,\n  batch: DocumentTasks[],\n): Promise<number> {\n  logger('Setting asset references on %d documents', batch.length)\n  return retryOnFailure(() =>\n    batch\n      .reduce(reducePatch, client.transaction())\n      .commit({visibility: 'async', tag: suffixTag(tag, 'asset.set-refs')})\n      .then(progress)\n      .then(() => batch.reduce((prev, add) => prev + add.tasks.length, 0)),\n  )\n}\n\nfunction getAssetType(assetId: string): string {\n  return assetId.slice(0, assetId.indexOf('-'))\n}\n\nfunction reducePatch(trx: Transaction, documentTasks: DocumentTasks): Transaction {\n  return trx.patch(documentTasks.documentId, (patch) => {\n    documentTasks.tasks.forEach((task) =>\n      patch\n        .setIfMissing({\n          [task.path]: {_type: getAssetType(task.assetId)},\n        })\n        .set({\n          [`${task.path}.asset`]: {\n            _type: 'reference',\n            _ref: task.assetId,\n          },\n        }),\n    )\n    return patch\n  })\n}\n"],"names":["basename","parse","parseUrl","isSanityImageUrl","debug","pMap","getHashedBufferForUri","progressStepper","retryOnFailure","suffixTag","urlExists","logger","ASSET_UPLOAD_CONCURRENCY","ASSET_PATCH_CONCURRENCY","ASSET_PATCH_BATCH_SIZE","ASSET_PATCH_BATCH_TASK_SIZE","uploadAssets","assets","options","concurrency","assetConcurrency","assetRefMap","getAssetRefMap","unreferencedAssets","forEach","asset","has","set","size","batches","failures","progress","onProgress","step","total","ensureAssetExists","ensureAssetWithRetries","bind","ensureMethod","allowFailingAssets","assetKey","i","catch","err","mapOptions","assetIds","keys","assetFailures","getUploadFailures","setAssetReferences","reduce","prev","add","item","documentId","path","url","type","key","refs","get","push","Map","split","buffer","sha1hash","downloadAsset","assetError","message","includes","ensureAsset","then","result","client","assetMap","replaceAssets","tag","assetDocId","getAssetDocumentIdForHash","assetMeta","hasFilename","originalFilename","hasNonFilenameMeta","Object","length","pathname","filename","uploadOptions","assetDoc","upload","patch","_id","commit","visibility","attemptNum","dataType","query","fetch","assetUrl","exists","errorWithAttempts","attempts","Error","lookup","values","assetId","documents","next","value","errorWithUrl","concat","map","patchTasksPerDoc","tasks","patchTasks","entries","acc","task","currentBatch","overallSize","Promise","resolve","setAssetRefs","setAssetReferenceBatch","batch","reducePatch","transaction","getAssetType","slice","indexOf","trx","documentTasks","setIfMissing","_type","_ref"],"mappings":"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"}