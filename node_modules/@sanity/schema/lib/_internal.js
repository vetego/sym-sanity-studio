import { SetBuilder, processSetSynchronization } from "@sanity/descriptors";
import { isObject, isEqual, difference, flatten, get, uniq, partition, omit, isPlainObject, cloneDeep } from "lodash-es";
import { OWN_PROPS_NAME, Rule, Schema } from "./_chunks-es/Rule.js";
import { ALL_FIELDS_GROUP_NAME, DEFAULT_MAX_FIELD_DEPTH, resolveSearchConfig, resolveSearchConfigForBaseFieldPaths } from "./_chunks-es/Rule.js";
import humanizeList from "humanize-list";
import leven from "leven";
import inspect from "object-inspect";
import { createReferenceTypeNode } from "groq-js";
const MAX_IDLE_WORK = 8.333333333333334;
class IdleScheduler {
  #durations = [];
  #lastAwake;
  constructor(durations) {
    this.#lastAwake = performance.now(), this.#durations = durations;
  }
  async map(arr, fn) {
    const result = [];
    for (const val of arr) {
      const pause = this._tryPause();
      pause && await pause, result.push(fn(val));
    }
    return result;
  }
  async forEach(arr, fn) {
    for (const val of arr) {
      const pause = this._tryPause();
      pause && await pause, fn(val);
    }
  }
  async forEachIter(iter, fn) {
    for (const val of iter) {
      const pause = this._tryPause();
      pause && await pause, fn(val);
    }
  }
  /** Should be invoked at the end to also measure the last pause. */
  end() {
    this.#durations.push(performance.now() - this.#lastAwake);
  }
  /**
   * Yields control back to the UI.
   */
  _tryPause() {
    const elapsed = performance.now() - this.#lastAwake;
    if (!(elapsed < MAX_IDLE_WORK))
      return this.#durations.push(elapsed), new Promise((resolve) => {
        const done = () => {
          this.#lastAwake = performance.now(), resolve();
        };
        typeof requestIdleCallback == "function" ? requestIdleCallback(done, { timeout: 1 }) : typeof requestAnimationFrame == "function" ? requestAnimationFrame(done) : setTimeout(done, 0);
      });
  }
}
const SYNC_SCHEDULER = {
  async map(arr, fn) {
    return arr.map(fn);
  },
  async forEach(arr, fn) {
    return arr.forEach(fn);
  },
  async forEachIter(iter, fn) {
    for (const val of iter)
      fn(val);
  }
}, MAX_DEPTH_UKNOWN = 5;
class DescriptorConverter {
  cache = /* @__PURE__ */ new WeakMap();
  /**
   * Returns a synchronization object for a schema.
   *
   * This is automatically cached in a weak map.
   */
  async get(schema, opts) {
    let value = this.cache.get(schema);
    if (value) return value;
    let idleScheduler;
    const scheduler = opts?.scheduler || (opts?.pauseDurations ? idleScheduler = new IdleScheduler(opts.pauseDurations) : SYNC_SCHEDULER), options = {
      fields: /* @__PURE__ */ new Map(),
      duplicateFields: /* @__PURE__ */ new Map(),
      arrayElements: /* @__PURE__ */ new Map(),
      duplicateArrayElements: /* @__PURE__ */ new Map()
    }, namedTypes = await scheduler.map(schema.getLocalTypeNames(), (name) => {
      const typeDef = convertTypeDef(schema.get(name), name, options);
      return { name, typeDef };
    }), rewriteMap = /* @__PURE__ */ new Map();
    for (const [fieldDef, key] of options.duplicateFields.entries())
      rewriteMap.set(fieldDef, { __type: "hoisted", key });
    for (const [arrayElem, key] of options.duplicateArrayElements.entries())
      rewriteMap.set(arrayElem, { __type: "hoisted", key });
    const builder = new SetBuilder({ rewriteMap });
    return await scheduler.forEachIter(options.duplicateFields.entries(), ([fieldDef, key]) => {
      builder.addObject("sanity.schema.hoisted", { key, value: { ...fieldDef } });
    }), await scheduler.forEachIter(options.duplicateArrayElements.entries(), ([arrayElem, key]) => {
      builder.addObject("sanity.schema.hoisted", { key, value: { ...arrayElem } });
    }), await scheduler.forEach(namedTypes, (namedType) => {
      builder.addObject("sanity.schema.namedType", namedType);
    }), schema.parent && builder.addSet(await this.get(schema.parent, { scheduler })), value = builder.build("sanity.schema.registry"), this.cache.set(schema, value), idleScheduler && idleScheduler.end(), value;
  }
}
function convertCommonTypeDef(schemaType, path, opts) {
  const ownProps = OWN_PROPS_NAME in schemaType ? schemaType[OWN_PROPS_NAME] : schemaType;
  let fields;
  Array.isArray(ownProps.fields) && (fields = ownProps.fields.map((field) => {
    const fieldPath = `${path}.${field.name}`, value = opts.fields.get(field);
    if (value) {
      const otherPath = opts.duplicateFields.get(value);
      return (!otherPath || isLessCanonicalName(fieldPath, otherPath)) && opts.duplicateFields.set(value, fieldPath), value;
    }
    const { name, group, fieldset, type } = field, converted = {
      name,
      typeDef: convertTypeDef(type, fieldPath, opts),
      groups: arrayifyString(group),
      fieldset
    };
    return opts.fields.set(field, converted), converted;
  }));
  let fieldsets;
  Array.isArray(ownProps.fieldsets) && (fieldsets = filterStringKey(
    "name",
    ownProps.fieldsets.map(
      ({ name, title, description, group, hidden, readOnly, options }) => ({
        name,
        title: maybeString(title),
        description: maybeString(description),
        group: maybeString(group),
        hidden: conditionalTrue(hidden),
        readOnly: conditionalTrue(readOnly),
        options: convertUnknown(options)
      })
    )
  ));
  let groups;
  Array.isArray(ownProps.groups) && (groups = filterStringKey(
    "name",
    ownProps.groups.map(
      ({ name, title, hidden, default: def, i18n }) => ({
        name,
        title: maybeString(title),
        hidden: conditionalTrue(hidden),
        default: maybeTrue(def),
        i18n: maybeI18n(i18n)
      })
    )
  ));
  const reason = ownProps.deprecated?.reason;
  let orderings;
  return Array.isArray(ownProps.orderings) && (orderings = ownProps.orderings.map(maybeOrdering).filter((o) => o !== void 0)), {
    title: maybeString(ownProps.title),
    description: maybeStringOrJSX(ownProps.description),
    readOnly: conditionalTrue(ownProps.readOnly),
    hidden: conditionalTrue(ownProps.hidden),
    liveEdit: maybeTrue(ownProps.liveEdit),
    options: convertUnknown(ownProps.options),
    initialValue: convertUnknown(ownProps.initialValue),
    deprecated: typeof reason == "string" ? { reason } : void 0,
    placeholder: maybeString(ownProps.placeholder),
    rows: maybeNumberAsString(ownProps.rows),
    fields,
    fieldsets,
    groups,
    validation: maybeValidations(ownProps),
    orderings
  };
}
function convertTypeDef(schemaType, path, opts) {
  const common2 = convertCommonTypeDef(schemaType, path, opts);
  if (!schemaType.type)
    return {
      extends: null,
      jsonType: schemaType.jsonType,
      ...common2
    };
  switch (schemaType.type.name) {
    case "array":
      return {
        extends: "array",
        of: schemaType.of.map((ofType, idx) => {
          const itemPath = `${path}.${ofType.name}`, value = opts.arrayElements.get(ofType);
          if (value) {
            const otherPath = opts.duplicateArrayElements.get(value);
            return (!otherPath || isLessCanonicalName(itemPath, otherPath)) && opts.duplicateArrayElements.set(value, itemPath), value;
          }
          const converted = {
            name: ofType.name,
            typeDef: convertTypeDef(ofType, `${path}.${ofType.name}`, opts)
          };
          return opts.arrayElements.set(ofType, converted), converted;
        }),
        ...common2
      };
    case "reference":
    case "globalDocumentReference":
    case "crossDatasetReference":
      return {
        extends: schemaType.type.name,
        to: filterStringKey(
          "name",
          schemaType.to.map((toType) => ({ name: toType.name || toType.type?.name || toType.type }))
        ),
        ...common2
      };
    default:
      return { extends: schemaType.type.name, ...common2 };
  }
}
function maybeString(val) {
  return typeof val == "string" ? val : void 0;
}
function maybeNumberAsString(val) {
  return typeof val == "number" ? val.toString() : void 0;
}
function maybeTrue(val) {
  return val === !0 ? !0 : void 0;
}
function conditionalTrue(val) {
  return typeof val == "function" ? FUNCTION_MARKER : maybeTrue(val);
}
function filterStringKey(key, arr) {
  return arr.filter((obj) => typeof obj[key] == "string");
}
function arrayifyString(val) {
  if (typeof val == "string")
    return [val];
  if (Array.isArray(val))
    return val.filter((elem) => typeof elem == "string");
}
const FUNCTION_MARKER = { __type: "function" }, UNKNOWN_MARKER = { __type: "unknown" }, UNDEFINED_MARKER = { __type: "undefined" }, CYCLIC_MARKER = { __type: "cyclic" }, MAX_DEPTH_MARKER = { __type: "maxDepth" };
function convertUnknown(val, seen = /* @__PURE__ */ new Set(), maxDepth = MAX_DEPTH_UKNOWN) {
  if (maxDepth === 0) return MAX_DEPTH_MARKER;
  if (typeof val == "string" || typeof val == "boolean" || val === null || val === void 0)
    return val;
  if (typeof val == "number")
    return { __type: "number", value: val.toString() };
  if (typeof val == "function") return FUNCTION_MARKER;
  if (seen.has(val))
    return CYCLIC_MARKER;
  if (seen.add(val), isObject(val)) {
    if (Array.isArray(val))
      return val.map((elem) => {
        const res = convertUnknown(elem, seen, maxDepth - 1);
        return res === void 0 ? UNDEFINED_MARKER : res;
      });
    if ("$$typeof" in val && "type" in val && "props" in val) {
      const { type, props } = val, strType = typeof type == "function" ? type.name : type;
      return typeof strType != "string" ? void 0 : {
        __type: "jsx",
        type: strType,
        props: convertUnknown(props, seen, maxDepth - 1)
      };
    }
    let hasType = !1;
    const result = {};
    for (const [key, field] of Object.entries(val))
      key === "__type" && (hasType = !0), result[key] = convertUnknown(field, seen, maxDepth - 1);
    return hasType ? { __type: "object", value: result } : result;
  }
  return UNKNOWN_MARKER;
}
function maybeStringOrJSX(val) {
  if (typeof val == "string") return val;
  if (isObject(val) && "$$typeof" in val && "type" in val && "props" in val) {
    const { type, props } = val, strType = typeof type == "function" ? type.name : type;
    return typeof strType != "string" ? void 0 : { __type: "jsx", type: strType, props: convertUnknown(props) };
  }
}
function maybeValidations(obj) {
  if (!isObject(obj) || !("type" in obj)) return;
  const impliedRules = [];
  switch ("options" in obj && isObject(obj.options) && "list" in obj.options && Array.isArray(obj.options.list) && impliedRules.push({
    type: "enum",
    values: obj.options.list.map((o) => convertUnknown(extractValueFromListOption(o, obj))).filter((v) => v !== void 0)
  }), obj.type) {
    case "url":
      impliedRules.push({
        type: "uri",
        allowRelative: !1
      });
      break;
    case "slug":
      impliedRules.push({
        type: "custom"
      });
      break;
    case "reference":
      impliedRules.push({
        type: "reference"
      });
      break;
    case "email":
      impliedRules.push({
        type: "email"
      });
      break;
  }
  if (!("validation" in obj) || !obj.validation)
    return impliedRules.length > 0 ? [
      {
        level: "error",
        rules: impliedRules
      }
    ] : void 0;
  const validations = [], rules = Array.isArray(obj.validation) ? obj.validation : [obj.validation];
  for (const rule of rules) {
    const validation = maybeValidation(rule);
    if (validation === void 0)
      continue;
    const rulesToAdd = impliedRules.filter((ir) => !validation.rules.some((r) => isEqual(r, ir)));
    rulesToAdd.length > 0 && validation.rules.unshift(...rulesToAdd), !validations.some((v) => isEqual(v, validation)) && validations.push(validation);
  }
  return validations.length > 0 ? validations : void 0;
}
function hasValueField(typeDef) {
  return !typeDef || typeof typeDef != "object" ? !1 : "fields" in typeDef ? Array.isArray(typeDef.fields) ? typeDef.fields.some((field) => field.name === "value") : !1 : "type" in typeDef && typeDef.type ? hasValueField(typeDef.type) : !1;
}
function extractValueFromListOption(option, typeDef) {
  return typeDef.jsonType === "object" && hasValueField(typeDef) ? option : isObject(option) && "value" in option && option.value ? option.value : option;
}
function maybeValidation(val) {
  if (val) {
    if (isIRuleFunction(val))
      try {
        const result = val(new Rule());
        if (isIRule(result))
          return maybeValidation(result);
        throw new Error("failed to convert to plain rule");
      } catch {
        return {
          level: "error",
          rules: [{ type: "custom", name: "function" }]
        };
      }
    if (isIRule(val)) {
      const level = val._level || "error", message = maybeValidationMessage(val._message), rules = [];
      for (const spec of val._rules || []) {
        const optional = val._required === "optional" || void 0, convertedRule = convertRuleSpec(spec, optional);
        convertedRule !== void 0 && (rules.some((r) => isEqual(r, convertedRule)) || rules.push(convertedRule));
      }
      return rules.length === 0 ? void 0 : {
        level,
        rules,
        ...message && { message }
      };
    }
  }
}
function isIRule(val) {
  return isObject(val) && "_rules" in val;
}
function maybeValidationMessage(val) {
  if (typeof val == "string") return val;
  if (!isObject(val) || Array.isArray(val)) return;
  const objectMessage = {};
  for (const [field, value] of Object.entries(val))
    typeof field != "string" || typeof value != "string" || (objectMessage[field] = value);
  return Object.keys(objectMessage).length > 0 ? objectMessage : void 0;
}
function isIRuleFunction(val) {
  return typeof val == "function";
}
function convertRuleSpec(spec, optional) {
  if (!isObject(spec) || !("flag" in spec))
    return;
  const constraint = "constraint" in spec ? spec.constraint : void 0;
  switch (spec.flag) {
    case "integer":
      return { type: "integer" };
    case "email":
      return { type: "email" };
    case "unique":
      return { type: "uniqueItems" };
    case "reference":
      return { type: "reference" };
    case "assetRequired":
      return { type: "assetRequired" };
    case "stringCasing":
      return constraint === "uppercase" ? { type: "uppercase" } : constraint === "lowercase" ? { type: "lowercase" } : void 0;
    case "all":
      if (Array.isArray(constraint)) {
        const children = constraint.map((childRule) => maybeValidation(childRule)).filter((c) => c !== void 0);
        if (children.length > 0)
          return { type: "allOf", children };
      }
      return;
    case "either":
      if (Array.isArray(constraint)) {
        const children = constraint.map((childRule) => maybeValidation(childRule)).filter((c) => c !== void 0);
        if (children.length > 0)
          return { type: "anyOf", children };
      }
      return;
    case "valid":
      return Array.isArray(constraint) ? {
        type: "enum",
        values: constraint.map((c) => convertUnknown(c)).filter((v) => v !== void 0)
      } : void 0;
    case "min":
      return { type: "minimum", value: convertConstraintValue(constraint) };
    case "max":
      return { type: "maximum", value: convertConstraintValue(constraint) };
    case "length":
      return { type: "length", value: convertConstraintValue(constraint) };
    case "precision":
      return { type: "precision", value: convertConstraintValue(constraint) };
    case "lessThan":
      return { type: "exclusiveMaximum", value: convertConstraintValue(constraint) };
    case "greaterThan":
      return { type: "exclusiveMinimum", value: convertConstraintValue(constraint) };
    case "regex":
      if (isObject(constraint) && "pattern" in constraint) {
        const { pattern } = constraint, invert = "invert" in constraint ? maybeBoolean(constraint.invert) : void 0;
        if (pattern instanceof RegExp)
          return {
            type: "regex",
            pattern: pattern.source,
            ...invert && { invert: !0 }
          };
      }
      return;
    case "uri": {
      const allowRelative = isObject(constraint) && "options" in constraint && isObject(constraint.options) && "allowRelative" in constraint.options ? maybeBoolean(constraint.options.allowRelative) : void 0;
      return {
        type: "uri",
        ...allowRelative !== void 0 && { allowRelative }
      };
    }
    case "custom":
      return { type: "custom", ...optional && { optional } };
    case "media":
      return { type: "custom", name: "media" };
    case "type":
      return;
    case "presence":
      return constraint === "required" ? { type: "required" } : void 0;
    default:
      return;
  }
}
function convertConstraintValue(constraint) {
  return isObject(constraint) && "type" in constraint && "path" in constraint && constraint.type && constraint.path ? {
    type: "fieldReference",
    path: Array.isArray(constraint.path) ? constraint.path : [constraint.path]
  } : String(constraint);
}
function maybeBoolean(val) {
  if (typeof val == "boolean")
    return val;
}
function maybeI18n(val) {
  if (!isObject(val) || Array.isArray(val)) return;
  const localizedMessage = {};
  for (const entry of Object.entries(val))
    if (isI18nEntry(entry)) {
      const [field, value] = entry;
      localizedMessage[field] = {
        ns: value.ns,
        key: value.key
      };
    }
  return Object.keys(localizedMessage).length > 0 ? localizedMessage : void 0;
}
function isI18nEntry(entry) {
  const [key, value] = entry;
  return typeof key == "string" && !!value && typeof value == "object" && "key" in value && "ns" in value && typeof value.key == "string" && typeof value.ns == "string";
}
function maybeOrdering(val) {
  if (!isObject(val) || Array.isArray(val)) return;
  const name = "name" in val && typeof val.name == "string" ? val.name : void 0;
  if (name === void 0) return;
  const title = "title" in val && typeof val.title == "string" ? val.title : name, by = "by" in val && Array.isArray(val.by) ? val.by : [], orderingBy = [];
  for (const item of by) {
    const orderingItem = maybeOrderingBy(item);
    orderingItem && orderingBy.push(orderingItem);
  }
  if (orderingBy.length === 0) return;
  const i18n = "i18n" in val ? maybeI18n(val.i18n) : void 0;
  return {
    name,
    title,
    by: orderingBy,
    ...i18n && { i18n }
  };
}
function maybeOrderingBy(val) {
  if (!isObject(val) || Array.isArray(val)) return;
  const field = "field" in val && typeof val.field == "string" ? val.field : void 0, direction = "direction" in val && (val.direction === "asc" || val.direction === "desc") ? val.direction : void 0;
  if (!(!field || !direction))
    return { field, direction };
}
function isLessCanonicalName(a, b) {
  return a.length < b.length || a.length === b.length && a < b;
}
function processSchemaSynchronization(sync, response) {
  return processSetSynchronization(sync, response);
}
const ACTIONS_FLAG = "__experimental_actions", DEFAULT_ACTIONS = ["create", "update", "delete", "publish"], VALID_ACTIONS = DEFAULT_ACTIONS, readActions = (schemaType) => ACTIONS_FLAG in schemaType ? schemaType[ACTIONS_FLAG] : DEFAULT_ACTIONS, validateActions = (typeName, actions) => {
  if (!Array.isArray(actions))
    throw new Error(
      `The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(
        ", "
      )}`
    );
  const invalid = difference(actions, VALID_ACTIONS);
  if (invalid.length > 0)
    throw new Error(
      `Invalid action${invalid.length > 1 ? "s" : ""} configured for schema type "${typeName}": ${invalid.join(
        ", "
      )}. Valid actions are: ${VALID_ACTIONS.join(", ")}`
    );
  return actions;
}, resolveEnabledActions = (schemaType) => validateActions(schemaType.name, readActions(schemaType)), isActionEnabled = (schemaType, action) => resolveEnabledActions(schemaType).includes(action);
var assetSourceData = {
  name: "sanity.assetSourceData",
  title: "Asset Source Data",
  type: "object",
  fields: [
    {
      name: "name",
      title: "Source name",
      description: "A canonical name for the source this asset is originating from",
      type: "string"
    },
    {
      name: "id",
      title: "Asset Source ID",
      description: "The unique ID for the asset within the originating source so you can programatically find back to it",
      type: "string"
    },
    {
      name: "url",
      title: "Asset information URL",
      description: "A URL to find more information about this asset in the originating source",
      type: "string"
    }
  ]
}, fileAsset = {
  name: "sanity.fileAsset",
  title: "File",
  type: "document",
  fieldsets: [
    {
      name: "system",
      title: "System fields",
      description: "These fields are managed by the system and not editable"
    }
  ],
  fields: [
    {
      name: "originalFilename",
      type: "string",
      title: "Original file name",
      readOnly: !0
    },
    {
      name: "label",
      type: "string",
      title: "Label"
    },
    {
      name: "title",
      type: "string",
      title: "Title"
    },
    {
      name: "description",
      type: "string",
      title: "Description"
    },
    {
      name: "altText",
      type: "string",
      title: "Alternative text"
    },
    {
      name: "sha1hash",
      type: "string",
      title: "SHA1 hash",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "extension",
      type: "string",
      title: "File extension",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "mimeType",
      type: "string",
      title: "Mime type",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "size",
      type: "number",
      title: "File size in bytes",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "assetId",
      type: "string",
      title: "Asset ID",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "uploadId",
      type: "string",
      readOnly: !0,
      hidden: !0,
      fieldset: "system"
    },
    {
      name: "path",
      type: "string",
      title: "Path",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "url",
      type: "string",
      title: "Url",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "source",
      type: "sanity.assetSourceData",
      title: "Source",
      readOnly: !0,
      fieldset: "system"
    }
  ],
  preview: {
    select: {
      title: "originalFilename",
      path: "path",
      mimeType: "mimeType",
      size: "size"
    },
    prepare(doc) {
      return {
        title: doc.title || doc.path.split("/").slice(-1)[0],
        subtitle: `${doc.mimeType} (${(doc.size / 1024 / 1024).toFixed(2)} MB)`
      };
    }
  },
  orderings: [
    {
      title: "File size",
      name: "fileSizeDesc",
      by: [{ field: "size", direction: "desc" }]
    }
  ]
}, geopoint = {
  title: "Geographical Point",
  name: "geopoint",
  type: "object",
  fields: [
    {
      name: "lat",
      type: "number",
      title: "Latitude"
    },
    {
      name: "lng",
      type: "number",
      title: "Longitude"
    },
    {
      name: "alt",
      type: "number",
      title: "Altitude"
    }
  ]
}, imageAsset = {
  name: "sanity.imageAsset",
  title: "Image",
  type: "document",
  fieldsets: [
    {
      name: "system",
      title: "System fields",
      description: "These fields are managed by the system and not editable"
    }
  ],
  fields: [
    {
      name: "originalFilename",
      type: "string",
      title: "Original file name",
      readOnly: !0
    },
    {
      name: "label",
      type: "string",
      title: "Label"
    },
    {
      name: "title",
      type: "string",
      title: "Title"
    },
    {
      name: "description",
      type: "string",
      title: "Description"
    },
    {
      name: "altText",
      type: "string",
      title: "Alternative text"
    },
    {
      name: "sha1hash",
      type: "string",
      title: "SHA1 hash",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "extension",
      type: "string",
      readOnly: !0,
      title: "File extension",
      fieldset: "system"
    },
    {
      name: "mimeType",
      type: "string",
      readOnly: !0,
      title: "Mime type",
      fieldset: "system"
    },
    {
      name: "size",
      type: "number",
      title: "File size in bytes",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "assetId",
      type: "string",
      title: "Asset ID",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "uploadId",
      type: "string",
      readOnly: !0,
      hidden: !0,
      fieldset: "system"
    },
    {
      name: "path",
      type: "string",
      title: "Path",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "url",
      type: "string",
      title: "Url",
      readOnly: !0,
      fieldset: "system"
    },
    {
      name: "metadata",
      type: "sanity.imageMetadata",
      title: "Metadata"
    },
    {
      name: "source",
      type: "sanity.assetSourceData",
      title: "Source",
      readOnly: !0,
      fieldset: "system"
    }
  ],
  preview: {
    select: {
      id: "_id",
      title: "originalFilename",
      mimeType: "mimeType",
      size: "size",
      media: "media"
    },
    prepare(doc) {
      return {
        title: doc.title || typeof doc.path == "string" && doc.path.split("/").slice(-1)[0],
        media: {
          asset: { _ref: doc.id },
          ...doc.media ? { media: doc.media } : {}
        },
        subtitle: `${doc.mimeType} (${(Number(doc.size) / 1024 / 1024).toFixed(2)} MB)`
      };
    }
  },
  orderings: [
    {
      title: "File size",
      name: "fileSizeDesc",
      by: [{ field: "size", direction: "desc" }]
    }
  ]
}, imageCrop = {
  name: "sanity.imageCrop",
  title: "Image crop",
  type: "object",
  fields: [
    {
      name: "top",
      type: "number",
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "bottom",
      type: "number",
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "left",
      type: "number",
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "right",
      type: "number",
      validation: (Rule2) => Rule2.required()
    }
  ]
}, imageDimensions = {
  name: "sanity.imageDimensions",
  type: "object",
  title: "Image dimensions",
  fields: [
    {
      name: "height",
      type: "number",
      title: "Height",
      readOnly: !0,
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "width",
      type: "number",
      title: "Width",
      readOnly: !0,
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "aspectRatio",
      type: "number",
      title: "Aspect ratio",
      readOnly: !0,
      validation: (Rule2) => Rule2.required()
    }
  ]
}, imageHotspot = {
  name: "sanity.imageHotspot",
  title: "Image hotspot",
  type: "object",
  fields: [
    {
      name: "x",
      type: "number",
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "y",
      type: "number",
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "height",
      type: "number",
      validation: (Rule2) => Rule2.required()
    },
    {
      name: "width",
      type: "number",
      validation: (Rule2) => Rule2.required()
    }
  ]
}, imageMetadata = {
  name: "sanity.imageMetadata",
  title: "Image metadata",
  type: "object",
  fieldsets: [
    {
      name: "extra",
      title: "Extra metadata\u2026",
      options: {
        collapsable: !0
      }
    }
  ],
  fields: [
    {
      name: "location",
      type: "geopoint"
    },
    {
      name: "dimensions",
      title: "Dimensions",
      type: "sanity.imageDimensions",
      fieldset: "extra"
    },
    {
      name: "palette",
      type: "sanity.imagePalette",
      title: "Palette",
      fieldset: "extra"
    },
    {
      name: "lqip",
      title: "LQIP (Low-Quality Image Placeholder)",
      type: "string",
      readOnly: !0
    },
    {
      name: "blurHash",
      title: "BlurHash",
      type: "string",
      readOnly: !0
    },
    {
      name: "hasAlpha",
      title: "Has alpha channel",
      type: "boolean",
      readOnly: !0
    },
    {
      name: "isOpaque",
      title: "Is opaque",
      type: "boolean",
      readOnly: !0
    }
  ]
}, imagePalette = {
  name: "sanity.imagePalette",
  title: "Image palette",
  type: "object",
  fields: [
    { name: "darkMuted", type: "sanity.imagePaletteSwatch", title: "Dark Muted" },
    { name: "lightVibrant", type: "sanity.imagePaletteSwatch", title: "Light Vibrant" },
    { name: "darkVibrant", type: "sanity.imagePaletteSwatch", title: "Dark Vibrant" },
    { name: "vibrant", type: "sanity.imagePaletteSwatch", title: "Vibrant" },
    { name: "dominant", type: "sanity.imagePaletteSwatch", title: "Dominant" },
    { name: "lightMuted", type: "sanity.imagePaletteSwatch", title: "Light Muted" },
    { name: "muted", type: "sanity.imagePaletteSwatch", title: "Muted" }
  ]
}, imagePaletteSwatch = {
  name: "sanity.imagePaletteSwatch",
  title: "Image palette swatch",
  type: "object",
  fields: [
    { name: "background", type: "string", title: "Background", readOnly: !0 },
    { name: "foreground", type: "string", title: "Foreground", readOnly: !0 },
    { name: "population", type: "number", title: "Population", readOnly: !0 },
    { name: "title", type: "string", title: "String", readOnly: !0 }
  ]
}, slug$1 = {
  title: "Slug",
  name: "slug",
  type: "object",
  fields: [
    {
      name: "current",
      title: "Current slug",
      type: "string",
      validation: (Rule2) => Rule2.required()
    },
    {
      // The source field is deprecated/unused, but leaving it included and hidden
      // to prevent rendering "Unknown field" warnings on legacy data
      name: "source",
      title: "Source field",
      type: "string",
      hidden: !0
    }
  ]
};
const builtinTypes = [
  assetSourceData,
  slug$1,
  geopoint,
  // legacyRichDate,
  imageAsset,
  fileAsset,
  imageCrop,
  imageHotspot,
  imageMetadata,
  imageDimensions,
  imagePalette,
  imagePaletteSwatch
], HELP_IDS = {
  TYPE_INVALID: "schema-type-invalid",
  TYPE_IS_ESM_MODULE: "schema-type-is-esm-module",
  TYPE_NAME_RESERVED: "schema-type-name-reserved",
  TYPE_MISSING_NAME: "schema-type-missing-name-or-type",
  TYPE_MISSING_TYPE: "schema-type-missing-name-or-type",
  TYPE_TITLE_RECOMMENDED: "schema-type-title-is-recommended",
  TYPE_TITLE_INVALID: "schema-type-title-is-recommended",
  OBJECT_FIELDS_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_NOT_UNIQUE: "schema-object-fields-invalid",
  OBJECT_FIELD_NAME_INVALID: "schema-object-fields-invalid",
  OBJECT_FIELD_DEFINITION_INVALID_TYPE: "schema-object-fields-invalid",
  ARRAY_PREDEFINED_CHOICES_INVALID: "schema-predefined-choices-invalid",
  ARRAY_OF_ARRAY: "schema-array-of-array",
  ARRAY_OF_INVALID: "schema-array-of-invalid",
  ARRAY_OF_NOT_UNIQUE: "schema-array-of-invalid",
  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: "schema-array-of-type-global-type-conflict",
  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: "schema-array-of-type-builtin-type-conflict",
  REFERENCE_TO_INVALID: "schema-reference-to-invalid",
  REFERENCE_TO_NOT_UNIQUE: "schema-reference-to-invalid",
  REFERENCE_INVALID_OPTIONS: "schema-reference-invalid-options",
  REFERENCE_INVALID_OPTIONS_LOCATION: "schema-reference-options-nesting",
  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: "schema-reference-filter-params-combination",
  SLUG_SLUGIFY_FN_RENAMED: "slug-slugifyfn-renamed",
  ASSET_METADATA_FIELD_INVALID: "asset-metadata-field-invalid",
  CROSS_DATASET_REFERENCE_INVALID: "cross-dataset-reference-invalid",
  GLOBAL_DOCUMENT_REFERENCE_INVALID: "global-document-reference-invalid",
  DEPRECATED_BLOCKEDITOR_KEY: "schema-deprecated-blockeditor-key",
  STANDALONE_BLOCK_TYPE: "schema-standalone-block-type"
};
function createValidationResult(severity, message, helpId) {
  if (helpId && !Object.keys(HELP_IDS).some((id) => HELP_IDS[id] === helpId))
    throw new Error(
      `Used the unknown helpId "${helpId}", please add it to the array in createValidationResult.js`
    );
  return {
    severity,
    message,
    helpId
  };
}
const error = (message, helpId) => createValidationResult("error", message, helpId), warning = (message, helpId) => createValidationResult("warning", message, helpId);
function groupProblems(types) {
  return flatten(types.map((type) => getTypeProblems(type))).filter(
    (type) => type.problems.length > 0
  );
}
function createTypeWithMembersProblemsAccessor(memberPropertyName, getMembers = (type) => get(type, memberPropertyName)) {
  return function(type, parentPath) {
    const currentPath = [
      ...parentPath,
      { kind: "type", type: type.type, name: type.name }
    ], members = getMembers(type) || [], memberProblems = Array.isArray(members) ? members.map((memberType) => {
      const propertySegment = {
        kind: "property",
        name: memberPropertyName
      }, memberPath = [...currentPath, propertySegment];
      return getTypeProblems(memberType, memberPath);
    }) : [
      [
        {
          path: currentPath,
          problems: [error(`Member declaration (${memberPropertyName}) is not an array`)]
        }
      ]
    ];
    return [
      {
        path: currentPath,
        problems: type._problems || []
      },
      ...flatten(memberProblems)
    ];
  };
}
const arrify = (val) => Array.isArray(val) ? val : typeof val > "u" && [] || [val], getObjectProblems = createTypeWithMembersProblemsAccessor("fields"), getImageProblems = createTypeWithMembersProblemsAccessor("fields"), getFileProblems = createTypeWithMembersProblemsAccessor("fields"), getArrayProblems = createTypeWithMembersProblemsAccessor("of"), getReferenceProblems = createTypeWithMembersProblemsAccessor(
  "to",
  (type) => "to" in type ? arrify(type.to) : []
), getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor("marks.annotations"), getBlockMemberProblems = createTypeWithMembersProblemsAccessor("of"), getBlockProblems = (type, problems) => [
  ...getBlockAnnotationProblems(type, problems),
  ...getBlockMemberProblems(type, problems)
];
function getDefaultProblems(type, path = []) {
  return [
    {
      path: [...path, { kind: "type", type: type.type, name: type.name }],
      problems: type._problems || []
    }
  ];
}
function getTypeProblems(type, path = []) {
  switch (type.type) {
    case "object":
      return getObjectProblems(type, path);
    case "document":
      return getObjectProblems(type, path);
    case "array":
      return getArrayProblems(type, path);
    case "reference":
      return getReferenceProblems(type, path);
    case "block":
      return getBlockProblems(type, path);
    case "image":
      return getImageProblems(type, path);
    case "file":
      return getFileProblems(type, path);
    default:
      return getDefaultProblems(type, path);
  }
}
function getDupes(array2, selector = (v) => v) {
  const dupes = array2.reduce((acc, item) => {
    const key = selector(item);
    return acc[key] || (acc[key] = []), acc[key].push(item), acc;
  }, {});
  return Object.keys(dupes).map((key) => dupes[key].length > 1 ? dupes[key] : null).filter(Boolean);
}
const NOOP_VISITOR = (typeDef) => typeDef, TYPE_TYPE = { name: "type", type: null }, FUTURE_RESERVED = ["any", "time", "date"];
function traverseSchema(types = [], coreTypes2 = [], visitor = NOOP_VISITOR) {
  const coreTypesRegistry = /* @__PURE__ */ Object.create(null), registry = /* @__PURE__ */ Object.create(null), coreTypeNames2 = coreTypes2.map((typeDef) => typeDef.name), reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames2), typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean);
  coreTypes2.forEach((coreType) => {
    coreTypesRegistry[coreType.name] = coreType;
  }), types.forEach((type, i) => {
    registry[type && type.name || `__unnamed_${i}`] = {};
  });
  function getType(typeName) {
    return typeName === "type" ? TYPE_TYPE : coreTypesRegistry[typeName] || registry[typeName] || null;
  }
  const duplicateNames = uniq(flatten(getDupes(typeNames)));
  function isDuplicate(typeName) {
    return duplicateNames.includes(typeName);
  }
  function getTypeNames() {
    return typeNames.concat(coreTypeNames2);
  }
  function isReserved(typeName) {
    return typeName === "type" || reservedTypeNames.includes(typeName);
  }
  const visitType = (isRoot) => (typeDef, index) => visitor(typeDef, {
    visit: visitType(!1),
    isRoot,
    getType,
    getTypeNames,
    isReserved,
    isDuplicate,
    index
  });
  return coreTypes2.forEach((coreTypeDef) => {
    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef));
  }), types.forEach((typeDef, i) => {
    Object.assign(
      registry[typeDef && typeDef.name || `__unnamed_${i}`],
      visitType(!0)(typeDef, i)
    );
  }), {
    get(typeName) {
      const res = registry[typeName] || coreTypesRegistry[typeName];
      if (res)
        return res;
      throw new Error(`No such type: ${typeName}`);
    },
    has(typeName) {
      return typeName in registry || typeName in coreTypesRegistry;
    },
    getTypeNames() {
      return Object.keys(registry);
    },
    getTypes() {
      return this.getTypeNames().map(this.get);
    },
    toJSON() {
      return this.getTypes();
    }
  };
}
const coreTypes = [
  { name: "array", jsonType: "array", type: "type" },
  { name: "block", jsonType: "object", type: "type" },
  { name: "boolean", jsonType: "boolean", type: "type" },
  { name: "datetime", jsonType: "string", type: "type" },
  { name: "date", jsonType: "string", type: "type" },
  { name: "document", jsonType: "object", type: "type" },
  { name: "email", jsonType: "string", type: "type" },
  { name: "file", jsonType: "object", type: "type" },
  { name: "geopoint", jsonType: "object", type: "type" },
  { name: "image", jsonType: "object", type: "type" },
  { name: "number", jsonType: "number", type: "type" },
  { name: "object", jsonType: "object", type: "type" },
  { name: "reference", jsonType: "object", type: "type" },
  { name: "crossDatasetReference", jsonType: "object", type: "type" },
  { name: "globalDocumentReference", jsonType: "object", type: "type" },
  { name: "slug", jsonType: "object", type: "type" },
  { name: "span", jsonType: "object", type: "type" },
  { name: "string", jsonType: "string", type: "type" },
  { name: "telephone", jsonType: "string", type: "type" },
  { name: "text", jsonType: "string", type: "type" },
  { name: "url", jsonType: "string", type: "type" }
], coreTypeNames = coreTypes.map((t) => t.name);
function traverseSanitySchema(schemaTypes, visitor) {
  return traverseSchema(schemaTypes, coreTypes, visitor);
}
function isPrimitiveTypeName(typeName) {
  return typeName === "string" || typeName === "number" || typeName === "boolean";
}
function isAssignable(typeName, type) {
  return (typeof type.name == "string" ? type.name : type.type) === typeName;
}
function quote$2(n) {
  return `"${n}"`;
}
function pluralize(arr, suf = "s") {
  return arr.length === 1 ? "" : suf;
}
function format(value) {
  return Array.isArray(value) ? `array with ${value.length} entries` : typeof value == "object" && value !== null ? `object with keys ${humanizeList(Object.keys(value).map(quote$2))}` : quote$2(value);
}
var array = (typeDef, visitorContext) => {
  const ofIsArray = Array.isArray(typeDef.of);
  if (ofIsArray) {
    const invalid = typeDef.of.reduce((errs, def, idx) => {
      if (typeof def.name == "string" && // specifying the same name as the type is redundant, but should not be a hard error at this point
      // Consider showing a warning for this and deprecate this ability eventually
      def.name !== def.type && coreTypeNames.includes(def.name))
        return errs.concat(
          error(
            `Found array member declaration with the same type name as a built-in type ("${def.name}"). Array members can not be given the same name as a built-in type.`,
            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT
          )
        );
      if (def.type === "object" && def.name && visitorContext.getType(def.name))
        return errs.concat(
          warning(
            `Found array member declaration with the same name as the global schema type "${def.name}". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,
            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT
          )
        );
      if (def.type === "array")
        return errs.concat(
          error(
            'Found array member declaration of type "array" - multidimensional arrays are not currently supported by Sanity',
            HELP_IDS.ARRAY_OF_ARRAY
          )
        );
      if (def)
        return errs;
      const err = `Found ${def === null ? "null" : typeof def}, expected member declaration`;
      return errs.concat(
        error(
          `Found invalid type member declaration in array at index ${idx}: ${err}`,
          HELP_IDS.ARRAY_OF_INVALID
        )
      );
    }, []);
    if (invalid.length > 0)
      return {
        ...typeDef,
        of: [],
        _problems: invalid
      };
  }
  const problems = flatten([
    ofIsArray ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map(
      (dupes) => error(
        `Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in array. This makes it impossible to tell their values apart and you should consider naming them`,
        HELP_IDS.ARRAY_OF_NOT_UNIQUE
      )
    ) : error(
      'The array type is missing or having an invalid value for the required "of" property',
      HELP_IDS.ARRAY_OF_INVALID
    )
  ]), of = ofIsArray ? typeDef.of : [], hasObjectTypesWithoutName = of.some(
    (type) => type.type === "object" && typeof type.name > "u"
  );
  of.some((ofType) => ofType.type === "block") && hasObjectTypesWithoutName && problems.push(
    error(
      "The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.",
      HELP_IDS.ARRAY_OF_INVALID
    )
  );
  const [primitiveTypes, objectTypes] = partition(
    of,
    (ofType) => isPrimitiveTypeName(ofType.type) || isPrimitiveTypeName(visitorContext.getType(ofType.type)?.jsonType)
  ), isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0;
  if (isMixedArray) {
    const primitiveTypeNames = primitiveTypes.map((t) => t.type), objectTypeNames = objectTypes.map((t) => t.type);
    problems.push(
      error(
        `The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(
          primitiveTypeNames
        )} ${humanizeList(primitiveTypeNames.map(quote$2))} and object type${pluralize(
          objectTypeNames
        )} ${humanizeList(objectTypeNames.map(quote$2))})`,
        HELP_IDS.ARRAY_OF_INVALID
      )
    );
  }
  const list = typeDef?.options?.list;
  return !isMixedArray && Array.isArray(list) && (primitiveTypes.length > 0 ? list.forEach((option) => {
    const value = option?.value ?? option;
    if (!primitiveTypes.some((primitiveType) => typeof value === visitorContext.getType(primitiveType.type).jsonType)) {
      const formattedTypeList = humanizeList(
        primitiveTypes.map((t) => t.name || t.type),
        { conjunction: "or" }
      );
      problems.push(
        error(
          `An invalid entry found in options.list: ${format(
            value
          )}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`,
          HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID
        )
      );
    }
  }) : list.forEach((option) => {
    const optionTypeName = option._type || "object";
    objectTypes.some(
      (validObjectType) => isAssignable(optionTypeName, validObjectType)
    ) || problems.push(
      error(
        `An invalid entry found in options.list: ${format(
          option
        )}. Must be an object with "_type" set to ${humanizeList(
          objectTypes.map((t) => t.name || t.type).map((t) => t === "object" ? "undefined" : quote$2(t)),
          { conjunction: "or" }
        )}`,
        HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID
      )
    );
  })), typeDef?.options?.list && typeDef?.options?.layout === "tags" && problems.push(
    warning(
      "Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`."
    )
  ), {
    ...typeDef,
    of: of.map(visitorContext.visit),
    _problems: problems
  };
};
function isJSONTypeOf(type, jsonType, visitorContext) {
  if ("jsonType" in type)
    return type.jsonType === jsonType;
  const parentType = visitorContext.getType(type.type);
  if (!parentType)
    throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`);
  return isJSONTypeOf(parentType, jsonType, visitorContext);
}
const getTypeOf = (thing) => Array.isArray(thing) ? "array" : typeof thing, quote$1 = (str) => `"${str}"`, allowedKeys = [
  "components",
  "lists",
  "marks",
  "name",
  "of",
  "options",
  "styles",
  "title",
  "type",
  "validation"
], allowedMarkKeys = ["decorators", "annotations"], allowedStyleKeys = ["blockEditor", "title", "value", "icon", "component"], allowedDecoratorKeys = ["blockEditor", "title", "value", "icon", "component"], allowedListKeys = ["title", "value", "icon", "component"], supportedBuiltInObjectTypes = [
  "file",
  "image",
  "object",
  "reference",
  "crossDatasetReference",
  "globalDocumentReference"
];
function validateBlockType(typeDef, visitorContext) {
  const problems = [];
  let styles = typeDef.styles, lists = typeDef.lists, marks = typeDef.marks, members = typeDef.of;
  const disallowedKeys = Object.keys(typeDef).filter(
    (key) => !allowedKeys.includes(key) && !key.startsWith("_")
  );
  return disallowedKeys.length > 0 && problems.push(
    error(
      `Found unknown properties for block declaration: ${humanizeList(
        disallowedKeys.map(quote$1)
      )}`
    )
  ), marks && (marks = validateMarks(typeDef.marks, visitorContext, problems)), styles && (styles = validateStyles(styles, visitorContext, problems)), lists && (lists = validateLists(lists, visitorContext, problems)), members && (members = validateMembers(members, visitorContext, problems)), {
    ...omit(typeDef, disallowedKeys),
    marks,
    styles,
    name: typeDef.name || typeDef.type,
    of: members,
    _problems: problems
  };
}
function validateMarks(marks, visitorContext, problems) {
  let decorators = marks.decorators, annotations = marks.annotations;
  if (!isPlainObject(marks))
    return problems.push(error(`"marks" declaration should be an object, got ${getTypeOf(marks)}`)), problems;
  const disallowedMarkKeys = Object.keys(marks).filter(
    (key) => !allowedMarkKeys.includes(key) && !key.startsWith("_")
  );
  return disallowedMarkKeys.length > 0 && problems.push(
    error(
      `Found unknown properties for block declaration: ${humanizeList(
        disallowedMarkKeys.map(quote$1)
      )}`
    )
  ), decorators && !Array.isArray(decorators) ? problems.push(
    error(`"marks.decorators" declaration should be an array, got ${getTypeOf(decorators)}`)
  ) : decorators && (decorators.filter((dec) => !!dec.blockEditor).forEach((dec) => {
    dec.icon = dec.blockEditor.icon, dec.component = dec.blockEditor.render;
  }), decorators = validateDecorators(decorators, visitorContext, problems)), annotations && !Array.isArray(annotations) ? problems.push(
    error(`"marks.annotations" declaration should be an array, got ${getTypeOf(annotations)}`)
  ) : annotations && (annotations = validateAnnotations(annotations, visitorContext, problems)), { ...marks, decorators, annotations };
}
function validateLists(lists, visitorContext, problems) {
  return Array.isArray(lists) ? (lists.forEach((list, index) => {
    if (!isPlainObject(list)) {
      problems.push(error(`List must be an object, got ${getTypeOf(list)}`));
      return;
    }
    const name = list.value || `#${index}`, disallowedKeys = Object.keys(list).filter(
      (key) => !allowedListKeys.includes(key) && !key.startsWith("_")
    );
    disallowedKeys.length > 0 && problems.push(
      error(
        `Found unknown properties for list ${name}: ${humanizeList(disallowedKeys.map(quote$1))}`
      )
    ), list.value ? typeof list.value != "string" ? problems.push(
      error(
        `List type #${index} has an invalid "value" property, expected string, got ${getTypeOf(
          list.value
        )}`
      )
    ) : list.title || problems.push(warning(`List type ${name} is missing recommended "title" property`)) : problems.push(error(`List #${index} is missing required "value" property`));
  }), lists) : (problems.push(error(`"lists" declaration should be an array, got ${getTypeOf(lists)}`)), problems);
}
function validateStyles(styles, visitorContext, problems) {
  return Array.isArray(styles) ? (styles.forEach((style, index) => {
    if (!isPlainObject(style)) {
      problems.push(error(`Style must be an object, got ${getTypeOf(style)}`));
      return;
    }
    const name = style.value || `#${index}`, disallowedKeys = Object.keys(style).filter(
      (key) => !allowedStyleKeys.includes(key) && !key.startsWith("_")
    );
    disallowedKeys.length > 0 && problems.push(
      error(
        `Found unknown properties for style ${name}: ${humanizeList(disallowedKeys.map(quote$1))}`
      )
    ), style.value ? typeof style.value != "string" ? problems.push(
      error(
        `Style #${index} has an invalid "value" property, expected string, got ${getTypeOf(
          style.value
        )}`
      )
    ) : style.title || problems.push(warning(`Style ${name} is missing recommended "title" property`)) : problems.push(error(`Style #${index} is missing required "value" property`)), typeof style.blockEditor < "u" && (problems.push(
      warning(
        'Style has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.',
        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY
      )
    ), style.component = style.component || style.blockEditor.render);
  }), styles) : (problems.push(error(`"styles" declaration should be an array, got ${getTypeOf(styles)}`)), problems);
}
function validateDecorators(decorators, visitorContext, problems) {
  return decorators.forEach((decorator, index) => {
    if (!isPlainObject(decorator)) {
      problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`));
      return;
    }
    const name = decorator.value || `#${index}`, disallowedKeys = Object.keys(decorator).filter(
      (key) => !allowedDecoratorKeys.includes(key) && !key.startsWith("_")
    );
    disallowedKeys.length > 0 && problems.push(
      error(
        `Found unknown properties for decorator ${name}: ${humanizeList(
          disallowedKeys.map(quote$1)
        )}`
      )
    ), decorator.value ? typeof decorator.value != "string" ? problems.push(
      error(
        `Decorator #${index} has an invalid "value" property, expected string, got ${getTypeOf(
          decorator.value
        )}`
      )
    ) : decorator.title || problems.push(warning(`Decorator ${name} is missing recommended "title" property`)) : problems.push(error(`Decorator #${index} is missing required "value" property`)), typeof decorator.blockEditor < "u" && (problems.push(
      warning(
        `Decorator "${name}" has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.`,
        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY
      )
    ), decorator.icon = decorator.icon || decorator.blockEditor.icon, decorator.component = decorator.component || decorator.blockEditor.render);
  }), decorators;
}
function validateAnnotations(annotations, visitorContext, problems) {
  return annotations.map((annotation) => {
    if (!isPlainObject(annotation))
      return {
        ...annotation,
        _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)]
      };
    const { _problems } = visitorContext.visit(annotation, visitorContext), targetType = annotation.type && visitorContext.getType(annotation.type);
    return targetType && !isJSONTypeOf(targetType, "object", visitorContext) && _problems.push(
      error(
        `Annotation cannot have type "${annotation.type}" - annotation types must inherit from object`
      )
    ), typeof annotation.blockEditor < "u" && (problems.push(
      warning(
        'Annotation has deprecated key "blockEditor", please refer to the documentation on how to configure the block type for version 3.',
        HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY
      )
    ), annotation.icon = annotation.icon || annotation.blockEditor.icon, annotation.blockEditor?.render && !annotation.components?.annotation && (annotation.components = annotation.components || {}, annotation.components.annotation = annotation.components.annotation || annotation.blockEditor.render)), { ...annotation, _problems };
  });
}
function validateMembers(members, visitorContext, problems) {
  if (!Array.isArray(members)) {
    problems.push(error(`"of" declaration should be an array, got ${getTypeOf(members)}`));
    return;
  }
  return members.map((member) => {
    const { _problems } = visitorContext.visit(member, visitorContext);
    if (member.type === "object" && member.name && visitorContext.getType(member.name))
      return {
        ...member,
        _problems: [
          warning(
            `Found array member declaration with the same name as the global schema type "${member.name}". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,
            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT
          )
        ]
      };
    let type = member;
    for (; type && !type.jsonType; )
      type = visitorContext.getType(type.type);
    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n));
    return (
      // Must be object-like type (to validate hoisted types)
      type && type.jsonType !== "object" || // Can't be a core type, or core object type that isn't supported (like 'span')
      nonObjectCoreTypes.some((coreName) => coreName === member.type) ? {
        ...member,
        _problems: [
          error(
            `Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join(
              "', '"
            )}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`,
            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT
          )
        ]
      } : { ...member, _problems }
    );
  });
}
function validateNonObjectFieldsProp(typeDef, visitorContext) {
  if (!("fields" in typeDef))
    return [];
  let type = typeDef;
  for (; type && !type.jsonType; )
    type = visitorContext.getType(type.type);
  return type && type.jsonType !== "object" ? [error('Type has propery "fields", but is not an object/document type.')] : [];
}
const quote = (str) => `"${str}"`;
function validateTypeName(typeName, visitorContext) {
  const possibleTypeNames = visitorContext.getTypeNames();
  if (!typeName)
    return [error("Type is missing a type.", HELP_IDS.TYPE_MISSING_TYPE)];
  if (typeof typeName != "string")
    return [
      error(
        'Type has an invalid "type"-property - should be a string.',
        HELP_IDS.TYPE_MISSING_TYPE
      )
    ];
  if (!possibleTypeNames.includes(typeName)) {
    const suggestions = possibleTypeNames.map((possibleTypeName) => [leven(typeName, possibleTypeName), possibleTypeName]).filter(([distance]) => distance < 3).map(([_, name]) => name), suggestion = suggestions.length > 0 ? ` Did you mean ${humanizeList(suggestions.map(quote), { conjunction: "or" })}?` : "";
    return [error(`Unknown type: ${typeName}.${suggestion}`)];
  }
  return [];
}
function validateDeprecatedProperties(type) {
  const warnings = [];
  return type?.inputComponent && warnings.push(
    warning('The "inputComponent" property is deprecated. Use "components.input" instead.')
  ), type?.preview?.component && warnings.push(
    warning('The "preview.component" property is deprecated. Use "components.preview" instead.')
  ), type?.diffComponent && warnings.push(
    warning('The "diffComponent" property is deprecated. Use "components.diff" instead.')
  ), type?.options?.editModal && warnings.push(
    warning('The "options.editModal" property is deprecated. Use "options.modal" instead.')
  ), type?.options?.isHighlighted && warnings.push(
    warning(
      'The "options.isHighlighted" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.'
    )
  ), warnings;
}
var common = (typeDef, visitorContext) => ({
  ...typeDef,
  _problems: [
    ...validateTypeName(typeDef.type, visitorContext),
    ...validateNonObjectFieldsProp(typeDef, visitorContext),
    ...validateDeprecatedProperties(typeDef)
  ].filter(Boolean)
});
function normalizeToProp$2(typeDef) {
  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : typeDef.to;
}
const VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/;
function isValidDatasetName(name) {
  return name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name) || `The provided dataset "${name}" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`;
}
var crossDatasetReference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to), normalizedTo = normalizeToProp$2(typeDef), problems = flatten([
    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(
      (dupes) => error(
        `Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`,
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    ) : error(
      'The cross dataset reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.',
      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
    )
  ]);
  if (isValidTo && normalizedTo.length === 0 && problems.push(
    error(
      'The cross dataset reference type should define at least one referenced type. Please check the "to" property.',
      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
    )
  ), normalizedTo.forEach((crossDatasetTypeDef, index) => {
    crossDatasetTypeDef.type || problems.push(
      error(
        `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    ), isPlainObject(crossDatasetTypeDef.preview) || problems.push(
      error(
        `Missing required preview config for the referenced type "${crossDatasetTypeDef.type || "<unknown type>"}"`,
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    );
  }), typeof typeDef.dataset == "string") {
    const datasetValidation = isValidDatasetName(typeDef.dataset);
    datasetValidation !== !0 && problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID));
  } else
    problems.push(
      error(
        "A cross dataset reference must specify a `dataset`",
        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
      )
    );
  return typeDef.studioUrl && typeof typeDef.studioUrl != "function" && problems.push(
    error(
      'The "studioUrl" property on a cross dataset reference must be a function taking "{id, type}" as argument and returning a studio url.',
      HELP_IDS.CROSS_DATASET_REFERENCE_INVALID
    )
  ), problems.push(...getOptionErrors$2(typeDef)), {
    ...typeDef,
    _problems: problems
  };
};
function getOptionErrors$2(typeDef) {
  const { options } = typeDef, problems = [];
  return problems.push(
    ...["filter", "filterParams"].filter((key) => key in typeDef).map(
      (key) => error(
        `\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`,
        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION
      )
    )
  ), options ? isPlainObject(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(
    error(
      "`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.",
      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION
    )
  ) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(
    error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)
  ) : typeof options.filterParams < "u" && !isPlainObject(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(
    Object.keys(options.filterParams).filter((key) => key.startsWith("__") || key.startsWith("$")).map((key) => error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))
  ) : problems : problems.concat(
    error(
      "The reference type expects `options` to be an object",
      HELP_IDS.REFERENCE_INVALID_OPTIONS
    )
  ) : problems;
}
const REACT_SYM_RE = /^Symbol\(react\..+\)$/;
function isComponentLike(value) {
  return typeof value == "function" || typeof value?.$$typeof == "symbol" && REACT_SYM_RE.test(String(value?.$$typeof));
}
function validateComponent(typeDef) {
  const components = "components" in typeDef ? typeDef.components : !1;
  if (!components)
    return [];
  const warnings = [];
  return components.input && !isComponentLike(components.input) && warnings.push(
    warning(
      `The \`components.input\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(
        components.input
      )}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`
    )
  ), components.field && !isComponentLike(components.field) && warnings.push(
    warning(
      `The \`components.field\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(
        components.field
      )}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`
    )
  ), components.item && !isComponentLike(components.item) && warnings.push(
    warning(
      `The \`components.item\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(
        components.item
      )}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`
    )
  ), components.preview && !isComponentLike(components.preview) && warnings.push(
    warning(
      `The \`components.preview\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(
        components.preview
      )}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`
    )
  ), warnings;
}
const VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/, CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;
function validateFieldName(name) {
  return typeof name != "string" ? [
    error(
      `Field names must be strings. Saw "${inspect(name)}"`,
      HELP_IDS.OBJECT_FIELD_NAME_INVALID
    )
  ] : name.startsWith("_") ? [
    error(
      `Invalid field name "${name}". Field names cannot start with underscores "_" as it's reserved for system fields.`,
      HELP_IDS.OBJECT_FIELD_NAME_INVALID
    )
  ] : VALID_FIELD_RE.test(name) ? CONVENTIONAL_FIELD_RE.test(name) ? [] : [
    warning(
      "Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional? It may be wise to keep special characters out of field names for easier access later on."
    ),
    HELP_IDS.OBJECT_FIELD_NAME_INVALID
  ] : [
    error(
      `Invalid field name: "${name}". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(
        VALID_FIELD_RE
      )}).`,
      HELP_IDS.OBJECT_FIELD_NAME_INVALID
    )
  ];
}
function validateField(field, _visitorContext) {
  if (!isPlainObject(field))
    return [
      error(
        `Incorrect type for field definition - should be an object, saw ${inspect(field)}`,
        HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE
      )
    ];
  const problems = [];
  return problems.push(
    ..."name" in field ? validateFieldName(field.name) : [error("Missing field name", HELP_IDS.OBJECT_FIELD_NAME_INVALID)]
  ), problems.push(...validateComponent(field)), problems;
}
function getDuplicateFields(array2) {
  const dupes = {};
  return array2.forEach((field) => {
    dupes[field.name] || (dupes[field.name] = []), dupes[field.name].push(field);
  }), Object.keys(dupes).map((fieldName) => dupes[fieldName].length > 1 ? dupes[fieldName] : null).filter(Boolean);
}
function validateFields(fields, options = { allowEmpty: !1 }) {
  const problems = [];
  if (!Array.isArray(fields))
    return [
      error(
        `The "fields" property must be an array of fields. Instead saw "${typeof fields}"`,
        HELP_IDS.OBJECT_FIELDS_INVALID
      )
    ];
  const fieldsWithNames = fields.filter((field) => typeof field.name == "string");
  getDuplicateFields(fieldsWithNames).forEach((dupes) => {
    problems.push(
      error(
        `Found ${dupes.length} fields with name "${dupes[0].name}" in object`,
        HELP_IDS.OBJECT_FIELD_NOT_UNIQUE
      )
    );
  }), fields.length === 0 && !options.allowEmpty && problems.push(error("Object should have at least one field", HELP_IDS.OBJECT_FIELDS_INVALID));
  const standaloneBlockFields = fields.filter((field) => field.type === "block").map((field) => `"${field.name}"`);
  if (standaloneBlockFields.length > 0) {
    const fmtFields = standaloneBlockFields.join(", ");
    problems.push(
      error(
        `Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`,
        HELP_IDS.STANDALONE_BLOCK_TYPE
      )
    );
  }
  return problems;
}
function validatePreview(preview) {
  return isPlainObject(preview) ? typeof preview.prepare < "u" && typeof preview.prepare != "function" ? [
    error(
      `The "preview.prepare" property must be a function, instead saw "${typeof preview.prepare}"`
    )
  ] : preview.select ? isPlainObject(preview.select) ? Object.keys(preview.select).reduce((errs, key) => typeof preview.select[key] == "string" ? errs : errs.concat(
    error(
      `The key "${key}" of "preview.select" must be a string, instead saw "${typeof preview.select[key]}"`
    )
  ), []) : [
    error(
      `The "preview.select" property must be an object, instead saw "${typeof preview.prepare}"`
    )
  ] : [] : [error(`The "preview" property must be an object, instead saw "${typeof preview}"`)];
}
var object = (typeDef, visitorContext) => {
  let problems = validateFields(typeDef.fields), preview = typeDef.preview;
  if (preview) {
    const previewErrors = validatePreview(typeDef.preview);
    problems = problems.concat(previewErrors), preview = previewErrors.some((err) => err.severity === "error") ? {} : preview;
  }
  return typeDef.type !== "document" && typeDef.type !== "object" && typeof typeDef.initialValue < "u" && problems.push(
    error('The "initialValue" property is currently only supported for document & object types.')
  ), {
    ...typeDef,
    preview,
    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field, index) => {
      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
}, documentVisitor = (typeDefinition, visitorContext) => {
  const typeDef = object(typeDefinition, visitorContext), { initialValue, initialValues } = typeDef;
  return typeof initialValue < "u" && !isPlainObject(initialValue) && typeof initialValue != "function" && typeDef._problems.push(
    error('The "initialValue" property must be either a plain object or a function')
  ), typeof initialValues < "u" && typeDef._problems.push(error('Found property "initialValues" - did you mean "initialValue"?')), typeDef;
}, file = (typeDef, visitorContext) => {
  const problems = [], fields = typeDef.fields;
  fields && problems.push(...validateFields(fields, { allowEmpty: !0 }));
  const invalidFieldNames = Array.isArray(fields) ? fields?.filter((field) => field.name === "asset") : [];
  return typeDef.options && typeof typeDef.options.metadata < "u" && !Array.isArray(typeDef.options.metadata) ? problems.push(
    error(
      "Invalid type for file `metadata` field - must be an array of strings",
      HELP_IDS.ASSET_METADATA_FIELD_INVALID
    )
  ) : invalidFieldNames.length > 0 && problems.push(error("The name `asset` is not a valid field name for type `file`.")), {
    ...typeDef,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
function normalizeToProp$1(typeDef) {
  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : [];
}
function isValidResourceType(resourceType) {
  return resourceType ? resourceType != "media-library" && resourceType != "dataset" ? 'The resource type must be either "media-library" or "dataset"' : !0 : "The resource type must be a non-empty string";
}
function isValidResourceId(resourceType, resourceId) {
  return resourceId ? resourceType === "dataset" ? resourceId.split(".").length !== 2 ? 'The resource ID for a dataset reference must be on the form "<projectId>.<datasetName>"' : !0 : resourceType === "media-library" ? !0 : `Cannot validate resource ID for resource type: ${resourceType}` : "The resource ID must be a non-empty string";
}
var globalDocumentReference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to), normalizedTo = normalizeToProp$1(typeDef), problems = flatten([
    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(
      (dupes) => error(
        `Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`,
        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
      )
    ) : error(
      'The global document reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.',
      HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
    )
  ]);
  if (isValidTo && normalizedTo.length === 0 && problems.push(
    error(
      'The global document reference type should define at least one referenced type. Please check the "to" property.',
      HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
    )
  ), normalizedTo.forEach((crossDatasetTypeDef, index) => {
    crossDatasetTypeDef.type || problems.push(
      error(
        `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,
        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
      )
    ), isPlainObject(crossDatasetTypeDef.preview) || problems.push(
      error(
        `Missing required preview config for the referenced type "${crossDatasetTypeDef.type || "<unknown type>"}"`,
        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
      )
    );
  }), typeof typeDef.resourceType == "string") {
    const validation = isValidResourceType(typeDef.resourceType);
    validation !== !0 && problems.push(error(validation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));
  } else
    problems.push(
      error(
        "A global document reference must specify a `resourceType`",
        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
      )
    );
  if (typeof typeDef.resourceId == "string") {
    const datasetValidation = isValidResourceId(typeDef.resourceType, typeDef.resourceId);
    datasetValidation !== !0 && problems.push(error(datasetValidation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID));
  } else
    problems.push(
      error(
        "A global document reference must specify a `resourceId`",
        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
      )
    );
  return typeDef.studioUrl && typeof typeDef.studioUrl != "function" && typeof typeDef.studioUrl != "string" && problems.push(
    error(
      'The "studioUrl" property on a global document reference must either be a function taking "{id, type}" as argument and returning a studio url, or a string being the base url pointing to a studio.',
      HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID
    )
  ), problems.push(...getOptionErrors$1(typeDef)), {
    ...typeDef,
    _problems: problems
  };
};
function getOptionErrors$1(typeDef) {
  const { options } = typeDef, problems = [];
  return problems.push(
    ...["filter", "filterParams"].filter((key) => key in typeDef).map(
      (key) => error(
        `\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`,
        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION
      )
    )
  ), options ? isPlainObject(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(
    error(
      "`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.",
      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION
    )
  ) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(
    error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)
  ) : typeof options.filterParams < "u" && !isPlainObject(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(
    Object.keys(options.filterParams).filter((key) => key.startsWith("__") || key.startsWith("$")).map((key) => error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))
  ) : problems : problems.concat(
    error(
      "The reference type expects `options` to be an object",
      HELP_IDS.REFERENCE_INVALID_OPTIONS
    )
  ) : problems;
}
const autoMeta = ["dimensions", "hasAlpha", "isOpaque"];
var image = (typeDef, visitorContext) => {
  const problems = [], fields = typeDef.fields;
  fields && problems.push(...validateFields(fields, { allowEmpty: !0 }));
  let options = typeDef.options;
  const metadata = options?.metadata, superfluousMeta = Array.isArray(metadata) ? metadata.filter((meta) => autoMeta.includes(meta)) : [], invalidFieldNames = ["asset", "hotspot", "crop"], fieldsWithInvalidName = Array.isArray(fields) ? fields?.filter((field) => invalidFieldNames.includes(field.name)) : [];
  return typeof metadata < "u" && !Array.isArray(metadata) ? problems.push(
    error(
      "Invalid type for image `metadata` field - must be an array of strings",
      HELP_IDS.ASSET_METADATA_FIELD_INVALID
    )
  ) : superfluousMeta.length > 0 ? (problems.push(
    warning(
      `Image \`metadata\` field contains superfluous properties (they are always included): ${superfluousMeta.join(
        ", "
      )}`
    )
  ), options = { ...options, metadata: metadata.filter((meta) => !autoMeta.includes(meta)) }) : fieldsWithInvalidName.length > 0 && problems.push(
    error(
      `The names \`${invalidFieldNames.join(
        "`, `"
      )}\` are invalid field names for type \`image\`.`
    )
  ), {
    ...typeDef,
    options,
    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {
      const { name, ...fieldTypeDef } = field, { _problems, ...fieldType } = visitorContext.visit(fieldTypeDef, index);
      return {
        name,
        ...fieldType,
        _problems: validateField(field).concat(_problems || [])
      };
    }),
    _problems: problems
  };
};
function normalizeToProp(typeDef) {
  return Array.isArray(typeDef.to) ? typeDef.to : typeDef.to ? [typeDef.to] : typeDef.to;
}
var reference = (typeDef, visitorContext) => {
  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to), normalizedTo = normalizeToProp(typeDef), problems = flatten([
    isValidTo ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map(
      (dupes) => error(
        `Found ${dupes.length} members with same type, but not unique names "${dupes[0].type}" in reference. This makes it impossible to tell their values apart and you should consider naming them`,
        HELP_IDS.REFERENCE_TO_INVALID
      )
    ) : error(
      'The reference type is missing or having an invalid value for the required "to" property. It should be an array of accepted types.',
      HELP_IDS.REFERENCE_TO_INVALID
    )
  ]);
  return isValidTo && normalizedTo.length === 0 && problems.push(
    error(
      'The reference type should define at least one accepted type. Please check the "to" property.',
      HELP_IDS.REFERENCE_TO_INVALID
    )
  ), problems.push(...getOptionErrors(typeDef)), {
    ...typeDef,
    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),
    _problems: problems
  };
};
function getOptionErrors(typeDef) {
  const { options } = typeDef, problems = [];
  return problems.push(
    ...["filter", "filterParams"].filter((key) => key in typeDef).map(
      (key) => error(
        `\`${key}\` is not allowed on a reference type definition - did you mean \`options.${key}\`?`,
        HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION
      )
    )
  ), options ? isPlainObject(options) ? typeof options.filter == "function" && typeof options.filterParams < "u" ? problems.concat(
    error(
      "`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.",
      HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION
    )
  ) : typeof options.filter == "function" || !options.filter && !options.filterParams ? problems : typeof options.filter != "string" ? problems.concat(
    error(`If set, \`filter\` must be a string. Got ${typeof options.filter}`)
  ) : typeof options.filterParams < "u" && !isPlainObject(options.filterParams) ? problems.concat(error("If set, `filterParams` must be an object.")) : options.filterParams ? problems.concat(
    Object.keys(options.filterParams).filter((key) => key.startsWith("__") || key.startsWith("$")).map((key) => error(`Filter parameter cannot be prefixed with "$" or "__". Got ${key}".`))
  ) : problems : problems.concat(
    error(
      "The reference type expects `options` to be an object",
      HELP_IDS.REFERENCE_INVALID_OPTIONS
    )
  ) : problems;
}
var rootType = (typeDef, visitorContext) => {
  const hasName = !!typeDef.name;
  if (!hasName && Object.keys(typeDef).length === 1)
    return {
      ...typeDef,
      _problems: [
        error(
          "Invalid/undefined type declaration, check declaration or the import/export of the schema type.",
          HELP_IDS.TYPE_INVALID
        )
      ]
    };
  const problems = [];
  return looksLikeEsmModule(typeDef) ? problems.push(
    error(
      "Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property",
      HELP_IDS.TYPE_IS_ESM_MODULE
    )
  ) : hasName ? visitorContext.isReserved(typeDef.name) && problems.push(
    error(
      `Invalid type name: "${typeDef.name}" is a reserved name.`,
      HELP_IDS.TYPE_NAME_RESERVED
    )
  ) : problems.push(error("Missing type name", HELP_IDS.TYPE_MISSING_NAME)), visitorContext.isDuplicate(typeDef.name) && problems.push(
    error(
      `Invalid type name: A type with name "${typeDef.name}" is already defined in the schema.`
    )
  ), problems.push(...validateComponent(typeDef)), "title" in typeDef && typeof typeDef.title != "string" && problems.push(warning("Type title is not a string.", HELP_IDS.TYPE_TITLE_INVALID)), {
    ...typeDef,
    _problems: problems
  };
};
function looksLikeEsmModule(typeDef) {
  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title);
}
var slug = (typeDef, visitorContext) => {
  const problems = [];
  return typeDef.options && typeDef.options.slugifyFn && (problems.push(
    warning(
      'Heads up! The "slugifyFn" option has been renamed to "slugify".',
      HELP_IDS.SLUG_SLUGIFY_FN_RENAMED
    )
  ), typeDef.options.slugify = typeDef.options.slugifyFn), {
    ...typeDef,
    _problems: problems
  };
};
const typeVisitors = {
  array,
  object,
  slug,
  file,
  image,
  block: validateBlockType,
  document: documentVisitor,
  reference,
  crossDatasetReference,
  globalDocumentReference
}, getNoopVisitor = (visitorContext) => (schemaDef) => ({
  name: `<unnamed_type_@_index_${visitorContext.index}>`,
  ...schemaDef,
  _problems: []
});
function combine(...visitors) {
  return (schemaType, visitorContext) => visitors.reduce(
    (result, visitor) => {
      const res = visitor(result, visitorContext);
      return {
        ...res,
        _problems: result._problems.concat(res._problems)
      };
    },
    { _problems: [], ...schemaType }
  );
}
function validateSchema(schemaTypes, {
  transformTypeVisitors = (visitors) => visitors,
  transformCommonVisitors = (visitors) => visitors
} = {}) {
  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {
    const typeVisitor = schemaDef && schemaDef.type && transformTypeVisitors(typeVisitors)[schemaDef.type] || getNoopVisitor(visitorContext), commonVisitors = transformCommonVisitors([common]);
    return visitorContext.isRoot ? combine(rootType, ...commonVisitors, typeVisitor)(schemaDef, visitorContext) : combine(...commonVisitors, typeVisitor)(schemaDef, visitorContext);
  });
}
class ValidationError extends Error {
  problems;
  constructor(problems) {
    super("ValidationError"), this.problems = problems, this.name = "ValidationError";
  }
}
const builtinSchema = Schema.compile({
  name: "studio",
  types: builtinTypes
});
function createSchemaFromManifestTypes(schemaDef) {
  const validated = validateSchema(schemaDef.types).getTypes(), problems = groupProblems(validated).filter(
    (group) => group.problems.some((problem) => problem.severity === "error")
  );
  if (problems.length > 0)
    throw new ValidationError(problems);
  return Schema.compile({
    name: schemaDef.name,
    types: schemaDef.types.map(coerceType).filter(Boolean),
    parent: builtinSchema
  });
}
function coerceType(obj) {
  if (!isObject(obj)) return;
  const typ = cloneDeep(obj);
  return traverse(typ), typ;
}
function traverse(obj) {
  if (isObject(obj)) {
    if (Array.isArray(obj)) {
      obj.forEach(traverse);
      return;
    }
    for (const v of Object.values(obj))
      traverse(v);
    coerceValidation(obj);
  }
}
function coerceValidation(val) {
  if (!isObject(val) || !("validation" in val)) return;
  const manifestValidation = Array.isArray(val.validation) ? val.validation : [val.validation];
  val.validation = manifestValidation.map((group) => {
    if (isObject(group))
      return (baseRule) => {
        let rule = baseRule;
        const level = "level" in group ? group.level : void 0, rules = "rules" in group ? group.rules : void 0, message = "message" in group ? group.message : void 0;
        if (!(!rules || !Array.isArray(rules))) {
          isValidLevel(level) && (message === void 0 || typeof message == "string") && (rule = rule[level](message));
          for (const ruleSpec of rules)
            rule = applyRuleSpec(rule, ruleSpec);
          return rule;
        }
      };
  }).filter(Boolean);
}
function coerceConstraintRule(val) {
  if (isObject(val))
    return Array.isArray(val) ? val.map(coerceConstraintRule).filter(Boolean) : (baseRule) => {
      let rule = baseRule;
      const rules = "_rules" in val ? val._rules : void 0, level = "_level" in val ? val._level : void 0, message = "_message" in val ? val._message : void 0;
      if (!(!rules || !Array.isArray(rules))) {
        typeof level == "string" && (rule = rule[level](message));
        for (const ruleSpec of rules)
          rule = applyRuleSpec(rule, ruleSpec);
        return rule;
      }
    };
}
function applyRuleSpec(rule, ruleSpec) {
  if (!ruleSpec || typeof ruleSpec != "object")
    return rule;
  const flag = "flag" in ruleSpec ? ruleSpec.flag : void 0, constraint = "constraint" in ruleSpec ? ruleSpec.constraint : void 0;
  switch (flag) {
    case "presence":
      if (constraint === "required")
        return rule.required();
      if (constraint === "optional")
        return rule.optional();
      break;
    case "type":
      if (typeof constraint == "string")
        return rule.type(constraint);
      break;
    case "min":
      if (typeof constraint == "number" || typeof constraint == "string")
        return rule.min(constraint);
      break;
    case "max":
      if (typeof constraint == "number" || typeof constraint == "string")
        return rule.max(constraint);
      break;
    case "length":
      if (typeof constraint == "number")
        return rule.length(constraint);
      break;
    case "integer":
      return rule.integer();
    case "email":
      return rule.email();
    case "unique":
      return rule.unique();
    case "reference":
      return rule.reference();
    case "precision":
      if (typeof constraint == "number")
        return rule.precision(constraint);
      break;
    case "positive":
      return rule.positive();
    case "negative":
      return rule.negative();
    case "greaterThan":
      if (typeof constraint == "number")
        return rule.greaterThan(constraint);
      break;
    case "lessThan":
      if (typeof constraint == "number")
        return rule.lessThan(constraint);
      break;
    case "stringCasing":
      if (constraint === "uppercase")
        return rule.uppercase();
      if (constraint === "lowercase")
        return rule.lowercase();
      break;
    case "valid":
      if (Array.isArray(constraint))
        return rule.valid(constraint);
      break;
    case "regex":
      if (isObject(constraint) && "pattern" in constraint && (typeof constraint.pattern == "string" || constraint.pattern instanceof RegExp)) {
        const options = {};
        "name" in constraint && typeof constraint.name == "string" && (options.name = constraint.name), "invert" in constraint && (options.invert = constraint.invert);
        const pattern = typeof constraint.pattern == "string" ? stringToRegExp(constraint.pattern) : constraint.pattern;
        return rule.regex(pattern, options);
      }
      break;
    case "uri":
      if (isObject(constraint) && "options" in constraint)
        return rule.uri(constraint.options);
      break;
    case "assetRequired":
      return rule.assetRequired();
    case "all":
      return rule.all(coerceConstraintRule(constraint));
    case "either":
      return rule.either(coerceConstraintRule(constraint));
    case "custom":
      if (constraint === void 0) return rule.custom(() => !0);
      if (typeof constraint == "function") return rule.custom(constraint);
      break;
    case "media":
      if (constraint === void 0) return rule.media(() => !0);
      if (typeof constraint == "function") return rule.media(constraint);
      break;
  }
  return rule;
}
const isValidLevel = (level) => !!level && typeof level == "string" && ["error", "warning", "info"].includes(level);
function stringToRegExp(str) {
  const match = str.match(/^\/(.*)\/([gimuy]*)$/);
  return match ? new RegExp(match[1], match[2]) : new RegExp(str);
}
const documentDefaultFields = (typeName) => ({
  _id: {
    type: "objectAttribute",
    value: { type: "string" }
  },
  _type: {
    type: "objectAttribute",
    value: { type: "string", value: typeName }
  },
  _createdAt: {
    type: "objectAttribute",
    value: { type: "string" }
  },
  _updatedAt: {
    type: "objectAttribute",
    value: { type: "string" }
  },
  _rev: {
    type: "objectAttribute",
    value: { type: "string" }
  }
}), typesMap = /* @__PURE__ */ new Map([
  ["text", { type: "string" }],
  ["url", { type: "string" }],
  ["datetime", { type: "string" }],
  ["date", { type: "string" }],
  ["boolean", { type: "boolean" }],
  ["email", { type: "string" }]
]);
function extractSchema(schemaDef, extractOptions = {}) {
  const inlineFields = /* @__PURE__ */ new Set(), documentTypes = /* @__PURE__ */ new Map(), schema = [], hoistedRefMap = /* @__PURE__ */ new Map(), { sortedSchemaTypeNames, repeated } = sortByDependencies(schemaDef);
  repeated.forEach((key, objectField) => {
    const base = convertSchemaType(objectField.type);
    if (base !== null) {
      if (base.type === "inline") {
        repeated.delete(objectField);
        return;
      }
      if (base.type === "unknown") {
        repeated.delete(objectField);
        return;
      }
      schema.push({
        type: "type",
        name: key,
        value: base
      });
    }
  }), sortedSchemaTypeNames.forEach((typeName) => {
    const schemaType = schemaDef.get(typeName);
    if (schemaType === void 0)
      return;
    const base = convertBaseType(schemaType);
    base !== null && (base.type === "type" && inlineFields.add(schemaType), base.type === "document" && documentTypes.set(typeName, base), schema.push(base));
  });
  function reserveRefName(refName) {
    const name = hoistedRefMap.get(refName);
    if (name) return name;
    for (let i = 0; i < 5; i++) {
      const uniqueName = `${refName}${i || ""}`;
      if (!schemaDef.has(uniqueName))
        return hoistedRefMap.set(refName, uniqueName), uniqueName;
    }
    return null;
  }
  function convertBaseType(schemaType) {
    let typeName;
    if (schemaType.type ? typeName = schemaType.type.name : "jsonType" in schemaType && (typeName = schemaType.jsonType), typeName === "document" && isObjectType(schemaType)) {
      const defaultAttributes = documentDefaultFields(schemaType.name), object2 = createObject(schemaType);
      return object2.type === "unknown" ? null : {
        name: schemaType.name,
        type: "document",
        attributes: {
          ...defaultAttributes,
          ...object2.attributes
        }
      };
    }
    const value = convertSchemaType(schemaType);
    return value.type === "unknown" ? null : value.type === "object" ? (value.attributes = {
      _type: {
        type: "objectAttribute",
        value: {
          type: "string",
          value: schemaType.name
        }
      },
      ...value.attributes
    }, {
      name: schemaType.name,
      type: "type",
      value
    }) : {
      name: schemaType.name,
      type: "type",
      value
    };
  }
  function convertSchemaType(schemaType) {
    if (inlineFields.has(schemaType.type))
      return { type: "inline", name: schemaType.type.name };
    if (schemaType.type?.name && sortedSchemaTypeNames.indexOf(schemaType.type?.name) > -1)
      return { type: "inline", name: schemaType.type?.name };
    if (isStringType(schemaType))
      return createStringTypeNodeDefintion(schemaType);
    if (isNumberType(schemaType))
      return createNumberTypeNodeDefintion(schemaType);
    if (schemaType.type && typesMap.has(schemaType.type.name))
      return typesMap.get(schemaType.type.name);
    if (isCrossDatasetReferenceType(schemaType))
      return { type: "unknown" };
    if (isGlobalDocumentReferenceType(schemaType))
      return { type: "unknown" };
    if (isReferenceType(schemaType))
      return createReferenceTypeNodeDefintion(schemaType);
    if (isArrayType(schemaType))
      return createArray(schemaType);
    if (isObjectType(schemaType))
      return createObject(schemaType);
    if (lastType(schemaType)?.name === "document") {
      const doc = documentTypes.get(schemaType.name);
      return doc === void 0 ? { type: "unknown" } : { type: "object", attributes: doc?.attributes };
    }
    throw new Error(`Type "${schemaType.name}" not found`);
  }
  function createObject(schemaType) {
    const attributes = {}, fields = gatherFields(schemaType);
    for (const field of fields) {
      const fieldIsRequired = isFieldRequired(field?.type?.validation);
      let value;
      const hoisted = repeated.get(field), isTopLevelSchemaType = sortedSchemaTypeNames.includes(field.type.name);
      if (hoisted && !isTopLevelSchemaType)
        value = {
          type: "inline",
          name: hoisted
        };
      else {
        if (value = convertSchemaType(field.type), value === null)
          continue;
        hasAssetRequired(field?.type?.validation) && value.type === "object" && (value.attributes.asset.optional = !1);
      }
      const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === !1 : !0;
      attributes[field.name] = {
        type: "objectAttribute",
        value,
        optional
      };
    }
    return extractOptions.enforceRequiredFields && hasAssetRequired(schemaType.validation) && attributes.asset && (attributes.asset.optional = !1), Object.keys(attributes).length === 0 ? { type: "unknown" } : (schemaType.type?.name !== "document" && schemaType.name !== "object" && (attributes._type = {
      type: "objectAttribute",
      value: {
        type: "string",
        value: schemaType.name
      }
    }), {
      type: "object",
      attributes
    });
  }
  function createArray(arraySchemaType) {
    const of = [];
    for (const item of arraySchemaType.of) {
      const field = convertSchemaType(item);
      field.type === "inline" ? of.push({
        type: "object",
        attributes: {
          _key: createKeyField()
        },
        rest: field
      }) : (field.type === "object" && (field.rest = {
        type: "object",
        attributes: {
          _key: createKeyField()
        }
      }), of.push(field));
    }
    return of.length === 0 ? { type: "null" } : {
      type: "array",
      of: of.length > 1 ? {
        type: "union",
        of
      } : of[0]
    };
  }
  function createReferenceTypeNodeDefintion(reference2) {
    const references = gatherReferenceNames(reference2);
    for (const name of references) {
      const refName = getInlineRefName(name);
      if (!hoistedRefMap.has(refName)) {
        const inlined = reserveRefName(refName);
        inlined && schema.push({
          type: "type",
          name: inlined,
          value: createReferenceTypeNode(name)
        });
      }
    }
    if (references.length === 1) {
      const inlined = hoistedRefMap.get(getInlineRefName(references[0]));
      return inlined ? { type: "inline", name: inlined } : createReferenceTypeNode(references[0]);
    }
    return {
      type: "union",
      of: references.map((name) => {
        const inlined = hoistedRefMap.get(getInlineRefName(name));
        return inlined ? { type: "inline", name: inlined } : createReferenceTypeNode(name);
      })
    };
  }
  return schema;
}
function getInlineRefName(typeName) {
  return `${typeName}.reference`;
}
function createKeyField() {
  return {
    type: "objectAttribute",
    value: {
      type: "string"
    }
  };
}
function isFieldRequired(validation) {
  if (!validation)
    return !1;
  const rules = Array.isArray(validation) ? validation : [validation];
  for (const rule of rules) {
    let required = !1;
    const proxy = new Proxy(
      {},
      {
        get: (target, methodName) => () => (methodName === "required" && (required = !0), proxy)
      }
    );
    if (typeof rule == "function" && (rule(proxy), required) || typeof rule == "object" && rule !== null && "_required" in rule && rule._required === "required")
      return !0;
  }
  return !1;
}
function hasAssetRequired(validation) {
  if (!validation)
    return !1;
  const rules = Array.isArray(validation) ? validation : [validation];
  for (const rule of rules) {
    let assetRequired = !1;
    const proxy = new Proxy(
      {},
      {
        get: (target, methodName) => () => (methodName === "assetRequired" && (assetRequired = !0), proxy)
      }
    );
    if (typeof rule == "function" && (rule(proxy), assetRequired) || typeof rule == "object" && rule !== null && "_rules" in rule && Array.isArray(rule._rules) && rule._rules.some((r) => r.flag === "assetRequired"))
      return !0;
  }
  return !1;
}
function isObjectType(typeDef) {
  return isType(typeDef, "object") || typeDef.jsonType === "object" || "fields" in typeDef;
}
function isArrayType(typeDef) {
  return isType(typeDef, "array");
}
function isReferenceType(typeDef) {
  return isType(typeDef, "reference");
}
function isCrossDatasetReferenceType(typeDef) {
  return isType(typeDef, "crossDatasetReference");
}
function isGlobalDocumentReferenceType(typeDef) {
  return isType(typeDef, "globalDocumentReference");
}
function isStringType(typeDef) {
  return isType(typeDef, "string");
}
function isNumberType(typeDef) {
  return isType(typeDef, "number");
}
function createStringTypeNodeDefintion(stringSchemaType) {
  const listOptions = stringSchemaType.options?.list;
  return listOptions && Array.isArray(listOptions) ? {
    type: "union",
    of: listOptions.map((v) => ({
      type: "string",
      value: typeof v == "string" ? v : v.value
    }))
  } : {
    type: "string"
  };
}
function createNumberTypeNodeDefintion(numberSchemaType) {
  const listOptions = numberSchemaType.options?.list;
  return listOptions && Array.isArray(listOptions) ? {
    type: "union",
    of: listOptions.map((v) => ({
      type: "number",
      value: typeof v == "number" ? v : v.value
    }))
  } : {
    type: "number"
  };
}
function gatherReferenceNames(type) {
  const allReferences = gatherReferenceTypes(type);
  return [...new Set(allReferences.map((ref) => ref.name))];
}
function gatherReferenceTypes(type) {
  const refTo = "to" in type ? type.to : [];
  return "type" in type && isReferenceType(type.type) ? [...gatherReferenceTypes(type.type), ...refTo] : refTo;
}
function gatherFields(type) {
  return "fields" in type ? type.type ? gatherFields(type.type).concat(type.fields) : type.fields : [];
}
function isType(typeDef, typeName) {
  let type = typeDef;
  for (; type; ) {
    if (type.name === typeName || type.type && type.type.name === typeName)
      return !0;
    type = type.type;
  }
  return !1;
}
function lastType(typeDef) {
  let type = typeDef;
  for (; type; ) {
    if (!type.type)
      return type;
    type = type.type;
  }
}
function sortByDependencies(compiledSchema) {
  const seen = /* @__PURE__ */ new Set(), objectMap = /* @__PURE__ */ new Set(), repeated = /* @__PURE__ */ new Map(), repeatedNames = /* @__PURE__ */ new Set();
  function pickRepeatedName(path) {
    for (let idx = path.length - 1; idx >= 1; idx--) {
      const name = path.slice(idx).join(".");
      if (!repeatedNames.has(name) && !compiledSchema.get(name))
        return repeatedNames.add(name), name;
    }
    for (let i = 1; i < 10; i++)
      for (let idx = path.length - 1; idx >= 1; idx--) {
        const name = `${path.slice(idx).join(".")}${i}`;
        if (!repeatedNames.has(name) && !compiledSchema.get(name))
          return repeatedNames.add(name), name;
      }
    return null;
  }
  function walkDependencies(schemaType, dependencies, path, hoistRepetitions = !0) {
    if (!seen.has(schemaType)) {
      if (seen.add(schemaType), "fields" in schemaType)
        for (const field of gatherFields(schemaType)) {
          const last = lastType(field.type);
          if (last.name === "document") {
            dependencies.add(last);
            continue;
          }
          let schemaTypeName;
          if (schemaType.type.type ? schemaTypeName = field.type.type.name : "jsonType" in schemaType.type && (schemaTypeName = field.type.jsonType), schemaTypeName === "object" || schemaTypeName === "block") {
            if (isReferenceType(field.type))
              field.type.to.forEach((ref) => dependencies.add(ref.type));
            else if (dependencies.add(field.type), hoistRepetitions && !validSchemaNames.has(field.type.name)) {
              const fieldPath = path.concat([field.name]);
              if (!repeated.has(field) && objectMap.has(field)) {
                const name = pickRepeatedName(fieldPath);
                name !== null && repeated.set(field, name);
              }
              objectMap.add(field);
            }
          } else field.type && dependencies.add(field.type);
          walkDependencies(field.type, dependencies, path.concat([field.name]));
        }
      else if ("of" in schemaType)
        for (const item of schemaType.of)
          walkDependencies(item, dependencies, path.concat(item.name), !isReferenceType(schemaType));
    }
  }
  const dependencyMap = /* @__PURE__ */ new Map(), schemaTypeNames = compiledSchema.getTypeNames(), validSchemaNames = /* @__PURE__ */ new Set();
  schemaTypeNames.forEach((typeName) => {
    const schemaType = compiledSchema.get(typeName);
    if (schemaType === void 0 || schemaType.type === null)
      return;
    validSchemaNames.add(typeName);
    const dependencies = /* @__PURE__ */ new Set();
    walkDependencies(schemaType, dependencies, [typeName]), dependencyMap.set(schemaType, dependencies), seen.clear();
  });
  const typeNames = [], currentlyVisiting = /* @__PURE__ */ new Set(), visited = /* @__PURE__ */ new Set();
  function visit(type) {
    if (visited.has(type) || currentlyVisiting.has(type))
      return;
    currentlyVisiting.add(type);
    const deps = dependencyMap.get(type);
    deps !== void 0 && deps.forEach((dep) => visit(dep)), currentlyVisiting.delete(type), visited.add(type), typeNames.includes(type.name) && typeNames.splice(typeNames.indexOf(type.name), 1), typeNames.unshift(type.name);
  }
  for (const [type] of dependencyMap)
    visit(type);
  return {
    sortedSchemaTypeNames: typeNames.filter((typeName) => validSchemaNames.has(typeName)),
    repeated
  };
}
function validateNoCallbacks(typeDef) {
  const problems = [];
  return problems.push(...validateConditionalProperties(typeDef)), problems.push(...validateValueProperties(typeDef)), problems.push(...validateComponents(typeDef)), problems.push(...validateOptions(typeDef)), problems.push(...validateFieldsetsAndGroups(typeDef)), problems.push(...validateBlockSpecific(typeDef)), problems;
}
function validateConditionalProperties(typeDef) {
  const problems = [];
  return typeof typeDef.hidden == "function" && problems.push(
    error('The "hidden" property cannot be a function. Use a static boolean value instead.')
  ), typeof typeDef.readOnly == "function" && problems.push(
    error('The "readOnly" property cannot be a function. Use a static boolean value instead.')
  ), problems;
}
function validateValueProperties(typeDef) {
  const problems = [];
  return typeof typeDef.initialValue == "function" && problems.push(
    error('The "initialValue" property cannot be a function. Use a static value instead.')
  ), typeof typeDef.validation == "function" && problems.push(
    error('The "validation" property cannot be a function. Use static validation rules instead.')
  ), typeDef.validation && typeof typeDef.validation == "object" && checkForCustomValidators(typeDef.validation) && problems.push(
    error("Custom validation functions are not supported. Use only built-in validation rules.")
  ), typeDef.preview?.prepare && typeof typeDef.preview.prepare == "function" && problems.push(error('The "preview.prepare" property cannot be a function.')), typeDef.blockEditor?.render && problems.push(error('The "blockEditor.render" property cannot be a function.')), problems;
}
function validateComponents(typeDef) {
  const problems = [];
  if (!typeDef.components)
    return problems;
  const componentProps = [
    "input",
    "field",
    "item",
    "preview",
    "diff",
    "block",
    "inlineBlock",
    "annotation"
  ];
  for (const prop of componentProps)
    typeDef.components[prop] && isComponentLike(typeDef.components[prop]) && problems.push(error(`The "components.${prop}" property cannot be a component function.`));
  return typeDef.components.portableText?.plugins && problems.push(
    error('The "components.portableText.plugins" property cannot contain plugin functions.')
  ), problems;
}
function validateOptions(typeDef) {
  const problems = [];
  return !typeDef.options || typeof typeDef.options != "object" || (problems.push(...validateCommonOptions(typeDef.options)), problems.push(...validateAssetSources(typeDef.options)), problems.push(...validateOtherFunctionOptions(typeDef.options))), problems;
}
function validateCommonOptions(options) {
  const problems = [];
  return typeof options.filter == "function" && problems.push(
    error(
      'The "options.filter" property cannot be a function. Use a static GROQ filter string with filterParams instead.'
    )
  ), typeof options.source == "function" && problems.push(
    error(
      'The "options.source" property cannot be a function. Use a static string path instead.'
    )
  ), typeof options.slugify == "function" && problems.push(error('The "options.slugify" property cannot be a function.')), typeof options.isUnique == "function" && problems.push(error('The "options.isUnique" property cannot be a function.')), problems;
}
function validateAssetSources(options) {
  const problems = [];
  if (!Array.isArray(options.sources))
    return problems;
  for (let i = 0; i < options.sources.length; i++) {
    const source = options.sources[i];
    source && (source.component && isComponentLike(source.component) && problems.push(
      error(`Asset source at index ${i} has a "component" property that cannot be a function.`)
    ), source.icon && isComponentLike(source.icon) && problems.push(
      error(`Asset source at index ${i} has an "icon" property that cannot be a component.`)
    ), (typeof source == "function" || source.Uploader) && problems.push(error(`Asset source at index ${i} contains functions or classes.`)));
  }
  return problems;
}
function validateOtherFunctionOptions(options) {
  const problems = [], knownFunctionOptions = ["filter", "source", "slugify", "isUnique"];
  for (const [key, value] of Object.entries(options))
    typeof value == "function" && !knownFunctionOptions.includes(key) && problems.push(error(`The "options.${key}" property cannot be a function.`));
  return problems;
}
function validateFieldsetsAndGroups(typeDef) {
  const problems = [];
  return problems.push(...validateFieldsets(typeDef.fieldsets)), problems.push(...validateGroups(typeDef.groups)), problems;
}
function validateFieldsets(fieldsets) {
  const problems = [];
  if (!Array.isArray(fieldsets))
    return problems;
  for (let i = 0; i < fieldsets.length; i++) {
    const fieldset = fieldsets[i];
    fieldset && (typeof fieldset.hidden == "function" && problems.push(
      error(`Fieldset at index ${i} has a "hidden" property that cannot be a function.`)
    ), typeof fieldset.readOnly == "function" && problems.push(
      error(`Fieldset at index ${i} has a "readOnly" property that cannot be a function.`)
    ));
  }
  return problems;
}
function validateGroups(groups) {
  const problems = [];
  if (!Array.isArray(groups))
    return problems;
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    group && (typeof group.hidden == "function" && problems.push(
      error(`Field group at index ${i} has a "hidden" property that cannot be a function.`)
    ), group.icon && isComponentLike(group.icon) && problems.push(
      error(`Field group at index ${i} has an "icon" property that cannot be a component.`)
    ));
  }
  return problems;
}
function validateBlockSpecific(typeDef) {
  const problems = [];
  return typeDef.type !== "block" || (problems.push(...validateBlockStyles(typeDef.styles)), problems.push(...validateBlockMarks(typeDef.marks))), problems;
}
function validateBlockStyles(styles) {
  const problems = [];
  if (!Array.isArray(styles))
    return problems;
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    style?.component && isComponentLike(style.component) && problems.push(
      error(`Block style at index ${i} has a "component" property that cannot be a function.`)
    );
  }
  return problems;
}
function validateBlockMarks(marks) {
  const problems = [];
  if (!marks)
    return problems;
  if (Array.isArray(marks.decorators))
    for (let i = 0; i < marks.decorators.length; i++) {
      const decorator = marks.decorators[i];
      decorator?.component && isComponentLike(decorator.component) && problems.push(
        error(
          `Block decorator at index ${i} has a "component" property that cannot be a function.`
        )
      );
    }
  if (Array.isArray(marks.annotations))
    for (let i = 0; i < marks.annotations.length; i++) {
      const annotation = marks.annotations[i];
      annotation?.component && isComponentLike(annotation.component) && problems.push(
        error(
          `Block annotation at index ${i} has a "component" property that cannot be a function.`
        )
      );
    }
  return problems;
}
function checkForCustomValidators(validation) {
  if (!validation) return !1;
  if (Array.isArray(validation))
    return validation.some((v) => checkForCustomValidators(v));
  if (typeof validation == "object") {
    if (Array.isArray(validation._rules))
      return validation._rules.some((rule) => rule.flag === "custom" && typeof rule.constraint == "function");
    if (typeof validation.custom == "function")
      return !0;
  }
  return !1;
}
function unsupportedTypeValidator(typeLabel) {
  return function() {
    return {
      _problems: [
        {
          severity: "error",
          message: `Type unsupported in Media Library aspects: ${typeLabel}.`
        }
      ]
    };
  };
}
function noCallbacksVisitor(typeDef, visitorContext) {
  return {
    ...typeDef,
    _problems: validateNoCallbacks(typeDef)
  };
}
function validateMediaLibraryAssetAspect(maybeAspect) {
  const validated = validateSchema([maybeAspect], {
    transformCommonVisitors: (visitors) => [...visitors, noCallbacksVisitor],
    transformTypeVisitors: (typeVisitors2) => ({
      ...typeVisitors2,
      document: unsupportedTypeValidator("document"),
      image: unsupportedTypeValidator("image"),
      file: unsupportedTypeValidator("file"),
      video: unsupportedTypeValidator("sanity.video"),
      reference: unsupportedTypeValidator("reference"),
      crossDatasetReference: unsupportedTypeValidator("cross dataset reference")
    })
  }), errors = groupProblems(validated.getTypes()).map((group) => group.problems.filter(({ severity }) => severity === "error")).filter((problems) => problems.length);
  return [errors.length === 0, errors];
}
export {
  ALL_FIELDS_GROUP_NAME,
  DEFAULT_MAX_FIELD_DEPTH,
  DescriptorConverter,
  ValidationError,
  builtinTypes,
  createSchemaFromManifestTypes,
  extractSchema,
  groupProblems,
  isActionEnabled,
  processSchemaSynchronization,
  resolveSearchConfig,
  resolveSearchConfigForBaseFieldPaths,
  validateMediaLibraryAssetAspect,
  validateSchema
};
//# sourceMappingURL=_internal.js.map
