{"version":3,"file":"_internal.js","sources":["../src/descriptors/scheduler.ts","../src/descriptors/convert.ts","../src/descriptors/sync.ts","../src/legacy/actionUtils.ts","../src/sanity/builtinTypes/assetSourceData.ts","../src/sanity/builtinTypes/fileAsset.ts","../src/sanity/builtinTypes/geopoint.ts","../src/sanity/builtinTypes/imageAsset.ts","../src/sanity/builtinTypes/imageCrop.ts","../src/sanity/builtinTypes/imageDimensions.ts","../src/sanity/builtinTypes/imageHotspot.ts","../src/sanity/builtinTypes/imageMetadata.ts","../src/sanity/builtinTypes/imagePalette.ts","../src/sanity/builtinTypes/imagePaletteSwatch.ts","../src/sanity/builtinTypes/slug.ts","../src/sanity/builtinTypes/index.ts","../src/sanity/validation/createValidationResult.ts","../src/sanity/groupProblems.ts","../src/sanity/validation/utils/getDupes.ts","../src/core/traverseSchema.ts","../src/sanity/coreTypes.ts","../src/sanity/traverseSchema.ts","../src/sanity/validation/types/array.ts","../src/sanity/validation/utils/isJSONTypeOf.ts","../src/sanity/validation/types/block.ts","../src/sanity/validation/utils/validateNonObjectFieldsProp.ts","../src/sanity/validation/utils/validateTypeName.ts","../src/sanity/validation/types/deprecated.ts","../src/sanity/validation/types/common.ts","../src/sanity/validation/types/crossDatasetReference.ts","../src/sanity/validation/utils/isComponent.ts","../src/sanity/validation/utils/validateComponent.ts","../src/sanity/validation/types/object.ts","../src/sanity/validation/types/document.ts","../src/sanity/validation/types/file.ts","../src/sanity/validation/types/globalDocumentReference.ts","../src/sanity/validation/types/image.ts","../src/sanity/validation/types/reference.ts","../src/sanity/validation/types/rootType.ts","../src/sanity/validation/types/slug.ts","../src/sanity/validateSchema.ts","../src/sanity/validation/ValidationError.ts","../src/sanity/createSchemaFromManifestTypes.ts","../src/sanity/extractSchema.ts","../src/sanity/validation/utils/validateNoCallbacks.ts","../src/sanity/validateMediaLibraryAssetAspect.ts"],"sourcesContent":["/** The scheduler is capable of executing work in different ways. */\nexport type Scheduler = {\n  map<T, U>(arr: T[], fn: (val: T) => U): Promise<U[]>\n  forEach<T>(arr: T[], fn: (val: T) => void): Promise<void>\n  forEachIter<T>(iter: Iterable<T>, fn: (val: T) => void): Promise<void>\n}\n\n/**\n * How long we're willing to do work before invoking the idle callback.\n * This is set to 50% of the budget of maintaining 60 FPS.\n */\nconst MAX_IDLE_WORK = 0.5 * (1000 / 60)\n\n/** A scheduler which uses an idle callback to process work. */\nexport class IdleScheduler implements Scheduler {\n  #durations: number[] = []\n  #lastAwake: number\n\n  constructor(durations: number[]) {\n    this.#lastAwake = performance.now()\n    this.#durations = durations\n  }\n\n  async map<T, U>(arr: T[], fn: (val: T) => U): Promise<U[]> {\n    const result: U[] = []\n    for (const val of arr) {\n      const pause = this._tryPause()\n      if (pause) await pause\n      result.push(fn(val))\n    }\n    return result\n  }\n\n  async forEach<T>(arr: T[], fn: (val: T) => void): Promise<void> {\n    for (const val of arr) {\n      const pause = this._tryPause()\n      if (pause) await pause\n      fn(val)\n    }\n  }\n\n  async forEachIter<T>(iter: Iterable<T>, fn: (val: T) => void): Promise<void> {\n    for (const val of iter) {\n      const pause = this._tryPause()\n      if (pause) await pause\n      fn(val)\n    }\n  }\n\n  /** Should be invoked at the end to also measure the last pause. */\n  end() {\n    this.#durations.push(performance.now() - this.#lastAwake)\n  }\n\n  /**\n   * Yields control back to the UI.\n   */\n  private _tryPause(): Promise<void> | undefined {\n    // Record how much time we've used so far:\n    const now = performance.now()\n    const elapsed = now - this.#lastAwake\n    if (elapsed < MAX_IDLE_WORK) {\n      // We're willing to do more work!\n      return undefined\n    }\n\n    this.#durations.push(elapsed)\n\n    return new Promise((resolve) => {\n      const done = () => {\n        this.#lastAwake = performance.now()\n        resolve()\n      }\n\n      if (typeof requestIdleCallback === 'function') {\n        requestIdleCallback(done, {timeout: 1})\n      } else if (typeof requestAnimationFrame === 'function') {\n        requestAnimationFrame(done)\n      } else {\n        setTimeout(done, 0)\n      }\n    })\n  }\n}\n\n/** A scheduler which does the work as synchronous as possible. */\nexport const SYNC_SCHEDULER: Scheduler = {\n  async map<T, U>(arr: T[], fn: (val: T) => U): Promise<U[]> {\n    return arr.map(fn)\n  },\n\n  async forEach<T>(arr: T[], fn: (val: T) => void): Promise<void> {\n    return arr.forEach(fn)\n  },\n\n  async forEachIter<T>(iter: Iterable<T>, fn: (val: T) => void): Promise<void> {\n    for (const val of iter) {\n      fn(val)\n    }\n  },\n}\n","import {\n  type EncodableObject,\n  type EncodableValue,\n  SetBuilder,\n  type SetSynchronization,\n} from '@sanity/descriptors'\nimport {\n  type ArraySchemaType,\n  type FieldGroupDefinition,\n  type FieldsetDefinition,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule as IRule,\n  type Schema,\n  type SchemaType,\n} from '@sanity/types'\nimport {isEqual, isObject} from 'lodash-es'\n\nimport {Rule} from '../legacy/Rule'\nimport {OWN_PROPS_NAME} from '../legacy/types/constants'\nimport {IdleScheduler, type Scheduler, SYNC_SCHEDULER} from './scheduler'\nimport {\n  type ArrayElement,\n  type ArrayTypeDef,\n  type CommonTypeDef,\n  type CoreTypeDef,\n  type CyclicMarker,\n  type DepthMarker,\n  type FieldReference,\n  type FunctionMarker,\n  type JSXMarker,\n  type ObjectField,\n  type ObjectFieldset,\n  type ObjectGroup,\n  type ObjectI18n,\n  type ObjectI18nValue,\n  type ObjectMessage,\n  type ObjectOrdering,\n  type ObjectOrderingBy,\n  type ReferenceTypeDef,\n  type RegistryType,\n  type Rule as RuleType,\n  type SubtypeDef,\n  type TypeDef,\n  type UndefinedMarker,\n  type UnknownMarker,\n  type Validation,\n  type ValidationMessage,\n} from './types'\n\nconst MAX_DEPTH_UKNOWN = 5\n\ntype UnknownRecord<T> = {[P in keyof T]: unknown}\n\nexport class DescriptorConverter {\n  cache: WeakMap<Schema, SetSynchronization<RegistryType>> = new WeakMap()\n\n  /**\n   * Returns a synchronization object for a schema.\n   *\n   * This is automatically cached in a weak map.\n   */\n  async get(\n    schema: Schema,\n    opts?: {\n      /**\n       * If present, this will use an idle scheduler which records duration into this array.\n       * This option will be ignored if the `scheduler` option is passed in.\n       **/\n      pauseDurations?: number[]\n\n      /** An explicit scheduler to do the work. */\n      scheduler?: Scheduler\n    },\n  ): Promise<SetSynchronization<RegistryType>> {\n    /*\n      Converting the schema into a descriptor consists of two parts:\n\n      1. Traversing the type into a descriptor.\n      2. Serializing the descriptor, including SHA256 hashing.\n\n      Note that only (2) can be done in a background worker since the type\n      itself isn't serializable (which is a requirement for a background\n      worker). In addition, we expect (2) to scale in the same way as (1): If it\n      takes X milliseconds to traverse the type into a descriptor it will\n      probably take c*X milliseconds to serialize it.\n\n      This means that a background worker actually doesn't give us that much\n      value. A huge type will either way be expensive to convert from a type to\n      a descriptor. Therefore this function currently only avoid blocking by\n      only processing each type separately.\n\n      If we want to minimize the blocking further we would have to restructure\n      this converter to be able to convert the types asynchronously and _then_\n      it might make sense to the serialization step itself in a background\n      worker.\n    */\n    let value = this.cache.get(schema)\n    if (value) return value\n\n    let idleScheduler: IdleScheduler | undefined\n    const scheduler =\n      opts?.scheduler ||\n      (opts?.pauseDurations\n        ? (idleScheduler = new IdleScheduler(opts.pauseDurations))\n        : SYNC_SCHEDULER)\n\n    const options: Options = {\n      fields: new Map(),\n      duplicateFields: new Map(),\n      arrayElements: new Map(),\n      duplicateArrayElements: new Map(),\n    }\n\n    const namedTypes = await scheduler.map(schema.getLocalTypeNames(), (name) => {\n      const typeDef = convertTypeDef(schema.get(name)!, name, options)\n      return {name, typeDef}\n    })\n\n    const rewriteMap = new Map<EncodableObject, EncodableObject>()\n\n    // First we populate the rewrite map with the duplications:\n    for (const [fieldDef, key] of options.duplicateFields.entries()) {\n      rewriteMap.set(fieldDef, {__type: 'hoisted', key})\n    }\n\n    for (const [arrayElem, key] of options.duplicateArrayElements.entries()) {\n      rewriteMap.set(arrayElem, {__type: 'hoisted', key})\n    }\n\n    const builder = new SetBuilder({rewriteMap})\n\n    // Now we can build the de-duplicated objects:\n    await scheduler.forEachIter(options.duplicateFields.entries(), ([fieldDef, key]) => {\n      builder.addObject('sanity.schema.hoisted', {key, value: {...fieldDef}})\n    })\n\n    await scheduler.forEachIter(options.duplicateArrayElements.entries(), ([arrayElem, key]) => {\n      builder.addObject('sanity.schema.hoisted', {key, value: {...arrayElem}})\n    })\n\n    await scheduler.forEach(namedTypes, (namedType) => {\n      builder.addObject('sanity.schema.namedType', namedType)\n    })\n\n    if (schema.parent) {\n      builder.addSet(await this.get(schema.parent, {scheduler}))\n    }\n\n    value = builder.build('sanity.schema.registry')\n    this.cache.set(schema, value)\n\n    // If we created the scheduler we also need to end it.\n    if (idleScheduler) idleScheduler.end()\n    return value\n  }\n}\n\nfunction convertCommonTypeDef(schemaType: SchemaType, path: string, opts: Options): CommonTypeDef {\n  // Note that OWN_PROPS_NAME is only set on subtypes, not the core types.\n  // We might consider setting OWN_PROPS_NAME on _all_ types to avoid this branch.\n  const ownProps = OWN_PROPS_NAME in schemaType ? (schemaType as any)[OWN_PROPS_NAME] : schemaType\n\n  let fields: ObjectField[] | undefined\n  if (Array.isArray(ownProps.fields)) {\n    fields = (ownProps.fields as ObjectSchemaType['fields']).map((field) => {\n      const fieldPath = `${path}.${field.name}`\n      const value = opts.fields.get(field)\n      if (value) {\n        // We've seen it before. Mark it as duplicate.\n        const otherPath = opts.duplicateFields.get(value)\n        // We always keep the _smallest_ path around.\n        if (!otherPath || isLessCanonicalName(fieldPath, otherPath))\n          opts.duplicateFields.set(value, fieldPath)\n        return value\n      }\n\n      const {name, group, fieldset, type} = field\n      const converted: ObjectField = {\n        name,\n        typeDef: convertTypeDef(type, fieldPath, opts),\n        groups: arrayifyString(group),\n        fieldset,\n      }\n      opts.fields.set(field, converted)\n      return converted\n    })\n  }\n\n  let fieldsets: ObjectFieldset[] | undefined\n  if (Array.isArray(ownProps.fieldsets)) {\n    fieldsets = filterStringKey(\n      'name',\n      (ownProps.fieldsets as Array<UnknownRecord<FieldsetDefinition>>).map(\n        ({name, title, description, group, hidden, readOnly, options}) => ({\n          name,\n          title: maybeString(title),\n          description: maybeString(description),\n          group: maybeString(group),\n          hidden: conditionalTrue(hidden),\n          readOnly: conditionalTrue(readOnly),\n          options: convertUnknown(options),\n        }),\n      ),\n    )\n  }\n\n  let groups: ObjectGroup[] | undefined\n  if (Array.isArray(ownProps.groups)) {\n    groups = filterStringKey(\n      'name',\n      (ownProps.groups as Array<UnknownRecord<FieldGroupDefinition>>).map(\n        ({name, title, hidden, default: def, i18n}) => ({\n          name,\n          title: maybeString(title),\n          hidden: conditionalTrue(hidden),\n          default: maybeTrue(def),\n          i18n: maybeI18n(i18n),\n        }),\n      ),\n    )\n  }\n\n  const reason = ownProps.deprecated?.reason\n\n  let orderings: ObjectOrdering[] | undefined\n  if (Array.isArray(ownProps.orderings)) {\n    orderings = ownProps.orderings\n      .map(maybeOrdering)\n      .filter((o: ObjectOrdering | undefined) => o !== undefined)\n  }\n\n  return {\n    title: maybeString(ownProps.title),\n    description: maybeStringOrJSX(ownProps.description),\n    readOnly: conditionalTrue(ownProps.readOnly),\n    hidden: conditionalTrue(ownProps.hidden),\n    liveEdit: maybeTrue(ownProps.liveEdit),\n    options: convertUnknown(ownProps.options),\n    initialValue: convertUnknown(ownProps.initialValue),\n    deprecated: typeof reason === 'string' ? {reason} : undefined,\n    placeholder: maybeString(ownProps.placeholder),\n    rows: maybeNumberAsString(ownProps.rows),\n    fields,\n    fieldsets,\n    groups,\n    validation: maybeValidations(ownProps),\n    orderings,\n  }\n}\n\ntype Options = {\n  /** Mapping of fields to descriptor value. Used for de-duping. */\n  fields: Map<object, ObjectField>\n\n  /**\n   * Once a field has been seen twice it's inserted into this map.\n   * The value here is the canonical name.\n   **/\n  duplicateFields: Map<ObjectField, string>\n\n  /** Mapping of array element to descriptor value. Used for de-duping. */\n  arrayElements: Map<object, ArrayElement>\n\n  /**\n   * Once an array element has been seen twice it's inserted into this map.\n   * The value here is the canonical name.\n   **/\n  duplicateArrayElements: Map<ArrayElement, string>\n}\n\nexport function convertTypeDef(schemaType: SchemaType, path: string, opts: Options): TypeDef {\n  const common = convertCommonTypeDef(schemaType, path, opts)\n\n  if (!schemaType.type) {\n    return {\n      extends: null,\n      jsonType: schemaType.jsonType,\n      ...common,\n    } satisfies CoreTypeDef\n  }\n\n  // The types below are somewhat magical: It's only direct subtypes of array/reference which\n  // are allowed to have of/to assigned to them. We handle them specifically here since this\n  // gives us more control over the types.\n\n  switch (schemaType.type.name) {\n    case 'array': {\n      return {\n        extends: 'array',\n        of: (schemaType as ArraySchemaType).of.map((ofType, idx) => {\n          const itemPath = `${path}.${ofType.name}`\n          const value = opts.arrayElements.get(ofType)\n          if (value) {\n            // We've seen it before. Mark it as duplicate.\n            const otherPath = opts.duplicateArrayElements.get(value)\n            // We always keep the _smallest_ path around.\n            if (!otherPath || isLessCanonicalName(itemPath, otherPath))\n              opts.duplicateArrayElements.set(value, itemPath)\n            return value\n          }\n          const converted: ArrayElement = {\n            name: ofType.name,\n            typeDef: convertTypeDef(ofType, `${path}.${ofType.name}`, opts),\n          }\n          opts.arrayElements.set(ofType, converted)\n          return converted\n        }),\n        ...common,\n      } satisfies ArrayTypeDef\n    }\n    case 'reference':\n    case 'globalDocumentReference':\n    case 'crossDatasetReference':\n      return {\n        extends: schemaType.type.name,\n        to: filterStringKey(\n          'name',\n          (schemaType as ReferenceSchemaType).to\n            // The `toType.type` case is for crossDatasetReferences/crossDatasetReference\n            .map((toType) => ({name: toType.name || toType.type?.name || toType.type})),\n        ),\n        ...common,\n      } satisfies ReferenceTypeDef\n    default:\n      return {extends: schemaType.type.name, ...common} satisfies SubtypeDef\n  }\n}\n\nfunction maybeString(val: unknown): string | undefined {\n  return typeof val === 'string' ? val : undefined\n}\n\nfunction maybeNumberAsString(val: unknown): string | undefined {\n  return typeof val === 'number' ? val.toString() : undefined\n}\n\n/** Returns `true` for `true` and undefined for everything else. */\nfunction maybeTrue(val: unknown): true | undefined {\n  return val === true ? true : undefined\n}\n\nfunction conditionalTrue(val: unknown): true | undefined | FunctionMarker {\n  if (typeof val === 'function') return FUNCTION_MARKER\n  return maybeTrue(val)\n}\n\nfunction filterStringKey<T, K extends keyof T>(key: K, arr: T[]): Array<T & {[key in K]: string}> {\n  return arr.filter((obj): obj is T & {[key in K]: string} => typeof obj[key] === 'string')\n}\n\nfunction arrayifyString(val: unknown): string[] | undefined {\n  if (typeof val === 'string') {\n    return [val]\n  }\n\n  if (Array.isArray(val)) {\n    return val.filter((elem) => typeof elem === 'string')\n  }\n\n  return undefined\n}\n\nconst FUNCTION_MARKER: FunctionMarker = {__type: 'function'}\nconst UNKNOWN_MARKER: UnknownMarker = {__type: 'unknown'}\nconst UNDEFINED_MARKER: UndefinedMarker = {__type: 'undefined'}\nconst CYCLIC_MARKER: CyclicMarker = {__type: 'cyclic'}\nconst MAX_DEPTH_MARKER: DepthMarker = {__type: 'maxDepth'}\n\nfunction convertUnknown(\n  val: unknown,\n  seen = new Set(),\n  maxDepth = MAX_DEPTH_UKNOWN,\n): EncodableValue | undefined {\n  if (maxDepth === 0) return MAX_DEPTH_MARKER\n\n  if (typeof val === 'string' || typeof val === 'boolean' || val === null || val === undefined) {\n    return val\n  }\n\n  if (typeof val === 'number') {\n    return {__type: 'number', value: val.toString()}\n  }\n\n  if (typeof val === 'function') return FUNCTION_MARKER\n\n  if (seen.has(val)) {\n    return CYCLIC_MARKER\n  }\n\n  seen.add(val)\n\n  if (isObject(val)) {\n    if (Array.isArray(val)) {\n      return val.map((elem) => {\n        const res = convertUnknown(elem, seen, maxDepth - 1)\n        return res === undefined ? UNDEFINED_MARKER : res\n      })\n    }\n\n    if ('$$typeof' in val && 'type' in val && 'props' in val) {\n      // React element:\n      const {type, props} = val\n      const strType = typeof type === 'function' ? type.name : type\n      if (typeof strType !== 'string') return undefined\n      return {\n        __type: 'jsx',\n        type: strType,\n        props: convertUnknown(props, seen, maxDepth - 1) as EncodableObject,\n      }\n    }\n\n    let hasType = false\n    const result: EncodableObject = {}\n    for (const [key, field] of Object.entries(val)) {\n      if (key === '__type') hasType = true\n      result[key] = convertUnknown(field, seen, maxDepth - 1)\n    }\n\n    return hasType ? {__type: 'object', value: result} : result\n  }\n\n  return UNKNOWN_MARKER\n}\n\nfunction maybeStringOrJSX(val: unknown): string | undefined | JSXMarker {\n  if (typeof val === 'string') return val\n  if (isObject(val) && '$$typeof' in val && 'type' in val && 'props' in val) {\n    const {type, props} = val\n    const strType = typeof type === 'function' ? type.name : type\n    if (typeof strType !== 'string') return undefined\n    return {__type: 'jsx', type: strType, props: convertUnknown(props) as EncodableObject}\n  }\n  return undefined\n}\n\n// maybeValidations attempts to serialize the validations of a type. Note: we need the whole type object and not\n// just the validation property as we need to recreate implied validations of various properties. This are technically\n// inherited and thus lost since we operate on the ownProps.\nfunction maybeValidations(obj: unknown): Validation[] | undefined {\n  if (!isObject(obj) || !('type' in obj)) return undefined\n\n  // Implied rules are rules which are inherited by the types. Since the descriptor operates on the ownProps\n  // it is necessary to add these rule back to ensure we have the default validations for the types.\n  const impliedRules: RuleType[] = []\n\n  if (\n    'options' in obj &&\n    isObject(obj.options) &&\n    'list' in obj.options &&\n    Array.isArray(obj.options.list)\n  ) {\n    impliedRules.push({\n      type: 'enum',\n      values: obj.options.list\n        .map((o) => convertUnknown(extractValueFromListOption(o, obj)))\n        .filter((v: EncodableValue | undefined) => v !== undefined),\n    })\n  }\n\n  switch (obj.type) {\n    case 'url':\n      impliedRules.push({\n        type: 'uri',\n        allowRelative: false,\n      })\n      break\n    case 'slug':\n      impliedRules.push({\n        type: 'custom',\n      })\n      break\n    case 'reference':\n      impliedRules.push({\n        type: 'reference',\n      })\n      break\n    case 'email':\n      impliedRules.push({\n        type: 'email',\n      })\n      break\n    default:\n    // Do nothing\n  }\n\n  // Shortcut\n  if (!('validation' in obj) || !obj.validation) {\n    if (impliedRules.length > 0) {\n      return [\n        {\n          level: 'error',\n          rules: impliedRules,\n        },\n      ]\n    }\n    return undefined\n  }\n\n  const validations: Validation[] = []\n  const rules = Array.isArray(obj.validation) ? obj.validation : [obj.validation]\n  for (const rule of rules) {\n    const validation = maybeValidation(rule)\n    if (validation === undefined) {\n      continue\n    }\n\n    // Add implied rules that aren't already defined in the validation\n    const rulesToAdd = impliedRules.filter((ir) => !validation.rules.some((r) => isEqual(r, ir)))\n    if (rulesToAdd.length > 0) {\n      validation.rules.unshift(...rulesToAdd)\n    }\n\n    // If the validation is already present, skip adding it\n    if (validations.some((v) => isEqual(v, validation))) {\n      continue\n    }\n\n    validations.push(validation)\n  }\n\n  return validations.length > 0 ? validations : undefined\n}\n\nfunction hasValueField(typeDef: unknown): boolean {\n  if (!typeDef || typeof typeDef !== 'object') return false\n  if (!('fields' in typeDef)) {\n    if ('type' in typeDef && typeDef.type) return hasValueField(typeDef.type)\n    return false\n  }\n  if (!Array.isArray(typeDef.fields)) return false\n  return typeDef.fields.some((field) => field.name === 'value')\n}\n\n// This logic is pulled from extractValueFromListOption in packages/sanity/src/core/validation/util/normalizeValidationRules.ts.\n// It has been slightly tweaked to be safer in accessing the value attribute of the option variable\nfunction extractValueFromListOption(option: unknown, typeDef: Record<string, unknown>): unknown {\n  // If you define a `list` option with object items, where the item has a `value` field,\n  // we don't want to treat that as the value but rather the surrounding object\n  // This differs from the case where you have a title/value pair setup for a string/number, for instance\n  if (typeDef.jsonType === 'object' && hasValueField(typeDef)) return option\n\n  if (isObject(option) && 'value' in option && option.value) {\n    return option.value\n  }\n\n  return option\n}\n\nfunction maybeValidation(val: unknown): Validation | undefined {\n  // Handle undefined, false\n  if (!val) {\n    return undefined\n  }\n\n  // Handle function rules - these are functions that return a Rule\n  if (isIRuleFunction(val)) {\n    try {\n      const result = val(new Rule())\n\n      // If the result is a Rule object, attempt to convert it\n      if (isIRule(result)) {\n        // Recursively convert the returned Rule object\n        return maybeValidation(result)\n      }\n\n      throw new Error('failed to convert to plain rule')\n    } catch (error) {\n      // If the function could not convert into a plain rule, mark it as custom\n      return {\n        level: 'error',\n        rules: [{type: 'custom', name: 'function'}],\n      }\n    }\n  }\n\n  // Handle Rule object\n  if (isIRule(val)) {\n    // Determine validation level\n    const level: Validation['level'] = val._level || 'error'\n\n    // Convert message\n    const message = maybeValidationMessage(val._message)\n\n    // Convert RuleSpec array to Rule array\n    const rules: RuleType[] = []\n\n    for (const spec of val._rules || []) {\n      // For custom rule spec, the optional property is determined by the rule.\n      // This is used to determine the behaviour the rule when the value is undefined or null\n      const optional = val._required === 'optional' || undefined\n      const convertedRule = convertRuleSpec(spec, optional)\n      if (convertedRule === undefined) {\n        continue\n      }\n\n      // If the converted spec is a duplicate, skip adding it\n      if (rules.some((r) => isEqual(r, convertedRule))) {\n        continue\n      }\n\n      rules.push(convertedRule)\n    }\n\n    if (rules.length === 0) {\n      return undefined\n    }\n\n    return {\n      level,\n      rules,\n      ...(message && {message}),\n    }\n  }\n\n  return undefined\n}\n\nfunction isIRule(val: unknown): val is IRule {\n  return isObject(val) && '_rules' in val\n}\n\nfunction maybeValidationMessage(val: unknown): ValidationMessage | undefined {\n  if (typeof val === 'string') return val\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  const objectMessage: ObjectMessage = {}\n  for (const [field, value] of Object.entries(val)) {\n    if (typeof field !== 'string' || typeof value !== 'string') {\n      continue\n    }\n    objectMessage[field] = value\n  }\n\n  return Object.keys(objectMessage).length > 0 ? objectMessage : undefined\n}\n\nfunction isIRuleFunction(val: unknown): val is (rule: IRule) => IRule | undefined {\n  return typeof val === 'function'\n}\n\n// eslint-disable-next-line complexity\nfunction convertRuleSpec(spec: unknown, optional?: true | undefined): RuleType | undefined {\n  if (!isObject(spec) || !('flag' in spec)) {\n    return undefined\n  }\n\n  const constraint = 'constraint' in spec ? spec.constraint : undefined\n\n  switch (spec.flag) {\n    case 'integer':\n      return {type: 'integer'}\n    case 'email':\n      return {type: 'email'}\n    case 'unique':\n      return {type: 'uniqueItems'}\n    case 'reference':\n      return {type: 'reference'}\n    case 'assetRequired':\n      return {type: 'assetRequired'}\n    case 'stringCasing':\n      if (constraint === 'uppercase') return {type: 'uppercase'}\n      if (constraint === 'lowercase') return {type: 'lowercase'}\n      return undefined\n    case 'all':\n      if (Array.isArray(constraint)) {\n        const children = constraint\n          .map((childRule) => maybeValidation(childRule))\n          .filter((c) => c !== undefined)\n        if (children.length > 0) {\n          return {type: 'allOf', children}\n        }\n      }\n      return undefined\n    case 'either':\n      if (Array.isArray(constraint)) {\n        const children = constraint\n          .map((childRule) => maybeValidation(childRule))\n          .filter((c) => c !== undefined)\n        if (children.length > 0) {\n          return {type: 'anyOf', children}\n        }\n      }\n      return undefined\n    case 'valid':\n      if (Array.isArray(constraint)) {\n        return {\n          type: 'enum',\n          values: constraint.map((c) => convertUnknown(c)).filter((v) => v !== undefined),\n        }\n      }\n      return undefined\n    case 'min':\n      return {type: 'minimum', value: convertConstraintValue(constraint)}\n    case 'max':\n      return {type: 'maximum', value: convertConstraintValue(constraint)}\n    case 'length':\n      return {type: 'length', value: convertConstraintValue(constraint)}\n    case 'precision':\n      return {type: 'precision', value: convertConstraintValue(constraint)}\n    case 'lessThan':\n      return {type: 'exclusiveMaximum', value: convertConstraintValue(constraint)}\n    case 'greaterThan':\n      return {type: 'exclusiveMinimum', value: convertConstraintValue(constraint)}\n    case 'regex':\n      if (isObject(constraint) && 'pattern' in constraint) {\n        const {pattern} = constraint\n        const invert = 'invert' in constraint ? maybeBoolean(constraint.invert) : undefined\n\n        if (pattern instanceof RegExp) {\n          return {\n            type: 'regex',\n            pattern: pattern.source,\n            ...(invert && {invert: true}),\n          }\n        }\n      }\n      return undefined\n    case 'uri': {\n      const allowRelative =\n        isObject(constraint) &&\n        'options' in constraint &&\n        isObject(constraint.options) &&\n        'allowRelative' in constraint.options\n          ? maybeBoolean(constraint.options.allowRelative)\n          : undefined\n\n      return {\n        type: 'uri',\n        ...(allowRelative !== undefined && {allowRelative}),\n      }\n    }\n    case 'custom':\n      return {type: 'custom', ...(optional && {optional})}\n    case 'media':\n      return {type: 'custom', name: 'media'}\n    case 'type':\n      return undefined\n    case 'presence':\n      if (constraint === 'required') return {type: 'required'}\n      if (constraint === 'optional') return undefined\n      return undefined\n    default:\n      return undefined\n  }\n}\n\nfunction convertConstraintValue(constraint: unknown): string | FieldReference {\n  if (\n    isObject(constraint) &&\n    'type' in constraint &&\n    'path' in constraint &&\n    constraint.type &&\n    constraint.path\n  ) {\n    // This is a FieldReference\n    return {\n      type: 'fieldReference',\n      path: Array.isArray(constraint.path) ? constraint.path : [constraint.path],\n    }\n  }\n  // Convert to string\n  return String(constraint)\n}\n\nfunction maybeBoolean(val: unknown): boolean | undefined {\n  if (typeof val === 'boolean') {\n    return val\n  }\n  return undefined\n}\n\nfunction maybeI18n(val: unknown): ObjectI18n | undefined {\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  // Convert I18nTextRecord to LocalizedMessage format\n  const localizedMessage: ObjectI18n = {}\n  for (const entry of Object.entries(val)) {\n    if (isI18nEntry(entry)) {\n      const [field, value] = entry\n      localizedMessage[field] = {\n        ns: value.ns,\n        key: value.key,\n      }\n    }\n  }\n\n  return Object.keys(localizedMessage).length > 0 ? localizedMessage : undefined\n}\n\nfunction isI18nEntry(entry: [unknown, unknown]): entry is [string, ObjectI18nValue] {\n  const [key, value] = entry\n  return (\n    typeof key === 'string' &&\n    !!value &&\n    typeof value === 'object' &&\n    'key' in value &&\n    'ns' in value &&\n    typeof value.key === 'string' &&\n    typeof value.ns === 'string'\n  )\n}\n\nfunction maybeOrdering(val: unknown): ObjectOrdering | undefined {\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  const name = 'name' in val && typeof val.name === 'string' ? val.name : undefined\n  // A valid ordering _must_ have a name\n  if (name === undefined) return undefined\n\n  // If no title is specified, default to the name\n  const title = 'title' in val && typeof val.title === 'string' ? val.title : name\n  const by = 'by' in val && Array.isArray(val.by) ? val.by : []\n\n  const orderingBy: ObjectOrderingBy[] = []\n  for (const item of by) {\n    const orderingItem = maybeOrderingBy(item)\n    if (orderingItem) {\n      orderingBy.push(orderingItem)\n    }\n  }\n\n  // A valid ordering _must_ have items (by)\n  if (orderingBy.length === 0) return undefined\n\n  const i18n = 'i18n' in val ? maybeI18n(val.i18n) : undefined\n\n  return {\n    name,\n    title,\n    by: orderingBy,\n    ...(i18n && {i18n}),\n  }\n}\n\nfunction maybeOrderingBy(val: unknown): ObjectOrderingBy | undefined {\n  if (!isObject(val) || Array.isArray(val)) return undefined\n\n  const field = 'field' in val && typeof val.field === 'string' ? val.field : undefined\n  const direction =\n    'direction' in val && (val.direction === 'asc' || val.direction === 'desc')\n      ? val.direction\n      : undefined\n\n  if (!field || !direction) return undefined\n\n  return {field, direction}\n}\n\n/**\n * Checks if `a` is smaller than `b` for determining a canonical name.\n */\nfunction isLessCanonicalName(a: string, b: string): boolean {\n  return a.length < b.length || (a.length === b.length && a < b)\n}\n","import {\n  processSetSynchronization,\n  type SetSynchronization,\n  type SynchronizationRequest,\n  type SynchronizationResult,\n} from '@sanity/descriptors'\n\nimport {type RegistryType} from './types'\n\n// This file provides wrapper types/functions for synchronizing a schema.\n// This avoids users of `@sanity/schema` to have to depend on `@sanity/descriptors`.\n\nexport type SchemaSynchronizationRequest = SynchronizationRequest\nexport type SchemaSynchronizationResult = SynchronizationResult\n\n/**\n * Returns the next request that should be generated for synchronizing the\n * schema, based on the previous response from the /synchronize endpoint.\n *\n * @param response - The previous response, or `null` if it's the first request.\n * @returns The next request, or `null` if it's been fully synchronized.\n */\nexport function processSchemaSynchronization(\n  sync: SetSynchronization<RegistryType>,\n  response: SchemaSynchronizationResult | null,\n): SchemaSynchronizationRequest | null {\n  return processSetSynchronization(sync, response)\n}\n","import {generateHelpUrl} from '@sanity/generate-help-url'\nimport {type SchemaType} from '@sanity/types'\nimport {difference} from 'lodash-es'\n\nconst ACTIONS_FLAG = '__experimental_actions'\n\nconst DEFAULT_ACTIONS = ['create', 'update', 'delete', 'publish']\nconst VALID_ACTIONS = DEFAULT_ACTIONS\n\n// todo: enable this when officially deprecating experimental actions\nconst DEPRECATE_EXPERIMENTAL_ACTIONS = false\n\nconst hasWarned = {}\nconst readActions = (schemaType: SchemaType): string[] => {\n  if (DEPRECATE_EXPERIMENTAL_ACTIONS && !(schemaType.name in hasWarned)) {\n    console.warn(`Heads up! Experimental actions is now deprecated and replaced by Document Actions. Read more about how to migrate on ${generateHelpUrl(\n      'experimental-actions-replaced-by-document-actions',\n    )}\".\n`)\n    ;(hasWarned as any)[schemaType.name] = true\n  }\n\n  return ACTIONS_FLAG in schemaType ? (schemaType[ACTIONS_FLAG] as string[]) : DEFAULT_ACTIONS\n}\n\nconst validateActions = (typeName: string, actions: string[]) => {\n  if (!Array.isArray(actions)) {\n    throw new Error(\n      `The value of <type>.${ACTIONS_FLAG} should be an array with any of the actions ${VALID_ACTIONS.join(\n        ', ',\n      )}`,\n    )\n  }\n\n  const invalid = difference(actions, VALID_ACTIONS)\n\n  if (invalid.length > 0) {\n    throw new Error(\n      `Invalid action${\n        invalid.length > 1 ? 's' : ''\n      } configured for schema type \"${typeName}\": ${invalid.join(\n        ', ',\n      )}. Valid actions are: ${VALID_ACTIONS.join(', ')}`,\n    )\n  }\n\n  return actions\n}\n\nexport const resolveEnabledActions = (schemaType: SchemaType): string[] =>\n  validateActions(schemaType.name, readActions(schemaType))\n\nexport const isActionEnabled = (schemaType: SchemaType, action: string): boolean =>\n  resolveEnabledActions(schemaType).includes(action)\n","export default {\n  name: 'sanity.assetSourceData',\n  title: 'Asset Source Data',\n  type: 'object',\n  fields: [\n    {\n      name: 'name',\n      title: 'Source name',\n      description: 'A canonical name for the source this asset is originating from',\n      type: 'string',\n    },\n    {\n      name: 'id',\n      title: 'Asset Source ID',\n      description:\n        'The unique ID for the asset within the originating source so you can programatically find back to it',\n      type: 'string',\n    },\n    {\n      name: 'url',\n      title: 'Asset information URL',\n      description: 'A URL to find more information about this asset in the originating source',\n      type: 'string',\n    },\n  ],\n}\n","export default {\n  name: 'sanity.fileAsset',\n  title: 'File',\n  type: 'document',\n  fieldsets: [\n    {\n      name: 'system',\n      title: 'System fields',\n      description: 'These fields are managed by the system and not editable',\n    },\n  ],\n  fields: [\n    {\n      name: 'originalFilename',\n      type: 'string',\n      title: 'Original file name',\n      readOnly: true,\n    },\n    {\n      name: 'label',\n      type: 'string',\n      title: 'Label',\n    },\n    {\n      name: 'title',\n      type: 'string',\n      title: 'Title',\n    },\n    {\n      name: 'description',\n      type: 'string',\n      title: 'Description',\n    },\n    {\n      name: 'altText',\n      type: 'string',\n      title: 'Alternative text',\n    },\n    {\n      name: 'sha1hash',\n      type: 'string',\n      title: 'SHA1 hash',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'extension',\n      type: 'string',\n      title: 'File extension',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'mimeType',\n      type: 'string',\n      title: 'Mime type',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'size',\n      type: 'number',\n      title: 'File size in bytes',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'assetId',\n      type: 'string',\n      title: 'Asset ID',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'uploadId',\n      type: 'string',\n      readOnly: true,\n      hidden: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'path',\n      type: 'string',\n      title: 'Path',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'url',\n      type: 'string',\n      title: 'Url',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'source',\n      type: 'sanity.assetSourceData',\n      title: 'Source',\n      readOnly: true,\n      fieldset: 'system',\n    },\n  ],\n  preview: {\n    select: {\n      title: 'originalFilename',\n      path: 'path',\n      mimeType: 'mimeType',\n      size: 'size',\n    },\n    prepare(doc: Record<string, any>) {\n      return {\n        title: doc.title || doc.path.split('/').slice(-1)[0],\n        subtitle: `${doc.mimeType} (${(doc.size / 1024 / 1024).toFixed(2)} MB)`,\n      }\n    },\n  },\n  orderings: [\n    {\n      title: 'File size',\n      name: 'fileSizeDesc',\n      by: [{field: 'size', direction: 'desc'}],\n    },\n  ],\n}\n","export default {\n  title: 'Geographical Point',\n  name: 'geopoint',\n  type: 'object',\n  fields: [\n    {\n      name: 'lat',\n      type: 'number',\n      title: 'Latitude',\n    },\n    {\n      name: 'lng',\n      type: 'number',\n      title: 'Longitude',\n    },\n    {\n      name: 'alt',\n      type: 'number',\n      title: 'Altitude',\n    },\n  ],\n}\n","import {type SanityDocument} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageAsset',\n  title: 'Image',\n  type: 'document',\n  fieldsets: [\n    {\n      name: 'system',\n      title: 'System fields',\n      description: 'These fields are managed by the system and not editable',\n    },\n  ],\n  fields: [\n    {\n      name: 'originalFilename',\n      type: 'string',\n      title: 'Original file name',\n      readOnly: true,\n    },\n    {\n      name: 'label',\n      type: 'string',\n      title: 'Label',\n    },\n    {\n      name: 'title',\n      type: 'string',\n      title: 'Title',\n    },\n    {\n      name: 'description',\n      type: 'string',\n      title: 'Description',\n    },\n    {\n      name: 'altText',\n      type: 'string',\n      title: 'Alternative text',\n    },\n    {\n      name: 'sha1hash',\n      type: 'string',\n      title: 'SHA1 hash',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'extension',\n      type: 'string',\n      readOnly: true,\n      title: 'File extension',\n      fieldset: 'system',\n    },\n    {\n      name: 'mimeType',\n      type: 'string',\n      readOnly: true,\n      title: 'Mime type',\n      fieldset: 'system',\n    },\n    {\n      name: 'size',\n      type: 'number',\n      title: 'File size in bytes',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'assetId',\n      type: 'string',\n      title: 'Asset ID',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'uploadId',\n      type: 'string',\n      readOnly: true,\n      hidden: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'path',\n      type: 'string',\n      title: 'Path',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'url',\n      type: 'string',\n      title: 'Url',\n      readOnly: true,\n      fieldset: 'system',\n    },\n    {\n      name: 'metadata',\n      type: 'sanity.imageMetadata',\n      title: 'Metadata',\n    },\n    {\n      name: 'source',\n      type: 'sanity.assetSourceData',\n      title: 'Source',\n      readOnly: true,\n      fieldset: 'system',\n    },\n  ],\n  preview: {\n    select: {\n      id: '_id',\n      title: 'originalFilename',\n      mimeType: 'mimeType',\n      size: 'size',\n      media: 'media',\n    },\n    prepare(doc: Partial<SanityDocument>) {\n      return {\n        title: doc.title || (typeof doc.path === 'string' && doc.path.split('/').slice(-1)[0]),\n        media: {\n          asset: {_ref: doc.id},\n          ...(doc.media ? {media: doc.media} : {}),\n        },\n        subtitle: `${doc.mimeType} (${(Number(doc.size) / 1024 / 1024).toFixed(2)} MB)`,\n      }\n    },\n  },\n  orderings: [\n    {\n      title: 'File size',\n      name: 'fileSizeDesc',\n      by: [{field: 'size', direction: 'desc'}],\n    },\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageCrop',\n  title: 'Image crop',\n  type: 'object',\n  fields: [\n    {\n      name: 'top',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'bottom',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'left',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'right',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageDimensions',\n  type: 'object',\n  title: 'Image dimensions',\n  fields: [\n    {\n      name: 'height',\n      type: 'number',\n      title: 'Height',\n      readOnly: true,\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'width',\n      type: 'number',\n      title: 'Width',\n      readOnly: true,\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'aspectRatio',\n      type: 'number',\n      title: 'Aspect ratio',\n      readOnly: true,\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  name: 'sanity.imageHotspot',\n  title: 'Image hotspot',\n  type: 'object',\n  fields: [\n    {\n      name: 'x',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'y',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'height',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      name: 'width',\n      type: 'number',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n  ],\n}\n","export default {\n  name: 'sanity.imageMetadata',\n  title: 'Image metadata',\n  type: 'object',\n  fieldsets: [\n    {\n      name: 'extra',\n      title: 'Extra metadataâ€¦',\n      options: {\n        collapsable: true,\n      },\n    },\n  ],\n  fields: [\n    {\n      name: 'location',\n      type: 'geopoint',\n    },\n    {\n      name: 'dimensions',\n      title: 'Dimensions',\n      type: 'sanity.imageDimensions',\n      fieldset: 'extra',\n    },\n    {\n      name: 'palette',\n      type: 'sanity.imagePalette',\n      title: 'Palette',\n      fieldset: 'extra',\n    },\n    {\n      name: 'lqip',\n      title: 'LQIP (Low-Quality Image Placeholder)',\n      type: 'string',\n      readOnly: true,\n    },\n    {\n      name: 'blurHash',\n      title: 'BlurHash',\n      type: 'string',\n      readOnly: true,\n    },\n    {\n      name: 'hasAlpha',\n      title: 'Has alpha channel',\n      type: 'boolean',\n      readOnly: true,\n    },\n    {\n      name: 'isOpaque',\n      title: 'Is opaque',\n      type: 'boolean',\n      readOnly: true,\n    },\n  ],\n}\n","export default {\n  name: 'sanity.imagePalette',\n  title: 'Image palette',\n  type: 'object',\n  fields: [\n    {name: 'darkMuted', type: 'sanity.imagePaletteSwatch', title: 'Dark Muted'},\n    {name: 'lightVibrant', type: 'sanity.imagePaletteSwatch', title: 'Light Vibrant'},\n    {name: 'darkVibrant', type: 'sanity.imagePaletteSwatch', title: 'Dark Vibrant'},\n    {name: 'vibrant', type: 'sanity.imagePaletteSwatch', title: 'Vibrant'},\n    {name: 'dominant', type: 'sanity.imagePaletteSwatch', title: 'Dominant'},\n    {name: 'lightMuted', type: 'sanity.imagePaletteSwatch', title: 'Light Muted'},\n    {name: 'muted', type: 'sanity.imagePaletteSwatch', title: 'Muted'},\n  ],\n}\n","export default {\n  name: 'sanity.imagePaletteSwatch',\n  title: 'Image palette swatch',\n  type: 'object',\n  fields: [\n    {name: 'background', type: 'string', title: 'Background', readOnly: true},\n    {name: 'foreground', type: 'string', title: 'Foreground', readOnly: true},\n    {name: 'population', type: 'number', title: 'Population', readOnly: true},\n    {name: 'title', type: 'string', title: 'String', readOnly: true},\n  ],\n}\n","import {type Rule} from '@sanity/types'\n\nexport default {\n  title: 'Slug',\n  name: 'slug',\n  type: 'object',\n  fields: [\n    {\n      name: 'current',\n      title: 'Current slug',\n      type: 'string',\n      validation: (Rule: Rule): Rule => Rule.required(),\n    },\n    {\n      // The source field is deprecated/unused, but leaving it included and hidden\n      // to prevent rendering \"Unknown field\" warnings on legacy data\n      name: 'source',\n      title: 'Source field',\n      type: 'string',\n      hidden: true,\n    },\n  ],\n}\n","import assetSourceData from './assetSourceData'\nimport fileAsset from './fileAsset'\nimport geopoint from './geopoint'\nimport imageAsset from './imageAsset'\nimport imageCrop from './imageCrop'\nimport imageDimensions from './imageDimensions'\nimport imageHotspot from './imageHotspot'\nimport imageMetadata from './imageMetadata'\nimport imagePalette from './imagePalette'\nimport imagePaletteSwatch from './imagePaletteSwatch'\nimport slug from './slug'\n\nexport const builtinTypes = [\n  assetSourceData,\n  slug,\n  geopoint,\n  // legacyRichDate,\n  imageAsset,\n  fileAsset,\n  imageCrop,\n  imageHotspot,\n  imageMetadata,\n  imageDimensions,\n  imagePalette,\n  imagePaletteSwatch,\n]\n","import {type SchemaValidationResult} from '../typedefs'\n\n// Temporary solution to ensure we have a central registry over used helpIds\nexport const HELP_IDS = {\n  TYPE_INVALID: 'schema-type-invalid',\n  TYPE_IS_ESM_MODULE: 'schema-type-is-esm-module',\n  TYPE_NAME_RESERVED: 'schema-type-name-reserved',\n  TYPE_MISSING_NAME: 'schema-type-missing-name-or-type',\n  TYPE_MISSING_TYPE: 'schema-type-missing-name-or-type',\n  TYPE_TITLE_RECOMMENDED: 'schema-type-title-is-recommended',\n  TYPE_TITLE_INVALID: 'schema-type-title-is-recommended',\n  OBJECT_FIELDS_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NOT_UNIQUE: 'schema-object-fields-invalid',\n  OBJECT_FIELD_NAME_INVALID: 'schema-object-fields-invalid',\n  OBJECT_FIELD_DEFINITION_INVALID_TYPE: 'schema-object-fields-invalid',\n  ARRAY_PREDEFINED_CHOICES_INVALID: 'schema-predefined-choices-invalid',\n  ARRAY_OF_ARRAY: 'schema-array-of-array',\n  ARRAY_OF_INVALID: 'schema-array-of-invalid',\n  ARRAY_OF_NOT_UNIQUE: 'schema-array-of-invalid',\n  ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT: 'schema-array-of-type-global-type-conflict',\n  ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT: 'schema-array-of-type-builtin-type-conflict',\n  REFERENCE_TO_INVALID: 'schema-reference-to-invalid',\n  REFERENCE_TO_NOT_UNIQUE: 'schema-reference-to-invalid',\n  REFERENCE_INVALID_OPTIONS: 'schema-reference-invalid-options',\n  REFERENCE_INVALID_OPTIONS_LOCATION: 'schema-reference-options-nesting',\n  REFERENCE_INVALID_FILTER_PARAMS_COMBINATION: 'schema-reference-filter-params-combination',\n  SLUG_SLUGIFY_FN_RENAMED: 'slug-slugifyfn-renamed',\n  ASSET_METADATA_FIELD_INVALID: 'asset-metadata-field-invalid',\n  CROSS_DATASET_REFERENCE_INVALID: 'cross-dataset-reference-invalid',\n  GLOBAL_DOCUMENT_REFERENCE_INVALID: 'global-document-reference-invalid',\n  DEPRECATED_BLOCKEDITOR_KEY: 'schema-deprecated-blockeditor-key',\n  STANDALONE_BLOCK_TYPE: 'schema-standalone-block-type',\n}\n\nfunction createValidationResult(\n  severity: SchemaValidationResult['severity'],\n  message: string,\n  helpId: string | null,\n): SchemaValidationResult {\n  if (helpId && !Object.keys(HELP_IDS).some((id) => (HELP_IDS as any)[id] === helpId)) {\n    throw new Error(\n      `Used the unknown helpId \"${helpId}\", please add it to the array in createValidationResult.js`,\n    )\n  }\n  return {\n    severity,\n    message,\n    helpId: helpId!,\n  }\n}\n\nexport const error = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('error', message, helpId!)\n\nexport const warning = (message: string, helpId?: string | null): SchemaValidationResult =>\n  createValidationResult('warning', message, helpId!)\n","import {\n  type SchemaType,\n  type SchemaTypeDefinition,\n  type SchemaValidationProblemGroup,\n} from '@sanity/types'\nimport {flatten, get} from 'lodash-es'\n\nimport {type ProblemPath, type ProblemPathPropertySegment, type TypeWithProblems} from './typedefs'\nimport {error} from './validation/createValidationResult'\n\n/**\n * @internal\n */\nexport function groupProblems(types: SchemaTypeDefinition[]): SchemaValidationProblemGroup[] {\n  return flatten<TypeWithProblems>(types.map((type) => getTypeProblems(type))).filter(\n    (type) => type.problems.length > 0,\n  )\n}\n\nfunction createTypeWithMembersProblemsAccessor(\n  memberPropertyName: string,\n  getMembers = (type: SchemaType) => get(type, memberPropertyName),\n) {\n  return function getProblems(type: any, parentPath: ProblemPath): TypeWithProblems[] {\n    const currentPath: ProblemPath = [\n      ...parentPath,\n      {kind: 'type', type: type.type, name: type.name},\n    ]\n\n    const members = getMembers(type) || []\n\n    const memberProblems: TypeWithProblems[][] = Array.isArray(members)\n      ? members.map((memberType) => {\n          const propertySegment: ProblemPathPropertySegment = {\n            kind: 'property',\n            name: memberPropertyName,\n          }\n          const memberPath: ProblemPath = [...currentPath, propertySegment]\n          return getTypeProblems(memberType, memberPath as any)\n        })\n      : [\n          [\n            {\n              path: currentPath,\n              problems: [error(`Member declaration (${memberPropertyName}) is not an array`)],\n            },\n          ],\n        ]\n\n    return [\n      {\n        path: currentPath,\n        problems: type._problems || [],\n      },\n      ...flatten(memberProblems),\n    ]\n  }\n}\n\nconst arrify = (val: any) =>\n  Array.isArray(val) ? val : (typeof val === 'undefined' && []) || [val]\n\nconst getObjectProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getImageProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getFileProblems = createTypeWithMembersProblemsAccessor('fields')\nconst getArrayProblems = createTypeWithMembersProblemsAccessor('of')\nconst getReferenceProblems = createTypeWithMembersProblemsAccessor('to', (type) =>\n  'to' in type ? arrify(type.to) : [],\n)\nconst getBlockAnnotationProblems = createTypeWithMembersProblemsAccessor('marks.annotations')\nconst getBlockMemberProblems = createTypeWithMembersProblemsAccessor('of')\nconst getBlockProblems = (type: any, problems: any) => [\n  ...getBlockAnnotationProblems(type, problems),\n  ...getBlockMemberProblems(type, problems),\n]\n\nfunction getDefaultProblems(type: any, path = []): TypeWithProblems[] {\n  return [\n    {\n      path: [...path, {kind: 'type', type: type.type, name: type.name}],\n      problems: type._problems || [],\n    },\n  ]\n}\n\nfunction getTypeProblems(type: SchemaTypeDefinition, path = []): TypeWithProblems[] {\n  switch (type.type) {\n    case 'object': {\n      return getObjectProblems(type, path)\n    }\n    case 'document': {\n      return getObjectProblems(type, path)\n    }\n    case 'array': {\n      return getArrayProblems(type, path)\n    }\n    case 'reference': {\n      return getReferenceProblems(type, path)\n    }\n    case 'block': {\n      return getBlockProblems(type, path)\n    }\n    case 'image': {\n      return getImageProblems(type, path)\n    }\n    case 'file': {\n      return getFileProblems(type, path)\n    }\n    default: {\n      return getDefaultProblems(type, path)\n    }\n  }\n}\n","export function getDupes(array: any, selector = (v: any) => v) {\n  const dupes = array.reduce((acc: any, item: any) => {\n    const key = selector(item)\n    if (!acc[key]) {\n      acc[key] = []\n    }\n    acc[key].push(item)\n    return acc\n  }, {})\n\n  return Object.keys(dupes)\n    .map((key) => (dupes[key].length > 1 ? dupes[key] : null))\n    .filter(Boolean)\n}\n","import {flatten, uniq} from 'lodash-es'\n\nimport {getDupes} from '../sanity/validation/utils/getDupes'\n\ntype SchemaType = Record<string, any>\ntype SchemaTypeDef = Record<string, any>\n\ntype VisitContext = {\n  isRoot: boolean\n  isReserved: (typeName: string) => boolean\n  visit: Visitor\n  index: number\n  isDuplicate: (typeName: string) => boolean\n  getType: (typeName: string) => null | SchemaType\n  getTypeNames: () => Array<string>\n}\n\nexport type Visitor = (typeDef: SchemaTypeDef, arg1: VisitContext) => SchemaType\n\nconst NOOP_VISITOR: Visitor = (typeDef) => typeDef\n\nexport class UnknownType {\n  name: string\n\n  constructor(name: string) {\n    this.name = name\n  }\n}\n\nconst TYPE_TYPE = {name: 'type', type: null}\n\nconst FUTURE_RESERVED = ['any', 'time', 'date']\n\nexport function traverseSchema(\n  types: SchemaTypeDef[] = [],\n  coreTypes: SchemaTypeDef[] = [],\n  visitor: Visitor = NOOP_VISITOR,\n) {\n  const coreTypesRegistry = Object.create(null)\n  const registry = Object.create(null)\n\n  const coreTypeNames = coreTypes.map((typeDef) => typeDef.name)\n\n  const reservedTypeNames = FUTURE_RESERVED.concat(coreTypeNames)\n\n  const typeNames = types.map((typeDef) => typeDef && typeDef.name).filter(Boolean)\n\n  coreTypes.forEach((coreType) => {\n    coreTypesRegistry[coreType.name] = coreType\n  })\n\n  types.forEach((type, i) => {\n    // Allocate a placeholder for each type\n    registry[(type && type.name) || `__unnamed_${i}`] = {}\n  })\n\n  function getType(typeName: any) {\n    return typeName === 'type'\n      ? TYPE_TYPE\n      : coreTypesRegistry[typeName] || registry[typeName] || null\n  }\n\n  const duplicateNames = uniq(flatten(getDupes(typeNames)))\n\n  function isDuplicate(typeName: any) {\n    return duplicateNames.includes(typeName)\n  }\n  function getTypeNames() {\n    return typeNames.concat(coreTypeNames)\n  }\n  function isReserved(typeName: any) {\n    return typeName === 'type' || reservedTypeNames.includes(typeName)\n  }\n\n  const visitType = (isRoot: any) => (typeDef: any, index: any) => {\n    return visitor(typeDef, {\n      visit: visitType(false),\n      isRoot,\n      getType,\n      getTypeNames,\n      isReserved,\n      isDuplicate,\n      index,\n    })\n  }\n\n  coreTypes.forEach((coreTypeDef) => {\n    Object.assign(coreTypesRegistry[coreTypeDef.name], visitType(coreTypeDef))\n  })\n\n  types.forEach((typeDef, i) => {\n    Object.assign(\n      registry[(typeDef && typeDef.name) || `__unnamed_${i}`],\n      visitType(true)(typeDef, i),\n    )\n  })\n\n  return {\n    get(typeName: string) {\n      const res = registry[typeName] || coreTypesRegistry[typeName]\n      if (res) {\n        return res\n      }\n      throw new Error(`No such type: ${typeName}`)\n    },\n    has(typeName: string): boolean {\n      return typeName in registry || typeName in coreTypesRegistry\n    },\n    getTypeNames(): string[] {\n      return Object.keys(registry)\n    },\n    getTypes() {\n      return this.getTypeNames().map(this.get)\n    },\n    toJSON() {\n      return this.getTypes()\n    },\n  }\n}\n","const coreTypes = [\n  {name: 'array', jsonType: 'array', type: 'type'},\n  {name: 'block', jsonType: 'object', type: 'type'},\n  {name: 'boolean', jsonType: 'boolean', type: 'type'},\n  {name: 'datetime', jsonType: 'string', type: 'type'},\n  {name: 'date', jsonType: 'string', type: 'type'},\n  {name: 'document', jsonType: 'object', type: 'type'},\n  {name: 'email', jsonType: 'string', type: 'type'},\n  {name: 'file', jsonType: 'object', type: 'type'},\n  {name: 'geopoint', jsonType: 'object', type: 'type'},\n  {name: 'image', jsonType: 'object', type: 'type'},\n  {name: 'number', jsonType: 'number', type: 'type'},\n  {name: 'object', jsonType: 'object', type: 'type'},\n  {name: 'reference', jsonType: 'object', type: 'type'},\n  {name: 'crossDatasetReference', jsonType: 'object', type: 'type'},\n  {name: 'globalDocumentReference', jsonType: 'object', type: 'type'},\n  {name: 'slug', jsonType: 'object', type: 'type'},\n  {name: 'span', jsonType: 'object', type: 'type'},\n  {name: 'string', jsonType: 'string', type: 'type'},\n  {name: 'telephone', jsonType: 'string', type: 'type'},\n  {name: 'text', jsonType: 'string', type: 'type'},\n  {name: 'url', jsonType: 'string', type: 'type'},\n] as const\n\nexport const coreTypeNames = coreTypes.map((t) => t.name)\nexport default coreTypes\n","import {traverseSchema, type Visitor} from '../core/traverseSchema'\nimport coreTypes from './coreTypes'\nimport {type _FIXME_} from './typedefs'\n\nexport function traverseSanitySchema(schemaTypes: _FIXME_[], visitor: Visitor) {\n  return traverseSchema(schemaTypes, coreTypes as _FIXME_, visitor)\n}\n","import humanizeList from 'humanize-list'\nimport {flatten, partition} from 'lodash-es'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction isPrimitiveTypeName(typeName: any) {\n  return typeName === 'string' || typeName === 'number' || typeName === 'boolean'\n}\n\nfunction isAssignable(typeName: any, type: any) {\n  return (typeof type.name === 'string' ? type.name : type.type) === typeName\n}\n\nfunction quote(n: any) {\n  return `\"${n}\"`\n}\n\nfunction pluralize(arr: unknown[], suf = 's') {\n  return arr.length === 1 ? '' : suf\n}\n\nfunction format(value: unknown) {\n  if (Array.isArray(value)) {\n    return `array with ${value.length} entries`\n  }\n  if (typeof value === 'object' && value !== null) {\n    return `object with keys ${humanizeList(Object.keys(value).map(quote))}`\n  }\n  return quote(value)\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  // name should already have been marked\n  const ofIsArray = Array.isArray(typeDef.of)\n\n  if (ofIsArray) {\n    const invalid = typeDef.of.reduce((errs: any, def: any, idx: any) => {\n      if (typeof def.name === 'string') {\n        // If an array member has been given a \"local\" type name, we want to trigger an error if the given member type name\n        // is one of the builtin types\n        //\n        // The following examples should be an error (where book is an existing root level type and reference is a built-in type):\n        //  - (â€¦) of: [{type: 'book', name: 'image'}]\n        //  - (â€¦) of: [{type: 'book', name: 'object'}]\n        //  - (â€¦) of: [{type: 'object', name: 'reference'}]\n        // The following examples are valid (where \"address\" is not defined as a global object type)\n        //  - (â€¦) of: [{type: 'object', name: 'address'}]\n        // The following examples are redundant, but should be allowed (at least for now)\n        //  - (â€¦) of: [{type: 'object', name: 'object'}]\n        //  - (â€¦) of: [{type: 'image', name: 'image'}]\n\n        if (\n          // specifying the same name as the type is redundant, but should not be a hard error at this point\n          // Consider showing a warning for this and deprecate this ability eventually\n          def.name !== def.type &&\n          coreTypeNames.includes(def.name)\n        ) {\n          return errs.concat(\n            error(\n              `Found array member declaration with the same type name as a built-in type (\"${def.name}\"). Array members can not be given the same name as a built-in type.`,\n              HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n            ),\n          )\n        }\n      }\n\n      if (def.type === 'object' && def.name && visitorContext.getType(def.name)) {\n        return errs.concat(\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${def.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        )\n      }\n      if (def.type === 'array') {\n        return errs.concat(\n          error(\n            `Found array member declaration of type \"array\" - multidimensional arrays are not currently supported by Sanity`,\n            HELP_IDS.ARRAY_OF_ARRAY,\n          ),\n        )\n      }\n\n      if (def) {\n        return errs\n      }\n\n      const err = `Found ${def === null ? 'null' : typeof def}, expected member declaration`\n      return errs.concat(\n        error(\n          `Found invalid type member declaration in array at index ${idx}: ${err}`,\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n      )\n    }, [])\n\n    if (invalid.length > 0) {\n      return {\n        ...typeDef,\n        of: [],\n        _problems: invalid,\n      }\n    }\n  }\n\n  const problems = flatten([\n    ofIsArray\n      ? getDupes(typeDef.of, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in array. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.ARRAY_OF_NOT_UNIQUE,\n          ),\n        )\n      : error(\n          'The array type is missing or having an invalid value for the required \"of\" property',\n          HELP_IDS.ARRAY_OF_INVALID,\n        ),\n  ])\n  const of = ofIsArray ? typeDef.of : []\n\n  // Don't allow object types without a name in block arrays\n  const hasObjectTypesWithoutName = of.some(\n    (type: any) => type.type === 'object' && typeof type.name === 'undefined',\n  )\n  const hasBlockType = of.some((ofType: any) => ofType.type === 'block')\n  if (hasBlockType && hasObjectTypesWithoutName) {\n    problems.push(\n      error(\n        \"The array type's 'of' property can't have an object type without a 'name' property as member, when the 'block' type is also a member of that array.\",\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const [primitiveTypes, objectTypes] = partition(\n    of,\n    (ofType) =>\n      isPrimitiveTypeName(ofType.type) ||\n      isPrimitiveTypeName(visitorContext.getType(ofType.type)?.jsonType),\n  )\n\n  const isMixedArray = primitiveTypes.length > 0 && objectTypes.length > 0\n\n  if (isMixedArray) {\n    const primitiveTypeNames = primitiveTypes.map((t) => t.type)\n    const objectTypeNames = objectTypes.map((t) => t.type)\n    problems.push(\n      error(\n        `The array type's 'of' property can't have both object types and primitive types (found primitive type ${pluralize(\n          primitiveTypeNames,\n        )} ${humanizeList(primitiveTypeNames.map(quote))} and object type${pluralize(\n          objectTypeNames,\n        )} ${humanizeList(objectTypeNames.map(quote))})`,\n        HELP_IDS.ARRAY_OF_INVALID,\n      ),\n    )\n  }\n\n  const list = typeDef?.options?.list\n  if (!isMixedArray && Array.isArray(list)) {\n    const isArrayOfPrimitives = primitiveTypes.length > 0\n    if (isArrayOfPrimitives) {\n      list.forEach((option) => {\n        const value = option?.value ?? option\n        const isDeclared = primitiveTypes.some((primitiveType) => {\n          return typeof value === visitorContext.getType(primitiveType.type).jsonType\n        })\n        if (!isDeclared) {\n          const formattedTypeList = humanizeList(\n            primitiveTypes.map((t) => t.name || t.type),\n            {conjunction: 'or'},\n          )\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                value,\n              )}. Must be either a value of type ${formattedTypeList}, or an object with {title: string, value: ${formattedTypeList}}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    } else {\n      list.forEach((option) => {\n        const optionTypeName = option._type || 'object'\n        const isDeclared = objectTypes.some((validObjectType) =>\n          isAssignable(optionTypeName, validObjectType),\n        )\n        if (!isDeclared) {\n          problems.push(\n            error(\n              `An invalid entry found in options.list: ${format(\n                option,\n              )}. Must be an object with \"_type\" set to ${humanizeList(\n                objectTypes\n                  .map((t) => t.name || t.type)\n                  .map((t) => (t === 'object' ? 'undefined' : quote(t))),\n                {conjunction: 'or'},\n              )}`,\n              HELP_IDS.ARRAY_PREDEFINED_CHOICES_INVALID,\n            ),\n          )\n        }\n      })\n    }\n  }\n\n  if (typeDef?.options?.list && typeDef?.options?.layout === 'tags') {\n    problems.push(\n      warning(\n        'Found array member declaration with both tags layout and a list of predefined values. If you want to display a list of predefined values, remove the tags layout from `options`.',\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    of: of.map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n","export function isJSONTypeOf(type: any, jsonType: any, visitorContext: any) {\n  if ('jsonType' in type) {\n    return type.jsonType === jsonType\n  }\n  const parentType = visitorContext.getType(type.type)\n  if (!parentType) {\n    throw new Error(`Could not resolve jsonType of ${type.name}. No parent type found`)\n  }\n  return isJSONTypeOf(parentType, jsonType, visitorContext)\n}\n","import humanizeList from 'humanize-list'\nimport {isPlainObject, omit} from 'lodash-es'\n\nimport {coreTypeNames} from '../../coreTypes'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {isJSONTypeOf} from '../utils/isJSONTypeOf'\n\nconst getTypeOf = (thing: any) => (Array.isArray(thing) ? 'array' : typeof thing)\nconst quote = (str: any) => `\"${str}\"`\nconst allowedKeys = [\n  'components',\n  'lists',\n  'marks',\n  'name',\n  'of',\n  'options',\n  'styles',\n  'title',\n  'type',\n  'validation',\n]\nconst allowedMarkKeys = ['decorators', 'annotations']\nconst allowedStyleKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedDecoratorKeys = ['blockEditor', 'title', 'value', 'icon', 'component']\nconst allowedListKeys = ['title', 'value', 'icon', 'component']\nconst supportedBuiltInObjectTypes = [\n  'file',\n  'image',\n  'object',\n  'reference',\n  'crossDatasetReference',\n  'globalDocumentReference',\n]\n\nexport default function validateBlockType(typeDef: any, visitorContext: any) {\n  const problems = []\n  let styles = typeDef.styles\n  let lists = typeDef.lists\n  let marks = typeDef.marks\n  let members = typeDef.of\n\n  const disallowedKeys = Object.keys(typeDef).filter(\n    (key) => !allowedKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (marks) {\n    marks = validateMarks(typeDef.marks, visitorContext, problems)\n  }\n\n  if (styles) {\n    styles = validateStyles(styles, visitorContext, problems)\n  }\n\n  if (lists) {\n    lists = validateLists(lists, visitorContext, problems)\n  }\n\n  if (members) {\n    members = validateMembers(members, visitorContext, problems)\n  }\n  return {\n    ...omit(typeDef, disallowedKeys),\n    marks,\n    styles,\n    name: typeDef.name || typeDef.type,\n    of: members,\n    _problems: problems,\n  }\n}\n\nfunction validateMarks(marks: any, visitorContext: any, problems: any) {\n  let decorators = marks.decorators\n  let annotations = marks.annotations\n\n  if (!isPlainObject(marks)) {\n    problems.push(error(`\"marks\" declaration should be an object, got ${getTypeOf(marks)}`))\n    return problems\n  }\n\n  const disallowedMarkKeys = Object.keys(marks).filter(\n    (key) => !allowedMarkKeys.includes(key) && !key.startsWith('_'),\n  )\n\n  if (disallowedMarkKeys.length > 0) {\n    problems.push(\n      error(\n        `Found unknown properties for block declaration: ${humanizeList(\n          disallowedMarkKeys.map(quote),\n        )}`,\n      ),\n    )\n  }\n\n  if (decorators && !Array.isArray(decorators)) {\n    problems.push(\n      error(`\"marks.decorators\" declaration should be an array, got ${getTypeOf(decorators)}`),\n    )\n  } else if (decorators) {\n    decorators\n      .filter((dec: any) => !!dec.blockEditor)\n      .forEach((dec: any) => {\n        dec.icon = dec.blockEditor.icon\n        dec.component = dec.blockEditor.render\n      })\n    decorators = validateDecorators(decorators, visitorContext, problems)\n  }\n\n  if (annotations && !Array.isArray(annotations)) {\n    problems.push(\n      error(`\"marks.annotations\" declaration should be an array, got ${getTypeOf(annotations)}`),\n    )\n  } else if (annotations) {\n    annotations = validateAnnotations(annotations, visitorContext, problems)\n  }\n\n  return {...marks, decorators, annotations}\n}\n\nfunction validateLists(lists: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(lists)) {\n    problems.push(error(`\"lists\" declaration should be an array, got ${getTypeOf(lists)}`))\n    return problems\n  }\n\n  lists.forEach((list, index) => {\n    if (!isPlainObject(list)) {\n      problems.push(error(`List must be an object, got ${getTypeOf(list)}`))\n      return\n    }\n\n    const name = list.value || `#${index}`\n    const disallowedKeys = Object.keys(list).filter(\n      (key) => !allowedListKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for list ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!list.value) {\n      problems.push(error(`List #${index} is missing required \"value\" property`))\n    } else if (typeof list.value !== 'string') {\n      problems.push(\n        error(\n          `List type #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            list.value,\n          )}`,\n        ),\n      )\n    } else if (!list.title) {\n      problems.push(warning(`List type ${name} is missing recommended \"title\" property`))\n    }\n  })\n  return lists\n}\n\nfunction validateStyles(styles: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(styles)) {\n    problems.push(error(`\"styles\" declaration should be an array, got ${getTypeOf(styles)}`))\n    return problems\n  }\n\n  styles.forEach((style, index) => {\n    if (!isPlainObject(style)) {\n      problems.push(error(`Style must be an object, got ${getTypeOf(style)}`))\n      return\n    }\n\n    const name = style.value || `#${index}`\n    const disallowedKeys = Object.keys(style).filter(\n      (key) => !allowedStyleKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for style ${name}: ${humanizeList(disallowedKeys.map(quote))}`,\n        ),\n      )\n    }\n\n    if (!style.value) {\n      problems.push(error(`Style #${index} is missing required \"value\" property`))\n    } else if (typeof style.value !== 'string') {\n      problems.push(\n        error(\n          `Style #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            style.value,\n          )}`,\n        ),\n      )\n    } else if (!style.title) {\n      problems.push(warning(`Style ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof style.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Style has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      style.component = style.component || style.blockEditor.render\n    }\n  })\n  return styles\n}\n\nfunction validateDecorators(decorators: any, visitorContext: any, problems: any) {\n  decorators.forEach((decorator: any, index: any) => {\n    if (!isPlainObject(decorator)) {\n      problems.push(error(`Annotation must be an object, got ${getTypeOf(decorator)}`))\n      return\n    }\n\n    const name = decorator.value || `#${index}`\n    const disallowedKeys = Object.keys(decorator).filter(\n      (key) => !allowedDecoratorKeys.includes(key) && !key.startsWith('_'),\n    )\n\n    if (disallowedKeys.length > 0) {\n      problems.push(\n        error(\n          `Found unknown properties for decorator ${name}: ${humanizeList(\n            disallowedKeys.map(quote),\n          )}`,\n        ),\n      )\n    }\n\n    if (!decorator.value) {\n      problems.push(error(`Decorator #${index} is missing required \"value\" property`))\n    } else if (typeof decorator.value !== 'string') {\n      problems.push(\n        error(\n          `Decorator #${index} has an invalid \"value\" property, expected string, got ${getTypeOf(\n            decorator.value,\n          )}`,\n        ),\n      )\n    } else if (!decorator.title) {\n      problems.push(warning(`Decorator ${name} is missing recommended \"title\" property`))\n    }\n    if (typeof decorator.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Decorator \"${name}\" has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      decorator.icon = decorator.icon || decorator.blockEditor.icon\n      decorator.component = decorator.component || decorator.blockEditor.render\n    }\n  })\n  return decorators\n}\n\nfunction validateAnnotations(annotations: any, visitorContext: any, problems: any) {\n  return annotations.map((annotation: any) => {\n    if (!isPlainObject(annotation)) {\n      return {\n        ...annotation,\n        _problems: [error(`Annotation must be an object, got ${getTypeOf(annotation)}`)],\n      }\n    }\n\n    const {_problems} = visitorContext.visit(annotation, visitorContext)\n    const targetType = annotation.type && visitorContext.getType(annotation.type)\n    if (targetType && !isJSONTypeOf(targetType, 'object', visitorContext)) {\n      _problems.push(\n        error(\n          `Annotation cannot have type \"${annotation.type}\" - annotation types must inherit from object`,\n        ),\n      )\n    }\n\n    if (typeof annotation.blockEditor !== 'undefined') {\n      problems.push(\n        warning(\n          `Annotation has deprecated key \"blockEditor\", please refer to the documentation on how to configure the block type for version 3.`,\n          HELP_IDS.DEPRECATED_BLOCKEDITOR_KEY,\n        ),\n      )\n      // TODO remove this backward compatibility at some point.\n      annotation.icon = annotation.icon || annotation.blockEditor.icon\n      if (annotation.blockEditor?.render && !annotation.components?.annotation) {\n        annotation.components = annotation.components || {}\n        annotation.components.annotation =\n          annotation.components.annotation || annotation.blockEditor.render\n      }\n    }\n\n    return {...annotation, _problems}\n  })\n}\n\nfunction validateMembers(members: any, visitorContext: any, problems: any) {\n  if (!Array.isArray(members)) {\n    problems.push(error(`\"of\" declaration should be an array, got ${getTypeOf(members)}`))\n    return undefined\n  }\n\n  return members.map((member) => {\n    const {_problems} = visitorContext.visit(member, visitorContext)\n    if (member.type === 'object' && member.name && visitorContext.getType(member.name)) {\n      return {\n        ...member,\n        _problems: [\n          warning(\n            `Found array member declaration with the same name as the global schema type \"${member.name}\". It's recommended to use a unique name to avoid possibly incompatible data types that shares the same name.`,\n            HELP_IDS.ARRAY_OF_TYPE_GLOBAL_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n\n    // Test that each member is of a support object-like type\n    let type = member\n    while (type && !type.jsonType) {\n      type = visitorContext.getType(type.type)\n    }\n    const nonObjectCoreTypes = coreTypeNames.filter((n) => !supportedBuiltInObjectTypes.includes(n))\n    if (\n      // Must be object-like type (to validate hoisted types)\n      (type && type.jsonType !== 'object') ||\n      // Can't be a core type, or core object type that isn't supported (like 'span')\n      nonObjectCoreTypes.some((coreName) => coreName === member.type)\n    ) {\n      return {\n        ...member,\n        _problems: [\n          error(\n            `Block member types must be a supported object-like type. The following built-in types are supported: '${supportedBuiltInObjectTypes.join(\n              \"', '\",\n            )}'. You can also use shorthands for previously defined object types like {type: 'myObjectType'}`,\n            HELP_IDS.ARRAY_OF_TYPE_BUILTIN_TYPE_CONFLICT,\n          ),\n        ],\n      }\n    }\n    return {...member, _problems}\n  })\n}\n","import {type SchemaType} from '@sanity/types'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error} from '../createValidationResult'\n\nexport function validateNonObjectFieldsProp(\n  typeDef: SchemaType,\n  visitorContext: any,\n): SchemaValidationResult[] {\n  if (!('fields' in typeDef)) {\n    return []\n  }\n\n  let type = typeDef\n  while (type && !type.jsonType) {\n    type = visitorContext.getType(type.type)\n  }\n\n  if (type && type.jsonType !== 'object') {\n    return [error(`Type has propery \"fields\", but is not an object/document type.`)]\n  }\n\n  return []\n}\n","import humanize from 'humanize-list'\nimport leven from 'leven'\n\nimport {error, HELP_IDS} from '../createValidationResult'\n\nconst quote = (str: any) => `\"${str}\"`\n\nexport function validateTypeName(typeName: string, visitorContext: any) {\n  const possibleTypeNames = visitorContext.getTypeNames()\n\n  if (!typeName) {\n    return [error(`Type is missing a type.`, HELP_IDS.TYPE_MISSING_TYPE)]\n  }\n\n  if (typeof typeName !== 'string') {\n    return [\n      error(\n        `Type has an invalid \"type\"-property - should be a string.`,\n        HELP_IDS.TYPE_MISSING_TYPE,\n      ),\n    ]\n  }\n\n  const isValid = possibleTypeNames.includes(typeName)\n\n  if (!isValid) {\n    const suggestions = possibleTypeNames\n      .map((possibleTypeName: any) => {\n        return [leven(typeName, possibleTypeName), possibleTypeName]\n      })\n      .filter(([distance]: any) => distance < 3)\n      .map(([_, name]: any) => name)\n\n    const suggestion =\n      suggestions.length > 0\n        ? ` Did you mean ${humanize(suggestions.map(quote), {conjunction: 'or'})}?`\n        : ''\n\n    return [error(`Unknown type: ${typeName}.${suggestion}`)]\n  }\n  return []\n}\n","import {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\n\nexport function validateDeprecatedProperties(type: any): SchemaValidationResult[] {\n  const warnings = []\n\n  if (type?.inputComponent) {\n    warnings.push(\n      warning(`The \"inputComponent\" property is deprecated. Use \"components.input\" instead.`),\n    )\n  }\n\n  if (type?.preview?.component) {\n    warnings.push(\n      warning(`The \"preview.component\" property is deprecated. Use \"components.preview\" instead.`),\n    )\n  }\n\n  if (type?.diffComponent) {\n    warnings.push(\n      warning(`The \"diffComponent\" property is deprecated. Use \"components.diff\" instead.`),\n    )\n  }\n\n  if (type?.options?.editModal) {\n    warnings.push(\n      warning(`The \"options.editModal\" property is deprecated. Use \"options.modal\" instead.`),\n    )\n  }\n\n  if (type?.options?.isHighlighted) {\n    warnings.push(\n      warning(\n        `The \"options.isHighlighted\" property is deprecated. You can put fields behind a collapsed fieldset if you want to hide them from plain sight.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {validateNonObjectFieldsProp} from '../utils/validateNonObjectFieldsProp'\nimport {validateTypeName} from '../utils/validateTypeName'\nimport {validateDeprecatedProperties} from './deprecated'\n\nexport default (typeDef: any, visitorContext: any) => {\n  return {\n    ...typeDef,\n    _problems: [\n      ...validateTypeName(typeDef.type, visitorContext),\n      ...validateNonObjectFieldsProp(typeDef, visitorContext),\n      ...validateDeprecatedProperties(typeDef),\n    ].filter(Boolean),\n  }\n}\n","import {flatten, isPlainObject} from 'lodash-es'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nconst VALID_DATASET = /^[a-z0-9~][-_a-z0-9]+$/\nexport function isValidDatasetName(name: string): string | true {\n  const isValid = name.length >= 2 && name.toLowerCase() === name && VALID_DATASET.test(name)\n  return (\n    isValid ||\n    `The provided dataset \"${name}\" doesn't look like a valid dataset. Dataset names must be more than 2 characters, can only contain lowercase characters, numbers, underscores and dashes and can not start with a dash or an underscore`\n  )\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n          ),\n        )\n      : error(\n          'The cross dataset reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The cross dataset reference type should define at least one referenced type. Please check the \"to\" property.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  normalizedTo.forEach((crossDatasetTypeDef: any, index: any) => {\n    if (!crossDatasetTypeDef.type) {\n      problems.push(\n        error(\n          `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n\n    if (!isPlainObject(crossDatasetTypeDef.preview)) {\n      problems.push(\n        error(\n          `Missing required preview config for the referenced type \"${\n            crossDatasetTypeDef.type || '<unknown type>'\n          }\"`,\n          HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n        ),\n      )\n    }\n  })\n\n  if (typeof typeDef.dataset === 'string') {\n    const datasetValidation = isValidDatasetName(typeDef.dataset)\n    if (datasetValidation !== true) {\n      problems.push(error(datasetValidation, HELP_IDS.CROSS_DATASET_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A cross dataset reference must specify a `dataset`',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeDef.studioUrl && typeof typeDef.studioUrl !== 'function') {\n    problems.push(\n      error(\n        'The \"studioUrl\" property on a cross dataset reference must be a function taking \"{id, type}\" as argument and returning a studio url.',\n        HELP_IDS.CROSS_DATASET_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","const REACT_SYM_RE = /^Symbol\\(react\\..+\\)$/\n\nexport function isComponentLike(value: any) {\n  const type = typeof value\n  // Note: we're not using `isValidElementType` from react-is here since it accepts too much, e.g. any strings.\n  return (\n    type === 'function' ||\n    (typeof value?.$$typeof === 'symbol' && REACT_SYM_RE.test(String(value?.$$typeof)))\n  )\n}\n","import inspect from '../../inspect'\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {warning} from '../createValidationResult'\nimport {isComponentLike} from './isComponent'\n\nexport function validateComponent(typeDef: any): SchemaValidationResult[] {\n  const components = 'components' in typeDef ? typeDef.components : false\n  if (!components) {\n    return []\n  }\n\n  const warnings: SchemaValidationResult[] = []\n\n  if (components.input && !isComponentLike(components.input)) {\n    warnings.push(\n      warning(\n        `The \\`components.input\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.input,\n        )}). If you have imported a custom input component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.field && !isComponentLike(components.field)) {\n    warnings.push(\n      warning(\n        `The \\`components.field\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.field,\n        )}). If you have imported a custom field component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.item && !isComponentLike(components.item)) {\n    warnings.push(\n      warning(\n        `The \\`components.item\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.item,\n        )}). If you have imported a custom item component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  if (components.preview && !isComponentLike(components.preview)) {\n    warnings.push(\n      warning(\n        `The \\`components.preview\\` property is set but does not appear to be a valid React component (expected a function, but saw ${inspect(\n          components.preview,\n        )}). If you have imported a custom preview component, please verify that you have imported the correct named/default export.`,\n      ),\n    )\n  }\n\n  return warnings\n}\n","import {isPlainObject} from 'lodash-es'\n\nimport inspect from '../../inspect'\nimport {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nconst VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/\nconst CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/\ninterface Field {\n  name: string\n}\n\ninterface PreviewConfig {\n  select?: {\n    [key: string]: string\n  }\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  prepare?: Function\n}\n\nfunction validateFieldName(name: any): Array<any> {\n  if (typeof name !== 'string') {\n    return [\n      error(\n        `Field names must be strings. Saw \"${inspect(name)}\"`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (name.startsWith('_')) {\n    return [\n      error(\n        `Invalid field name \"${name}\". Field names cannot start with underscores \"_\" as it's reserved for system fields.`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n\n  if (!VALID_FIELD_RE.test(name)) {\n    return [\n      error(\n        `Invalid field name: \"${name}\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ${String(\n          VALID_FIELD_RE,\n        )}).`,\n        HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n      ),\n    ]\n  }\n  if (!CONVENTIONAL_FIELD_RE.test(name)) {\n    return [\n      warning(\n        'Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' +\n          ' It may be wise to keep special characters out of field names for easier access later on.',\n      ),\n      HELP_IDS.OBJECT_FIELD_NAME_INVALID,\n    ]\n  }\n  return []\n}\n\nexport function validateField(field: any, _visitorContext: any) {\n  if (!isPlainObject(field)) {\n    return [\n      error(\n        `Incorrect type for field definition - should be an object, saw ${inspect(field)}`,\n        HELP_IDS.OBJECT_FIELD_DEFINITION_INVALID_TYPE,\n      ),\n    ]\n  }\n\n  const problems = []\n  problems.push(\n    ...('name' in field\n      ? validateFieldName(field.name)\n      : [error('Missing field name', HELP_IDS.OBJECT_FIELD_NAME_INVALID)]),\n  )\n  problems.push(...validateComponent(field))\n  return problems\n}\n\nfunction getDuplicateFields(array: Array<Field>): Array<Array<Field> | null> {\n  const dupes: {[name: string]: Array<Field>} = {}\n  array.forEach((field) => {\n    if (!dupes[field.name]) {\n      dupes[field.name] = []\n    }\n    dupes[field.name].push(field)\n  })\n  return Object.keys(dupes)\n    .map((fieldName) => (dupes[fieldName].length > 1 ? dupes[fieldName] : null))\n    .filter(Boolean)\n}\n\nexport function validateFields(fields: any, options = {allowEmpty: false}) {\n  const problems = []\n  const fieldsIsArray = Array.isArray(fields)\n  if (!fieldsIsArray) {\n    return [\n      error(\n        `The \"fields\" property must be an array of fields. Instead saw \"${typeof fields}\"`,\n        HELP_IDS.OBJECT_FIELDS_INVALID,\n      ),\n    ]\n  }\n\n  const fieldsWithNames = fields.filter((field) => typeof field.name === 'string')\n\n  getDuplicateFields(fieldsWithNames).forEach((dupes) => {\n    problems.push(\n      error(\n        `Found ${dupes!.length} fields with name \"${dupes![0].name}\" in object`,\n        HELP_IDS.OBJECT_FIELD_NOT_UNIQUE,\n      ),\n    )\n  })\n\n  if (fields.length === 0 && !options.allowEmpty) {\n    problems.push(error('Object should have at least one field', HELP_IDS.OBJECT_FIELDS_INVALID))\n  }\n\n  const standaloneBlockFields = fields\n    .filter((field) => field.type === 'block')\n    .map((field) => `\"${field.name}\"`)\n\n  if (standaloneBlockFields.length > 0) {\n    const fmtFields = standaloneBlockFields.join(', ')\n    problems.push(\n      error(\n        `Invalid standalone block field(s) ${fmtFields}. Block content must be defined as an array of blocks`,\n        HELP_IDS.STANDALONE_BLOCK_TYPE,\n      ),\n    )\n  }\n\n  return problems\n}\n\nexport function validatePreview(preview: PreviewConfig) {\n  if (!isPlainObject(preview)) {\n    return [error(`The \"preview\" property must be an object, instead saw \"${typeof preview}\"`)]\n  }\n\n  if (typeof preview.prepare !== 'undefined' && typeof preview.prepare !== 'function') {\n    return [\n      error(\n        `The \"preview.prepare\" property must be a function, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  if (!preview.select) {\n    return []\n  }\n\n  if (!isPlainObject(preview.select)) {\n    return [\n      error(\n        `The \"preview.select\" property must be an object, instead saw \"${typeof preview.prepare}\"`,\n      ),\n    ]\n  }\n\n  return Object.keys(preview.select).reduce((errs: any, key) => {\n    return typeof preview.select![key] === 'string'\n      ? errs\n      : errs.concat(\n          error(\n            `The key \"${key}\" of \"preview.select\" must be a string, instead saw \"${typeof preview\n              .select![key]}\"`,\n          ),\n        )\n  }, [])\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  let problems = validateFields(typeDef.fields)\n\n  let preview = typeDef.preview\n  if (preview) {\n    const previewErrors = validatePreview(typeDef.preview)\n    problems = problems.concat(previewErrors)\n    preview = previewErrors.some((err: any) => err.severity === 'error') ? {} : preview\n  }\n\n  if (\n    typeDef.type !== 'document' &&\n    typeDef.type !== 'object' &&\n    typeof typeDef.initialValue !== 'undefined'\n  ) {\n    problems.push(\n      error(`The \"initialValue\" property is currently only supported for document & object types.`),\n    )\n  }\n\n  return {\n    ...typeDef,\n    preview,\n    fields: (Array.isArray(typeDef.fields) ? typeDef.fields : []).map((field: any, index: any) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {isPlainObject} from 'lodash-es'\n\nimport {error} from '../createValidationResult'\nimport object from './object'\n\nexport default (typeDefinition: any, visitorContext: any) => {\n  const typeDef = object(typeDefinition, visitorContext)\n  const {initialValue, initialValues} = typeDef\n\n  const hasInitialValue = typeof initialValue !== 'undefined'\n  if (hasInitialValue && !isPlainObject(initialValue) && typeof initialValue !== 'function') {\n    typeDef._problems.push(\n      error(`The \"initialValue\" property must be either a plain object or a function`),\n    )\n  }\n\n  if (typeof initialValues !== 'undefined') {\n    typeDef._problems.push(error(`Found property \"initialValues\" - did you mean \"initialValue\"?`))\n  }\n\n  return typeDef\n}\n","import {error, HELP_IDS} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  const invalidFieldNames = Array.isArray(fields)\n    ? fields?.filter((field) => field.name === 'asset')\n    : []\n\n  if (\n    typeDef.options &&\n    typeof typeDef.options.metadata !== 'undefined' &&\n    !Array.isArray(typeDef.options.metadata)\n  ) {\n    problems.push(\n      error(\n        `Invalid type for file \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (invalidFieldNames.length > 0) {\n    problems.push(error('The name `asset` is not a valid field name for type `file`.'))\n  }\n\n  return {\n    ...typeDef,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {flatten, isPlainObject} from 'lodash-es'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : []\n}\n\nexport function isValidResourceType(resourceType: string): string | true {\n  if (!resourceType) {\n    return 'The resource type must be a non-empty string'\n  }\n  if (resourceType != 'media-library' && resourceType != 'dataset') {\n    return 'The resource type must be either \"media-library\" or \"dataset\"'\n  }\n  return true\n}\n\nexport function isValidResourceId(resourceType: string, resourceId: string): string | true {\n  if (!resourceId) {\n    return 'The resource ID must be a non-empty string'\n  }\n  if (resourceType === 'dataset') {\n    const parts = resourceId.split('.')\n    if (parts.length !== 2) {\n      return 'The resource ID for a dataset reference must be on the form \"<projectId>.<datasetName>\"'\n    }\n    return true\n  }\n  if (resourceType === 'media-library') {\n    return true\n  }\n  return `Cannot validate resource ID for resource type: ${resourceType}`\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n          ),\n        )\n      : error(\n          'The global document reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The global document reference type should define at least one referenced type. Please check the \"to\" property.',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  normalizedTo.forEach((crossDatasetTypeDef: any, index: any) => {\n    if (!crossDatasetTypeDef.type) {\n      problems.push(\n        error(\n          `The referenced type at index ${index} must be named. Specify the name of the type you want to create references to.`,\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n      )\n    }\n\n    if (!isPlainObject(crossDatasetTypeDef.preview)) {\n      problems.push(\n        error(\n          `Missing required preview config for the referenced type \"${\n            crossDatasetTypeDef.type || '<unknown type>'\n          }\"`,\n          HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n        ),\n      )\n    }\n  })\n\n  if (typeof typeDef.resourceType === 'string') {\n    const validation = isValidResourceType(typeDef.resourceType)\n    if (validation !== true) {\n      problems.push(error(validation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A global document reference must specify a `resourceType`',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (typeof typeDef.resourceId === 'string') {\n    const datasetValidation = isValidResourceId(typeDef.resourceType, typeDef.resourceId)\n    if (datasetValidation !== true) {\n      problems.push(error(datasetValidation, HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID))\n    }\n  } else {\n    problems.push(\n      error(\n        'A global document reference must specify a `resourceId`',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  if (\n    typeDef.studioUrl &&\n    typeof typeDef.studioUrl !== 'function' &&\n    typeof typeDef.studioUrl !== 'string'\n  ) {\n    problems.push(\n      error(\n        'The \"studioUrl\" property on a global document reference must either be a function taking \"{id, type}\" as argument and returning a studio url, or a string being the base url pointing to a studio.',\n        HELP_IDS.GLOBAL_DOCUMENT_REFERENCE_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateField, validateFields} from './object'\n\nconst autoMeta = ['dimensions', 'hasAlpha', 'isOpaque']\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n  const fields = typeDef.fields\n\n  if (fields) {\n    problems.push(...validateFields(fields, {allowEmpty: true}))\n  }\n\n  let options = typeDef.options\n  const metadata = options?.metadata\n  const superfluousMeta = Array.isArray(metadata)\n    ? metadata.filter((meta) => autoMeta.includes(meta))\n    : []\n\n  const invalidFieldNames = ['asset', 'hotspot', 'crop']\n\n  const fieldsWithInvalidName = Array.isArray(fields)\n    ? fields?.filter((field) => invalidFieldNames.includes(field.name))\n    : []\n\n  if (typeof metadata !== 'undefined' && !Array.isArray(metadata)) {\n    problems.push(\n      error(\n        `Invalid type for image \\`metadata\\` field - must be an array of strings`,\n        HELP_IDS.ASSET_METADATA_FIELD_INVALID,\n      ),\n    )\n  } else if (superfluousMeta.length > 0) {\n    problems.push(\n      warning(\n        `Image \\`metadata\\` field contains superfluous properties (they are always included): ${superfluousMeta.join(\n          ', ',\n        )}`,\n      ),\n    )\n    options = {...options, metadata: metadata!.filter((meta) => !autoMeta.includes(meta))}\n  } else if (fieldsWithInvalidName.length > 0) {\n    problems.push(\n      error(\n        `The names \\`${invalidFieldNames.join(\n          '`, `',\n        )}\\` are invalid field names for type \\`image\\`.`,\n      ),\n    )\n  }\n\n  return {\n    ...typeDef,\n    options,\n    fields: (Array.isArray(fields) ? fields : []).map((field, index) => {\n      const {name, ...fieldTypeDef} = field\n      const {_problems, ...fieldType} = visitorContext.visit(fieldTypeDef, index)\n      return {\n        name,\n        ...fieldType,\n        _problems: validateField(field, visitorContext).concat(_problems || []),\n      }\n    }),\n    _problems: problems,\n  }\n}\n","import {flatten, isPlainObject} from 'lodash-es'\n\nimport {type SchemaValidationResult} from '../../typedefs'\nimport {error, HELP_IDS} from '../createValidationResult'\nimport {getDupes} from '../utils/getDupes'\n\nfunction normalizeToProp(typeDef: any) {\n  if (Array.isArray(typeDef.to)) {\n    return typeDef.to\n  }\n  return typeDef.to ? [typeDef.to] : typeDef.to\n}\n\nexport default (typeDef: any, visitorContext: any) => {\n  const isValidTo = Array.isArray(typeDef.to) || isPlainObject(typeDef.to)\n  const normalizedTo = normalizeToProp(typeDef)\n\n  const problems = flatten([\n    isValidTo\n      ? getDupes(normalizedTo, (t) => `${t.name};${t.type}`).map((dupes) =>\n          error(\n            `Found ${dupes.length} members with same type, but not unique names \"${dupes[0].type}\" in reference. This makes it impossible to tell their values apart and you should consider naming them`,\n            HELP_IDS.REFERENCE_TO_INVALID,\n          ),\n        )\n      : error(\n          'The reference type is missing or having an invalid value for the required \"to\" property. It should be an array of accepted types.',\n          HELP_IDS.REFERENCE_TO_INVALID,\n        ),\n  ])\n\n  if (isValidTo && normalizedTo.length === 0) {\n    problems.push(\n      error(\n        'The reference type should define at least one accepted type. Please check the \"to\" property.',\n        HELP_IDS.REFERENCE_TO_INVALID,\n      ),\n    )\n  }\n\n  problems.push(...getOptionErrors(typeDef))\n\n  return {\n    ...typeDef,\n    to: (isValidTo ? normalizedTo : []).map(visitorContext.visit),\n    _problems: problems,\n  }\n}\n\nfunction getOptionErrors(typeDef: any): SchemaValidationResult[] {\n  const {options} = typeDef\n  const problems = [] as SchemaValidationResult[]\n\n  problems.push(\n    ...['filter', 'filterParams']\n      .filter((key) => key in typeDef)\n      .map((key) =>\n        error(\n          `\\`${key}\\` is not allowed on a reference type definition - did you mean \\`options.${key}\\`?`,\n          HELP_IDS.REFERENCE_INVALID_OPTIONS_LOCATION,\n        ),\n      ),\n  )\n\n  if (!options) {\n    return problems\n  }\n\n  if (!isPlainObject(options)) {\n    return problems.concat(\n      error(\n        'The reference type expects `options` to be an object',\n        HELP_IDS.REFERENCE_INVALID_OPTIONS,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' && typeof options.filterParams !== 'undefined') {\n    return problems.concat(\n      error(\n        '`filterParams` cannot be used if `filter` is a function. Either statically define `filter` as a string, or return `params` from the `filter`-function.',\n        HELP_IDS.REFERENCE_INVALID_FILTER_PARAMS_COMBINATION,\n      ),\n    )\n  }\n\n  if (typeof options.filter === 'function' || (!options.filter && !options.filterParams)) {\n    return problems\n  }\n\n  if (typeof options.filter !== 'string') {\n    return problems.concat(\n      error(`If set, \\`filter\\` must be a string. Got ${typeof options.filter}`),\n    )\n  }\n\n  if (typeof options.filterParams !== 'undefined' && !isPlainObject(options.filterParams)) {\n    return problems.concat(error(`If set, \\`filterParams\\` must be an object.`))\n  }\n\n  if (options.filterParams) {\n    return problems.concat(\n      Object.keys(options.filterParams)\n        .filter((key) => key.startsWith('__') || key.startsWith('$'))\n        .map((key) => error(`Filter parameter cannot be prefixed with \"$\" or \"__\". Got ${key}\".`)),\n    )\n  }\n\n  return problems\n}\n","import {error, HELP_IDS, warning} from '../createValidationResult'\nimport {validateComponent} from '../utils/validateComponent'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const hasName = Boolean(typeDef.name)\n  if (!hasName && Object.keys(typeDef).length === 1) {\n    // Short-circuit on obviously invalid types (only key is _problems)\n    return {\n      ...typeDef,\n      _problems: [\n        error(\n          'Invalid/undefined type declaration, check declaration or the import/export of the schema type.',\n          HELP_IDS.TYPE_INVALID,\n        ),\n      ],\n    }\n  }\n\n  const problems = []\n  if (looksLikeEsmModule(typeDef)) {\n    problems.push(\n      error(\n        'Type appears to be an ES6 module imported through CommonJS require - use an import statement or access the `.default` property',\n        HELP_IDS.TYPE_IS_ESM_MODULE,\n      ),\n    )\n  } else if (!hasName) {\n    problems.push(error('Missing type name', HELP_IDS.TYPE_MISSING_NAME))\n  } else if (visitorContext.isReserved(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: \"${typeDef.name}\" is a reserved name.`,\n        HELP_IDS.TYPE_NAME_RESERVED,\n      ),\n    )\n  }\n\n  if (visitorContext.isDuplicate(typeDef.name)) {\n    problems.push(\n      error(\n        `Invalid type name: A type with name \"${typeDef.name}\" is already defined in the schema.`,\n      ),\n    )\n  }\n\n  problems.push(...validateComponent(typeDef))\n\n  if ('title' in typeDef && typeof typeDef.title !== 'string') {\n    problems.push(warning('Type title is not a string.', HELP_IDS.TYPE_TITLE_INVALID))\n  }\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n\nfunction looksLikeEsmModule(typeDef: any) {\n  return !typeDef.name && typeDef.default && (typeDef.default.name || typeDef.default.title)\n}\n","import {HELP_IDS, warning} from '../createValidationResult'\n\nexport default (typeDef: any, visitorContext: any) => {\n  const problems = []\n\n  if (typeDef.options && typeDef.options.slugifyFn) {\n    problems.push(\n      warning(\n        'Heads up! The \"slugifyFn\" option has been renamed to \"slugify\".',\n        HELP_IDS.SLUG_SLUGIFY_FN_RENAMED,\n      ),\n    )\n\n    typeDef.options.slugify = typeDef.options.slugifyFn\n  }\n\n  return {\n    ...typeDef,\n    _problems: problems,\n  }\n}\n","import {traverseSanitySchema} from './traverseSchema'\nimport {type _FIXME_} from './typedefs'\nimport array from './validation/types/array'\nimport block from './validation/types/block'\nimport common from './validation/types/common'\nimport crossDatasetReference from './validation/types/crossDatasetReference'\nimport documentVisitor from './validation/types/document'\nimport file from './validation/types/file'\nimport globalDocumentReference from './validation/types/globalDocumentReference'\nimport image from './validation/types/image'\nimport object from './validation/types/object'\nimport reference from './validation/types/reference'\nimport rootType from './validation/types/rootType'\nimport slug from './validation/types/slug'\n\nconst typeVisitors = {\n  array,\n  object,\n  slug,\n  file,\n  image,\n  block,\n  document: documentVisitor,\n  reference: reference,\n  crossDatasetReference: crossDatasetReference,\n  globalDocumentReference,\n}\n\nconst getNoopVisitor = (visitorContext: any) => (schemaDef: any) => ({\n  name: `<unnamed_type_@_index_${visitorContext.index}>`,\n  ...schemaDef,\n  _problems: [],\n})\n\nfunction combine(...visitors: any) {\n  return (schemaType: any, visitorContext: any) => {\n    return visitors.reduce(\n      (result: any, visitor: any) => {\n        const res = visitor(result, visitorContext)\n        return {\n          ...res,\n          _problems: result._problems.concat(res._problems),\n        }\n      },\n      {_problems: [], ...schemaType},\n    )\n  }\n}\n\ninterface Options {\n  transformTypeVisitors?: (visitors: typeof typeVisitors) => Partial<typeof typeVisitors>\n  transformCommonVisitors?: (visitors: any[]) => any[]\n}\n\n/**\n * @internal\n */\nexport function validateSchema(\n  schemaTypes: _FIXME_,\n  {\n    transformTypeVisitors = (visitors) => visitors,\n    transformCommonVisitors = (visitors) => visitors,\n  }: Options = {},\n) {\n  return traverseSanitySchema(schemaTypes, (schemaDef, visitorContext) => {\n    const typeVisitor =\n      (schemaDef &&\n        schemaDef.type &&\n        (transformTypeVisitors(typeVisitors) as any)[schemaDef.type]) ||\n      getNoopVisitor(visitorContext)\n\n    // Transform common visitors for extensibility\n    const commonVisitors = transformCommonVisitors([common])\n\n    if (visitorContext.isRoot) {\n      return combine(rootType, ...commonVisitors, typeVisitor)(schemaDef, visitorContext)\n    }\n\n    return combine(...commonVisitors, typeVisitor)(schemaDef, visitorContext)\n  })\n}\n","import {type SchemaValidationProblemGroup} from '@sanity/types'\n\nexport class ValidationError extends Error {\n  public problems: SchemaValidationProblemGroup[]\n  constructor(problems: SchemaValidationProblemGroup[]) {\n    super('ValidationError')\n    this.problems = problems\n    this.name = 'ValidationError'\n  }\n}\n","import {\n  type CustomValidator,\n  type MediaValidator,\n  type Rule as IRule,\n  type RuleTypeConstraint,\n  type UriValidationOptions,\n} from '@sanity/types'\nimport {cloneDeep, isObject} from 'lodash-es'\n\nimport {Schema} from '../legacy/Schema'\nimport {builtinTypes} from './builtinTypes'\nimport {groupProblems} from './groupProblems'\nimport {type SchemaValidationResult} from './typedefs'\nimport {validateSchema} from './validateSchema'\nimport {ValidationError} from './validation/ValidationError'\n\nconst builtinSchema = Schema.compile({\n  name: 'studio',\n  types: builtinTypes,\n})\n\nexport function createSchemaFromManifestTypes(schemaDef: {name: string; types: unknown[]}) {\n  const validated = validateSchema(schemaDef.types).getTypes()\n  const validation = groupProblems(validated)\n  const problems = validation.filter((group) =>\n    group.problems.some((problem: SchemaValidationResult) => problem.severity === 'error'),\n  )\n\n  if (problems.length > 0) {\n    throw new ValidationError(problems)\n  }\n\n  return Schema.compile({\n    name: schemaDef.name,\n    types: schemaDef.types.map(coerceType).filter(Boolean),\n    parent: builtinSchema,\n  })\n}\n\n// coerceType attempts to coerce a json schema into a Sanity schema type. This mainly involves\n// converting a json normalized rule into an actual '@sanity/schema' Rule.\nfunction coerceType(obj: unknown) {\n  if (!isObject(obj)) return undefined\n  const typ = cloneDeep(obj)\n  traverse(typ)\n  return typ\n}\n\nfunction traverse(obj: unknown) {\n  if (!isObject(obj)) {\n    return\n  }\n\n  if (Array.isArray(obj)) {\n    obj.forEach(traverse)\n    return\n  }\n\n  for (const v of Object.values(obj)) {\n    traverse(v)\n  }\n\n  coerceValidation(obj)\n}\n\n// Convert a json rule into a '@sanity/schema' Rule.\nfunction coerceValidation(val: unknown) {\n  if (!isObject(val) || !('validation' in val)) return\n\n  // Convert ManifestValidationGroup[] to Rule functions\n  const manifestValidation = Array.isArray(val.validation) ? val.validation : [val.validation]\n\n  val.validation = manifestValidation\n    .map((group) => {\n      if (!isObject(group)) return undefined\n\n      return (baseRule: IRule) => {\n        let rule = baseRule\n        const level = 'level' in group ? group.level : undefined\n        const rules = 'rules' in group ? group.rules : undefined\n        const message = 'message' in group ? group.message : undefined\n\n        if (!rules || !Array.isArray(rules)) return undefined\n\n        // Apply level if specified\n        if (isValidLevel(level) && (message === undefined || typeof message === 'string')) {\n          rule = rule[level](message)\n        }\n\n        // Apply each rule in the group\n        for (const ruleSpec of rules) {\n          rule = applyRuleSpec(rule, ruleSpec)\n        }\n\n        return rule\n      }\n    })\n    .filter(Boolean)\n}\n\nfunction coerceConstraintRule(val: unknown): any {\n  if (!isObject(val)) return undefined\n\n  if (Array.isArray(val)) {\n    return val.map(coerceConstraintRule).filter(Boolean)\n  }\n\n  return (baseRule: any) => {\n    let rule = baseRule\n\n    const rules = '_rules' in val ? val._rules : undefined\n    const level = '_level' in val ? val._level : undefined\n    const message = '_message' in val ? val._message : undefined\n\n    if (!rules || !Array.isArray(rules)) return undefined\n\n    // Apply level if specified\n    if (typeof level === 'string') {\n      rule = rule[level](message)\n    }\n\n    // Apply each rule in the group\n    for (const ruleSpec of rules) {\n      rule = applyRuleSpec(rule, ruleSpec)\n    }\n\n    return rule\n  }\n}\n\n// eslint-disable-next-line complexity\nfunction applyRuleSpec(rule: IRule, ruleSpec: unknown): IRule {\n  if (!ruleSpec || typeof ruleSpec !== 'object') {\n    return rule\n  }\n\n  const flag = 'flag' in ruleSpec ? ruleSpec.flag : undefined\n  const constraint = 'constraint' in ruleSpec ? ruleSpec.constraint : undefined\n\n  switch (flag) {\n    case 'presence':\n      if (constraint === 'required') {\n        return rule.required()\n      } else if (constraint === 'optional') {\n        return rule.optional()\n      }\n      break\n\n    case 'type':\n      if (typeof constraint === 'string') {\n        return rule.type(constraint as RuleTypeConstraint)\n      }\n      break\n\n    case 'min':\n      if (typeof constraint === 'number' || typeof constraint === 'string') {\n        return rule.min(constraint)\n      }\n      break\n\n    case 'max':\n      if (typeof constraint === 'number' || typeof constraint === 'string') {\n        return rule.max(constraint)\n      }\n      break\n\n    case 'length':\n      if (typeof constraint === 'number') {\n        return rule.length(constraint)\n      }\n      break\n\n    case 'integer':\n      return rule.integer()\n\n    case 'email':\n      return rule.email()\n\n    case 'unique':\n      return rule.unique()\n\n    case 'reference':\n      return rule.reference()\n\n    case 'precision':\n      if (typeof constraint === 'number') {\n        return rule.precision(constraint)\n      }\n      break\n\n    case 'positive':\n      return rule.positive()\n\n    case 'negative':\n      return rule.negative()\n\n    case 'greaterThan':\n      if (typeof constraint === 'number') {\n        return rule.greaterThan(constraint)\n      }\n      break\n\n    case 'lessThan':\n      if (typeof constraint === 'number') {\n        return rule.lessThan(constraint)\n      }\n      break\n\n    case 'stringCasing':\n      if (constraint === 'uppercase') {\n        return rule.uppercase()\n      } else if (constraint === 'lowercase') {\n        return rule.lowercase()\n      }\n      break\n\n    case 'valid':\n      if (Array.isArray(constraint)) {\n        return rule.valid(constraint)\n      }\n      break\n\n    case 'regex':\n      if (\n        isObject(constraint) &&\n        'pattern' in constraint &&\n        (typeof constraint.pattern === 'string' || constraint.pattern instanceof RegExp)\n      ) {\n        const options: any = {}\n        if ('name' in constraint && typeof constraint.name === 'string') {\n          options.name = constraint.name\n        }\n        if ('invert' in constraint) {\n          options.invert = constraint.invert\n        }\n        const pattern =\n          typeof constraint.pattern === 'string'\n            ? stringToRegExp(constraint.pattern)\n            : constraint.pattern\n        return rule.regex(pattern, options)\n      }\n      break\n\n    case 'uri':\n      if (isObject(constraint) && 'options' in constraint) {\n        return rule.uri(constraint.options as UriValidationOptions)\n      }\n      break\n\n    case 'assetRequired':\n      return rule.assetRequired()\n\n    case 'all':\n      return rule.all(coerceConstraintRule(constraint))\n\n    case 'either':\n      return rule.either(coerceConstraintRule(constraint))\n\n    case 'custom':\n      // When the manifest schema types are serialized, the custom function will be stripped. We add it back here to keep track that\n      // a rule did exist at one point.\n      if (constraint === undefined) return rule.custom(() => true)\n      if (typeof constraint === 'function') return rule.custom(constraint as CustomValidator)\n      break\n\n    case 'media':\n      // When the manifest schema types are serialized, the custom function will be stripped. We add it back here to keep track that\n      // a rule did exist at one point.\n      if (constraint === undefined) return rule.media(() => true)\n      if (typeof constraint === 'function') return rule.media(constraint as MediaValidator)\n      break\n\n    default:\n      break\n  }\n\n  return rule\n}\n\nconst isValidLevel = (level: unknown): level is 'error' | 'warning' | 'info' => {\n  return !!level && typeof level === 'string' && ['error', 'warning', 'info'].includes(level)\n}\n\nfunction stringToRegExp(str: string): RegExp {\n  // RegExp.toString() returns \"/pattern/flags\"\n  const match = str.match(/^\\/(.*)\\/([gimuy]*)$/)\n  if (match) {\n    return new RegExp(match[1], match[2])\n  }\n  // Fallback if the format doesn't match\n  return new RegExp(str)\n}\n","import {\n  type ArraySchemaType,\n  type NumberSchemaType,\n  type ObjectField,\n  type ObjectFieldType,\n  type ObjectSchemaType,\n  type ReferenceSchemaType,\n  type Rule,\n  type Schema as SchemaDef,\n  type SchemaType as SanitySchemaType,\n  type SchemaValidationValue,\n  type StringSchemaType,\n} from '@sanity/types'\nimport {\n  type ArrayTypeNode,\n  createReferenceTypeNode,\n  type DocumentSchemaType,\n  type InlineTypeNode,\n  type NullTypeNode,\n  type NumberTypeNode,\n  type ObjectAttribute,\n  type ObjectTypeNode,\n  type SchemaType,\n  type StringTypeNode,\n  type TypeDeclarationSchemaType,\n  type TypeNode,\n  type UnionTypeNode,\n  type UnknownTypeNode,\n} from 'groq-js'\n\nconst documentDefaultFields = (typeName: string): Record<string, ObjectAttribute> => ({\n  _id: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _type: {\n    type: 'objectAttribute',\n    value: {type: 'string', value: typeName},\n  },\n  _createdAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _updatedAt: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n  _rev: {\n    type: 'objectAttribute',\n    value: {type: 'string'},\n  },\n})\nconst typesMap = new Map<string, TypeNode>([\n  ['text', {type: 'string'}],\n  ['url', {type: 'string'}],\n  ['datetime', {type: 'string'}],\n  ['date', {type: 'string'}],\n  ['boolean', {type: 'boolean'}],\n  ['email', {type: 'string'}],\n])\n\nexport interface ExtractSchemaOptions {\n  enforceRequiredFields?: boolean\n}\n\n/**\n * Extracts a GROQ-compatible schema from a Sanity schema definition. The extraction happens in three passes:\n *\n * 1. **Dependency analysis & hoisting detection** (`sortByDependencies`): Walks the entire schema to sort\n *    types topologically and identifies inline object fields that are used multiple times (candidates\n *    for \"hoisting\").\n *\n * 2. **Hoisted type creation**: For any repeated inline fields, we create top-level named type definitions\n *    first, so they exist before being referenced.\n *\n * 3. **Main type conversion**: Processes each schema type in dependency order. When a field was marked for\n *    hoisting, we emit an `inline` reference to the hoisted type instead of duplicating the structure.\n */\nexport function extractSchema(\n  schemaDef: SchemaDef,\n  extractOptions: ExtractSchemaOptions = {},\n): SchemaType {\n  const inlineFields = new Set<SanitySchemaType>()\n  const documentTypes = new Map<string, DocumentSchemaType>()\n  const schema: SchemaType = []\n\n  /**\n   * A map for keeping track of the unique names we generate for hoisted references\n   */\n  const hoistedRefMap = new Map<string, string>()\n\n  // `repeated` maps ObjectField instances â†’ hoisted type names. When the same inline type (e.g., `blocksTest`)\n  // is used in multiple documents, Sanity's compiled schema reuses the same ObjectField object reference. This\n  // allows us to detect repetition via object identity, not structural comparison.\n  const {sortedSchemaTypeNames, repeated} = sortByDependencies(schemaDef)\n\n  // Create top-level type definitions for hoisted (repeated) inline types. These must be added to the schema\n  // before we process the main types, so that inline references to them can resolve correctly.\n  repeated.forEach((key, objectField) => {\n    const base = convertSchemaType(objectField.type)\n    if (base === null) {\n      return\n    }\n    // Skip creating hoisted types that would just be inline references to existing types.\n    // Remove from `repeated` so the field falls through to convertSchemaType in createObject.\n    if (base.type === 'inline') {\n      repeated.delete(objectField)\n      return\n    }\n    // Skip creating hoisted types for unknown types - there's no point hoisting types we don't understand.\n    // Remove from `repeated` so the field falls through to convertSchemaType in createObject.\n    if (base.type === 'unknown') {\n      repeated.delete(objectField)\n      return\n    }\n    schema.push({\n      type: 'type',\n      name: key,\n      value: base,\n    })\n  })\n  sortedSchemaTypeNames.forEach((typeName) => {\n    const schemaType = schemaDef.get(typeName)\n    if (schemaType === undefined) {\n      return\n    }\n    const base = convertBaseType(schemaType)\n    if (base === null) {\n      return\n    }\n    if (base.type === 'type') {\n      inlineFields.add(schemaType)\n    }\n    if (base.type === 'document') {\n      documentTypes.set(typeName, base)\n    }\n\n    schema.push(base)\n  })\n\n  /**\n   * Get unique schema name for a type name. It checks for collisions with names from the user defined\n   * types and allows specifying a suffix to add to the name of the type\n   *\n   * @param refName - the ref name to get unique name for\n   */\n  function reserveRefName(refName: string) {\n    const name = hoistedRefMap.get(refName)\n    if (name) return name\n\n    for (let i = 0; i < 5; i++) {\n      const uniqueName = `${refName}${i || ''}`\n\n      // if the list of schema types contain the uniqueName we need to try the next prefix\n      if (schemaDef.has(uniqueName)) continue\n\n      // the type name is unique\n      hoistedRefMap.set(refName, uniqueName)\n      return uniqueName\n    }\n\n    return null\n  }\n\n  function convertBaseType(\n    schemaType: SanitySchemaType,\n  ): DocumentSchemaType | TypeDeclarationSchemaType | null {\n    let typeName: string | undefined\n    if (schemaType.type) {\n      typeName = schemaType.type.name\n    } else if ('jsonType' in schemaType) {\n      typeName = schemaType.jsonType\n    }\n\n    if (typeName === 'document' && isObjectType(schemaType)) {\n      const defaultAttributes = documentDefaultFields(schemaType.name)\n\n      const object = createObject(schemaType)\n      if (object.type === 'unknown') {\n        return null\n      }\n\n      return {\n        name: schemaType.name,\n        type: 'document',\n        attributes: {\n          ...defaultAttributes,\n          ...object.attributes,\n        },\n      }\n    }\n\n    const value = convertSchemaType(schemaType)\n    if (value.type === 'unknown') {\n      return null\n    }\n    if (value.type === 'object') {\n      value.attributes = {\n        _type: {\n          type: 'objectAttribute',\n          value: {\n            type: 'string',\n            value: schemaType.name,\n          },\n        },\n        ...value.attributes,\n      }\n      return {\n        name: schemaType.name,\n        type: 'type',\n        value,\n      }\n    }\n\n    return {\n      name: schemaType.name,\n      type: 'type',\n      value,\n    }\n  }\n\n  function convertSchemaType(schemaType: SanitySchemaType): TypeNode {\n    // if we have already seen the base type, we can just reference it\n    if (inlineFields.has(schemaType.type!)) {\n      return {type: 'inline', name: schemaType.type!.name} satisfies InlineTypeNode\n    }\n\n    // If we have a type that is point to a type, that is pointing to a type, we assume this is a circular reference\n    // and we return an inline type referencing it instead\n    if (schemaType.type?.name && sortedSchemaTypeNames.indexOf(schemaType.type?.name) > -1) {\n      return {type: 'inline', name: schemaType.type?.name} satisfies InlineTypeNode\n    }\n\n    if (isStringType(schemaType)) {\n      return createStringTypeNodeDefintion(schemaType)\n    }\n\n    if (isNumberType(schemaType)) {\n      return createNumberTypeNodeDefintion(schemaType)\n    }\n\n    // map some known types\n    if (schemaType.type && typesMap.has(schemaType.type.name)) {\n      return typesMap.get(schemaType.type.name)!\n    }\n\n    // Cross dataset references are not supported\n    if (isCrossDatasetReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies UnknownTypeNode // we don't support cross-dataset references at the moment\n    }\n\n    // Global document references are not supported\n    if (isGlobalDocumentReferenceType(schemaType)) {\n      return {type: 'unknown'} satisfies UnknownTypeNode // we don't support global document references at the moment\n    }\n\n    if (isReferenceType(schemaType)) {\n      return createReferenceTypeNodeDefintion(schemaType)\n    }\n\n    if (isArrayType(schemaType)) {\n      return createArray(schemaType)\n    }\n\n    if (isObjectType(schemaType)) {\n      return createObject(schemaType)\n    }\n\n    if (lastType(schemaType)?.name === 'document') {\n      const doc = documentTypes.get(schemaType.name)\n      if (doc === undefined) {\n        return {type: 'unknown'} satisfies UnknownTypeNode\n      }\n      return {type: 'object', attributes: doc?.attributes} satisfies ObjectTypeNode\n    }\n\n    throw new Error(`Type \"${schemaType.name}\" not found`)\n  }\n  function createObject(\n    schemaType: ObjectSchemaType | SanitySchemaType,\n  ): ObjectTypeNode | UnknownTypeNode {\n    const attributes: Record<string, ObjectAttribute> = {}\n\n    const fields = gatherFields(schemaType)\n    for (const field of fields) {\n      const fieldIsRequired = isFieldRequired(field?.type?.validation)\n      let value: TypeNode\n\n      const hoisted = repeated.get(field)\n      const isTopLevelSchemaType = sortedSchemaTypeNames.includes(field.type.name)\n\n      // Check if this field should use a hoisted type reference instead of inlining. We only hoist if:\n      // - The field is in the `repeated` map (used more than once) AND\n      // - The field's type is NOT a top-level schema type (those are already named)\n      if (hoisted && !isTopLevelSchemaType) {\n        // This field is hoisted, hoist it with an inline type\n        value = {\n          type: 'inline',\n          name: hoisted,\n        }\n      } else {\n        value = convertSchemaType(field.type)\n        if (value === null) {\n          continue\n        }\n\n        // if the field sets assetRequired() we will mark the asset attribute as required\n        // also guard against the case where the field is not an object, though type validation should catch this\n        if (hasAssetRequired(field?.type?.validation) && value.type === 'object') {\n          value.attributes.asset.optional = false\n        }\n      }\n\n      // if we extract with enforceRequiredFields, we will mark the field as optional only if it is not a required field,\n      // else we will always mark it as optional\n      const optional = extractOptions.enforceRequiredFields ? fieldIsRequired === false : true\n\n      attributes[field.name] = {\n        type: 'objectAttribute',\n        value,\n        optional,\n      }\n    }\n\n    // If we enforce required fields and the schema type itself (not just its fields) has assetRequired validation\n    // we set asset.optional=false. This handles cases like array members with validation: (rule) => rule.assetRequired()\n    if (\n      extractOptions.enforceRequiredFields &&\n      hasAssetRequired(schemaType.validation) &&\n      attributes.asset\n    ) {\n      attributes.asset.optional = false\n    }\n\n    // Ignore empty objects\n    if (Object.keys(attributes).length === 0) {\n      return {type: 'unknown'} satisfies UnknownTypeNode\n    }\n\n    if (schemaType.type?.name !== 'document' && schemaType.name !== 'object') {\n      attributes._type = {\n        type: 'objectAttribute',\n        value: {\n          type: 'string',\n          value: schemaType.name,\n        },\n      }\n    }\n\n    return {\n      type: 'object',\n      attributes,\n    }\n  }\n\n  function createArray(arraySchemaType: ArraySchemaType): ArrayTypeNode | NullTypeNode {\n    const of: TypeNode[] = []\n    for (const item of arraySchemaType.of) {\n      const field = convertSchemaType(item)\n      if (field.type === 'inline') {\n        of.push({\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n          rest: field,\n        } satisfies ObjectTypeNode)\n      } else if (field.type === 'object') {\n        field.rest = {\n          type: 'object',\n          attributes: {\n            _key: createKeyField(),\n          },\n        }\n        of.push(field)\n      } else {\n        of.push(field)\n      }\n    }\n\n    if (of.length === 0) {\n      return {type: 'null'}\n    }\n\n    return {\n      type: 'array',\n      of:\n        of.length > 1\n          ? {\n              type: 'union',\n              of,\n            }\n          : of[0],\n    }\n  }\n\n  function createReferenceTypeNodeDefintion(\n    reference: ReferenceSchemaType,\n  ): ObjectTypeNode | InlineTypeNode | UnionTypeNode<InlineTypeNode | ObjectTypeNode> {\n    const references = gatherReferenceNames(reference)\n\n    // Ensure hoisted reference types exist for each referenced document type\n    for (const name of references) {\n      const refName = getInlineRefName(name)\n      if (!hoistedRefMap.has(refName)) {\n        const inlined = reserveRefName(refName)\n        if (inlined) {\n          schema.push({\n            type: 'type',\n            name: inlined,\n            value: createReferenceTypeNode(name),\n          })\n        }\n      }\n    }\n\n    if (references.length === 1) {\n      const inlined = hoistedRefMap.get(getInlineRefName(references[0]))\n      if (inlined) {\n        return {type: 'inline', name: inlined}\n      }\n      return createReferenceTypeNode(references[0])\n    }\n\n    return {\n      type: 'union',\n      of: references.map((name) => {\n        const inlined = hoistedRefMap.get(getInlineRefName(name))\n        if (inlined) {\n          return {type: 'inline', name: inlined}\n        }\n        return createReferenceTypeNode(name)\n      }),\n    }\n  }\n\n  return schema\n}\n\nfunction getInlineRefName(typeName: string) {\n  return `${typeName}.reference`\n}\n\nfunction createKeyField(): ObjectAttribute<StringTypeNode> {\n  return {\n    type: 'objectAttribute',\n    value: {\n      type: 'string',\n    },\n  }\n}\n\nfunction isFieldRequired(validation?: SchemaValidationValue): boolean {\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let required = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'required') {\n            required = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (required) {\n        return true\n      }\n    }\n\n    if (typeof rule === 'object' && rule !== null && '_required' in rule) {\n      if (rule._required === 'required') {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction hasAssetRequired(validation?: SchemaValidationValue): boolean {\n  if (!validation) {\n    return false\n  }\n  const rules = Array.isArray(validation) ? validation : [validation]\n  for (const rule of rules) {\n    let assetRequired = false\n\n    // hack to check if a field is required. We create a proxy that returns itself when a method is called,\n    // if the method is \"required\" we set a flag\n    const proxy = new Proxy(\n      {},\n      {\n        get: (target, methodName) => () => {\n          if (methodName === 'assetRequired') {\n            assetRequired = true\n          }\n          return proxy\n        },\n      },\n    ) as Rule\n\n    if (typeof rule === 'function') {\n      rule(proxy)\n      if (assetRequired) {\n        return true\n      }\n    }\n\n    if (\n      typeof rule === 'object' &&\n      rule !== null &&\n      '_rules' in rule &&\n      Array.isArray(rule._rules)\n    ) {\n      if (rule._rules.some((r) => r.flag === 'assetRequired')) {\n        return true\n      }\n    }\n  }\n\n  return false\n}\n\nfunction isObjectType(typeDef: SanitySchemaType): typeDef is ObjectSchemaType {\n  return isType(typeDef, 'object') || typeDef.jsonType === 'object' || 'fields' in typeDef\n}\nfunction isArrayType(typeDef: SanitySchemaType): typeDef is ArraySchemaType {\n  return isType(typeDef, 'array')\n}\nfunction isReferenceType(typeDef: SanitySchemaType): typeDef is ReferenceSchemaType {\n  return isType(typeDef, 'reference')\n}\nfunction isCrossDatasetReferenceType(typeDef: SanitySchemaType) {\n  return isType(typeDef, 'crossDatasetReference')\n}\nfunction isGlobalDocumentReferenceType(typeDef: SanitySchemaType) {\n  return isType(typeDef, 'globalDocumentReference')\n}\nfunction isStringType(typeDef: SanitySchemaType): typeDef is StringSchemaType {\n  return isType(typeDef, 'string')\n}\nfunction isNumberType(typeDef: SanitySchemaType): typeDef is NumberSchemaType {\n  return isType(typeDef, 'number')\n}\nfunction createStringTypeNodeDefintion(\n  stringSchemaType: StringSchemaType,\n): StringTypeNode | UnionTypeNode<StringTypeNode> {\n  const listOptions = stringSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'string',\n        value: typeof v === 'string' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'string',\n  }\n}\n\nfunction createNumberTypeNodeDefintion(\n  numberSchemaType: NumberSchemaType,\n): NumberTypeNode | UnionTypeNode<NumberTypeNode> {\n  const listOptions = numberSchemaType.options?.list\n  if (listOptions && Array.isArray(listOptions)) {\n    return {\n      type: 'union',\n      of: listOptions.map((v) => ({\n        type: 'number',\n        value: typeof v === 'number' ? v : v.value,\n      })),\n    }\n  }\n  return {\n    type: 'number',\n  }\n}\n\n// Traverse the reference type tree and gather all the reference names\nfunction gatherReferenceNames(type: ReferenceSchemaType): string[] {\n  const allReferences = gatherReferenceTypes(type)\n  // Remove duplicates\n  return [...new Set(allReferences.map((ref) => ref.name))]\n}\n\nfunction gatherReferenceTypes(type: ReferenceSchemaType): ObjectSchemaType[] {\n  const refTo = 'to' in type ? type.to : []\n  if ('type' in type && isReferenceType(type.type!)) {\n    return [...gatherReferenceTypes(type.type), ...refTo]\n  }\n\n  return refTo\n}\n\n// Traverse the type tree and gather all the fields\nfunction gatherFields(type: SanitySchemaType | ObjectSchemaType): ObjectField[] {\n  if ('fields' in type) {\n    return type.type ? gatherFields(type.type).concat(type.fields) : type.fields\n  }\n\n  return []\n}\n\n// Traverse the type tree and check if the type or any of its subtypes are of the given type\nfunction isType(\n  typeDef: SanitySchemaType | ObjectField | ObjectFieldType,\n  typeName: string,\n): boolean {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (type.name === typeName || (type.type && type.type.name === typeName)) {\n      return true\n    }\n\n    type = type.type\n  }\n  return false\n}\n\n// Traverse the type tree and return the \"last\" type, ie deepest type in the tree\nfunction lastType(typeDef: SanitySchemaType): SanitySchemaType | undefined {\n  let type: SchemaType | ObjectField | ObjectFieldType | undefined = typeDef\n  while (type) {\n    if (!type.type) {\n      return type\n    }\n    type = type.type\n  }\n\n  return undefined\n}\n\n/**\n * Sorts schema types topologically by their dependencies using depth-first traversal.\n *\n * Also detects \"repeated\" inline object fields - fields that appear in multiple places in the schema. These\n * are candidates for hoisting to avoid duplication in the output.\n *\n * @returns\n * - `sortedSchemaTypeNames`: Type names in dependency order (dependencies come first)\n * - `repeated`: Map from ObjectField â†’ generated hoisted type name (e.g., \"blocks.content\")\n *\n * Detection relies on object identity: Sanity's compiled schema reuses the same ObjectField instance when an\n * inline type is referenced multiple times.\n */\nfunction sortByDependencies(compiledSchema: SchemaDef): {\n  sortedSchemaTypeNames: string[]\n  repeated: Map<ObjectField, string>\n} {\n  const seen = new Set<SanitySchemaType>()\n  const objectMap = new Set<ObjectField>()\n  const repeated = new Map<ObjectField, string>()\n  const repeatedNames = new Set<string>()\n\n  /**\n   * Generates a unique name for a hoisted type based on its field path.\n   * Tries shortest suffix first (e.g., \"content\"), then progressively longer\n   * paths (e.g., \"blocks.content\", \"post.blocks.content\") until finding a unique name.\n   */\n  function pickRepeatedName(path: string[]): string | null {\n    for (let idx = path.length - 1; idx >= 1; idx--) {\n      const name = path.slice(idx).join('.')\n      if (!repeatedNames.has(name) && !compiledSchema.get(name)) {\n        repeatedNames.add(name)\n        return name\n      }\n    }\n    for (let i = 1; i < 10; i++) {\n      for (let idx = path.length - 1; idx >= 1; idx--) {\n        const name = `${path.slice(idx).join('.')}${i}`\n        if (!repeatedNames.has(name) && !compiledSchema.get(name)) {\n          repeatedNames.add(name)\n          return name\n        }\n      }\n    }\n    return null\n  }\n\n  // Walks the dependencies of a schema type and adds them to the dependencies set\n  function walkDependencies(\n    schemaType: SanitySchemaType,\n    dependencies: Set<SanitySchemaType>,\n    path: string[],\n    hoistRepetitions = true,\n  ): void {\n    if (seen.has(schemaType)) {\n      return\n    }\n    seen.add(schemaType)\n\n    if ('fields' in schemaType) {\n      for (const field of gatherFields(schemaType)) {\n        const last = lastType(field.type)\n        if (last!.name === 'document') {\n          dependencies.add(last!)\n          continue\n        }\n\n        let schemaTypeName: string | undefined\n        if (schemaType.type!.type) {\n          schemaTypeName = field.type.type!.name\n        } else if ('jsonType' in schemaType.type!) {\n          schemaTypeName = field.type.jsonType\n        }\n        if (schemaTypeName === 'object' || schemaTypeName === 'block') {\n          if (isReferenceType(field.type)) {\n            // Reference types are handled by createReferenceTypeNodeDefintion - add their targets as dependencies\n            // but skip hoisting detection since references have their own hoisting mechanism\n            field.type.to.forEach((ref) => dependencies.add(ref.type!))\n          } else {\n            dependencies.add(field.type)\n\n            // Hoisting detection: Only consider inline types (not in compiledSchema). If we've seen this exact\n            // ObjectField before, it's used in multiple places and should be hoisted to a named type to avoid\n            // duplication.\n            if (hoistRepetitions && !validSchemaNames.has(field.type.name)) {\n              const fieldPath = path.concat([field.name])\n              // eslint-disable-next-line max-depth\n              if (!repeated.has(field) && objectMap.has(field)) {\n                // The field is not in the repeated set, but it's the second time we see it â€“Â time to add it\n                const name = pickRepeatedName(fieldPath)\n\n                // If we couldn't pick a name, we skip hoisting for this field\n                // eslint-disable-next-line max-depth\n                if (name !== null) {\n                  repeated.set(field, name)\n                }\n              }\n\n              // Track all inline object fields we encounter\n              objectMap.add(field)\n            }\n          }\n        } else if (field.type) {\n          dependencies.add(field.type)\n        }\n        walkDependencies(field.type, dependencies, path.concat([field.name]))\n      }\n    } else if ('of' in schemaType) {\n      for (const item of schemaType.of) {\n        walkDependencies(item, dependencies, path.concat(item.name), !isReferenceType(schemaType))\n      }\n    }\n  }\n  const dependencyMap = new Map<SanitySchemaType, Set<SanitySchemaType>>()\n  const schemaTypeNames = compiledSchema.getTypeNames()\n  const validSchemaNames = new Set<string>()\n  schemaTypeNames.forEach((typeName) => {\n    const schemaType = compiledSchema.get(typeName)\n    if (schemaType === undefined || schemaType.type === null) {\n      return\n    }\n    validSchemaNames.add(typeName)\n    const dependencies = new Set<SanitySchemaType>()\n\n    walkDependencies(schemaType, dependencies, [typeName])\n    dependencyMap.set(schemaType, dependencies)\n    seen.clear() // Clear the seen set for the next type\n  })\n\n  // Sorts the types by their dependencies\n  const typeNames: string[] = []\n  // holds a temporary mark for types that are currently being visited, to detect cyclic dependencies\n  const currentlyVisiting = new Set<SanitySchemaType>()\n\n  // holds a permanent mark for types that have been already visited\n  const visited = new Set<SanitySchemaType>()\n\n  // visit implements a depth-first search\n  function visit(type: SanitySchemaType) {\n    if (visited.has(type)) {\n      return\n    }\n    // If we find a type that is already in the temporary mark, we have a cyclic dependency.\n    if (currentlyVisiting.has(type)) {\n      return\n    }\n    // mark this as a temporary mark, meaning it's being visited\n    currentlyVisiting.add(type)\n    const deps = dependencyMap.get(type)\n    if (deps !== undefined) {\n      deps.forEach((dep) => visit(dep))\n    }\n    currentlyVisiting.delete(type)\n    visited.add(type)\n\n    if (typeNames.includes(type.name)) {\n      typeNames.splice(typeNames.indexOf(type.name), 1)\n    }\n    typeNames.unshift(type.name)\n  }\n  // Visit all types in the dependency map\n  for (const [type] of dependencyMap) {\n    visit(type)\n  }\n\n  return {\n    sortedSchemaTypeNames: typeNames.filter((typeName) => validSchemaNames.has(typeName)),\n    repeated,\n  }\n}\n","import {type SchemaValidationResult} from '../../typedefs'\nimport {error} from '../createValidationResult'\nimport {isComponentLike} from './isComponent'\n\n/**\n * Validates that a type definition contains no callback functions or code.\n * This is useful for contexts where schemas need to be serializable.\n *\n * @internal\n */\nexport function validateNoCallbacks(typeDef: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  problems.push(...validateConditionalProperties(typeDef))\n  problems.push(...validateValueProperties(typeDef))\n  problems.push(...validateComponents(typeDef))\n  problems.push(...validateOptions(typeDef))\n  problems.push(...validateFieldsetsAndGroups(typeDef))\n  problems.push(...validateBlockSpecific(typeDef))\n\n  return problems\n}\n\nfunction validateConditionalProperties(typeDef: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (typeof typeDef.hidden === 'function') {\n    problems.push(\n      error(`The \"hidden\" property cannot be a function. Use a static boolean value instead.`),\n    )\n  }\n\n  if (typeof typeDef.readOnly === 'function') {\n    problems.push(\n      error(`The \"readOnly\" property cannot be a function. Use a static boolean value instead.`),\n    )\n  }\n\n  return problems\n}\n\nfunction validateValueProperties(typeDef: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (typeof typeDef.initialValue === 'function') {\n    problems.push(\n      error(`The \"initialValue\" property cannot be a function. Use a static value instead.`),\n    )\n  }\n\n  if (typeof typeDef.validation === 'function') {\n    problems.push(\n      error(`The \"validation\" property cannot be a function. Use static validation rules instead.`),\n    )\n  }\n\n  if (typeDef.validation && typeof typeDef.validation === 'object') {\n    const hasCustomValidator = checkForCustomValidators(typeDef.validation)\n    if (hasCustomValidator) {\n      problems.push(\n        error(`Custom validation functions are not supported. Use only built-in validation rules.`),\n      )\n    }\n  }\n\n  if (typeDef.preview?.prepare && typeof typeDef.preview.prepare === 'function') {\n    problems.push(error(`The \"preview.prepare\" property cannot be a function.`))\n  }\n\n  if (typeDef.blockEditor?.render) {\n    problems.push(error(`The \"blockEditor.render\" property cannot be a function.`))\n  }\n\n  return problems\n}\n\nfunction validateComponents(typeDef: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (!typeDef.components) {\n    return problems\n  }\n\n  const componentProps = [\n    'input',\n    'field',\n    'item',\n    'preview',\n    'diff',\n    'block',\n    'inlineBlock',\n    'annotation',\n  ]\n\n  for (const prop of componentProps) {\n    if (typeDef.components[prop] && isComponentLike(typeDef.components[prop])) {\n      problems.push(error(`The \"components.${prop}\" property cannot be a component function.`))\n    }\n  }\n\n  if (typeDef.components.portableText?.plugins) {\n    problems.push(\n      error(`The \"components.portableText.plugins\" property cannot contain plugin functions.`),\n    )\n  }\n\n  return problems\n}\n\nfunction validateOptions(typeDef: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (!typeDef.options || typeof typeDef.options !== 'object') {\n    return problems\n  }\n\n  problems.push(...validateCommonOptions(typeDef.options))\n  problems.push(...validateAssetSources(typeDef.options))\n  problems.push(...validateOtherFunctionOptions(typeDef.options))\n\n  return problems\n}\n\nfunction validateCommonOptions(options: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (typeof options.filter === 'function') {\n    problems.push(\n      error(\n        `The \"options.filter\" property cannot be a function. Use a static GROQ filter string with filterParams instead.`,\n      ),\n    )\n  }\n\n  if (typeof options.source === 'function') {\n    problems.push(\n      error(\n        `The \"options.source\" property cannot be a function. Use a static string path instead.`,\n      ),\n    )\n  }\n\n  if (typeof options.slugify === 'function') {\n    problems.push(error(`The \"options.slugify\" property cannot be a function.`))\n  }\n\n  if (typeof options.isUnique === 'function') {\n    problems.push(error(`The \"options.isUnique\" property cannot be a function.`))\n  }\n\n  return problems\n}\n\nfunction validateAssetSources(options: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (!Array.isArray(options.sources)) {\n    return problems\n  }\n\n  for (let i = 0; i < options.sources.length; i++) {\n    const source = options.sources[i]\n    if (!source) continue\n\n    if (source.component && isComponentLike(source.component)) {\n      problems.push(\n        error(`Asset source at index ${i} has a \"component\" property that cannot be a function.`),\n      )\n    }\n\n    if (source.icon && isComponentLike(source.icon)) {\n      problems.push(\n        error(`Asset source at index ${i} has an \"icon\" property that cannot be a component.`),\n      )\n    }\n\n    if (typeof source === 'function' || source.Uploader) {\n      problems.push(error(`Asset source at index ${i} contains functions or classes.`))\n    }\n  }\n\n  return problems\n}\n\nfunction validateOtherFunctionOptions(options: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n  const knownFunctionOptions = ['filter', 'source', 'slugify', 'isUnique']\n\n  for (const [key, value] of Object.entries(options)) {\n    if (typeof value === 'function' && !knownFunctionOptions.includes(key)) {\n      problems.push(error(`The \"options.${key}\" property cannot be a function.`))\n    }\n  }\n\n  return problems\n}\n\nfunction validateFieldsetsAndGroups(typeDef: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  problems.push(...validateFieldsets(typeDef.fieldsets))\n  problems.push(...validateGroups(typeDef.groups))\n\n  return problems\n}\n\nfunction validateFieldsets(fieldsets: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (!Array.isArray(fieldsets)) {\n    return problems\n  }\n\n  for (let i = 0; i < fieldsets.length; i++) {\n    const fieldset = fieldsets[i]\n    if (!fieldset) continue\n\n    if (typeof fieldset.hidden === 'function') {\n      problems.push(\n        error(`Fieldset at index ${i} has a \"hidden\" property that cannot be a function.`),\n      )\n    }\n\n    if (typeof fieldset.readOnly === 'function') {\n      problems.push(\n        error(`Fieldset at index ${i} has a \"readOnly\" property that cannot be a function.`),\n      )\n    }\n  }\n\n  return problems\n}\n\nfunction validateGroups(groups: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (!Array.isArray(groups)) {\n    return problems\n  }\n\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i]\n    if (!group) continue\n\n    if (typeof group.hidden === 'function') {\n      problems.push(\n        error(`Field group at index ${i} has a \"hidden\" property that cannot be a function.`),\n      )\n    }\n\n    if (group.icon && isComponentLike(group.icon)) {\n      problems.push(\n        error(`Field group at index ${i} has an \"icon\" property that cannot be a component.`),\n      )\n    }\n  }\n\n  return problems\n}\n\nfunction validateBlockSpecific(typeDef: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (typeDef.type !== 'block') {\n    return problems\n  }\n\n  problems.push(...validateBlockStyles(typeDef.styles))\n  problems.push(...validateBlockMarks(typeDef.marks))\n\n  return problems\n}\n\nfunction validateBlockStyles(styles: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (!Array.isArray(styles)) {\n    return problems\n  }\n\n  for (let i = 0; i < styles.length; i++) {\n    const style = styles[i]\n    if (style?.component && isComponentLike(style.component)) {\n      problems.push(\n        error(`Block style at index ${i} has a \"component\" property that cannot be a function.`),\n      )\n    }\n  }\n\n  return problems\n}\n\nfunction validateBlockMarks(marks: any): SchemaValidationResult[] {\n  const problems: SchemaValidationResult[] = []\n\n  if (!marks) {\n    return problems\n  }\n\n  if (Array.isArray(marks.decorators)) {\n    for (let i = 0; i < marks.decorators.length; i++) {\n      const decorator = marks.decorators[i]\n      if (decorator?.component && isComponentLike(decorator.component)) {\n        problems.push(\n          error(\n            `Block decorator at index ${i} has a \"component\" property that cannot be a function.`,\n          ),\n        )\n      }\n    }\n  }\n\n  if (Array.isArray(marks.annotations)) {\n    for (let i = 0; i < marks.annotations.length; i++) {\n      const annotation = marks.annotations[i]\n      if (annotation?.component && isComponentLike(annotation.component)) {\n        problems.push(\n          error(\n            `Block annotation at index ${i} has a \"component\" property that cannot be a function.`,\n          ),\n        )\n      }\n    }\n  }\n\n  return problems\n}\n\n/**\n * Checks if a validation rule or array of rules contains custom validators\n */\nfunction checkForCustomValidators(validation: any): boolean {\n  if (!validation) return false\n\n  // If it's an array, check each item\n  if (Array.isArray(validation)) {\n    return validation.some((v) => checkForCustomValidators(v))\n  }\n\n  // Check if it's a Rule object with custom validators\n  if (typeof validation === 'object') {\n    // Look for _rules array which contains the actual validation rules\n    if (Array.isArray(validation._rules)) {\n      return validation._rules.some((rule: any) => {\n        // Check if the rule has a custom validator function\n        return rule.flag === 'custom' && typeof rule.constraint === 'function'\n      })\n    }\n\n    // Also check for direct custom property (different Rule structure)\n    if (typeof validation.custom === 'function') {\n      return true\n    }\n  }\n\n  return false\n}\n","import {type SchemaValidationProblem} from '@sanity/types'\n\nimport {groupProblems} from './groupProblems'\nimport {validateSchema} from './validateSchema'\nimport {validateNoCallbacks} from './validation/utils/validateNoCallbacks'\n\nfunction unsupportedTypeValidator(typeLabel: string) {\n  return function () {\n    return {\n      _problems: [\n        {\n          severity: 'error',\n          message: `Type unsupported in Media Library aspects: ${typeLabel}.`,\n        },\n      ],\n    }\n  }\n}\n\nfunction noCallbacksVisitor(typeDef: any, visitorContext: any) {\n  return {\n    ...typeDef,\n    _problems: validateNoCallbacks(typeDef),\n  }\n}\n\n/**\n * Ensure that the provided value is a valid Media Library asset aspect that can be safely deployed.\n *\n * @internal\n */\nexport function validateMediaLibraryAssetAspect(\n  maybeAspect: unknown,\n): [isValidMediaLibraryAspect: boolean, validationErrors: SchemaValidationProblem[][]] {\n  const input = [maybeAspect]\n\n  const validated = validateSchema(input, {\n    transformCommonVisitors: (visitors) => [...visitors, noCallbacksVisitor],\n    transformTypeVisitors: (typeVisitors) => ({\n      ...typeVisitors,\n      document: unsupportedTypeValidator('document'),\n      image: unsupportedTypeValidator('image'),\n      file: unsupportedTypeValidator('file'),\n      video: unsupportedTypeValidator('sanity.video'),\n      reference: unsupportedTypeValidator('reference'),\n      crossDatasetReference: unsupportedTypeValidator('cross dataset reference'),\n    }),\n  })\n\n  const validation = groupProblems(validated.getTypes())\n\n  const errors = validation\n    .map((group) => group.problems.filter(({severity}) => severity === 'error'))\n    .filter((problems) => problems.length)\n\n  return [errors.length === 0, errors]\n}\n"],"names":["common","Rule","slug","array","coreTypes","coreTypeNames","quote","humanize","normalizeToProp","getOptionErrors","block","object","reference","typeVisitors"],"mappings":"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"}